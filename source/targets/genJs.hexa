// The Hexa Compiler
// Copyright (C) 2021  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// Generates JavaScript
/// Uses some modern features: classes, let, const, =>
class GenJs {
		new () {}

		var project: NiceProject
		let extension = '.js'
		let nativeEnums = false
		var toIterator = false

		static fun spawn() {
			return new GenJs()
		}

		fun perform(normalizer): String {
			project = normalizer
			return stringify()
		}

		fun stringify() {
			let out = ['// Generated by Hexa https://hexalang.github.io\n']

			if (project.package.addLicenseNoticeToOutput) {
				out.push('// \(project.package.name)\n')
				out.push('// LICENSE \(project.package.license)\n')
			} else {
				out.push('// The generated code is subject to the original license\n')
			}

			out.push(';(() => {\n\t"use strict"\n\tconst $global = typeof(window) === "undefined"? global : window')
			out.push('\n\tif (typeof($global.require) === "undefined") { $global.require = () => {} };')

			let constantsIndex = out.length
			let constants = [] // They don't access other variables
			out.push('')

			// Types
			for e in project.enumsSimple {
				// No need to output simple enum values
				if (e.staticVars.length + e.staticMethods.length == 0) {
					continue
				}

				out.push('\n\tvar ' + e.name + ' = {')
				for v in e.staticMethods { switch (v) {
					case NiceStatement.Function(name, expr, args, defaults):
						out.push('\n\t\t' + name + ': ')
						out.push(printFunctionArguments(args, defaults) + ' => { ' + printStatement(expr) + ' }')
						out.push(',')
				}}
				out.push('\n\t}')

				for v in e.staticVars { switch (v) {
					case NiceStatement.Var(name, expr):
						out.push('\n\t' + e.name + '.' + name)
						if (expr != null) {
							out.push(' = ' + printExpression(expr))
						}
					case NiceStatement.Const(name, expr):
						out.push('\n\t' + e.name + '.' + name)
						out.push(' = ' + printExpression(expr))
				}}
			}

			for e in project.enumsComplex {
				if e.staticMethods.length == 0, e.names.length == 0 {
					out.push('\n\tvar ' + e.name + ' = {}')
				} else {
					out.push('\n\tvar ' + e.name + ' = {')
					for v in e.staticMethods { switch (v) {
						case NiceStatement.Function(name, expr, args, defaults):
							out.push('\n\t\t' + name + ': ')
							out.push(printFunctionArguments(args, defaults) + ' => { ' + printStatement(expr) + ' }')
							out.push(',')
					}}
					var i = 0
					for name in e.names { // Only values *with* parameters
						if (e.constructors[i] != null) {
							out.push('\n\t\t' + name + ': ')
							out.push('(' + e.constructors[i].join(',') + ')=>[')
							out.push('' + i + ',' + e.constructors[i].join(','))
							out.push('],')
						}
						i++
					}
					out.push('\n\t}')
				}

				var i = 0
				for name in e.names { // Only values *without* parameters
					if (e.constructors[i] != null) {
					} else {
						out.push('\n\tObject.defineProperty(' + e.name + ', "' + name + '", { get: () => { return [' + i + '] }})')
						/*
							Sadly, this optimization breaks object inequality (for Map's):
							out.push('E.name = ["' + name + '",' + i + '];')
						*/
					}
					i++
				}
				for v in e.staticVars { switch (v) {
					case NiceStatement.Var(name, expr):
						out.push('\n\t' + e.name + '.' + name)
						if (expr != null) {
							out.push(' = ' + printExpression(expr))
						}
					case NiceStatement.Const(name, expr):
						out.push('\n\t' + e.name + '.' + name)
						out.push(' = ' + printExpression(expr))
				}}
			}

			for i in project.interfaces {
				throw i
			}

			for c in project.classes {
				if (c.useless) {
					continue
				}

				if (c.external) {
					if (c.jsRequire != null) {
						constants.push('\n\t' + 'const ' + c.name + ' = require("' + c.jsRequire + '")')
						continue
					}
					if let jsNative = c.jsNative, jsNative != c.name {
						out.push('\n\t' + 'var ' + c.name + ' = $global.' + jsNative)
					}
					continue
				}

				out.push('\n\t' + 'var ' + c.name + ' = class')
				if let extend = c.extend {
					out.push(' extends ' + extend)
				}
				out.push(' {')
				for v in c.methods { switch (v) {
					case NiceStatement.Function(name, expr, args):
					if name == null or name == 'new' {
						out.push('\n\t\tconstructor')
					} else {
						out.push('\n\t\t' + name)
					}
					out.push('(' + args.join(', ') + ') ')

					if name == null || name == 'new', c.vars.length > 0 {
						// Init fields
						out.push('{ ')
						for v in c.vars { switch (v) {
							case NiceStatement.Var(name, expr):
							if (expr != null) {
								out.push('\n\t\t\tthis.' + name + ' = ' + printExpression(expr) + '')
							}
							case NiceStatement.Const(name, expr):
							if (expr != null) {// null if property
								out.push('\n\t\t\tthis.' + name + ' = ' + printExpression(expr) + '')
							}
						}}
						out.push('\n\t\t')
						out.push(printStatement(expr) + ' };')
					} else {
						out.push(printBlock(expr) + ';')
					}
				}}
				for name in c.property {
					// Generate native setters `get name() {}`
					out.push('\n\t\tget ' + name + '() { return this.get_\(name)(); };')
					out.push('\n\t\tset ' + name + '(value) { return this.set_\(name)(value); };')
				}
				out.push('\n\t}')

				for v in c.staticVars { switch (v) {
					case NiceStatement.Var(name, expr):
						out.push('\n\t' + c.name + '.' + name)
						if (expr != null) {
							out.push(' = ' + printExpression(expr))
						}
					case NiceStatement.Const(name, expr):
						out.push('\n\t' + c.name + '.' + name)
						out.push(' = ' + printExpression(expr))
				}}
				for v in c.staticMethods { switch (v) {
					case NiceStatement.Function(name, expr, args, defaults):
						out.push('\n\t' + c.name + '.' + name + ' = ')
						out.push(printFunctionArguments(args, defaults) + ' => ' + printBlock(expr) + ';')
				}}
			}

			for g in project.globalFuncs { switch (g) {
				case NiceStatement.Function(name, expr, args, defaults):
					out.push('\n\tfunction ' + name)
					out.push(printFunctionArguments(args, defaults) + ' ' + printBlock(expr) + ';')
			}}

			for g in project.globalVars { switch (g) {
				case NiceStatement.Var(name, expr):
					out.push('\n\tvar ' + name)
					if (expr != null) {
						out.push(' = ' + printExpression(expr))
					} else {
						out.push(' = null')
					}
				case NiceStatement.Const(name, expr):
					out.push('\n\tvar ' + name + ' = ' + printExpression(expr))
			}}

			// Init
			for init in project.init {
				out.push('\n\t{\n\t\t')
				out.push(printStatement(init))
				out.push('\n\t}')
			}

			if (toIterator) {
				constants.unshift('\n\tfunction $toIterator(v) { if (typeof(v) === "number") { v = Math.max(v, 0); const i = new Uint32Array(v); let n = 0; while (n < v) i[n] = n++; return i; } return v; };')
			}
			out[constantsIndex] = constants.join('')
			out.push('\n})();\n')
			return out.join('')
		}

		var tabs = '\t\t'

		@inline fun pushTab() {
			tabs += '\t'
		}

		@inline fun popTab() {
			tabs = tabs.substring(0, tabs.length - 1)
		}

		let globalAccessor = '' // Empty, otherwise __dirname not works
		let reserved = [
			// TODO fix package_TODO in normalizer.project.package -- seems like race condition of renaming
			'with', 'const', 'instanceof', 'typeof', 'delete', 'undefined', 'package_TODO',
			'async', 'await', 'arguments'
		]

		// Surrounds with { brackets } single statement
		fun printBlock(s: NiceStatement): String {
			switch (s) {
				case NiceStatement.Block(el):
					if (el.length == 1) { switch (el[0]) {
						case NiceStatement.Block(_):
							return printStatement(el[0])
					}}
					if (el.length == 1) {
						return '{ ' + printStatement(el[0]) + ' }'
					}
					if (el.length == 0) {
						return '{}'
					}
					return printStatement(s)
				case _:
					return '{ ' + printStatement(s) + ' }'
			}
		}

		fun printStatement(s: NiceStatement) {
			switch (s) {
				case NiceStatement.Statements(els):
					var r = ''
					for s in els {
						if (s != null) {
							r += '\n' + tabs + printStatement(s) + ';'
						}
					}
					return r

				case NiceStatement.Break: return 'break'
				case NiceStatement.Continue: return 'continue'
				case NiceStatement.Block(el):
					if (el.length == 1) { switch (el[0]) {
						case NiceStatement.Block(_):
							return printStatement(el[0])
					}}

					pushTab()
					var r = '{'

					for e in el { switch (e) {
						case null:
						case NiceStatement.Statements(els):
							for s in els {
								if (s != null) {
									r += '\n' + tabs + printStatement(s) + ';'
								}
							}
						case _:
							r += '\n' + tabs + printStatement(e) + ';'
					}}

					popTab()
					return r + '\n' + tabs + '}'
				case NiceStatement.Const(name, expr):
					return 'const ' + name + (expr == null? ' = null' : ' = ' + printExpression(expr))
				case NiceStatement.Var(name, expr): return 'let ' + name + (expr == null? '' : ' = ' + printExpression(expr))
				case NiceStatement.Function(name, expr, args, defaults):
					return 'const ' + name + ' = ' + printFunctionArguments(args, defaults) + ' => ' + printBlock(expr)
				case NiceStatement.Return(e):
					if (e == null) {
						return 'return'
					}
					return 'return ' + printExpression(e)
				case NiceStatement.If(econd, eif, eelse):
					var r = 'if (' + printExpression(econd) + ') ' + printBlock(eif)
					if (eelse != null) {
						r += ' else ' + printStatement(eelse)
					}
					return r
				case NiceStatement.Call(e, args): return printExpression(e) + printCallArguments(args)
				case NiceStatement.SuperConstructor(args): return 'super' + printCallArguments(args)
				case NiceStatement.Try(expr, t, v, catches, temp):
					var r = 'try '
					r += printBlock(expr)
					r += ' catch (\(temp)) {\n' + tabs + '\t'
					pushTab()
					for i in catches.length {
						var typeof = 'T'
						switch (t[i]) {
							case Type.ClassInstance(type):
								typeof = type.name
							case _:
								throw '' + t[i]
						}
						switch (typeof) {
							case 'Any':
								r += 'if (true) { '
							case 'String':
								r += 'if (typeof(\(temp)) == "string") { '
							case 'Int':
								r += 'if (typeof(\(temp)) == "number") { '
							case 'Float':
								// TODO special handling !=Int & sort Int check to first
								r += 'if (typeof(\(temp)) == "number") { '
							case 'Bool':
								r += 'if (typeof(\(temp)) == "boolean") { '
							case _:
								r += 'if (\(temp) instanceof \(typeof)) { '
						}
						r += '\n' + tabs
						r += 'const \(v[i]) = \(temp)'
						r += '\n' + tabs
						r += printStatement(catches[i])
						r += ' }'
						r += ' else'
						r += '\n' + tabs
					}
					r += '\n' + tabs + 'throw \(temp);'
					popTab()
					return r + '\n' + tabs + '}'
				case NiceStatement.Assign(a, v):
					return printExpression(a) + ' = ' + printExpression(v)
				case NiceStatement.Throw(e):
					return 'throw ' + printExpression(e)
				case NiceStatement.For(name, over, by):
					toIterator = true
					return 'for (const ' + name + ' of $toIterator(' + printExpression(over) + ')) ' + printStatement(by)
				case NiceStatement.Increment(e): return printExpression(e) + '++'
				case NiceStatement.Decrement(e): return printExpression(e) + '--'
				case NiceStatement.While(econd, e, pre):
					if (pre) {
						return 'while (' + printExpression(econd) + ') ' + printStatement(e)
					}
					return 'do {' + printStatement(e) + '} while (' + printExpression(econd) + ')'
				case NiceStatement.Assignop(a, op, value):
					return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)

				case NiceStatement.Switch(expr, cases, statements, guards, binds):
					var r = 'switch (' + printExpression(expr) + ') {'

					// case 1: case 2: case 3:
					for i in cases.length { if (cases[i].length > 0) {
						r += '\n' + tabs
						for cc in cases[i] { switch (cc) {
							case NiceExpression.Null(_):
								// JavaScript is very strict on this
								// in `switch` null != undefined
								// In Hexa we do not have `undefined`
								// and undefined considered to be == null
								r += 'case null: case undefined: '
							case _:
								r += 'case ' + printExpression(cc) + ': '
						}}
						pushTab()
						r += '{\n' + tabs
						if let binders = binds[i] {
							for bind in binders {
								r += printStatement(bind) + ';\n' + tabs
							}
						}

						if let guard = guards[i] {
							pushTab()
							r += 'if (' + printExpression(guard) + ') {\n' + tabs
						}

						r += printStatement(statements[i])
						popTab()
						if let guard = guards[i] {
							popTab()
							r += '\n\t' + tabs + 'break; } }\n' + tabs
						} else {
							r += '\n' + tabs + '} break;\n' + tabs
						}
					}}

					// default:
					for i in cases.length { if (cases[i].length == 0) {
						r += '\n' + tabs + 'default: '
						r += '\n' + tabs
						r += printStatement(statements[i])
						r += '\n' + tabs
					}}

					return r + '}'

				case null: console.error("Got null statement kind in JavaScript generator, probably unsupported feature was used, ignoring")
				case _: console.error("Unknown statement kind:", s)
			}

			return '{/* undefined */}'
		}

		fun printCallArguments(args: [NiceExpression]): String {
			return '(' + [for a in args printExpression(a)].join(', ') + ')'
		}

		fun printFunctionArguments(args: [String], defaults: [NiceExpression]) {
			return '(' + [for a in args.length
				args[a] + ((defaults != null && defaults[a] != null)? ' = ' + printExpression(defaults[a]) : '')
			].join(', ') + ')'
		}

		fun printExpression(e: NiceExpression) {
			switch (e) {
				case NiceExpression.Null: return 'null'
				case NiceExpression.This: return 'this'
				case NiceExpression.Ident(name): return name
				case NiceExpression.Int(v): return '' + v
				case NiceExpression.MetaInt(v, meta, type): return '' + v + 'n'
				case NiceExpression.Float(v): return '' + v
				case NiceExpression.String(s):

					let s = s.split('')
					let charsOut = []
					while (s.length > 0) {
						switch (s[0]) {
							case "'":
							charsOut.push("\\")
							charsOut.push("'")
							s.shift()
							case "\n":
							charsOut.push("\\n")
							s.shift()
							case "\r":
							charsOut.push("\\r")
							s.shift()
							case "\\":
							s.shift()
							if (s[0] == "'") {
								charsOut.push("\\'")
								s.shift()
							} else if (s[0] == '"') {
								charsOut.push('\\"')
								s.shift()
							} else if (s[0] == '\\') {
								charsOut.push("\\\\")
								s.shift()
							} else {
								charsOut.push('\\')
							}
							case _:
							charsOut.push(s[0])
							s.shift()
						}
					}

					return "'" + charsOut.join('') + "'"
				case NiceExpression.True: return 'true'
				case NiceExpression.False: return 'false'
				case NiceExpression.Dot(expr, name):
					switch (expr) {
						case NiceExpression.Int(_): return '(' + printExpression(expr) + ').' + name
						case NiceExpression.Float(_): return '(' + printExpression(expr) + ').' + name
					}
					return printExpression(expr) + '.' + name
				case NiceExpression.Call(e, args): return printExpression(e) + printCallArguments(args)
				case NiceExpression.Function(name, expr, args, defaults):
					if (name == null) {
						return printFunctionArguments(args, defaults) + ' => ' + printBlock(expr)
					}
					return '((() => { const ' + name + ' = ' + printFunctionArguments(args, defaults) + ' => '
					+ printBlock(expr) + '; return ' + name + ' })())'
				case NiceExpression.Arrow(expr, args, defaults):
					return printFunctionArguments(args, defaults) + ' => (' + printExpression(expr) + ')'
				case NiceExpression.New(e, args): return 'new ' + printExpression(e) + printCallArguments(args)
				case NiceExpression.Array(el): return '[' + [for a in el printExpression(a)].join(', ') + ']'
				case NiceExpression.Unop(op, postfix, e):
					if (postfix) {
						return '(' + printExpression(e) + Token.stringify(op) + ')'
					}
					return '(' + Token.stringify(op) + printExpression(e) + ')'
				case NiceExpression.Elvis(nullable, othewise):
					return '((' + printExpression(nullable) + ') || (' + printExpression(othewise) + '))'
				case NiceExpression.Parenthesis(e): return '(' + printExpression(e) + ')'
				case NiceExpression.Binop(a, op, b):
					return printExpression(a) + ' ' + Token.stringify(op) + ' ' + printExpression(b)
				case NiceExpression.Index(expr, index):
					return printExpression(expr) + '[' + printExpression(index) + ']'
				case NiceExpression.If(econd, eif, eelse):
					var r = ''
					try {
						r += '(' + printExpression(econd) + ')?'
						r += ' (' + printExpression(eif) + ')'
						r += ' : ' + printExpression(eelse)
						return r
					} catch (error: Any) {
						console.log('If =>', e, error)
						return r + '<!-- If => error -->'
					}
				case NiceExpression.EnumTag(expr):
					let e = printExpression(expr)
					return e + '&&' + e + '[0]'
				case NiceExpression.Object(names, el):
					return '{' + [for i in el.length {
						((names[i]) + ':' + printExpression(el[i]))
					}].join(', ') + '}'
				case NiceExpression.Map(keys, values):
					if (keys.length == 0) {
						return 'new Map()'
					}
					return 'new Map([' +
					[for i in keys.length '[' + printExpression(keys[i]) + ', ' + printExpression(values[i]) + ']'].join(', ')
					+ '])'
				case NiceExpression.Assignop(a, op, value):
					return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)
				case NiceExpression.NativeOperator(kind, args, s): switch (kind) {
					case NativeOperatorKind.Infix: return '((' + printExpression(args[0]) + ') ' + s + ' (' + printExpression(args[1]) + '))'
					case NativeOperatorKind.Function: return s + printCallArguments(args)
					case NativeOperatorKind.Prefix: return '(' + s + '(' + printExpression(args[0]) + '))'
					case NativeOperatorKind.Postfix: return '((' + printExpression(args[1]) + ')' + s + ')'
				}
				case NiceExpression.UnsafeBitCast(e, t): return '(' + printExpression(e) + ')'
				case NiceExpression.Is(e, t): return '((' + printExpression(e) + ') instanceof ' + Type.stringify(t) + ')'
				case NiceExpression.Enum(type, tagName, tag, args):
					if args.length == 0 {
						return '/*\(tagName)*/[' + printExpression(tag) + ']'
					}
					return ('/*\(tagName)*/[' + printExpression(tag) + ',' + [for a in args printExpression(a)].join(',') + ']')
				case NiceExpression.EnumParameter(expr, index):
					return printExpression(expr) + '[' + (1 + index) + ']'
				case null:
					console.error("Got null expression kind in JavaScript generator, probably unsupported feature was used, ignoring")
				case _:
					console.error("Unknown expression kind:", e)
			}

			return '{/* undefined */}'
		}
}
