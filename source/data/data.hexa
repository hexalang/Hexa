// The Hexa Compiler
// Copyright (C) 2021-2022 Oleg Petrenko
// Copyright (C) 2018 Bogdan Danylchenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// TODO refactor to nodes.

/// `@name(values[0], ...values[n])`
/// `@name(names[0]: values[0], ...names[n]: values[n])`
class Decorator {
	var name: String
	var values: [Node]
	new (name: String, values: [Node]) {
		this.name = name
		this.values = values
	}
}

// TODO move to nodes.hexa
/// Syntax tree
// TODO unindent
enum Node {
		/// `"text"`
		String(text: String)

		/// `ident`
		Ident(name: String)

		/// `ident<T>`
		ParametricIdent(name: String, params: [NodeType])

		/// `true`/`false`
		Bool(bool: Bool)

		/// `this`
		This

		/// `super`
		Super

		/// `123`
		Int(number: Int)

		/// `123n`
		/// `123u32`
		MetaInt(number: BigInt, meta: Meta)

		/// `0.123`
		Float(s: Float)

		/// `null`
		Null

		/// `declare Alias = Value`
		TypeAlias(alias: NodeType, value: NodeType)

		/// `left op right` like `a + b`
		// TODO rename to `Binary`
		Binop(left: Node, op: Token, right: Node)

		/// `storage op= value`
		AssignOp(storage: Node, op: Token, value: Node)

		// { el[0] ... el[n] }
		Block(el: [Node])

		// e(args[0], ...args[n])
		Call(e: Node, args: [Node], argNames: [String])

		/// if econd[0], ...econd[n] { eif } [else { eelse }]
		If(econd: [Node], eif: Node, eelse: Node?, ternary: Bool)

		/// `(inner)`
		Parenthesis(inner: Node)

		/// `return e`
		Return(e: Node?)

		/// `throw e`
		Throw(e: Node)

		/// `break`
		Break

		/// `continue`
		Continue

		// postfix ? e op : op e
		// TODO rename to `Unary`
		Unop(op: Token, postfix: Bool, e: Node)

		// while reason { e } or if pre == true then do { e } while reason
		While(reason: Node, e: Node, pre: Bool)

		// `declare fun name<params>(vars): retType { body }`
		// Name is `new` for constructor
		// TODO expr Node.Block (goal is *not* to `Node extends NodeBlock` but to actually limit tags)
		Function(name: String?, body: Node, vars: [Node], retType: NodeType, external: Bool)

		// (vars): rettype => { expr }
		Arrow(expr: Node, vars: [Node], retType: NodeType)

		// [declare] (const ? let : var) name: t = expr
		Var(name: String, t: NodeType, expr: Node, const: Bool, external: Bool)

		// external class t extends extend implements implement { fields }
		Class(t: NodeType, extend: NodeType?, implement: [NodeType], fields: [Node], external: Bool, kind: ClassKind)

		// var name: T { get { return x } set (v) {} }
		// Var, Function, Function
		Property(field: Node, getter: Node, setter: Node)

		// try { expr } catch v[0]: t[0] { catches[0] } ... catch v[n]: t[n] { catches[n] }
		Try(expr: Node, t: [NodeType], v: [Node], catches: [Node])

		/// `expr.name`
		Dot(expr: Node, name: String)

		// expr.Name
		DotUpper(expr: Node, name: String)

		// new t { } (args)
		New(path: [String], t: NodeType, args: [Node], fields: [String], el: [Node], argNames: [String])

		// [elements[0], ...elements[n]]
		Array(elements: [Node])

		// [keys[0] : values[0], ... keys[n] : values[n]]
		Map(keys: [Node], values: [Node])

		// expr[index]
		Index(expr: Node, index: Node)

		// switch exprs[0], exprs[n] {
		//     case cases[0]: conds[0]
		//     case cases[n]: conds[n]
		// }
		Switch(exprs: [Node], conds: [Node], guards: [Node], cases: [Node])

		// module path[0].path[1].r..path[n] { el }
		Module(path: String, el: [Node])

		// Not present in syntax, used for typing
		ModuleExports(handle: Module)

		// import xxx as yyy in "test"
		Import(el: [ImportNode], path: String)

		// { name[0]: el[0], name[1]: el[1], ... name[n]: el[n] }
		// NOTE: Do not use Map here
		Object(names: [String], el: [Node])

		// enum t : valuesType extends extend { fields[0] ... fields[n] }
		Enum(t: NodeType, fields: [Node], valuesType: NodeType, extend: NodeType?)

		// let expr(extract[0], ..., extract[n]) = name
		EnumExtract(path: [String], bind: [Node/*.Var*/], expr: Node)

		/// `expr is T`
		Is(expr: Node, aType: NodeType)

		/// `expr as T`
		/// `expr as? T`
		/// `expr as! T`
		As(expr: Node, kind: Token, toType: NodeType)

		/// `_`
		Underscore

		/// `...`
		Interval

		/// `static` field
		Static(field: Node)

		/// `private` field or type
		Private(field: Node)

		// for name in over by
		// for name in over ... range by
		For(name: String, over: Node, by: Node, range: Node)

		/// `nullable ?? othewise`
		Elvis(nullable: Node, otherwise: Node)

		/// `T<A, B>` but as expression
		NodeTypeValue(type: NodeType)

		static fun stringify(node: Node): String {
			switch node {
				case String(s): return "'\(s)'"
				case Ident(name): return name
				case Bool(b): return b? "true" : "false"
				case Int(s): return s.toString()
				case Float(s): return s.toString()
				case Null: return "null"
				case This: return "this"
				case Parenthesis(expr): return "(" + Node.stringify(expr) + ")"
				case Index(expr, index): return Node.stringify(expr) + '[' + Node.stringify(index) + ']'
				case Dot(expr, name): return Node.stringify(expr) + '.' + name
				case DotUpper(expr, name): return Node.stringify(expr) + '.' + name
				case Call(e, args, argNames):
					let arg = []
					for i in args.length {
						if let name = argNames[i] {
							arg.push(name + ': ' + Node.stringify(args[i]))
						} else {
							arg.push(Node.stringify(args[i]))
						}
					}
					return Node.stringify(e) + '(' + arg.join(', ') + ')'
				case Array(elements): return '[' + [for el in elements Node.stringify(el)].join(', ') + ']'
				case Binop(a, op, b): return Node.stringify(a) + ' ' + Token.stringify(op) + ' ' + Node.stringify(b)
				case Object(names, el):
					return '{' + [for i in el.length names[i] + ': ' + Node.stringify(el[i])].join(', ') + '}'
				case NodeTypeValue(t):
					return DataHelper.extractTypeName(t)
				case Static(f): return 'static ' + Node.stringify(f)
				case _:
					return "..."
			}
		}
}

/// Node extensions
class DataHelper {
		/// returns var NAME
		static fun varName(v: Node) {
			switch v {
				case Var(name,_): return name
				case _: throw 'varName got not a Var, but `\(v)`'
			}
		}

		/// returns var NAME, enum NAME {}, function NAME(), etc
		static fun nameOf(v: Node): String {
			switch v {
				case Private(node): return nameOf(node)
				case Property(node): return nameOf(node)
				case Var(name,_): return name
				case Enum(t, _):
					switch t {
						case Type(name): return name
						case ParametricType(name, _): return name
					}
					throw "unreachable #1"

				case Function(name,_): return name
				case Class(t, _):
					switch t {
						case Type(name): return name
						case ParametricType(name, _): return name
					}
					throw "unreachable #2"

				case TypeAlias(t, _): switch t {
					case Type(name): return name
					case ParametricType(name): return name
				}
				case Static(field): return nameOf(field)
				case _: throw 'nameOf expected named node, but got `\(v)`'
			}
		}

		/// @decorator("hello", "world")
		static fun asStringAttValue(a: Decorator, index: Int): String {
			switch a.values[index] {
				case null: throw 'Got null, not a string'
				case String(s): return s
				case _: throw 'Got `\(a.values[index])`, not a string'
			}
		}

		/// { a b c } => c
		static fun getLastOfBlock(block: Node): Node? {
			switch block {
				case null: throw 'Got null, not a block'
				case Block(el): return el[el.length - 1]
				case _: throw 'Got `\(block)`, not a block'
			}
		}

		/// Node that doesn't return a value, like "x = var a" or "x = return 123"
		static fun isVoidValue(block: Node): Bool {
			switch block {
				case null: return true
				case Return(_): return true
				case Break: return true
				case Continue: return true
				case Var(_): return true
				case If(_,_,eelse): if eelse == null {
					return true
				}
				case Enum(_): return true
				case Class(_): return true
				case Switch(_): return true
				// Also recursively traverses { ... { ... { ... void }}}
				case Block(el):
				if el.length == 0 {
					return true
				}
				return isVoidValue(el[el.length - 1])
				case _: return false
			}
			return false
		}

		/// Returns the only name of type
		static fun extractTypeName(t: NodeType): String? {
			switch t {
			case Type(name): return name
			case Ident(name): return name
			case ParametricType(name, _): return name
			case null: return null
			case _:
				// TODO
				//let data = project.data.get(t)
				//let msg = 'Type has no name: ' + JSON.stringify(t)
				//if let data = data {
				//	throw new CompilerError(Fail.TyperError, msg, data.line, data.column, data.fileName)
				//} else {
				console.error('Type has no name:', JSON.stringify(t))
				//throw new CompilerErrors([new CompilerError(Fail.TyperError, msg, 0, 0, "")])
				//}
				//throw 'Type has no name: ' + JSON.stringify(t)
				return null
			}
		}

		static fun getDecorator(atts: [Decorator], name: String): Decorator? {
			if let atts = atts, atts.length > 0 { for att in atts {
				if att.name == name {
					return att
				}
			}}
			return null
		}

		static fun isTitleCase(string: String): Bool {
			// TODO just check by ASCII code
			return string.charAt(0) == string.charAt(0).toUpperCase()
		}
}

/// `var a: NodeType`
enum NodeType {
	/// `T?`
	Optional(type: NodeType)

	/// `T` or `path.T`
	Type(name: String, path: String?)

	/// `T<K, V>`
	// TODO delete Type and always just use ParametricType with params==null`null!!!!`
	ParametricType(name: String, params: [NodeType], path: String?)

	/// `(T, T) => T`
	Function(args: [NodeType], ret: NodeType)

	/// `(T, T) => T`
	// TODO named args or what?
	FunctionArg(name: String, type: NodeType, defaultValue: Node)

	/// `{ a: T, b: T}`
	// TODO `{ let a: T, var b: T}`
	Object(names: [String], types: [NodeType])

	// Expression-like for evaluating dependent types

	/// `ident`
	Ident(name: String)

	/// `123`
	Int(value: Int)

	/// `0.123`
	Float(value: Float)

	/// `"text"`
	String(value: String)

	// `name(argName: value)`
	Call(name: String, argNames: [String], values: [NodeType])

	static fun stringify(nodeType: NodeType): String {
		switch nodeType {
			case Optional(type):
				return NodeType.stringify(type) + '?'
			case Object(names, types):
				// TODO i: `return [for i : name in names`
				if names.length == 0 {
					return '{}'
				}
				return '{ ' + [for i in names.length
					names[i] + ': ' + NodeType.stringify(types[i])
				].join(', ') + ' }'
			case Function(args, ret):
				return '(' + args.map(arg => NodeType.stringify(arg)).join(', ') + ') => ' + NodeType.stringify(ret)
		}
		return DataHelper.extractTypeName(nodeType)
	}
}
