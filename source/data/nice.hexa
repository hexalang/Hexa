// The Hexa Compiler
// Copyright (C) 2018-2020 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Does not return a value
enum Statement {
	/// Multiple statements *not* wrapped into a block
	// TODO get rid of this, use meta blocks like native gen (currentBlock push/pop)
	Statements(el: [Statement])

	Block(el: [Statement])
	Call(e: Expression, args: [Expression], expects: [Type], kind: CallKind)
	// TODO why need same `Call` here when we have same expression?
	Var(name: String, expr: Expression, type: Type)
	// TODO ^ expr is nullable
	// CapturedVar
	Const(name: String, expr: Expression, type: Type)
	Function(name: String, expr: Statement, args: [String], defaults: [Expression], funcType: Type)
	// TODO ^ funcType to plain class, so no need to pattern match it
	Return(e: Expression) // TODO Null?
	If(econd: Expression, eif: Statement, eelse: Statement) // TODO Null?
	Try(expr: Expression, t: [Type], v: [String], catches: [Statement], temp: String)
	Throw(value: Expression)
	Assign(name: Expression, value: Expression, to: Type)
	// TODO ^ more precise assign, like `Assign[Class/Enum][Global/Static]Var`
	// ^ same for reading values
	Assignop(name: Expression, op: Token, value: Expression)
	For(name: String, over: Expression, by: Statement)
	While(econd: Expression, e: Statement, pre: Bool)
	Increment(e: Expression)
	Decrement(e: Expression)
	Switch(expr: Expression, cases: [[Expression]], statements: [Statement], guards: [Expression], binds: [[Statement]])
	Continue
	Break
	SuperConstructor(args: [Expression])
	// TODO seems like types *here* `EnumValue(e: THISTYPE)` not checked
}

// Returns a value
// TODO assign overal expr type in norm where positions set?
// TODO unindent
enum Expression {
		String(s: String)
		// TODO : Int32
		Int(v: Int)
		MetaInt(v: BigInt, meta: Meta, type: Type)
		// TODO UInt32, BigInt
		// TODO : Float
		Float(v: Float)
		True
		False
		Ident(name: String, type: Type)
		// TODO ^ instead of `globalAccessor` just add `kind: Global/Local`
		// TODO ^ LocalVar
//		Reference(name: NiceName, type: Type)
//		NativeIdent(s: String) // Just textual as is, sorta hack
		Null
		This(me: Type)
		Dot(expr: Expression, name: String, result: Type)
		// TODO ^ resolved references, not `expr: Expression, name: String`
		// ^ but instead something precise like `ClassStaticField`, `LocalVar`, `CapturedVar`
//		Field(expr: Expression, field: Int)
//		DynamicField(expr: Expression, name: String, result: Type)
		Call(e: Expression, args: [Expression], result: Type, kind: CallKind)
		// CallMethod(e, name, rags)
		// ^ todo expects
		New(e: Expression, args: [Expression], result: Type)
		Binop(a: Expression, op: Token, b: Expression, result: Type)
		Function(name: String, expr: Statement, args: [String], defaults: [Expression], funcType: Type)
		Arrow(expr: Expression, args: [String], defaults: [Expression], types: [NodeType], returns: NodeType, funcType: Type)
		Parenthesis(inner: Expression)
		Object(names: [String], el: [Expression], types: [NodeType])
		Array(values: [Expression], arrayType: Type)
		Map(keys: [Expression], values: [Expression], keyType: NodeType, valueType: NodeType)
		Unop(op: Token, postfix: Bool, e: Expression)
		Elvis(nullable: Node, othewise: Node)
		If(econd: Expression, eif: Expression, eelse: Expression) // TODO Null?
		Index(expr: Expression, index: Expression, result: Type)
		UnsafeBitCast(expr: Expression, to: Type)
		Is(expr: Expression, of: Type)

		/// name op= value
		Assignop(name: Expression, op: Token, value: Expression)
		NativeOperator(kind: NativeOperatorKind, args: [Expression], name: String)

		/// `switch expr.tag` extracts tag for `case tag` patterns
		EnumTag(expr: Expression)

		/// Type.TagName(args)
		Enum(type: String, tagName: String, tag: Expression, args: [Expression])

		/// `case E.N(parameter1, parameter2):` does `parameterN` extraction
		EnumParameter(expr: Expression, index: Int)

		/// `_` used in case patterns (when native enums enabled)
		Underscore

		SizeOf(what: Type)
}

enum NativeOperatorKind : Int {
	Infix = 0
	Function = 1
	Prefix = 2
	Postfix = 3
}

enum CallKind : Int {
	Static = 10
	Function = 11
	VirtualMethod = 12
	// TODO KnownVirtualMethod = 13
}

class NiceProject {
	let interfaces: [NiceClass] = []
	let classes: [NiceClass] = []
	let enumsSimple: [NiceSimpleEnum] = []
	let enumsComplex: [NiceComplexEnum] = []
	let globalVars: [Statement] = []
	let globalFuncs: [Statement] = []
	let init: [Statement] = []
	var package: Package
	var typer: Typer
	let expressionType: [Expression : Type] = [:]
	let expressionPosition: [Expression : NodeData] = [:]
	let statementPosition: [Statement : NodeData] = [:]
	let native: [Expression : Bool] = [:]
	var mapDecorators: [Node : [Decorator]] = [:]

	new () {}
}

class NiceClass {
	new () {}
	var external: Bool
	var useless: Bool
	var name: String
	var extend: String?
	var genericParams: [String]
	var implement: String
	var implementParams: [String]
	var rename: Int
	var constructor

	var staticMethods: [Statement] = []
	var staticVars: [Statement] = []
	var methods: [Statement] = []
	var vars: [Statement] = []
	let property: [String] = [] // `var/let { get ?set }`

	var jsRequire: String? = null
	var jsNative: String? = null
}

class NiceSimpleEnum {
	new () {}
	var name: String
	var external: Bool
	var names: [String]
	var values: [Expression]
	var staticMethods: [Statement] = []
	var staticVars: [Statement] = []
}

class NiceComplexEnum  {
	new () {}
	var name: String
	var external: Bool
	var names: [String]
	var constructors: [[String]]
	var constructorsTypes: [[Type]]
	var types: [[NodeType]]
	var staticMethods: [Statement] = []
	var staticVars: [Statement] = []
	var expose: Bool
}
