// Generated by Hexa https://hexalang.github.io
// The Hexa Compiler
// LICENSE LGPL-3.0-only
;(() => {
	"use strict"
	const $global = typeof(window) === "undefined"? global : window
	if (typeof($global.require) === "undefined") { $global.require = () => {} };
	const selfVersion="1.0.0";
	function $toIterator(v) { if (typeof(v) === "number") { v = Math.max(v, 0); const i = new Uint32Array(v); let n = 0; while (n < v) i[n] = n++; return i; } return v; };
	const Fs = require("fs")
	const Path = require("path")
	const ProcessModule = require("process")
	var Token = {
		stringify: (token, param = null) => { {
			const temp = token;
			switch (temp) {
			case 70: {
				return '@'
			} break;
			
			case 83: {
				return '$'
			} break;
			
			case 78: {
				return '#'
			} break;
			
			case 71: {
				return ']'
			} break;
			
			case 72: {
				return '['
			} break;
			
			case 73: {
				return '}'
			} break;
			
			case 74: {
				return '{'
			} break;
			
			case 76: {
				return ':'
			} break;
			
			case 75: {
				return ','
			} break;
			
			case 123: {
				return '<!--default-->'
			} break;
			
			case 77: {
				return '.'
			} break;
			
			case 0: {
				return '<!--eof-->'
			} break;
			
			case 98: {
				return '...'
			} break;
			
			case 58: {
				return 'as'
			} break;
			
			case 3: {
				return 'break'
			} break;
			
			case 4: {
				return 'case'
			} break;
			
			case 6: {
				return 'catch'
			} break;
			
			case 7: {
				return 'class'
			} break;
			
			case 8: {
				return 'continue'
			} break;
			
			case 9: {
				return 'do'
			} break;
			
			case 10: {
				return 'else'
			} break;
			
			case 11: {
				return 'enum'
			} break;
			
			case 12: {
				return 'extends'
			} break;
			
			case 13: {
				return 'declare'
			} break;
			
			case 14: {
				return 'false'
			} break;
			
			case 15: {
				return 'for'
			} break;
			
			case 21: {
				return 'fun'
			} break;
			
			case 17: {
				return 'if'
			} break;
			
			case 18: {
				return 'implements'
			} break;
			
			case 2: {
				return 'import'
			} break;
			
			case 20: {
				return 'in'
			} break;
			
			case 22: {
				return 'interface'
			} break;
			
			case 23: {
				return 'let'
			} break;
			
			case 25: {
				return 'new'
			} break;
			
			case 26: {
				return 'null'
			} break;
			
			case 29: {
				return 'private'
			} break;
			
			case 31: {
				return 'return'
			} break;
			
			case 32: {
				return 'static'
			} break;
			
			case 59: {
				return 'super'
			} break;
			
			case 33: {
				return 'switch'
			} break;
			
			case 34: {
				return 'this'
			} break;
			
			case 35: {
				return 'throw'
			} break;
			
			case 36: {
				return 'true'
			} break;
			
			case 37: {
				return 'try'
			} break;
			
			case 40: {
				return 'var'
			} break;
			
			case 41: {
				return 'while'
			} break;
			
			case 111: {
				return '+'
			} break;
			
			case 112: {
				return '&'
			} break;
			
			case 90: {
				return '=>'
			} break;
			
			case 91: {
				return '='
			} break;
			
			case 92: {
				return '&&'
			} break;
			
			case 93: {
				return '||'
			} break;
			
			case 86: {
				return '--'
			} break;
			
			case 94: {
				return '/'
			} break;
			
			case 95: {
				return '=='
			} break;
			
			case 96: {
				return '>'
			} break;
			
			case 97: {
				return '>='
			} break;
			
			case 87: {
				return '++'
			} break;
			
			case 110: {
				return '\\'
			} break;
			
			case 99: {
				return '<'
			} break;
			
			case 100: {
				return '<='
			} break;
			
			case 101: {
				return '%'
			} break;
			
			case 102: {
				return '*'
			} break;
			
			case 88: {
				return '~'
			} break;
			
			case 89: {
				return '!'
			} break;
			
			case 103: {
				return '!='
			} break;
			
			case 104: {
				return '|'
			} break;
			
			case 105: {
				return '<<'
			} break;
			
			case 106: {
				return '>>'
			} break;
			
			case 107: {
				return '-'
			} break;
			
			case 108: {
				return '>>>'
			} break;
			
			case 109: {
				return '^'
			} break;
			
			case 113: {
				return '?.'
			} break;
			
			case 79: {
				return ')'
			} break;
			
			case 80: {
				return '('
			} break;
			
			case 81: {
				return '?'
			} break;
			
			case 82: {
				return ';'
			} break;
			
			case 1: {
				return '_'
			} break;
			
			case 61: {
				return ((param == null))? ('TitleCase') : param
			} break;
			
			case 64: {
				return ((param == null))? ('string') : ('\'' + (param) + '\'')
			} break;
			
			case 66: {
				return ((param == null))? ('backtick') : ('`' + (param) + '`')
			} break;
			
			case 62: {
				return ((param == null))? ('identifier') : param
			} break;
			
			case 63: {
				return ((param == null))? ('integer') : param
			} break;
			
			case 60: {
				return ((param == null))? ('float') : param
			} break;
			
			case 65: {
				return ('///' + (param) + '')
			} break;
			
			case 57: {
				return 'is'
			} break;
			};
		} },
	}
	var NiceStatement = {
		Statements: (el)=>[0,el],
		Block: (el_1986)=>[1,el_1986],
		Call: (e,args,expects,kind)=>[2,e,args,expects,kind],
		Var: (name,expr,type)=>[3,name,expr,type],
		Const: (name_1987,expr_1988,type_1989)=>[4,name_1987,expr_1988,type_1989],
		Function: (name_1990,expr_1991,args_1992,defaults,funcType)=>[5,name_1990,expr_1991,args_1992,defaults,funcType],
		Return: (e_1993)=>[6,e_1993],
		If: (econd,eif,eelse)=>[7,econd,eif,eelse],
		Try: (expr_1994,t,v,catches,temp)=>[8,expr_1994,t,v,catches,temp],
		Throw: (value)=>[9,value],
		Assign: (name_1995,value_1996,to)=>[10,name_1995,value_1996,to],
		Assignop: (name_1997,op,value_1998)=>[11,name_1997,op,value_1998],
		For: (name_1999,over,by)=>[12,name_1999,over,by],
		While: (econd_2000,e_2001,pre)=>[13,econd_2000,e_2001,pre],
		Increment: (e_2002)=>[14,e_2002],
		Decrement: (e_2003)=>[15,e_2003],
		Switch: (expr_2004,cases,statements,guards,binds)=>[16,expr_2004,cases,statements,guards,binds],
		SuperConstructor: (args_2005)=>[19,args_2005],
	}
	Object.defineProperty(NiceStatement, "Continue", { get: () => { return [17] }})
	Object.defineProperty(NiceStatement, "Break", { get: () => { return [18] }})
	var NiceExpression = {
		String: (s)=>[0,s],
		Int: (v_2006)=>[1,v_2006],
		MetaInt: (v_2007,meta,type_2008)=>[2,v_2007,meta,type_2008],
		Float: (v_2009)=>[3,v_2009],
		Ident: (s_2010,type_2011)=>[6,s_2010,type_2011],
		This: (me)=>[8,me],
		Dot: (expr_2012,name_2013,result)=>[9,expr_2012,name_2013,result],
		Call: (e_2014,args_2015,result_2016,kind_2017)=>[10,e_2014,args_2015,result_2016,kind_2017],
		New: (e_2018,args_2019,result_2020)=>[11,e_2018,args_2019,result_2020],
		Binop: (a,op_2021,b,result_2022)=>[12,a,op_2021,b,result_2022],
		Function: (name_2023,expr_2024,args_2025,defaults_2026,funcType_2027)=>[13,name_2023,expr_2024,args_2025,defaults_2026,funcType_2027],
		Arrow: (expr_2028,args_2029,defaults_2030,types,returns,funcType_2031)=>[14,expr_2028,args_2029,defaults_2030,types,returns,funcType_2031],
		Parenthesis: (inner)=>[15,inner],
		Object: (names,el_2032,types_2033)=>[16,names,el_2032,types_2033],
		Array: (values,arrayType)=>[17,values,arrayType],
		Map: (keys,values_2034,keyType,valueType)=>[18,keys,values_2034,keyType,valueType],
		Unop: (op_2035,postfix,e_2036)=>[19,op_2035,postfix,e_2036],
		Elvis: (nullable,othewise)=>[20,nullable,othewise],
		If: (econd_2037,eif_2038,eelse_2039)=>[21,econd_2037,eif_2038,eelse_2039],
		Index: (expr_2040,index)=>[22,expr_2040,index],
		UnsafeBitCast: (expr_2041,to_2042)=>[23,expr_2041,to_2042],
		Is: (expr_2043,of)=>[24,expr_2043,of],
		Assignop: (name_2044,op_2045,value_2046)=>[25,name_2044,op_2045,value_2046],
		NativeOperator: (kind_2047,args_2048,name_2049)=>[26,kind_2047,args_2048,name_2049],
		EnumTag: (expr_2050)=>[27,expr_2050],
		Enum: (type_2051,tagName,tag,args_2052)=>[28,type_2051,tagName,tag,args_2052],
		EnumParameter: (expr_2053,index_2054)=>[29,expr_2053,index_2054],
	}
	Object.defineProperty(NiceExpression, "True", { get: () => { return [4] }})
	Object.defineProperty(NiceExpression, "False", { get: () => { return [5] }})
	Object.defineProperty(NiceExpression, "Null", { get: () => { return [7] }})
	Object.defineProperty(NiceExpression, "Underscore", { get: () => { return [30] }})
	var ImportNode = {
		Lower: (name)=>[0,name],
		Upper: (name_2055)=>[1,name_2055],
		As: (left,right)=>[3,left,right],
	}
	Object.defineProperty(ImportNode, "AllTheThings", { get: () => { return [2] }})
	var Node = {
		stringify: (node) => { {
			const temp = node;
			switch (temp&&temp[0]) {
			case 0: {
				const s_2112 = temp[1];
				return ('\'' + (s_2112) + '\'')
			} break;
			
			case 1: {
				const name_2113 = temp[1];
				return name_2113
			} break;
			
			case 2: {
				const b_2114 = temp[1];
				return (b_2114)? ('true') : 'false'
			} break;
			
			case 5: {
				const s_2115 = temp[1];
				return s_2115.toString()
			} break;
			
			case 7: {
				const s_2116 = temp[1];
				return s_2116.toString()
			} break;
			
			case 8: {
				return 'null'
			} break;
			
			case 3: {
				return 'this'
			} break;
			
			case 15: {
				const expr_2117 = temp[1];
				return '(' + Node.stringify(expr_2117) + ')'
			} break;
			
			case 33: {
				const expr_2118 = temp[1];
				const index_2119 = temp[2];
				return Node.stringify(expr_2118) + '[' + Node.stringify(index_2119) + ']'
			} break;
			
			case 28: {
				const expr_2120 = temp[1];
				const name_2121 = temp[2];
				return Node.stringify(expr_2120) + '.' + name_2121
			} break;
			
			case 29: {
				const expr_2122 = temp[1];
				const name_2123 = temp[2];
				return Node.stringify(expr_2122) + '.' + name_2123
			} break;
			
			case 13: {
				const e_2124 = temp[1];
				const args_2125 = temp[2];
				const argNames_2126 = temp[3];
				{
					const arg = [];
					{
						let i = 0;
						let it = 0;
						let at = args_2125.length;
						while (it < at) {
							i = it;
							it++;
							{
								let step = 0;
								const name_2127 = argNames_2126[i];
								if (step == 0 && name_2127 != null) { step = 1 };
								if (step == 1) { arg.push(name_2127 + ': ' + Node.stringify(args_2125[i])) } else {
									arg.push(Node.stringify(args_2125[i]));
								};
							};
						};
					};
					return Node.stringify(e_2124) + '(' + arg.join(', ') + ')';
				}
			} break;
			
			case 31: {
				const elements_2128 = temp[1];
				return '[' + (() => {
					const result = [];
					const value_2129 = elements_2128;
					for (const el of $toIterator(value_2129)) result.push(Node.stringify(el));
					return result;
				})().join(', ') + ']'
			} break;
			
			case 10: {
				const a_2130 = temp[1];
				const op_2131 = temp[2];
				const b_2132 = temp[3];
				return Node.stringify(a_2130) + ' ' + Token.stringify(op_2131) + ' ' + Node.stringify(b_2132)
			} break;
			
			case 38: {
				const names_2133 = temp[1];
				const el_2134 = temp[2];
				return '{' + (() => {
					const result_2135 = [];
					const value_2136 = el_2134.length;
					for (const i of $toIterator(value_2136)) result_2135.push(names_2133[i] + ': ' + Node.stringify(el_2134[i]));
					return result_2135;
				})().join(', ') + '}'
			} break;
			
			case 51: {
				const t_2137 = temp[1];
				return DataHelper.extractTypeName(t_2137)
			} break;
			
			case 47: {
				const f = temp[1];
				return 'static ' + Node.stringify(f)
			} break;
			
			default: 
			return '...'
			};
		} },
		String: (s)=>[0,s],
		Ident: (name_2056)=>[1,name_2056],
		Bool: (b)=>[2,b],
		Int: (s_2057)=>[5,s_2057],
		MetaInt: (s_2058,meta)=>[6,s_2058,meta],
		Float: (s_2059)=>[7,s_2059],
		TypeAlias: (alias,value)=>[9,alias,value],
		Binop: (a,op,b_2060)=>[10,a,op,b_2060],
		AssignOp: (a_2061,op_2062,b_2063)=>[11,a_2061,op_2062,b_2063],
		Block: (el)=>[12,el],
		Call: (e,args,argNames)=>[13,e,args,argNames],
		If: (econd,eif,eelse,ternary)=>[14,econd,eif,eelse,ternary],
		Parenthesis: (inner)=>[15,inner],
		Return: (e_2064)=>[16,e_2064],
		Throw: (e_2065)=>[17,e_2065],
		Unop: (op_2066,postfix,e_2067)=>[20,op_2066,postfix,e_2067],
		While: (econd_2068,e_2069,pre)=>[21,econd_2068,e_2069,pre],
		Function: (name_2070,expr,vars,retType,external)=>[22,name_2070,expr,vars,retType,external],
		Arrow: (expr_2071,vars_2072,retType_2073)=>[23,expr_2071,vars_2072,retType_2073],
		Var: (name_2074,t,expr_2075,const_2076,external_2077)=>[24,name_2074,t,expr_2075,const_2076,external_2077],
		Class: (t_2078,extend,implement,fields,external_2079,kind)=>[25,t_2078,extend,implement,fields,external_2079,kind],
		Property: (v,g,s_2080)=>[26,v,g,s_2080],
		Try: (expr_2081,t_2082,v_2083,catches)=>[27,expr_2081,t_2082,v_2083,catches],
		Dot: (expr_2084,name_2085)=>[28,expr_2084,name_2085],
		DotUpper: (expr_2086,name_2087)=>[29,expr_2086,name_2087],
		New: (path,t_2088,args_2089,fields_2090,el_2091,argNames_2092)=>[30,path,t_2088,args_2089,fields_2090,el_2091,argNames_2092],
		Array: (elements)=>[31,elements],
		Map: (keys,values_2093)=>[32,keys,values_2093],
		Index: (expr_2094,index)=>[33,expr_2094,index],
		Switch: (exprs,conds,guards,cases)=>[34,exprs,conds,guards,cases],
		Module: (path_2095,el_2096)=>[35,path_2095,el_2096],
		ModuleExports: (handle)=>[36,handle],
		Import: (el_2097,path_2098)=>[37,el_2097,path_2098],
		Object: (names,el_2099)=>[38,names,el_2099],
		Enum: (t_2100,fields_2101,valuesType,extend_2102)=>[39,t_2100,fields_2101,valuesType,extend_2102],
		EnumExtract: (path_2103,bind,expr_2104)=>[40,path_2103,bind,expr_2104],
		Is: (expr_2105,t_2106)=>[43,expr_2105,t_2106],
		As: (expr_2107,kind_2108,t_2109)=>[44,expr_2107,kind_2108,t_2109],
		Static: (field)=>[47,field],
		Private: (field_2110)=>[48,field_2110],
		For: (name_2111,over,by,range)=>[49,name_2111,over,by,range],
		Elvis: (nullable,othewise)=>[50,nullable,othewise],
		NodeTypeValue: (type)=>[51,type],
	}
	Object.defineProperty(Node, "This", { get: () => { return [3] }})
	Object.defineProperty(Node, "Super", { get: () => { return [4] }})
	Object.defineProperty(Node, "Null", { get: () => { return [8] }})
	Object.defineProperty(Node, "Break", { get: () => { return [18] }})
	Object.defineProperty(Node, "Continue", { get: () => { return [19] }})
	Object.defineProperty(Node, "EnumConstructor", { get: () => { return [41] }})
	Object.defineProperty(Node, "EnumPattern", { get: () => { return [42] }})
	Object.defineProperty(Node, "Underscore", { get: () => { return [45] }})
	Object.defineProperty(Node, "Interval", { get: () => { return [46] }})
	var NodeType = {
		stringify: (nodeType) => { return DataHelper.extractTypeName(nodeType) },
		Optional: (type_2175)=>[0,type_2175],
		Type: (name_2176,path_2177)=>[1,name_2176,path_2177],
		ParametricType: (name_2178,params,path_2179)=>[2,name_2178,params,path_2179],
		Function: (args_2180,ret)=>[3,args_2180,ret],
		FunctionArg: (name_2181,type_2182,defaultValue)=>[4,name_2181,type_2182,defaultValue],
		Object: (names_2183,types)=>[5,names_2183,types],
		Int: (value_2184)=>[6,value_2184],
		Float: (value_2185)=>[7,value_2185],
		String: (value_2186)=>[8,value_2186],
		Call: (name_2187,argNames_2188,values_2189)=>[9,name_2187,argNames_2188,values_2189],
	}
	var Type = {
		stringify: (type_2199) => { {
			const temp = type_2199;
			switch (temp&&temp[0]) {
			case 4: {
				const type_2200 = temp[1];
				const generic_2201 = temp[2];
				{
					{
						let step = 0;
						const gen = generic_2201;
						if (step == 0 && gen != null) { step = 1 };
						if (step == 1) { return DataHelper.nameOf(type_2200.parent) + '<' + (() => {
							const result = [];
							const value = gen;
							for (const g of $toIterator(value)) result.push(Type.stringify(g));
							return result;
						})().join(', ') + '>' };
					};
					return DataHelper.nameOf(type_2200.parent);
				}
			} break;
			
			case 3: {
				const type_2202 = temp[1];
				return DataHelper.nameOf(type_2202.parent)
			} break;
			
			case 10: {
				const args_2203 = temp[1];
				const returns_2204 = temp[2];
				return '(' + (() => {
					const result_2205 = [];
					const value_2206 = args_2203;
					for (const arg of $toIterator(value_2206)) result_2205.push(Type.stringify(arg));
					return result_2205;
				})().join(', ') + ') => ' + Type.stringify(returns_2204)
			} break;
			
			case 1: {
				const handle_2207 = temp[1];
				{
					{
						let step_2208 = 0;
						const value_2209 = handle_2207.value;
						if (step_2208 == 0 && value_2209 != null) { step_2208 = 1 };
						if (step_2208 == 1) { return Type.stringify(value_2209) + '?' };
					};
					return 'Unknown?';
				}
			} break;
			
			case 2: {
				const type_2210 = temp[1];
				return Type.stringify(type_2210) + '?'
			} break;
			
			case 6: {
				const type_2211 = temp[1];
				return DataHelper.nameOf(type_2211.parent)
			} break;
			
			case 7: {
				const type_2212 = temp[1];
				const tag_2213 = temp[2];
				{
					const tagName = type_2212.fieldNames[tag_2213];
					return DataHelper.nameOf(type_2212.parent) + '.' + tagName;
				}
			} break;
			
			case 0: {
				const handle_2214 = temp[1];
				{
					{
						let step_2215 = 0;
						const value_2216 = handle_2214.value;
						if (step_2215 == 0 && value_2216 != null) { step_2215 = 1 };
						if (step_2215 == 1) { return Type.stringify(value_2216) };
					};
					return 'Unknown';
				}
			} break;
			
			default: 
			return '~?' + type_2199 + '?~'
			};
		} },
		unwrapNullable: (t) => { {
			{
				const temp_2217 = t;
				switch (temp_2217&&temp_2217[0]) {
				case 1: {
					const handle_2218 = temp_2217[1];
					return handle_2218.value
				} break;
				
				case 2: {
					const t_2219 = temp_2217[1];
					return t_2219
				} break;
				};
			};
			return t;
		} },
		Unknown: (handle)=>[0,handle],
		UnknownNullable: (handle_2190)=>[1,handle_2190],
		Nullable: (type)=>[2,type],
		Class: (type_2191)=>[3,type_2191],
		ClassInstance: (type_2192,generic)=>[4,type_2192,generic],
		SuperOf: (type_2193)=>[5,type_2193],
		Enum: (type_2194)=>[6,type_2194],
		EnumInstance: (type_2195,tag)=>[7,type_2195,tag],
		EnumConstructor: (type_2196,tag_2197)=>[8,type_2196,tag_2197],
		Alias: (type_2198)=>[9,type_2198],
		Function: (args,returns)=>[10,args,returns],
		Struct: (names,types)=>[11,names,types],
	}
	var process_99 = $global.process
	var console_47 = $global.console
	var Normalizer = class {
		constructor(project) { 
			this.niceProject = new NiceProject()
			this.keywords = []
			this.reservedGlobals = []
			this.collected = []
			this.nativeEnums = false
			this.globalAccessor = '<!-- global -->'
			this.inline = new Map()
			this.nonInlineRead = new Map()
			this.scopes = [new Map()]
			this.globals = []
			this.id = Math.round(Math.random() * 123)
			this.parentNames = new Map()
		this.project = project };
		normalize() {
			for (const global of $toIterator(this.reservedGlobals)) {
				this.addToScope(global);
			};
			for (const file of $toIterator(this.project.moduleInfo)) {
				for (const e of $toIterator(file.nodes)) {
					const temp = e;
					switch (temp&&temp[0]) {
					case 25: {
						const t = temp[1];
						const ext = temp[2];
						const impl = temp[3];
						const fields = temp[4];
						const external = temp[5];
						this.renameClassFields(fields)
					} break;
					
					case 39: {
						const t_113 = temp[1];
						const fields_114 = temp[2];
						const valuesType = temp[3];
						this.renameClassFields(fields_114)
					} break;
					
					case 24: {
						const name = temp[1];
						const t_115 = temp[2];
						const expr = temp[3];
						const const_116 = temp[4];
						const external_117 = temp[5];
						{
							const atts = this.project.mapDecorators.get(e);
							{
								let step = 0;
								const native = Normalizer.getDec(atts, 'rename');
								if (step == 0 && native != null) { step = 1 };
								if (step == 1) {
									const temp_118 = native.values[0];
									switch (temp_118&&temp_118[0]) {
									case 0: {
										const s = temp_118[1];
										this.uniqueNative(s, e)
									} break;
									
									default: 
									throw '@rename takes string as argument'
									};
								} else {
									this.unique(name, e);
								};
							};
						}
					} break;
					
					case 22: {
						const name_119 = temp[1];
						const expr_120 = temp[2];
						const vars = temp[3];
						const rettype = temp[4];
						const external_121 = temp[5];
						if ((this.parentNames.get(e) == null)) {
							let step_122 = 0;
							const name_123 = this.getNative(e);
							if (step_122 == 0 && name_123 != null) { step_122 = 1 };
							if (step_122 == 1) { this.uniqueNative(name_123, e) } else {
								let step_124 = 0;
								const name_125 = name_119;
								if (step_124 == 0 && name_125 != null) { step_124 = 1 };
								if (step_124 == 1) { this.unique(name_125, e) };
							};
						}
					} break;
					};
				};
			};
			const init_126 = [];
			for (const file of $toIterator(this.project.moduleInfo)) {
				const initial = [];
				this.pushScope();
				for (const e of $toIterator(file.nodes)) {
					const temp_127 = e;
					switch (temp_127&&temp_127[0]) {
					case 22: {
						{
							let step_128 = 0;
							const s_129 = this.nodeToStatement(e);
							if (step_128 == 0 && s_129 != null) { step_128 = 1 };
							if (step_128 == 1) { this.niceProject.globalFuncs.push(s_129) };
						}
					} break;
					
					case 24: {
						{
							let step_130 = 0;
							const s_131 = this.nodeToStatement(e);
							if (step_130 == 0 && s_131 != null) { step_130 = 1 };
							if (step_130 == 1) { this.niceProject.globalVars.push(s_131) };
						}
					} break;
					
					case 39: {
						this.fillStatement(e, 'path')
					} break;
					
					case 25: {
						this.fillStatement(e, 'path')
					} break;
					
					default: 
					{
						const statement = this.fillStatement(e, null);
						{
							const temp_132 = statement;
							switch (temp_132&&temp_132[0]) {
							case null: case undefined: {
								{
								}
							} break;
							
							case 1: {
								const el = temp_132[1];
								if ((el.length > 0)) { initial.push(statement) }
							} break;
							
							default: 
							initial.push(statement)
							};
						};
					}
					};
				};
				this.popScope();
				if ((initial.length > 0)) { init_126.push(/*Block*/[1,initial]) };
			};
			this.niceProject.init.push(/*Block*/[1,init_126]);
			if ((this.niceProject.init.length > 1)) { throw 'too many inits' };
			this.niceProject.package = this.package;
			this.niceProject.typer = this.typer;
			this.niceProject.classes.sort((a, b) => {
				if ((a.external == true)) { return (-1) };
				if ((a.extend == null)) { return 0 };
				return 1;
			});
			return this.niceProject;
		};
		nodeToExpression(e) {
			const result = this.nodeToExpressionWithoutPosition(e);
			if ((result != null)) {
				this.niceProject.expressionPosition.set(result, this.project.data.get(e));
				if ((this.niceProject.expressionType.get(result) == null)) { this.niceProject.expressionType.set(result, this.typer.types.get(e)) };
			};
			return result;
		};
		nodeToExpressionWithoutPosition(e_133) {
			if ((e_133 == null)) { return null };
			{
				const temp_134 = e_133;
				switch (temp_134&&temp_134[0]) {
				case 0: {
					const v = temp_134[1];
					return /*String*/[0,v]
				} break;
				
				case 5: {
					const v_135 = temp_134[1];
					return /*Int*/[1,v_135]
				} break;
				
				case 6: {
					const v_136 = temp_134[1];
					const meta = temp_134[2];
					return /*MetaInt*/[2,v_136,meta,this.typer.types.get(e_133)]
				} break;
				
				case 7: {
					const v_137 = temp_134[1];
					return /*Float*/[3,v_137]
				} break;
				
				case 2: {
					const v_138 = temp_134[1];
					{
						if (v_138) { return /*True*/[4] };
						return /*False*/[5];
					}
				} break;
				
				case 8: {
					return /*Null*/[7]
				} break;
				
				case 51: {
					const t_139 = temp_134[1];
					{
						const temp_140 = t_139;
						switch (temp_140&&temp_140[0]) {
						case 1: {
							const name_141 = temp_140[1];
							return /*Ident*/[6,(() => {
								const result_142 = this.parentNames.get(this.typer.parents.get(e_133));
								if (result_142 != null) { return result_142 };
								return name_141;
							})(),null]
						} break;
						};
					}
				} break;
				
				case 1: {
					const name_143 = temp_134[1];
					{
						let source = this.typer.parents.get(e_133);
						{
							let step_144 = 0;
							const value = this.inline.get(source);
							if (step_144 == 0 && value != null) { step_144 = 1 };
							if (step_144 == 1) { return value };
						};
						this.nonInlineRead.set(source, true);
						{
							const temp_145 = source;
							switch (temp_145&&temp_145[0]) {
							case null: case undefined: {
								throw ('Unmapped `' + (e_133) + '` of name `' + (name_143) + '` ') + JSON.stringify(this.project.data.get(e_133))
							} break;
							
							case 24: {
								const name_146 = temp_145[1];
								{
									const staticSource = this.typer.parents.get(source);
									{
										let step_147 = 0;
										const map = this.typer.parents.get(source);
										if (step_147 == 0 && map != null) { step_147 = 1 };
										if (step_147 == 1) {
											const temp_148 = (map);
											switch (temp_148&&temp_148[0]) {
											case 35: {
												{
													const name_149 = (() => {
														const result_150 = this.parentNames.get(source);
														if (result_150 != null) { return result_150 };
														return name_146;
													})();
													return /*Ident*/[6,this.globalAccessor + name_149,this.typer.types.get(source)];
												}
											} break;
											
											default: 
											{
												const type = this.typer.types.get(this.typer.parents.get(source));
												return /*Dot*/[9,/*This*/[8,type],this.getClassDotField(staticSource, name_146),this.typer.types.get(e_133)];
											}
											};
										};
									};
								}
							} break;
							
							case 22: {
								const name_151 = temp_145[1];
								{
									let step_152 = 0;
									const map_153 = this.typer.parents.get(source);
									if (step_152 == 0 && map_153 != null) { step_152 = 1 };
									if (step_152 == 1) {
										const temp_154 = (map_153);
										switch (temp_154&&temp_154[0]) {
										case 35: {
											{
												const result_155 = /*Ident*/[6,this.globalAccessor + ((() => {
													const result_156 = this.parentNames.get(source);
													if (result_156 != null) { return result_156 };
													return name_151;
												})()),null];
												{
													let step_157 = 0;
													const name_158 = this.getNative(source);
													if (step_157 == 0 && name_158 != null) { step_157 = 1 };
													if (step_157 == 1) { this.niceProject.native.set(result_155, true) };
												};
												return result_155;
											}
										} break;
										
										default: 
										{
											const type_159 = this.typer.types.get(this.typer.parents.get(source));
											return /*Dot*/[9,/*This*/[8,type_159],(() => {
												const result_160 = this.parentNames.get(source);
												if (result_160 != null) { return result_160 };
												return name_151;
											})(),this.typer.types.get(e_133)];
										}
										};
									};
								}
							} break;
							
							case 47: {
								const f = temp_145[1];
								{
									const staticSource_161 = this.typer.parents.get(source);
									{
										const temp_162 = staticSource_161;
										switch (temp_162&&temp_162[0]) {
										case 25: {
											const t_163 = temp_162[1];
											return /*Dot*/[9,/*Ident*/[6,DataHelper.extractTypeName(t_163),null],this.getClassDotField(staticSource_161, name_143),this.typer.types.get(e_133)]
										} break;
										
										case 39: {
											const t_164 = temp_162[1];
											return /*Dot*/[9,/*Ident*/[6,DataHelper.extractTypeName(t_164),null],this.getClassDotField(staticSource_161, name_143),this.typer.types.get(e_133)]
										} break;
										
										default: 
										throw ('staticSource is ' + (staticSource_161) + ' for ' + (name_143) + '')
										};
									};
								}
							} break;
							};
						};
						const result_165 = /*Ident*/[6,(() => {
							const result_166 = this.parentNames.get(source);
							if (result_166 != null) { return result_166 };
							return name_143;
						})(),this.typer.types.get(e_133)];
						if (Normalizer.getDec(this.project.mapDecorators.get(source), 'rename') != null) { this.niceProject.native.set(result_165, true) };
						return result_165;
					}
				} break;
				
				case 28: {
					const expr_167 = temp_134[1];
					const name_168 = temp_134[2];
					{
						const parent = this.typer.parents.get(expr_167);
						{
							const temp_169 = parent;
							switch (temp_169&&temp_169[0]) {
							case 39: {
								const t_170 = temp_169[1];
								const fields_171 = temp_169[2];
								const valuesType_172 = temp_169[3];
								{
									{
										let step_173 = 0;
										const temp_174 = (!this.nativeEnums);
										let vt = null;
										if (step_173 == 0 && temp_174 != false) {
											vt = valuesType_172;
											step_173 = 1;
										};
										let tag = null;
										if (step_173 == 1 && vt != null) {
											tag = this.getTag(parent, name_168);
											step_173 = 2;
										};
										if (step_173 == 2 && tag != null) { step_173 = 3 };
										if (step_173 == 3) { return tag };
									};
									return /*Dot*/[9,this.nodeToExpression(expr_167),(() => {
										const result_175 = this.getClassDotField(parent, name_168);
										if (result_175 != null) { return result_175 };
										return name_168;
									})(),this.typer.types.get(e_133)];
								}
							} break;
							
							case 25: {
								return /*Dot*/[9,this.nodeToExpression(expr_167),(() => {
									const result_176 = this.getClassDotField(parent, name_168);
									if (result_176 != null) { return result_176 };
									return name_168;
								})(),this.typer.types.get(e_133)]
							} break;
							};
						};
						{
							let step_177 = 0;
							const type_178 = this.typer.types.get(expr_167);
							if (step_177 == 0 && type_178 != null) { step_177 = 1 };
							if (step_177 == 1) {
								const temp_179 = (type_178);
								switch (temp_179&&temp_179[0]) {
								case 4: {
									const type_180 = temp_179[1];
									{
										const renamed = type_180.fieldRenames[type_180.fieldNames.indexOf(name_168)];
										{
											let step_181 = 0;
											const rename = renamed;
											if (step_181 == 0 && rename != null) { step_181 = 1 };
											if (step_181 == 1) { return /*Dot*/[9,this.nodeToExpression(expr_167),rename,this.typer.types.get(e_133)] };
										};
									}
								} break;
								};
							};
						};
						const value_182 = this.nodeToExpression(expr_167);
						if ((name_168 == 'length')) {
							const temp_183 = value_182;
							switch (temp_183&&temp_183[0]) {
							case 0: {
								const s_184 = temp_183[1];
								return /*Int*/[1,s_184.length]
							} break;
							};
						};
						return /*Dot*/[9,value_182,name_168,this.typer.types.get(e_133)];
					}
				} break;
				
				case 29: {
					const expr_185 = temp_134[1];
					const name_186 = temp_134[2];
					{
						const parent_187 = this.typer.parents.get(expr_185);
						{
							const temp_188 = parent_187;
							switch (temp_188&&temp_188[0]) {
							case 39: {
								const t_189 = temp_188[1];
								const fields_190 = temp_188[2];
								const valuesType_191 = temp_188[3];
								{
									{
										let step_192 = 0;
										const temp_193 = (!this.nativeEnums);
										let vt_194 = null;
										if (step_192 == 0 && temp_193 != false) {
											vt_194 = valuesType_191;
											step_192 = 1;
										};
										let tag_195 = null;
										if (step_192 == 1 && vt_194 != null) {
											tag_195 = this.getTag(parent_187, name_186);
											step_192 = 2;
										};
										if (step_192 == 2 && tag_195 != null) { step_192 = 3 };
										if (step_192 == 3) { return tag_195 };
									};
									{
										let step_196 = 0;
										const temp_197 = (!this.nativeEnums);
										let temp_198 = null;
										if (step_196 == 0 && temp_197 != false) {
											temp_198 = valuesType_191 == null;
											step_196 = 1;
										};
										let tag_199 = null;
										if (step_196 == 1 && temp_198 != false) {
											tag_199 = this.getTag(parent_187, name_186);
											step_196 = 2;
										};
										if (step_196 == 2 && tag_199 != null) { step_196 = 3 };
										if (step_196 == 3) { return /*Enum*/[28,DataHelper.extractTypeName(t_189),name_186,tag_199,[]] };
									};
									return /*Dot*/[9,this.nodeToExpression(expr_185),(() => {
										const result_200 = this.getClassDotField(parent_187, name_186);
										if (result_200 != null) { return result_200 };
										return name_186;
									})(),this.typer.types.get(e_133)];
								}
							} break;
							
							case 25: {
								return /*Dot*/[9,this.nodeToExpression(expr_185),(() => {
									const result_201 = this.getClassDotField(parent_187, name_186);
									if (result_201 != null) { return result_201 };
									return name_186;
								})(),this.typer.types.get(e_133)]
							} break;
							};
						};
						return /*Dot*/[9,this.nodeToExpression(expr_185),name_186,this.typer.types.get(e_133)];
					}
				} break;
				
				case 13: {
					const expr_202 = temp_134[1];
					const args = temp_134[2];
					const argNames = temp_134[3];
					{
						if (args.length == 1) {
							const temp_203 = expr_202;
							switch (temp_203&&temp_203[0]) {
							case 28: {
								const expr_204 = temp_203[1];
								const name_205 = temp_203[2];
								if (name_205 == 'charCodeAt') {
									const temp_206 = expr_204;
									switch (temp_206&&temp_206[0]) {
									case 0: {
										const s_207 = temp_206[1];
										if (s_207.indexOf('\\') == (-1)) {
											const temp_208 = args[0];
											switch (temp_208&&temp_208[0]) {
											case 5: {
												const v_209 = temp_208[1];
												{
													const i = v_209;
													if ((i < s_207.length) && (i > (-1))) {
														const value_210 = s_207.charCodeAt(i);
														const result_211 = (value_210 > (-1))? (/*Int*/[1,'' + value_210]) : /*Int*/[1,'0'];
														this.niceProject.expressionType.set(result_211, this.typer.typeInt);
														return result_211;
													};
												}
											} break;
											};
										}
									} break;
									};
								}
							} break;
							};
						};
						let kind = 11;
						{
							const temp_212 = expr_202;
							switch (temp_212&&temp_212[0]) {
							case 28: {
								const expr_213 = temp_212[1];
								{
									const temp_214 = (this.typer.types.get(expr_213));
									switch (temp_214&&temp_214[0]) {
									case 4: {
										kind = 12
									} break;
									
									case 3: {
										kind = 10
									} break;
									};
								}
							} break;
							};
						};
						const a_215 = [];
						for (const arg of $toIterator(args)) {
							a_215.push(this.nodeToExpression(arg));
						};
						if (((!this.nativeEnums))) {
							const temp_216 = expr_202;
							switch (temp_216&&temp_216[0]) {
							case 29: {
								const expr_217 = temp_216[1];
								const name_218 = temp_216[2];
								{
									const parent_219 = this.typer.parents.get(expr_217);
									{
										const temp_220 = parent_219;
										switch (temp_220&&temp_220[0]) {
										case 39: {
											const t_221 = temp_220[1];
											const fields_222 = temp_220[2];
											const valuesType_223 = temp_220[3];
											{
												let step_224 = 0;
												const tag_225 = this.getTag(parent_219, name_218);
												if (step_224 == 0 && tag_225 != null) { step_224 = 1 };
												if (step_224 == 1) { return /*Enum*/[28,DataHelper.extractTypeName(t_221),name_218,tag_225,a_215] };
											}
										} break;
										};
									};
								}
							} break;
							};
						};
						const atts_226 = this.project.mapDecorators.get(this.typer.parents.get(expr_202));
						{
							let step_227 = 0;
							const infix = Normalizer.getDec(atts_226, 'infix');
							if (step_227 == 0 && infix != null) { step_227 = 1 };
							if (step_227 == 1) {
								const temp_228 = infix.values[0];
								switch (temp_228&&temp_228[0]) {
								case 0: {
									const s_229 = temp_228[1];
									return /*NativeOperator*/[26,0,a_215,s_229]
								} break;
								
								default: 
								throw '@infix takes string as argument'
								};
							};
						};
						{
							let step_230 = 0;
							const operator = Normalizer.getDec(atts_226, 'operator');
							if (step_230 == 0 && operator != null) { step_230 = 1 };
							if (step_230 == 1) {
								const temp_231 = operator.values[0];
								switch (temp_231&&temp_231[0]) {
								case 0: {
									const s_232 = temp_231[1];
									return /*NativeOperator*/[26,1,a_215,s_232]
								} break;
								
								default: 
								throw '@operator takes string as argument'
								};
							};
						};
						const v_233 = this.nodeToExpression(expr_202);
						{
							const temp_234 = v_233;
							switch (temp_234&&temp_234[0]) {
							case 9: {
								const expr_235 = temp_234[1];
								{
									const temp_236 = expr_235;
									switch (temp_236&&temp_236[0]) {
									case 8: {
										kind = 12
									} break;
									};
								}
							} break;
							};
						};
						return /*Call*/[10,v_233,a_215,this.typer.types.get(e_133),kind];
					}
				} break;
				
				case 10: {
					const a_237 = temp_134[1];
					const op = temp_134[2];
					const b_238 = temp_134[3];
					{
						const ea = this.nodeToExpression(a_237);
						const eb = this.nodeToExpression(b_238);
						if (op == 111) {
							const temp_239 = ea;
							switch (temp_239&&temp_239[0]) {
							case 0: {
								const sa = temp_239[1];
								{
									const temp_240 = eb;
									switch (temp_240&&temp_240[0]) {
									case 0: {
										const sb = temp_240[1];
										return /*String*/[0,sa + sb]
									} break;
									
									case 1: {
										const sb_241 = temp_240[1];
										return /*String*/[0,sa + sb_241]
									} break;
									
									case 3: {
										const sb_242 = temp_240[1];
										return /*String*/[0,sa + sb_242]
									} break;
									
									case 4: {
										return /*String*/[0,sa + 'true']
									} break;
									
									case 5: {
										return /*String*/[0,sa + 'false']
									} break;
									};
								}
							} break;
							
							case 1: {
								const sa_243 = temp_239[1];
								{
									const temp_244 = eb;
									switch (temp_244&&temp_244[0]) {
									case 1: {
										const sb_245 = temp_244[1];
										return /*Int*/[1,sa_243 + sb_245]
									} break;
									
									case 3: {
										const sb_246 = temp_244[1];
										return /*Float*/[3,sa_243 + sb_246]
									} break;
									
									case 0: {
										const sb_247 = temp_244[1];
										return /*String*/[0,sa_243 + sb_247]
									} break;
									};
								}
							} break;
							
							case 3: {
								const sa_248 = temp_239[1];
								{
									const temp_249 = eb;
									switch (temp_249&&temp_249[0]) {
									case 1: {
										const sb_250 = temp_249[1];
										return /*Float*/[3,sa_248 + sb_250]
									} break;
									
									case 3: {
										const sb_251 = temp_249[1];
										return /*Float*/[3,sa_248 + sb_251]
									} break;
									
									case 0: {
										const sb_252 = temp_249[1];
										return /*String*/[0,sa_248 + sb_252]
									} break;
									};
								}
							} break;
							};
						};
						if ((op == 93)) {
							const temp_253 = ea;
							switch (temp_253&&temp_253[0]) {
							case 4: {
								{
									const temp_254 = eb;
									switch (temp_254&&temp_254[0]) {
									case 5: {
										return /*True*/[4]
									} break;
									
									case 4: {
										return /*True*/[4]
									} break;
									};
								}
							} break;
							
							case 5: {
								{
									const temp_255 = eb;
									switch (temp_255&&temp_255[0]) {
									case 5: {
										return /*False*/[5]
									} break;
									
									case 4: {
										return /*True*/[4]
									} break;
									};
								}
							} break;
							};
						};
						if ((op == 92)) {
							const temp_256 = ea;
							switch (temp_256&&temp_256[0]) {
							case 4: {
								{
									const temp_257 = eb;
									switch (temp_257&&temp_257[0]) {
									case 5: {
										return /*False*/[5]
									} break;
									
									case 4: {
										return /*True*/[4]
									} break;
									};
								}
							} break;
							
							case 5: {
								{
									const temp_258 = eb;
									switch (temp_258&&temp_258[0]) {
									case 5: {
										return /*False*/[5]
									} break;
									
									case 4: {
										return /*False*/[5]
									} break;
									};
								}
							} break;
							};
						};
						return /*Binop*/[12,ea,op,eb,this.typer.types.get(e_133)];
					}
				} break;
				
				case 30: {
					const path = temp_134[1];
					const t_259 = temp_134[2];
					const args_260 = temp_134[3];
					const fields_261 = temp_134[4];
					const el_262 = temp_134[5];
					{
						const v_263 = /*Ident*/[6,(() => {
							const result_264 = this.parentNames.get(this.typer.parents.get(e_133));
							if (result_264 != null) { return result_264 };
							return DataHelper.extractTypeName(t_259);
						})(),null];
						const a_265 = [];
						for (const arg of $toIterator(args_260)) {
							a_265.push(this.nodeToExpression(arg));
						};
						return /*New*/[11,v_263,a_265,this.typer.types.get(e_133)];
					}
				} break;
				
				case 22: {
					const name_266 = temp_134[1];
					const expr_267 = temp_134[2];
					const vars_268 = temp_134[3];
					const rettype_269 = temp_134[4];
					const external_270 = temp_134[5];
					{
						const a_271 = [];
						const defaults = [];
						const types = [];
						for (const arg of $toIterator(vars_268)) {
							const temp_272 = arg;
							switch (temp_272&&temp_272[0]) {
							case 24: {
								const name_273 = temp_272[1];
								const t_274 = temp_272[2];
								const expr_275 = temp_272[3];
								const const_276 = temp_272[4];
								{
									a_271.push(this.unique(name_273, arg));
									types.push(t_274);
									if ((expr_275 != null)) { defaults.push(this.nodeToExpression(expr_275)) } else {
										defaults.push(null);
									};
								}
							} break;
							};
						};
						return /*Function*/[13,(name_266 != null)? (this.unique(name_266, e_133)) : (null),this.nodeToStatement(expr_267),a_271,defaults,this.typer.types.get(e_133)];
					}
				} break;
				
				case 23: {
					const expr_277 = temp_134[1];
					const vars_278 = temp_134[2];
					const rettype_279 = temp_134[3];
					{
						const a_280 = [];
						const defaults_281 = [];
						const types_282 = [];
						for (const arg of $toIterator(vars_278)) {
							const temp_283 = arg;
							switch (temp_283&&temp_283[0]) {
							case 24: {
								const name_284 = temp_283[1];
								const t_285 = temp_283[2];
								const expr_286 = temp_283[3];
								const const_287 = temp_283[4];
								{
									a_280.push(this.unique(name_284, arg));
									types_282.push(t_285);
									if ((expr_286 != null)) { defaults_281.push(this.nodeToExpression(expr_286)) } else {
										defaults_281.push(null);
									};
								}
							} break;
							};
						};
						return /*Arrow*/[14,this.nodeToExpression(expr_277),a_280,defaults_281,types_282,rettype_279,this.typer.types.get(e_133)];
					}
				} break;
				
				case 12: {
					const el_288 = temp_134[1];
					{
						if ((el_288.length == 0)) { return /*Object*/[16,[],[],[]] };
						if ((el_288.length == 1)) { return this.nodeToExpression(el_288[0]) };
						const block = [];
						let i_289 = 0;
						while (i_289 < el_288.length - 1) {
							{
								let step_290 = 0;
								const s_291 = this.nodeToStatement(el_288[i_289]);
								if (step_290 == 0 && s_291 != null) { step_290 = 1 };
								if (step_290 == 1) { block.push(s_291) };
							};
							i_289++;
						};
						const result_292 = el_288[el_288.length - 1];
						block.push(/*Return*/[6,this.nodeToExpression(result_292)]);
						return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,block],[],[],null]],[],this.typer.types.get(result_292),11];
					}
				} break;
				
				case 38: {
					const names = temp_134[1];
					const el_293 = temp_134[2];
					{
						const els = [];
						const types_294 = [];
						for (const e of $toIterator(el_293)) {
							els.push(this.nodeToExpression(e));
							types_294.push(this.typer.types.get(e));
						};
						return /*Object*/[16,names,els,types_294];
					}
				} break;
				
				case 15: {
					const inner = temp_134[1];
					{
						const unwrapNestedParens = (inner_295) => {
							const temp_296 = inner_295;
							switch (temp_296&&temp_296[0]) {
							case 15: {
								const i_297 = temp_296[1];
								return unwrapNestedParens(i_297)
							} break;
							
							default: 
							return inner_295
							};
						};
						const value_298 = this.nodeToExpression(unwrapNestedParens(inner));
						{
							const temp_299 = value_298;
							switch (temp_299&&temp_299[0]) {
							case 1: {
								return value_298
							} break;
							
							case 0: {
								return value_298
							} break;
							
							case 3: {
								return value_298
							} break;
							
							case 4: {
								return value_298
							} break;
							
							case 5: {
								return value_298
							} break;
							
							case 7: {
								return value_298
							} break;
							};
						};
						return /*Parenthesis*/[15,value_298];
					}
				} break;
				
				case 31: {
					const el_300 = temp_134[1];
					{
						if ((el_300.length == 1)) {
							const temp_301 = el_300[0];
							switch (temp_301&&temp_301[0]) {
							case 49: {
								const name_302 = temp_301[1];
								const over = temp_301[2];
								const by = temp_301[3];
								const range = temp_301[4];
								{
									const block_303 = [];
									const result_304 = this.unique('result');
									const resultType = this.typer.types.get(e_133);
									block_303.push(/*Const*/[4,result_304,/*Array*/[17,[],this.typer.types.get(e_133)],this.typer.types.get(e_133)]);
									const value_305 = this.unique('value');
									const valueType = this.typer.types.get(el_300[0]);
									block_303.push(/*Const*/[4,value_305,this.nodeToExpression(over),valueType]);
									const push = /*Call*/[2,/*Dot*/[9,/*Ident*/[6,result_304,this.typer.types.get(e_133)],'push',null],[this.nodeToExpression(by)],[],12];
									const fillLoop = () => {
										{
											const temp_306 = over;
											switch (temp_306&&temp_306[0]) {
											case 5: {
												const s_307 = temp_306[1];
												{
													const i_308 = name_302;
													block_303.push(/*Const*/[4,i_308,/*Int*/[1,(-1)],this.typer.typeInt]);
													block_303.push(/*While*/[13,/*Binop*/[12,/*Parenthesis*/[15,/*Binop*/[12,/*Ident*/[6,i_308,this.typer.typeInt],111,/*Int*/[1,1],this.typer.typeInt]],99,/*Ident*/[6,value_305,valueType],this.typer.typeBool],/*Block*/[1,[/*Increment*/[14,/*Ident*/[6,i_308,this.typer.typeInt]], push]],true]);
													return;
												}
											} break;
											};
										};
										block_303.push(/*For*/[12,name_302,/*Ident*/[6,value_305,valueType],push]);
									};
									fillLoop();
									block_303.push(/*Return*/[6,/*Ident*/[6,result_304,resultType]]);
									return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,block_303],[],[],/*Function*/[10,[],this.typer.types.get(e_133)]]],[],this.typer.types.get(e_133),11];
								}
							} break;
							};
						};
						const els_309 = [];
						const types_310 = [];
						for (const e of $toIterator(el_300)) {
							els_309.push(this.nodeToExpression(e));
							types_310.push(this.typer.types.get(e));
						};
						return /*Array*/[17,els_309,this.typer.types.get(e_133)];
					}
				} break;
				
				case 50: {
					const nullable = temp_134[1];
					const otherwise = temp_134[2];
					{
						const result_311 = this.unique('result');
						const resultType_312 = null;
						return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,[/*Const*/[4,result_311,this.nodeToExpression(nullable),null], /*If*/[7,/*Binop*/[12,/*Ident*/[6,result_311,null],103,/*Null*/[7],this.typer.typeBool],/*Return*/[6,/*Ident*/[6,result_311,null]],null], /*Return*/[6,this.nodeToExpression(otherwise)]]],[],[],/*Function*/[10,[],this.typer.types.get(otherwise)]]],[],this.typer.types.get(otherwise),11];
						return /*Elvis*/[20,this.nodeToExpression(nullable),this.nodeToExpression(otherwise)];
					}
				} break;
				
				case 20: {
					const op_313 = temp_134[1];
					const postfix = temp_134[2];
					const e_314 = temp_134[3];
					{
						const expression = this.nodeToExpression(e_314);
						{
							const temp_315 = op_313;
							switch (temp_315) {
							case 89: {
								{
									const temp_316 = expression;
									switch (temp_316&&temp_316[0]) {
									case 4: {
										return /*False*/[5]
									} break;
									
									case 5: {
										{
											return /*True*/[4];
											console.log('dat bruh');
											return /*True*/[4];
										}
									} break;
									};
								}
							} break;
							};
						};
						return /*Unop*/[19,op_313,postfix,expression];
					}
				} break;
				
				case 3: {
					return /*This*/[8,this.typer.types.get(e_133)]
				} break;
				
				case 32: {
					const keys = temp_134[1];
					const values = temp_134[2];
					{
						const k = [];
						const v_317 = [];
						for (const key of $toIterator(keys)) {
							k.push(this.nodeToExpression(key));
						};
						for (const value of $toIterator(values)) {
							v_317.push(this.nodeToExpression(value));
						};
						return /*Map*/[18,k,v_317,this.typer.types.get(keys[0]),this.typer.types.get(values[0])];
					}
				} break;
				
				case 11: {
					const a_318 = temp_134[1];
					const op_319 = temp_134[2];
					const b_320 = temp_134[3];
					return /*Assignop*/[25,this.nodeToExpression(a_318),op_319,this.nodeToExpression(b_320)]
				} break;
				
				case 14: {
					const econd = temp_134[1];
					const eif = temp_134[2];
					const eelse = temp_134[3];
					{
						let binds = false;
						for (const cond of $toIterator(econd)) {
							const temp_321 = cond;
							switch (temp_321&&temp_321[0]) {
							case 24: {
								binds = true
							} break;
							};
						};
						if ((!binds) && econd.length == 1) { return /*If*/[21,this.nodeToExpression(econd[0]),this.nodeToExpression(eif),this.nodeToExpression(eelse)] };
						if ((!binds)) {
							let parens = /*Parenthesis*/[15,this.nodeToExpression(econd[0])];
							let i_322 = 1;
							while (i_322 < econd.length) {
								parens = /*Binop*/[12,parens,92,/*Parenthesis*/[15,this.nodeToExpression(econd[i_322])],this.typer.typeBool];
								i_322++;
							};
							return /*If*/[21,parens,this.nodeToExpression(eif),this.nodeToExpression(eelse)];
						};
						return /*If*/[21,this.nodeToExpression(econd[0]),this.nodeToExpression(eif),this.nodeToExpression(eelse)];
					}
				} break;
				
				case 33: {
					const expr_323 = temp_134[1];
					const index = temp_134[2];
					return /*Index*/[22,this.nodeToExpression(expr_323),this.nodeToExpression(index)]
				} break;
				
				case 44: {
					const e_324 = temp_134[1];
					const kind_325 = temp_134[2];
					const t_326 = temp_134[3];
					{
						const temp_327 = kind_325;
						switch (temp_327) {
						case 81: {
							console.log('`as?` is not yet supported by normalizer, only `as!`')
						} break;
						
						case 89: {
							return /*UnsafeBitCast*/[23,this.nodeToExpression(e_324),this.typer.types.get(t_326)]
						} break;
						
						default: 
						console.log('`as` is not yet supported by normalizer, only `as!`')
						};
					}
				} break;
				
				case 43: {
					const e_328 = temp_134[1];
					const t_329 = temp_134[2];
					return /*Is*/[24,this.nodeToExpression(e_328),this.typer.types.get(t_329)]
				} break;
				
				case 34: {
					const exprs = temp_134[1];
					const conds = temp_134[2];
					const guards = temp_134[3];
					const cases = temp_134[4];
					{
						const block_330 = [];
						const caseRet = [];
						let funcType = this.typer.typeVoid;
						let resultType_331 = this.typer.typeVoid;
						for (const c of $toIterator(cases)) {
							resultType_331 = this.typer.types.get(c);
							funcType = /*Function*/[10,[],resultType_331];
							caseRet.push(/*Return*/[16,c]);
						};
						block_330.push(this.nodeToStatement(/*Switch*/[34,exprs,conds,guards,caseRet]));
						return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,block_330],[],[],funcType]],[],resultType_331,11];
					}
				} break;
				
				case 35: {
					{
					}
				} break;
				
				case 37: {
					{
					}
				} break;
				
				case 9: {
					{
					}
				} break;
				
				default: 
				console.error('(internal warning) Unknown node type for expression:', e_133, this.project.data.get(e_133))
				};
			};
			return null;
		};
		nodeToStatement(e_332) {
			const result_333 = this.nodeToStatementWithoutPosition(e_332);
			if ((result_333 != null)) { this.niceProject.statementPosition.set(result_333, this.project.data.get(e_332)) };
			return result_333;
		};
		nodeToStatementWithoutPosition(e_334) {
			if ((e_334 == null)) { return null };
			{
				const temp_335 = e_334;
				switch (temp_335&&temp_335[0]) {
				case 12: {
					const el_336 = temp_335[1];
					{
						let els_337 = [];
						for (const e of $toIterator(el_336)) {
							const statement_338 = this.nodeToStatement(e);
							if (statement_338 != null) { els_337.push(statement_338) };
						};
						if (els_337.length == 1) {
							const temp_339 = els_337[0];
							switch (temp_339&&temp_339[0]) {
							case 1: {
								return els_337[0]
							} break;
							};
						};
						return /*Block*/[1,els_337];
					}
				} break;
				
				case 39: {
					const t_340 = temp_335[1];
					const fields_341 = temp_335[2];
					const valuesType_342 = temp_335[3];
					{
						this.renameClassFields(fields_341);
						const isComplexEnum = valuesType_342 == null;
						if (isComplexEnum) {
							const type_343 = new NiceComplexEnum();
							type_343.name = this.unique(DataHelper.extractTypeName(t_340), e_334);
							this.globals.push(type_343.name);
							const names_344 = [];
							const constructors = [];
							const constructorsTypes = [];
							const types_345 = [];
							for (const f of $toIterator(fields_341)) {
								const temp_346 = f;
								switch (temp_346&&temp_346[0]) {
								case 51: {
									const t_347 = temp_346[1];
									{
										const temp_348 = t_347;
										switch (temp_348&&temp_348[0]) {
										case 1: {
											const name_349 = temp_348[1];
											{
												names_344.push(name_349);
												constructors.push(null);
												constructorsTypes.push(null);
												types_345.push(null);
											}
										} break;
										};
									}
								} break;
								
								case 13: {
									const e_350 = temp_346[1];
									const args_351 = temp_346[2];
									const argNames_352 = temp_346[3];
									{
										{
											const temp_353 = e_350;
											switch (temp_353&&temp_353[0]) {
											case 51: {
												const t_354 = temp_353[1];
												{
													const temp_355 = t_354;
													switch (temp_355&&temp_355[0]) {
													case 1: {
														const name_356 = temp_355[1];
														names_344.push(name_356)
													} break;
													};
												}
											} break;
											};
										};
										constructors.push((() => {
											const result_357 = [];
											const value_358 = argNames_352;
											for (const arg of $toIterator(value_358)) result_357.push(this.unique((arg)));
											return result_357;
										})());
										constructorsTypes.push((() => {
											const result_359 = [];
											const value_360 = args_351;
											for (const arg of $toIterator(value_360)) result_359.push(this.typer.toType(Typer.nodeToNodeType(arg), arg));
											return result_359;
										})());
										types_345.push((() => {
											const result_361 = [];
											const value_362 = args_351;
											for (const arg of $toIterator(value_362)) result_361.push(this.unique((arg)));
											return result_361;
										})());
									}
								} break;
								
								case 47: {
									const field = temp_346[1];
									{
										const temp_363 = field;
										switch (temp_363&&temp_363[0]) {
										case 24: {
											const name_364 = temp_363[1];
											const t_365 = temp_363[2];
											const expr_366 = temp_363[3];
											const const_367 = temp_363[4];
											{
												const uname = (() => {
													const result_368 = this.parentNames.get(field);
													if (result_368 != null) { return result_368 };
													return this.unique(name_364, field);
												})();
												if (const_367) {
													const value_369 = this.nodeToExpression(expr_366);
													this.saveInlineIfViable(f, value_369);
													type_343.staticVars.push(/*Const*/[4,uname,value_369,this.typer.types.get(field)]);
												} else {
													type_343.staticVars.push(/*Var*/[3,uname,this.nodeToExpression(expr_366),this.typer.types.get(field)]);
												};
											}
										} break;
										
										case 22: {
											const name_370 = temp_363[1];
											const expr_371 = temp_363[2];
											const vars_372 = temp_363[3];
											const rettype_373 = temp_363[4];
											const external_374 = temp_363[5];
											{
												const uname_375 = (() => {
													const result_376 = this.parentNames.get(field);
													if (result_376 != null) { return result_376 };
													return this.unique(name_370, field);
												})();
												const a_377 = [];
												const defaults_378 = [];
												const types_379 = [];
												for (const arg of $toIterator(vars_372)) {
													const temp_380 = arg;
													switch (temp_380&&temp_380[0]) {
													case 24: {
														const name_381 = temp_380[1];
														const t_382 = temp_380[2];
														const expr_383 = temp_380[3];
														const const_384 = temp_380[4];
														{
															a_377.push(this.unique(name_381, arg));
															types_379.push(t_382);
															if ((expr_383 != null)) { defaults_378.push(this.nodeToExpression(expr_383)) } else {
																defaults_378.push(null);
															};
														}
													} break;
													};
												};
												type_343.staticMethods.push(/*Function*/[5,uname_375,this.unwrapNestingBlocks(this.nodeToStatement(expr_371)),a_377,defaults_378,this.typer.types.get(field)]);
											}
										} break;
										
										default: 
										console.error('(internal warning) Unknown complex enum static field kind:', field)
										};
									}
								} break;
								
								default: 
								console.error('(internal warning) Unknown complex enum field kind:', f)
								};
							};
							type_343.names = names_344;
							type_343.constructors = constructors;
							type_343.constructorsTypes = constructorsTypes;
							type_343.types = types_345;
							this.niceProject.enumsComplex.push(type_343);
							return null;
						} else {
							const type_385 = new NiceSimpleEnum();
							type_385.name = DataHelper.extractTypeName(t_340);
							const names_386 = [];
							const values_387 = [];
							for (const f of $toIterator(fields_341)) {
								const temp_388 = f;
								switch (temp_388&&temp_388[0]) {
								case 10: {
									const a_389 = temp_388[1];
									const op_390 = temp_388[2];
									const b_391 = temp_388[3];
									{
										{
											const temp_392 = a_389;
											switch (temp_392&&temp_392[0]) {
											case 51: {
												const t_393 = temp_392[1];
												{
													const temp_394 = t_393;
													switch (temp_394&&temp_394[0]) {
													case 1: {
														const name_395 = temp_394[1];
														names_386.push(name_395)
													} break;
													};
												}
											} break;
											};
										};
										{
											const temp_396 = b_391;
											switch (temp_396&&temp_396[0]) {
											case 0: {
												const s_397 = temp_396[1];
												values_387.push(/*String*/[0,s_397])
											} break;
											
											case 5: {
												const s_398 = temp_396[1];
												values_387.push(/*Int*/[1,s_398])
											} break;
											
											default: 
											console.error('(internal warning) Unknown node field value kind:', b_391)
											};
										};
									}
								} break;
								
								case 51: {
									const t_399 = temp_388[1];
									{
										const temp_400 = t_399;
										switch (temp_400&&temp_400[0]) {
										case 1: {
											const name_401 = temp_400[1];
											names_386.push(name_401)
										} break;
										};
									}
								} break;
								
								case 47: {
									const field_402 = temp_388[1];
									{
										const temp_403 = field_402;
										switch (temp_403&&temp_403[0]) {
										case 24: {
											const name_404 = temp_403[1];
											const t_405 = temp_403[2];
											const expr_406 = temp_403[3];
											const const_407 = temp_403[4];
											{
												const uname_408 = (() => {
													const result_409 = this.parentNames.get(field_402);
													if (result_409 != null) { return result_409 };
													return this.unique(name_404, field_402);
												})();
												if (const_407) {
													const value_410 = this.nodeToExpression(expr_406);
													this.saveInlineIfViable(f, value_410);
													type_385.staticVars.push(/*Const*/[4,uname_408,value_410,this.typer.types.get(field_402)]);
												} else {
													type_385.staticVars.push(/*Var*/[3,uname_408,this.nodeToExpression(expr_406),this.typer.types.get(field_402)]);
												};
											}
										} break;
										
										case 22: {
											const name_411 = temp_403[1];
											const expr_412 = temp_403[2];
											const vars_413 = temp_403[3];
											const rettype_414 = temp_403[4];
											const external_415 = temp_403[5];
											{
												const uname_416 = (() => {
													const result_417 = this.parentNames.get(field_402);
													if (result_417 != null) { return result_417 };
													return this.unique(name_411, field_402);
												})();
												const a_418 = [];
												const defaults_419 = [];
												const types_420 = [];
												for (const arg of $toIterator(vars_413)) {
													const temp_421 = arg;
													switch (temp_421&&temp_421[0]) {
													case 24: {
														const name_422 = temp_421[1];
														const t_423 = temp_421[2];
														const expr_424 = temp_421[3];
														const const_425 = temp_421[4];
														{
															a_418.push(this.unique(name_422, arg));
															types_420.push(t_423);
															if ((expr_424 != null)) { defaults_419.push(this.nodeToExpression(expr_424)) } else {
																defaults_419.push(null);
															};
														}
													} break;
													};
												};
												type_385.staticMethods.push(/*Function*/[5,uname_416,this.unwrapNestingBlocks(this.nodeToStatement(expr_412)),a_418,defaults_419,this.typer.types.get(field_402)]);
											}
										} break;
										
										default: 
										console.error('(internal warning) Unknown simple enum static field kind:', field_402)
										};
									}
								} break;
								
								default: 
								console.error('(internal warning) Unknown simple enum field kind:', f)
								};
							};
							type_385.names = names_386;
							type_385.values = values_387;
							this.niceProject.enumsSimple.push(type_385);
							return null;
						};
					}
				} break;
				
				case 25: {
					const t_426 = temp_335[1];
					const ext_427 = temp_335[2];
					const impl_428 = temp_335[3];
					const fields_429 = temp_335[4];
					const external_430 = temp_335[5];
					{
						this.renameClassFields(fields_429);
						const type_431 = new NiceClass();
						{
							const temp_432 = (this.typer.types.get(e_334));
							switch (temp_432&&temp_432[0]) {
							case 3: {
								const the = temp_432[1];
								type_431.useless = the.useless
							} break;
							};
						};
						type_431.external = external_430;
						type_431.extend = DataHelper.extractTypeName(ext_427);
						for (const implement of $toIterator(impl_428)) {
							const temp_433 = implement;
							switch (temp_433&&temp_433[0]) {
							case 1: {
								const name_434 = temp_433[1];
								type_431.implement = name_434
							} break;
							
							case 2: {
								const name_435 = temp_433[1];
								const params = temp_433[2];
								{
									type_431.implement = name_435;
									type_431.implementParams = (() => {
										const result_436 = [];
										const value_437 = params;
										for (const param of $toIterator(value_437)) result_436.push(DataHelper.extractTypeName(param));
										return result_436;
									})();
								}
							} break;
							};
						};
						{
							const temp_438 = t_426;
							switch (temp_438&&temp_438[0]) {
							case 1: {
								const name_439 = temp_438[1];
								{
								}
							} break;
							
							case 2: {
								const name_440 = temp_438[1];
								const params_441 = temp_438[2];
								type_431.genericParams = (() => {
									const result_442 = [];
									const value_443 = params_441;
									for (const param of $toIterator(value_443)) result_442.push(DataHelper.extractTypeName(param));
									return result_442;
								})()
							} break;
							};
						};
						const atts_444 = this.project.mapDecorators.get(e_334);
						{
							let step_445 = 0;
							const require_446 = Normalizer.getDec(atts_444, 'require');
							if (step_445 == 0 && require_446 != null) { step_445 = 1 };
							if (step_445 == 1) {
								const temp_447 = require_446.values[0];
								switch (temp_447&&temp_447[0]) {
								case 0: {
									const s_448 = temp_447[1];
									type_431.jsRequire = s_448
								} break;
								
								default: 
								throw '@require takes string as argument'
								};
							};
						};
						{
							let step_449 = 0;
							const native_450 = Normalizer.getDec(atts_444, 'rename');
							if (step_449 == 0 && native_450 != null) { step_449 = 1 };
							if (step_449 == 1) {
								const temp_451 = native_450.values[0];
								switch (temp_451&&temp_451[0]) {
								case 0: {
									const s_452 = temp_451[1];
									{
										type_431.jsNative = s_452;
										type_431.name = this.unique(s_452, e_334);
									}
								} break;
								
								default: 
								throw '@rename takes string as argument'
								};
							} else {
								type_431.name = this.unique(DataHelper.extractTypeName(t_426), e_334);
							};
						};
						this.globals.push(type_431.name);
						for (const f of $toIterator(fields_429)) {
							const temp_453 = f;
							switch (temp_453&&temp_453[0]) {
							case 24: {
								const name_454 = temp_453[1];
								const t_455 = temp_453[2];
								const expr_456 = temp_453[3];
								const const_457 = temp_453[4];
								{
									const uname_458 = (() => {
										const result_459 = this.parentNames.get(f);
										if (result_459 != null) { return result_459 };
										return this.unique(name_454, f);
									})();
									if (const_457) {
										const value_460 = this.nodeToExpression(expr_456);
										this.saveInlineIfViable(f, value_460);
										type_431.vars.push(/*Const*/[4,uname_458,value_460,this.typer.types.get(f)]);
									} else {
										type_431.vars.push(/*Var*/[3,uname_458,this.nodeToExpression(expr_456),this.typer.types.get(f)]);
									};
								}
							} break;
							
							case 26: {
								const field_461 = temp_453[1];
								{
									const temp_462 = field_461;
									switch (temp_462&&temp_462[0]) {
									case 24: {
										const name_463 = temp_462[1];
										const t_464 = temp_462[2];
										const expr_465 = temp_462[3];
										const const_466 = temp_462[4];
										{
											const uname_467 = (() => {
												const result_468 = this.parentNames.get(f);
												if (result_468 != null) { return result_468 };
												return this.unique(name_463, f);
											})();
											if (const_466) { type_431.vars.push(/*Const*/[4,uname_467,this.nodeToExpression(expr_465),this.typer.types.get(field_461)]) } else {
												type_431.vars.push(/*Var*/[3,uname_467,this.nodeToExpression(expr_465),this.typer.types.get(field_461)]);
											};
											type_431.property.push(uname_467);
										}
									} break;
									};
								}
							} break;
							
							case 22: {
								const name_469 = temp_453[1];
								const expr_470 = temp_453[2];
								const vars_471 = temp_453[3];
								const rettype_472 = temp_453[4];
								const external_473 = temp_453[5];
								{
									const uname_474 = ((name_469 == 'new'))? ('new') : ((() => {
										const result_475 = this.parentNames.get(f);
										if (result_475 != null) { return result_475 };
										return this.unique(name_469, f);
									})());
									const a_476 = [];
									const defaults_477 = [];
									const types_478 = [];
									for (const arg of $toIterator(vars_471)) {
										const temp_479 = arg;
										switch (temp_479&&temp_479[0]) {
										case 24: {
											const name_480 = temp_479[1];
											const t_481 = temp_479[2];
											const expr_482 = temp_479[3];
											const const_483 = temp_479[4];
											{
												a_476.push(this.unique(name_480, arg));
												types_478.push(t_481);
												if ((expr_482 != null)) { defaults_477.push(this.nodeToExpression(expr_482)) } else {
													defaults_477.push(null);
												};
											}
										} break;
										};
									};
									type_431.methods.push(/*Function*/[5,uname_474,this.unwrapNestingBlocks(this.nodeToStatement(expr_470)),a_476,defaults_477,this.typer.types.get(f)]);
								}
							} break;
							
							case 47: {
								const field_484 = temp_453[1];
								{
									const temp_485 = field_484;
									switch (temp_485&&temp_485[0]) {
									case 24: {
										const name_486 = temp_485[1];
										const t_487 = temp_485[2];
										const expr_488 = temp_485[3];
										const const_489 = temp_485[4];
										{
											const uname_490 = (() => {
												const result_491 = this.parentNames.get(field_484);
												if (result_491 != null) { return result_491 };
												return this.unique(name_486, field_484);
											})();
											if (const_489) {
												const value_492 = this.nodeToExpression(expr_488);
												this.saveInlineIfViable(f, value_492);
												type_431.staticVars.push(/*Const*/[4,uname_490,value_492,this.typer.types.get(field_484)]);
											} else {
												type_431.staticVars.push(/*Var*/[3,uname_490,this.nodeToExpression(expr_488),this.typer.types.get(field_484)]);
											};
										}
									} break;
									
									case 22: {
										const name_493 = temp_485[1];
										const expr_494 = temp_485[2];
										const vars_495 = temp_485[3];
										const rettype_496 = temp_485[4];
										{
											const uname_497 = (() => {
												const result_498 = this.parentNames.get(field_484);
												if (result_498 != null) { return result_498 };
												return this.unique(name_493, field_484);
											})();
											const a_499 = [];
											const defaults_500 = [];
											const types_501 = [];
											for (const arg of $toIterator(vars_495)) {
												const temp_502 = arg;
												switch (temp_502&&temp_502[0]) {
												case 24: {
													const name_503 = temp_502[1];
													const t_504 = temp_502[2];
													const expr_505 = temp_502[3];
													const const_506 = temp_502[4];
													{
														a_499.push(this.unique(name_503, arg));
														types_501.push(t_504);
														if ((expr_505 != null)) { defaults_500.push(this.nodeToExpression(expr_505)) } else {
															defaults_500.push(null);
														};
													}
												} break;
												};
											};
											type_431.staticMethods.push(/*Function*/[5,uname_497,this.unwrapNestingBlocks(this.nodeToStatement(expr_494)),a_499,defaults_500,this.typer.types.get(field_484)]);
										}
									} break;
									
									default: 
									console.error('(internal warning) Unknown class static field kind:', field_484)
									};
								}
							} break;
							
							default: 
							console.error('(internal warning) Unknown class field kind:', f)
							};
						};
						this.niceProject.classes.push(type_431);
						return null;
					}
				} break;
				
				case 9: {
					{
					}
				} break;
				
				case 30: {
					const path_507 = temp_335[1];
					const t_508 = temp_335[2];
					const args_509 = temp_335[3];
					const fields_510 = temp_335[4];
					const values_511 = temp_335[5];
					return /*Const*/[4,this.unique('temp'),this.nodeToExpression(e_334),this.typer.types.get(e_334)]
				} break;
				
				case 13: {
					const e_512 = temp_335[1];
					const args_513 = temp_335[2];
					const argNames_514 = temp_335[3];
					{
						let kind_515 = 11;
						{
							const temp_516 = e_512;
							switch (temp_516&&temp_516[0]) {
							case 4: {
								{
									const a_517 = [];
									for (const arg of $toIterator(args_513)) {
										a_517.push(this.nodeToExpression(arg));
									};
									return /*SuperConstructor*/[19,a_517];
								}
							} break;
							
							case 28: {
								const expr_518 = temp_516[1];
								{
									const temp_519 = (this.typer.types.get(expr_518));
									switch (temp_519&&temp_519[0]) {
									case 4: {
										kind_515 = 12
									} break;
									
									case 3: {
										kind_515 = 10
									} break;
									};
								}
							} break;
							};
						};
						const v_520 = this.nodeToExpression(e_512);
						const a_521 = [];
						for (const arg of $toIterator(args_513)) {
							a_521.push(this.nodeToExpression(arg));
						};
						let expects = [];
						{
							const temp_522 = (this.typer.types.get(e_512));
							switch (temp_522&&temp_522[0]) {
							case 10: {
								const args_523 = temp_522[1];
								expects = args_523
							} break;
							};
						};
						{
							const temp_524 = v_520;
							switch (temp_524&&temp_524[0]) {
							case 9: {
								const expr_525 = temp_524[1];
								{
									const temp_526 = expr_525;
									switch (temp_526&&temp_526[0]) {
									case 8: {
										kind_515 = 12
									} break;
									};
								}
							} break;
							};
						};
						return /*Call*/[2,v_520,a_521,expects,kind_515];
					}
				} break;
				
				case 24: {
					const name_527 = temp_335[1];
					const t_528 = temp_335[2];
					const expr_529 = temp_335[3];
					const const_530 = temp_335[4];
					const external_531 = temp_335[5];
					{
						const uname_532 = (() => {
							const result_533 = this.parentNames.get(e_334);
							if (result_533 != null) { return result_533 };
							return this.unique(name_527, e_334);
						})();
						if (external_531) { return null };
						if (const_530) {
							const value_534 = this.nodeToExpression(expr_529);
							this.saveInlineIfViable(e_334, value_534);
							return /*Const*/[4,uname_532,value_534,this.typer.types.get(e_334)];
						};
						return /*Var*/[3,uname_532,this.nodeToExpression(expr_529),this.typer.types.get(e_334)];
					}
				} break;
				
				case 22: {
					const name_535 = temp_335[1];
					const expr_536 = temp_335[2];
					const vars_537 = temp_335[3];
					const rettype_538 = temp_335[4];
					const external_539 = temp_335[5];
					{
						let uname_540 = null;
						const atts_541 = this.project.mapDecorators.get(e_334);
						{
							let step_542 = 0;
							const native_543 = Normalizer.getDec(atts_541, 'rename');
							if (step_542 == 0 && native_543 != null) { step_542 = 1 };
							if (step_542 == 1) {
								const temp_544 = native_543.values[0];
								switch (temp_544&&temp_544[0]) {
								case 0: {
									const s_545 = temp_544[1];
									{
										if ((this.parentNames.get(e_334) == null)) { this.uniqueNative(s_545, e_334) };
										uname_540 = this.parentNames.get(e_334);
									}
								} break;
								
								default: 
								throw '@rename takes string as argument'
								};
							} else {
								uname_540 = ((name_535 != null))? (((() => {
									const result_546 = this.parentNames.get(e_334);
									if (result_546 != null) { return result_546 };
									return this.unique(name_535, e_334);
								})())) : (null);
							};
						};
						if (external_539) { return null };
						let rettype_547 = rettype_538;
						const a_548 = [];
						const defaults_549 = [];
						let types_550 = [];
						for (const arg of $toIterator(vars_537)) {
							const temp_551 = arg;
							switch (temp_551&&temp_551[0]) {
							case 24: {
								const name_552 = temp_551[1];
								const t_553 = temp_551[2];
								const expr_554 = temp_551[3];
								const const_555 = temp_551[4];
								{
									a_548.push(this.unique(name_552, arg));
									types_550.push(t_553);
									if ((expr_554 != null)) { defaults_549.push(this.nodeToExpression(expr_554)) } else {
										defaults_549.push(null);
									};
								}
							} break;
							};
						};
						if ((name_535 == 'new')) { return /*Function*/[5,null,this.unwrapNestingBlocks(this.nodeToStatement(expr_536)),a_548,defaults_549,this.typer.types.get(e_334)] };
						return /*Function*/[5,uname_540,this.unwrapNestingBlocks(this.nodeToStatement(expr_536)),a_548,defaults_549,this.typer.types.get(e_334)];
					}
				} break;
				
				case 49: {
					const name_556 = temp_335[1];
					const over_557 = temp_335[2];
					const by_558 = temp_335[3];
					const range_559 = temp_335[4];
					{
						if ((range_559 == null)) {
							const temp_560 = over_557;
							switch (temp_560&&temp_560[0]) {
							case 5: {
								const s_561 = temp_560[1];
								{
									const i_562 = this.unique(name_556, e_334);
									const it = this.unique('it');
									return /*Block*/[1,[/*Var*/[3,i_562,/*Int*/[1,0],this.typer.typeInt], /*Var*/[3,it,/*Int*/[1,0],this.typer.typeInt], /*While*/[13,/*Binop*/[12,/*Ident*/[6,it,this.typer.typeInt],99,/*Int*/[1,s_561],this.typer.typeBool],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,i_562,this.typer.typeInt],/*Ident*/[6,it,this.typer.typeInt],null], /*Increment*/[14,/*Ident*/[6,it,this.typer.typeInt]], this.nodeToStatement(by_558)]],true]]];
								}
							} break;
							
							default: 
							{
								let iteratorOverInt = false;
								{
									const temp_563 = (this.typer.types.get(over_557));
									switch (temp_563&&temp_563[0]) {
									case 4: {
										const type_564 = temp_563[1];
										const generic = temp_563[2];
										if ((generic == null || generic.length == 0) && (type_564.name == 'Int')) { iteratorOverInt = true }
									} break;
									};
								};
								if (iteratorOverInt) {
									const i_565 = this.unique(name_556, e_334);
									const it_566 = this.unique('it');
									const finish = this.unique('at');
									return /*Block*/[1,[/*Var*/[3,i_565,/*Int*/[1,0],this.typer.typeInt], /*Var*/[3,it_566,/*Int*/[1,0],this.typer.typeInt], /*Var*/[3,finish,this.nodeToExpression(over_557),this.typer.types.get(over_557)], /*While*/[13,/*Binop*/[12,/*Ident*/[6,it_566,this.typer.typeInt],99,/*Ident*/[6,finish,this.typer.types.get(over_557)],this.typer.typeBool],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,i_565,this.typer.typeInt],/*Ident*/[6,it_566,this.typer.typeInt],null], /*Increment*/[14,/*Ident*/[6,it_566,this.typer.typeInt]], this.nodeToStatement(by_558)]],true]]];
								};
							}
							};
						};
						{
							let step_567 = 0;
							const range_568 = range_559;
							if (step_567 == 0 && range_568 != null) { step_567 = 1 };
							if (step_567 == 1) {
								const i_569 = this.unique(name_556, e_334);
								const it_570 = this.unique('it');
								const finish_571 = this.unique('at');
								return /*Block*/[1,[/*Var*/[3,i_569,/*Int*/[1,0],this.typer.typeInt], /*Var*/[3,it_570,this.nodeToExpression(over_557),this.typer.typeInt], /*Var*/[3,finish_571,this.nodeToExpression(range_568),this.typer.typeInt], /*While*/[13,/*Binop*/[12,/*Ident*/[6,it_570,this.typer.typeInt],99,/*Ident*/[6,finish_571,this.typer.typeInt],this.typer.typeBool],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,i_569,this.typer.typeInt],/*Ident*/[6,it_570,this.typer.typeInt],null], /*Increment*/[14,/*Ident*/[6,it_570,this.typer.typeInt]], this.nodeToStatement(by_558)]],true]]];
							};
						};
						return /*For*/[12,name_556,this.nodeToExpression(over_557),this.nodeToStatement(by_558)];
					}
				} break;
				
				case 16: {
					const e_572 = temp_335[1];
					{
						if ((e_572 == null)) { return /*Return*/[6,null] };
						return /*Return*/[6,this.nodeToExpression(e_572)];
					}
				} break;
				
				case 28: {
					const expr_573 = temp_335[1];
					const name_574 = temp_335[2];
					return /*Const*/[4,this.unique('temp'),this.nodeToExpression(e_334),this.typer.types.get(e_334)]
				} break;
				
				case 29: {
					const expr_575 = temp_335[1];
					const name_576 = temp_335[2];
					return /*Const*/[4,this.unique('temp'),this.nodeToExpression(e_334),this.typer.types.get(e_334)]
				} break;
				
				case 14: {
					const econd_577 = temp_335[1];
					const eif_578 = temp_335[2];
					const eelse_579 = temp_335[3];
					{
						let binds_580 = false;
						for (const cond of $toIterator(econd_577)) {
							const temp_581 = cond;
							switch (temp_581&&temp_581[0]) {
							case 24: {
								binds_580 = true
							} break;
							};
						};
						if (((!binds_580) && econd_577.length == 1)) { return /*If*/[7,this.nodeToExpression(econd_577[0]),this.nodeToStatement(eif_578),this.nodeToStatement(eelse_579)] };
						if ((!binds_580)) {
							let parens_582 = /*Parenthesis*/[15,this.nodeToExpression(econd_577[0])];
							let i_583 = 1;
							while (i_583 < econd_577.length) {
								parens_582 = /*Binop*/[12,parens_582,92,/*Parenthesis*/[15,this.nodeToExpression(econd_577[i_583])],this.typer.typeBool];
								i_583++;
							};
							return /*If*/[7,parens_582,this.nodeToStatement(eif_578),this.nodeToStatement(eelse_579)];
						};
						const block_584 = [];
						let current = 0;
						const step_585 = this.unique('step');
						block_584.push(/*Var*/[3,step_585,/*Int*/[1,0],this.typer.typeInt]);
						let nullable_586 = false;
						let last = '';
						const lastType = this.typer.types.get(econd_577[0]);
						{
							const temp_587 = econd_577[0];
							switch (temp_587&&temp_587[0]) {
							case 24: {
								const name_588 = temp_587[1];
								const t_589 = temp_587[2];
								const expr_590 = temp_587[3];
								const const_591 = temp_587[4];
								{
									last = this.unique(name_588, econd_577[0]);
									nullable_586 = true;
									block_584.push(/*Const*/[4,last,this.nodeToExpression(expr_590),this.typer.types.get(econd_577[0])]);
								}
							} break;
							
							default: 
							{
								last = this.unique('temp');
								block_584.push(/*Const*/[4,last,this.nodeToExpression(econd_577[0]),this.typer.types.get(econd_577[0])]);
							}
							};
						};
						while (current < econd_577.length - 1) {
							const temp_592 = econd_577[current + 1];
							switch (temp_592&&temp_592[0]) {
							case 24: {
								const vname = temp_592[1];
								const t_593 = temp_592[2];
								const expr_594 = temp_592[3];
								const const_595 = temp_592[4];
								{
									const name_596 = this.unique(vname, econd_577[current + 1]);
									block_584.push(/*Var*/[3,name_596,/*Null*/[7],this.typer.types.get(expr_594)]);
									block_584.push(/*If*/[7,/*Binop*/[12,/*Binop*/[12,/*Ident*/[6,step_585,this.typer.typeInt],95,/*Int*/[1,current + 0],this.typer.typeBool],92,/*Binop*/[12,/*Ident*/[6,last,lastType],103,(nullable_586)? (/*Null*/[7]) : /*False*/[5],this.typer.typeBool],this.typer.typeBool],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,name_596,this.typer.types.get(expr_594)],this.nodeToExpression(expr_594),null], /*Assign*/[10,/*Ident*/[6,step_585,this.typer.typeInt],/*Int*/[1,current + 1],null]]],null]);
									current++;
									last = name_596;
									nullable_586 = true;
								}
							} break;
							
							default: 
							{
								const next = this.unique('temp');
								const nextType = this.typer.types.get(econd_577[0]);
								block_584.push(/*Var*/[3,next,/*Null*/[7],nextType]);
								block_584.push(/*If*/[7,/*Binop*/[12,/*Binop*/[12,/*Ident*/[6,step_585,this.typer.typeInt],95,/*Int*/[1,current + 0],this.typer.typeBool],92,/*Binop*/[12,/*Ident*/[6,last,lastType],103,(nullable_586)? (/*Null*/[7]) : /*False*/[5],this.typer.typeBool],this.typer.typeBool],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,next,nextType],this.nodeToExpression(econd_577[current + 1]),null], /*Assign*/[10,/*Ident*/[6,step_585,this.typer.typeInt],/*Int*/[1,current + 1],null]]],null]);
								current++;
								last = next;
								nullable_586 = false;
							}
							};
						};
						block_584.push(/*If*/[7,/*Binop*/[12,/*Binop*/[12,/*Ident*/[6,step_585,this.typer.typeInt],95,/*Int*/[1,econd_577.length - 1],this.typer.typeBool],92,/*Binop*/[12,/*Ident*/[6,last,lastType],103,(nullable_586)? (/*Null*/[7]) : /*False*/[5],this.typer.typeBool],this.typer.typeBool],/*Assign*/[10,/*Ident*/[6,step_585,this.typer.typeInt],/*Int*/[1,econd_577.length],null],null]);
						block_584.push(/*If*/[7,/*Binop*/[12,/*Ident*/[6,step_585,this.typer.typeInt],95,/*Int*/[1,econd_577.length],this.typer.typeBool],this.nodeToStatement(eif_578),this.nodeToStatement(eelse_579)]);
						return /*Block*/[1,block_584];
					}
				} break;
				
				case 27: {
					const expr_597 = temp_335[1];
					const t_598 = temp_335[2];
					const v_599 = temp_335[3];
					const catches = temp_335[4];
					{
						let temp_600 = this.unique('temp');
						let tt = [];
						let vv = [];
						for (const c of $toIterator(v_599)) {
							vv.push(DataHelper.nameOf(c));
						};
						let cc = [];
						for (const c of $toIterator(catches)) {
							cc.push(this.nodeToStatement(c));
						};
						for (const c of $toIterator(t_598)) {
							tt.push(this.typer.types.get(c));
						};
						return /*Try*/[8,this.nodeToStatement(expr_597),tt,vv,cc,temp_600];
					}
				} break;
				
				case 17: {
					const value_601 = temp_335[1];
					return /*Throw*/[9,this.nodeToExpression(value_601)]
				} break;
				
				case 11: {
					const a_602 = temp_335[1];
					const op_603 = temp_335[2];
					const b_604 = temp_335[3];
					return /*Assignop*/[11,this.nodeToExpression(a_602),op_603,this.nodeToExpression(b_604)]
				} break;
				
				case 10: {
					const a_605 = temp_335[1];
					const op_606 = temp_335[2];
					const b_607 = temp_335[3];
					{
						const temp_608 = op_606;
						switch (temp_608) {
						case 91: {
							return /*Assign*/[10,this.nodeToExpression(a_605),this.nodeToExpression(b_607),null]
						} break;
						
						default: 
						{
							const sa_609 = this.nodeToStatement(a_605);
							const sb_610 = this.nodeToStatement(b_607);
							if ((sa_609 == null) && (sb_610 == null)) { return null };
							if (((sa_609 == null) || (sb_610 == null))) { return (() => {
								const result_611 = sa_609;
								if (result_611 != null) { return result_611 };
								return sb_610;
							})() };
							return /*Statements*/[0,[sa_609, sb_610]];
						}
						};
					}
				} break;
				
				case 19: {
					return /*Continue*/[17]
				} break;
				
				case 18: {
					return /*Break*/[18]
				} break;
				
				case 21: {
					const econd_612 = temp_335[1];
					const e_613 = temp_335[2];
					const pre = temp_335[3];
					return /*While*/[13,this.nodeToExpression(econd_612),this.nodeToStatement(e_613),pre]
				} break;
				
				case 20: {
					const op_614 = temp_335[1];
					const postfix_615 = temp_335[2];
					const e_616 = temp_335[3];
					{
						const temp_617 = op_614;
						switch (temp_617) {
						case 87: {
							return /*Increment*/[14,this.nodeToExpression(e_616)]
						} break;
						
						case 86: {
							return /*Decrement*/[15,this.nodeToExpression(e_616)]
						} break;
						
						default: 
						{
						}
						};
					}
				} break;
				
				case 15: {
					const inner_618 = temp_335[1];
					{
						const unwrapNestedParens_619 = (inner_620) => {
							const temp_621 = inner_620;
							switch (temp_621&&temp_621[0]) {
							case 15: {
								const i_622 = temp_621[1];
								return unwrapNestedParens_619(i_622)
							} break;
							
							default: 
							return inner_620
							};
						};
						return this.nodeToStatement(unwrapNestedParens_619(inner_618));
					}
				} break;
				
				case 34: {
					const exprs_623 = temp_335[1];
					const conds_624 = temp_335[2];
					const guards_625 = temp_335[3];
					const cases_626 = temp_335[4];
					{
						if ((exprs_623.length > 1)) { console.error('Multiple switch values not yet supported:', e_334, this.project.data.get(e_334)) };
						const s_627 = [];
						const c = [];
						if (this.nativeEnums) {
							const index_628 = this.nodeToExpression(exprs_623[0]);
							{
								let i_629 = 0;
								let it_630 = 0;
								let at = cases_626.length;
								while (it_630 < at) {
									i_629 = it_630;
									it_630++;
									{
										const toCase = (co) => {
											const temp_631 = co;
											switch (temp_631&&temp_631[0]) {
											case 8: {
												return /*Null*/[7]
											} break;
											
											case 45: {
												return /*Underscore*/[30]
											} break;
											
											case 0: {
												const v_632 = temp_631[1];
												return /*String*/[0,v_632]
											} break;
											
											case 5: {
												const v_633 = temp_631[1];
												return /*Int*/[1,v_633]
											} break;
											
											case 7: {
												const v_634 = temp_631[1];
												return /*Float*/[3,v_634]
											} break;
											
											case 2: {
												const v_635 = temp_631[1];
												{
													if (v_635) { return /*True*/[4] };
													return /*False*/[5];
												}
											} break;
											
											case 28: {
												const expr_636 = temp_631[1];
												const name_637 = temp_631[2];
												return /*Dot*/[9,this.nodeToExpression(expr_636),name_637,null]
											} break;
											
											case 29: {
												const expr_638 = temp_631[1];
												const name_639 = temp_631[2];
												return /*Dot*/[9,this.nodeToExpression(expr_638),name_639,null]
											} break;
											
											case 10: {
												const a_640 = temp_631[1];
												const op_641 = temp_631[2];
												const b_642 = temp_631[3];
												{
													const temp_643 = op_641;
													switch (temp_643) {
													case 104: {
														return /*Binop*/[12,toCase(a_640),104,toCase(b_642),null]
													} break;
													
													default: 
													console.error('(internal warning) Unknown native case binop kind:', e_334, this.typer.parents.get(e_334))
													};
												}
											} break;
											
											case 13: {
												const e_644 = temp_631[1];
												const args_645 = temp_631[2];
												const argNames_646 = temp_631[3];
												{
													const temp_647 = e_644;
													switch (temp_647&&temp_647[0]) {
													case 29: {
														const expr_648 = temp_647[1];
														const name_649 = temp_647[2];
														{
															const a_650 = [];
															{
																let arg = 0;
																let it_651 = 0;
																let at_652 = args_645.length;
																while (it_651 < at_652) {
																	arg = it_651;
																	it_651++;
																	{
																		const temp_653 = args_645[arg];
																		switch (temp_653&&temp_653[0]) {
																		case 1: {
																			const name_654 = temp_653[1];
																			a_650.push(/*Ident*/[6,this.unique(name_654, args_645[arg]),null])
																		} break;
																		
																		case 45: {
																			a_650.push(/*Underscore*/[30])
																		} break;
																		
																		default: 
																		console.log('(internal warning) Unknown native case extract value kind:', args_645[arg])
																		};
																	};
																};
															};
															return /*Call*/[10,this.nodeToExpression(e_644),a_650,null,11];
														}
													} break;
													
													default: 
													console.error('(internal warning) Unknown case extract kind:', e_644, this.typer.parents.get(e_644))
													};
												}
											} break;
											
											default: 
											console.error('(internal warning) Unknown native enum case kind:', co, this.project.data.get(co))
											};
										};
										c.push([toCase(conds_624[i_629])]);
										s_627.push(this.nodeToStatement(cases_626[i_629]));
									};
								};
							};
							return /*Switch*/[16,index_628,c,s_627,[],[]];
						};
						const temp_655 = this.unique('temp');
						const value_656 = this.nodeToExpression(exprs_623[0]);
						let index_657 = /*Ident*/[6,temp_655,null];
						let promoted = false;
						let enumType = null;
						{
							const temp_658 = Type.unwrapNullable(this.typer.types.get(exprs_623[0]));
							switch (temp_658&&temp_658[0]) {
							case 6: {
								const type_659 = temp_658[1];
								{
									if ((type_659.fieldsTypeSimple == null)) {
										index_657 = /*EnumTag*/[27,index_657];
										promoted = true;
									};
									enumType = type_659;
								}
							} break;
							
							case 7: {
								const type_660 = temp_658[1];
								{
									if ((type_660.fieldsTypeSimple == null)) {
										index_657 = /*EnumTag*/[27,index_657];
										promoted = true;
									};
									enumType = type_660;
								}
							} break;
							};
						};
						let i_661 = 0;
						const guardians = [];
						const binds_662 = [];
						for (const ec of $toIterator(cases_626)) {
							const block_663 = [];
							const co_664 = conds_624[i_661];
							const cx = [];
							const binders = [];
							binds_662.push(binders);
							const addTag = (co_665) => {
								const temp_666 = co_665;
								switch (temp_666&&temp_666[0]) {
								case 8: {
									cx.push(/*Null*/[7])
								} break;
								
								case 45: {
									{
									}
								} break;
								
								case 0: {
									const v_667 = temp_666[1];
									cx.push(/*String*/[0,v_667])
								} break;
								
								case 5: {
									const v_668 = temp_666[1];
									cx.push(/*Int*/[1,v_668])
								} break;
								
								case 7: {
									const v_669 = temp_666[1];
									cx.push(/*Float*/[3,v_669])
								} break;
								
								case 2: {
									const v_670 = temp_666[1];
									if (v_670) { cx.push(/*True*/[4]) } else {
										cx.push(/*False*/[5]);
									}
								} break;
								
								case 13: {
									const e_671 = temp_666[1];
									const args_672 = temp_666[2];
									const argNames_673 = temp_666[3];
									{
										{
											const temp_674 = e_671;
											switch (temp_674&&temp_674[0]) {
											case 29: {
												const expr_675 = temp_674[1];
												const name_676 = temp_674[2];
												{
													const parent_677 = this.typer.parents.get(expr_675);
													const tag_678 = this.getTag(parent_677, name_676);
													cx.push(tag_678);
												}
											} break;
											
											case 51: {
												const t_679 = temp_674[1];
												{
													const temp_680 = t_679;
													switch (temp_680&&temp_680[0]) {
													case 1: {
														const name_681 = temp_680[1];
														{
															let step_682 = 0;
															const enumType_683 = enumType;
															if (step_682 == 0 && enumType_683 != null) { step_682 = 1 };
															if (step_682 == 1) { cx.push(this.getTag(enumType_683.parent, name_681)) };
														}
													} break;
													};
												}
											} break;
											
											default: 
											console.error('(internal warning) Unknown case extract kind:', e_671, this.typer.parents.get(e_671))
											};
										};
										if (((!promoted))) { index_657 = /*EnumTag*/[27,index_657] };
										promoted = true;
										{
											let arg_684 = 0;
											let it_685 = 0;
											let at_686 = args_672.length;
											while (it_685 < at_686) {
												arg_684 = it_685;
												it_685++;
												{
													const temp_687 = args_672[arg_684];
													switch (temp_687&&temp_687[0]) {
													case 1: {
														const name_688 = temp_687[1];
														binders.push(/*Const*/[4,this.unique(name_688, args_672[arg_684]),/*EnumParameter*/[29,/*Ident*/[6,temp_655,this.typer.types.get(args_672[arg_684])],arg_684],this.typer.types.get(args_672[arg_684])])
													} break;
													
													case 45: {
														{
														}
													} break;
													
													case 46: {
														{
														}
													} break;
													
													default: 
													console.log('(internal warning) Unknown case extract value kind:', arg_684)
													};
												};
											};
										};
									}
								} break;
								
								case 29: {
									const expr_689 = temp_666[1];
									const name_690 = temp_666[2];
									cx.push(this.getTag(this.typer.parents.get(expr_689), name_690))
								} break;
								
								case 10: {
									const a_691 = temp_666[1];
									const op_692 = temp_666[2];
									const b_693 = temp_666[3];
									{
										const temp_694 = op_692;
										switch (temp_694) {
										case 104: {
											{
												addTag(a_691);
												addTag(b_693);
											}
										} break;
										
										default: 
										console.error('(internal warning) Unknown case binop kind:', e_334, this.typer.parents.get(e_334))
										};
									}
								} break;
								
								case 51: {
									const t_695 = temp_666[1];
									{
										const temp_696 = t_695;
										switch (temp_696&&temp_696[0]) {
										case 1: {
											const name_697 = temp_696[1];
											{
												{
													let step_698 = 0;
													const enumType_699 = enumType;
													if (step_698 == 0 && enumType_699 != null) { step_698 = 1 };
													if (step_698 == 1) {
														const tag_700 = this.getTag(enumType_699.parent, name_697);
														cx.push(tag_700);
													};
												};
												if (enumType == null) { console.log('null enumType for ' + name_697) };
											}
										} break;
										};
									}
								} break;
								
								default: 
								console.error('(internal warning) Unknown case kind:', co_665, this.project.data.get(co_665))
								};
							};
							addTag(co_664);
							c.push(cx);
							block_663.push(this.unwrapNestingBlocks(this.nodeToStatement(ec)));
							s_627.push(this.unwrapNestingBlocks(/*Block*/[1,block_663]));
							{
								let step_701 = 0;
								const guard = guards_625[i_661];
								if (step_701 == 0 && guard != null) { step_701 = 1 };
								if (step_701 == 1) { guardians.push(this.nodeToExpression(guard)) } else {
									guardians.push(null);
								};
							};
							i_661++;
						};
						return /*Block*/[1,[/*Const*/[4,temp_655,value_656,this.typer.types.get(exprs_623[0])], /*Switch*/[16,index_657,c,s_627,guardians,binds_662]]];
					}
				} break;
				
				case 33: {
					const v_702 = temp_335[1];
					const index_703 = temp_335[2];
					{
						this.project.hints.push(new Hint(10, ('Unused value of index `' + (Node.stringify(e_334)) + '`'), this.project.data.get(e_334)));
						{
							const temp_704 = index_703;
							switch (temp_704&&temp_704[0]) {
							case 0: {
								return this.nodeToStatement(v_702)
							} break;
							
							case 5: {
								return this.nodeToStatement(v_702)
							} break;
							
							case 2: {
								return this.nodeToStatement(v_702)
							} break;
							
							case 7: {
								return this.nodeToStatement(v_702)
							} break;
							};
						};
						return /*Statements*/[0,[this.nodeToStatement(v_702), this.nodeToStatement(index_703)]];
					}
				} break;
				
				case 1: {
					const name_705 = temp_335[1];
					this.project.hints.push(new Hint(10, ('Unused value `' + (name_705) + '`'), this.project.data.get(e_334)))
				} break;
				
				case 23: {
					this.project.hints.push(new Hint(10, 'Unused arrow => function', this.project.data.get(e_334)))
				} break;
				
				case 0: {
					const v_706 = temp_335[1];
					this.project.hints.push(new Hint(10, ('Unused string `\"' + (v_706) + '\"`'), this.project.data.get(e_334)))
				} break;
				
				case 2: {
					const v_707 = temp_335[1];
					this.project.hints.push(new Hint(10, ('Unused boolean `' + (v_707) + '`'), this.project.data.get(e_334)))
				} break;
				
				case 5: {
					const v_708 = temp_335[1];
					this.project.hints.push(new Hint(10, ('Unused number `' + (v_708) + '`'), this.project.data.get(e_334)))
				} break;
				
				case 7: {
					const v_709 = temp_335[1];
					this.project.hints.push(new Hint(10, ('Unused float `' + (v_709) + '`'), this.project.data.get(e_334)))
				} break;
				
				case 8: {
					this.project.hints.push(new Hint(10, 'Unused `null`', this.project.data.get(e_334)))
				} break;
				
				case 35: {
					{
					}
				} break;
				
				case null: case undefined: {
					console.log('(internal warning) seems like null node passed to normalizer')
				} break;
				
				default: 
				return /*Const*/[4,this.unique('temp'),this.nodeToExpression(e_334),this.typer.types.get(e_334)]
				};
			};
			return null;
		};
		getTag(enumNode, name_710) {
			const temp_711 = enumNode;
			switch (temp_711&&temp_711[0]) {
			case 39: {
				const t_712 = temp_711[1];
				const fields_713 = temp_711[2];
				const valuesType_714 = temp_711[3];
				{
					let typed = (null);
					{
						const temp_715 = (this.typer.types.get(enumNode));
						switch (temp_715&&temp_715[0]) {
						case 6: {
							const type_716 = temp_715[1];
							typed = type_716
						} break;
						};
					};
					let i_717 = 0;
					for (const f of $toIterator(fields_713)) {
						{
							const temp_718 = f;
							switch (temp_718&&temp_718[0]) {
							case 51: {
								const t_719 = temp_718[1];
								{
									const temp_720 = t_719;
									switch (temp_720&&temp_720[0]) {
									case 1: {
										const n = temp_720[1];
										{
											if ((n == name_710)) { if ((typed.fieldsTypeSimple == this.typer.typeString)) { return /*String*/[0,n] } };
											if ((n == name_710)) { return /*Int*/[1,i_717] };
										}
									} break;
									};
								}
							} break;
							
							case 13: {
								const e_721 = temp_718[1];
								{
									const temp_722 = e_721;
									switch (temp_722&&temp_722[0]) {
									case 51: {
										const t_723 = temp_722[1];
										{
											const temp_724 = t_723;
											switch (temp_724&&temp_724[0]) {
											case 1: {
												const n_725 = temp_724[1];
												if ((n_725 == name_710)) { return /*Int*/[1,i_717] }
											} break;
											};
										}
									} break;
									};
								}
							} break;
							
							case 10: {
								const a_726 = temp_718[1];
								const op_727 = temp_718[2];
								const b_728 = temp_718[3];
								{
									const temp_729 = a_726;
									switch (temp_729&&temp_729[0]) {
									case 51: {
										const t_730 = temp_729[1];
										{
											const temp_731 = t_730;
											switch (temp_731&&temp_731[0]) {
											case 1: {
												const n_732 = temp_731[1];
												if ((n_732 == name_710)) { return this.nodeToExpression(b_728) }
											} break;
											};
										}
									} break;
									};
								}
							} break;
							
							case 47: {
								return null
							} break;
							
							default: 
							console.error('(internal warning) Unknown enum tag kind:', f)
							};
						};
						i_717++;
					};
					throw ('Enum has no tag or field `' + (name_710) + '` ') + t_712;
				}
			} break;
			};
		};
		getNative(e_734) {
			const atts_735 = this.project.mapDecorators.get(e_734);
			{
				let step_736 = 0;
				const native_737 = Normalizer.getDec(atts_735, 'rename');
				if (step_736 == 0 && native_737 != null) { step_736 = 1 };
				if (step_736 == 1) {
					const temp_738 = native_737.values[0];
					switch (temp_738&&temp_738[0]) {
					case 0: {
						const s_739 = temp_738[1];
						return s_739
					} break;
					
					default: 
					throw '@rename takes string as argument'
					};
				};
			};
			return null;
		};
		pushScope() { this.scopes.push((new Map())) };
		popScope() { this.scopes.pop() };
		hasInScope(name_740) {
			for (const scope of $toIterator(this.scopes)) {
				if ((scope.get(name_740) != null)) { return true };
			};
			return false;
		};
		addToScope(name_741) { this.scopes[this.scopes.length - 1].set(name_741, true) };
		unique(name_742, node) {
			let uname_743 = name_742;
			while (this.hasInScope(uname_743) || (this.keywords.indexOf(uname_743) != (-1)) || (this.globals.indexOf(uname_743) != (-1))) {
				uname_743 = (name_742 + '_') + ((++this.id));
			};
			this.addToScope(uname_743);
			if (node != null) { this.parentNames.set(node, uname_743) };
			return uname_743;
		};
		uniqueNative(name_744, node_745) {
			this.addToScope(name_744);
			this.parentNames.set(node_745, name_744);
		};
		fillStatement(e_746) { return this.nodeToStatement(e_746) };
		renameClassFields(fields_747) {
			this.pushScope();
			for (const f of $toIterator(fields_747)) {
				const temp_748 = f;
				switch (temp_748&&temp_748[0]) {
				case 24: {
					const name_749 = temp_748[1];
					const t_750 = temp_748[2];
					const expr_751 = temp_748[3];
					const const_752 = temp_748[4];
					{
						const atts_753 = this.project.mapDecorators.get(f);
						{
							let step_754 = 0;
							const native_755 = Normalizer.getDec(atts_753, 'rename');
							if (step_754 == 0 && native_755 != null) { step_754 = 1 };
							if (step_754 == 1) {
								const temp_756 = native_755.values[0];
								switch (temp_756&&temp_756[0]) {
								case 0: {
									const s_757 = temp_756[1];
									if ((this.parentNames.get(f) == null)) { this.unique(s_757, f) }
								} break;
								
								default: 
								throw '@rename takes string as argument'
								};
							} else if ((this.parentNames.get(f) == null)) { this.unique(name_749, f) };
						};
					}
				} break;
				
				case 22: {
					const name_758 = temp_748[1];
					const expr_759 = temp_748[2];
					const vars_760 = temp_748[3];
					const rettype_761 = temp_748[4];
					if (name_758 == 'new') { this.parentNames.set(f, 'new') } else {
						const atts_762 = this.project.mapDecorators.get(f);
						{
							let step_763 = 0;
							const native_764 = Normalizer.getDec(atts_762, 'rename');
							if (step_763 == 0 && native_764 != null) { step_763 = 1 };
							if (step_763 == 1) {
								const temp_765 = native_764.values[0];
								switch (temp_765&&temp_765[0]) {
								case 0: {
									const s_766 = temp_765[1];
									if ((this.parentNames.get(f) == null)) { this.unique(s_766, f) }
								} break;
								
								default: 
								throw '@rename takes string as argument'
								};
							} else if (this.parentNames.get(f) == null) { this.unique(name_758, f) };
						};
					}
				} break;
				
				case 47: {
					const field_767 = temp_748[1];
					{
						const temp_768 = field_767;
						switch (temp_768&&temp_768[0]) {
						case 24: {
							const name_769 = temp_768[1];
							const t_770 = temp_768[2];
							const expr_771 = temp_768[3];
							const const_772 = temp_768[4];
							{
								const atts_773 = this.project.mapDecorators.get(f);
								{
									let step_774 = 0;
									const native_775 = Normalizer.getDec(atts_773, 'rename');
									if (step_774 == 0 && native_775 != null) { step_774 = 1 };
									if (step_774 == 1) {
										const temp_776 = native_775.values[0];
										switch (temp_776&&temp_776[0]) {
										case 0: {
											const s_777 = temp_776[1];
											if ((this.parentNames.get(field_767) == null)) { this.unique(s_777, field_767) }
										} break;
										
										default: 
										throw '@rename takes string as argument'
										};
									} else if ((this.parentNames.get(field_767) == null)) { this.unique(name_769, field_767) };
								};
							}
						} break;
						
						case 22: {
							const name_778 = temp_768[1];
							const expr_779 = temp_768[2];
							const vars_780 = temp_768[3];
							const rettype_781 = temp_768[4];
							{
								const atts_782 = this.project.mapDecorators.get(f);
								{
									let step_783 = 0;
									const native_784 = Normalizer.getDec(atts_782, 'rename');
									if (step_783 == 0 && native_784 != null) { step_783 = 1 };
									if (step_783 == 1) {
										const temp_785 = native_784.values[0];
										switch (temp_785&&temp_785[0]) {
										case 0: {
											const s_786 = temp_785[1];
											if ((this.parentNames.get(field_767) == null)) { this.unique(s_786, field_767) }
										} break;
										
										default: 
										throw '@rename takes string as argument'
										};
									} else if ((this.parentNames.get(field_767) == null)) { this.unique(name_778, field_767) };
								};
							}
						} break;
						};
					}
				} break;
				};
			};
			this.popScope();
		};
		getClassDotField(expr_787, name_788) {
			{
				const temp_789 = expr_787;
				switch (temp_789&&temp_789[0]) {
				case 25: {
					const t_790 = temp_789[1];
					const ext_791 = temp_789[2];
					const impl_792 = temp_789[3];
					const fields_793 = temp_789[4];
					const external_794 = temp_789[5];
					for (const f of $toIterator(fields_793)) {
						const temp_795 = f;
						switch (temp_795&&temp_795[0]) {
						case 47: {
							const sf = temp_795[1];
							if ((DataHelper.nameOf(sf) == name_788)) { return (() => {
								const result_796 = this.parentNames.get(sf);
								if (result_796 != null) { return result_796 };
								return name_788;
							})() }
						} break;
						
						case 24: {
							const n_797 = temp_795[1];
							if ((n_797 == name_788)) { return (() => {
								const result_798 = this.parentNames.get(f);
								if (result_798 != null) { return result_798 };
								return name_788;
							})() }
						} break;
						};
					}
				} break;
				
				case 39: {
					const t_799 = temp_789[1];
					const fields_800 = temp_789[2];
					const valuesType_801 = temp_789[3];
					for (const f of $toIterator(fields_800)) {
						const temp_802 = f;
						switch (temp_802&&temp_802[0]) {
						case 47: {
							const sf_803 = temp_802[1];
							if ((DataHelper.nameOf(sf_803) == name_788)) { return (() => {
								const result_804 = this.parentNames.get(sf_803);
								if (result_804 != null) { return result_804 };
								return name_788;
							})() }
						} break;
						};
					}
				} break;
				};
			};
			return null;
		};
		unwrapNestingBlocks(block_805) {
			const temp_806 = block_805;
			switch (temp_806&&temp_806[0]) {
			case 1: {
				const el_807 = temp_806[1];
				{
					if ((el_807.length == 1)) { return this.unwrapNestingBlocks(el_807[0]) };
					return block_805;
				}
			} break;
			
			default: 
			return block_805
			};
		};
		saveInlineIfViable(e_808, value_809) {
			const temp_810 = value_809;
			switch (temp_810&&temp_810[0]) {
			case 1: {
				this.inline.set(e_808, value_809)
			} break;
			
			case 0: {
				this.inline.set(e_808, value_809)
			} break;
			
			case 3: {
				this.inline.set(e_808, value_809)
			} break;
			
			case 4: {
				this.inline.set(e_808, value_809)
			} break;
			
			case 5: {
				this.inline.set(e_808, value_809)
			} break;
			
			case 7: {
				this.inline.set(e_808, value_809)
			} break;
			};
		};
	}
	Normalizer.getDec = (atts_733, atname) => {
			if ((atts_733 != null && atts_733.length > 0)) { for (const att of $toIterator(atts_733)) {
				if ((att.name == atname)) { return att };
			} };
			return null;
		};
	var Typer = class {
		constructor(project) { 
			this.currentModule = new Module()
			this.scopes = [new Map()]
			this.scopeTypes = [new Map()]
			this.parents = new Map()
			this.types = new Map()
			this.typeString = null
			this.typeIntClass = new ClassType()
			this.typeInt = this.typeIntClass.instantiate()
			this.typeFloat = null
			this.typeBool = null
			this.typeArray = new ClassType()
			this.typeMap = (null)
			this.typeAnyClass = new ClassType()
			this.typeAny = this.typeAnyClass.instantiate()
			this.nodeAny = null
			this.typeVoid = null
			this.namespaces = new Map()
			this.typeBigInt = null
			this.typeInt32 = null
			this.typeInt64 = null
			this.typeInt16 = null
			this.typeInt8 = null
			this.typeUInt32 = null
			this.typeUInt64 = null
			this.typeUInt16 = null
			this.typeUInt8 = null
			this.typeFloat32 = null
			this.functionAllowedToThrow = false
			this.functionThrows = false
			this.insideTry = false
			this.insideFunction = false
			this.allowBreakAndContinue = false
			this.functionReturnsAType = null
			this.functionActuallyReturns = false
			this.insideClassMethod = false
			this.allowSuper = false
			this.thisType = (null)
			this.thisNode = (null)
		this.project = project };
		fillModules() {
			const checkOverrides = (info, name, e) => {
				if ((info.exported.has(name))) { this.fail(('Module `' + (info.path) + '` already exports name `' + (name) + '`'), e) };
				if ((info.imported.has(name))) { this.fail(('Module `' + (info.path) + '` already imports name `' + (name) + '`'), e) };
			};
			for (const info of $toIterator(this.project.moduleInfo)) {
				const nodes = info.nodes;
				for (const e of $toIterator(nodes)) {
					let named = true;
					{
						const temp = e;
						switch (temp&&temp[0]) {
						case 24: {
							{
							}
						} break;
						
						case 39: {
							{
							}
						} break;
						
						case 22: {
							{
							}
						} break;
						
						case 25: {
							{
							}
						} break;
						
						case 9: {
							{
							}
						} break;
						
						default: 
						named = false
						};
					};
					if (named) {
						const name_811 = DataHelper.nameOf(e);
						checkOverrides(info, name_811, e);
						info.exported.set(name_811, e);
						this.project.mapModules.set(e, info);
					};
				};
			};
			for (const info of $toIterator(this.project.moduleInfo)) {
				const nodes_812 = info.nodes;
				this.pushScope();
				let doneImports = false;
				for (const e of $toIterator(nodes_812)) {
					let named_813 = true;
					let lastOne = nodes_812[0];
					{
						const temp_814 = e;
						switch (temp_814&&temp_814[0]) {
						case 37: {
							const els = temp_814[1];
							const path = temp_814[2];
							{
								if (doneImports) { this.fail('Imports should follow before expressions\n' + this.positionOf(lastOne) + 'Expression is here', e) };
								const index = this.project.mapModules.get(e);
								if (index == null) { this.fail('Cannot import ' + path, e) };
								console.log('import index ok', path);
								const importAs = (name_815, to) => {
									let step = 0;
									const target = index;
									if (step == 0 && target != null) { step = 1 };
									if (step == 1) { if (name_815 == '*') { info.imported.set(to, /*ModuleExports*/[36,target]) } else {
										let step_816 = 0;
										const what = target.exported.get(name_815);
										if (step_816 == 0 && what != null) { step_816 = 1 };
										if (step_816 == 1) {
											checkOverrides(info, to, e);
											info.imported.set(to, what);
										} else {
											let has = (() => {
												const result = [];
												const value = target.exported.keys();
												for (const key of $toIterator(value)) result.push(key);
												return result;
											})().join(', ');
											if (has == '') { has = 'module is empty' };
											this.fail(('Module `' + (path) + '` does not export `' + (name_815) + '`\nAvailable exports: ' + (has) + ''), e);
										};
									} };
								};
								if (els.length == 0) {
									let step_817 = 0;
									const target_818 = index;
									if (step_817 == 0 && target_818 != null) { step_817 = 1 };
									if (step_817 == 1) { for (const key of $toIterator(target_818.exported.keys())) {
										info.imported.set(key, target_818.exported.get(key));
									} };
								};
								for (const el of $toIterator(els)) {
									const temp_819 = el;
									switch (temp_819&&temp_819[0]) {
									case 0: {
										const name_820 = temp_819[1];
										importAs(name_820, name_820)
									} break;
									
									case 1: {
										const name_821 = temp_819[1];
										importAs(name_821, name_821)
									} break;
									
									case 3: {
										const left = temp_819[1];
										const right = temp_819[2];
										{
											let lhs = '';
											{
												const temp_822 = left;
												switch (temp_822&&temp_822[0]) {
												case 0: {
													const name_823 = temp_822[1];
													lhs = name_823
												} break;
												
												case 1: {
													const name_824 = temp_822[1];
													lhs = name_824
												} break;
												
												case 2: {
													lhs = '*'
												} break;
												
												default: 
												this.fail('This `import ??? as` kind not implemented yet or syntax is incorrect', e)
												};
											};
											{
												const temp_825 = right;
												switch (temp_825&&temp_825[0]) {
												case 0: {
													const name_826 = temp_825[1];
													importAs(lhs, name_826)
												} break;
												
												case 1: {
													const name_827 = temp_825[1];
													importAs(lhs, name_827)
												} break;
												
												default: 
												this.fail(('This `import ' + (lhs) + ' as ???` kind not implemented yet or syntax is incorrect'), e)
												};
											};
										}
									} break;
									
									default: 
									this.fail('This import kind not implemented yet', e)
									};
								};
							}
						} break;
						
						default: 
						{
							lastOne = e;
							doneImports = true;
							const node = e;
							if (this.currentModule != info) {};
							this.currentModule = info;
							{
								const temp_828 = node;
								switch (temp_828&&temp_828[0]) {
								case 25: {
									{
										this.parents.set(node, e);
										this.fillModuleTypes(node);
									}
								} break;
								
								case 39: {
									{
										this.parents.set(node, e);
										this.fillModuleTypes(node);
									}
								} break;
								
								case 9: {
									{
										this.parents.set(node, e);
										this.fillModuleTypes(node);
									}
								} break;
								
								case 22: {
									const name_829 = temp_828[1];
									const expr = temp_828[2];
									const vars = temp_828[3];
									const rettype = temp_828[4];
									{
										let step_830 = 0;
										const rettype_831 = rettype;
										if (step_830 == 0 && rettype_831 != null) { step_830 = 1 };
										if (step_830 == 1) { this.types.set(node, /*Function*/[10,this.varTypes(vars),this.toType(rettype_831, node)]) };
									}
								} break;
								
								case 24: {
									const name_832 = temp_828[1];
									const t = temp_828[2];
									const e_833 = temp_828[3];
									const const_834 = temp_828[4];
									{
										let step_835 = 0;
										const t_836 = t;
										if (step_835 == 0 && t_836 != null) { step_835 = 1 };
										if (step_835 == 1) { this.types.set(node, this.toType(t_836, node)) };
									}
								} break;
								
								default: 
								{
								}
								};
							};
						}
						};
					};
				};
			};
			for (const info of $toIterator(this.project.moduleInfo)) {
				const nodes_837 = info.nodes;
				const self = /*Module*/[35,info.path,info.nodes];
				this.pushScope();
				this.currentModule = info;
				for (const node of $toIterator(nodes_837)) {
					const temp_838 = node;
					switch (temp_838&&temp_838[0]) {
					case 37: {
						{
						}
					} break;
					
					case 25: {
						{
						}
					} break;
					
					case 9: {
						{
						}
					} break;
					
					case 39: {
						{
						}
					} break;
					
					default: 
					{
						this.parents.set(node, self);
						this.fill(node);
					}
					};
				};
				this.popScope();
			};
			if ((Typer.failures.length > 0)) {
				const errors = Typer.failures.slice();
				Typer.failures = [];
				throw new CompilerErrors(errors);
			};
		};
		find(name_839) {
			let subj = null;
			{
				let i = 0;
				let it = 0;
				let at = this.scopes.length;
				while (it < at) {
					i = it;
					it++;
					{
						subj = this.scopes[this.scopes.length - i - 1].get(name_839);
						if ((subj != null)) { break };
					};
				};
			};
			if ((subj == null)) { subj = this.findInNamespaceRoots(name_839) };
			return subj;
		};
		proposeSimilar(names, subject, what_840) {
			if (names.length == 0) { return ('No ' + (what_840) + ' available for access') };
			const ten = (names.length > 11)? (names.slice(0, 10).join(', ') + ' and ' + (names.length - 10) + ' more ' + what_840) : names.join(', ');
			const available = ('Available ' + (what_840) + ' are: ') + ten;
			const subject_841 = subject.toLowerCase();
			const charSubj = subject_841.split('');
			let bestValue = 0;
			let bestName = '';
			for (const name of $toIterator(names)) {
				const named_842 = name.toLowerCase();
				if ((named_842.startsWith(subject_841) || subject_841.startsWith(named_842))) { return ('Did you mean `' + (name) + '`?\n\n') + available };
				let index_843 = 0;
				let thisValue = 0;
				for (const char of $toIterator(named_842.split(''))) {
					if ((char == charSubj[index_843])) { thisValue++ };
					index_843++;
				};
				if ((thisValue > bestValue)) {
					bestValue = thisValue;
					bestName = name;
				};
			};
			if ((bestValue > 2)) { return ('Did you mean `' + (bestName) + '`?\n\n') + available };
			return available;
		};
		registerClassType(node_844, callback) {
			const mod = this.currentModule;
			this.currentModule = (() => {
				const result_845 = this.project.mapModules.get(node_844);
				if (result_845 != null) { return result_845 };
				return mod;
			})();
			const registered = this.registerClassTypeWrapped(node_844, callback);
			this.currentModule = mod;
			return registered;
		};
		registerClassTypeWrapped(node_846, callback_847) {
			let step_848 = 0;
			const type = this.types.get(node_846);
			if (step_848 == 0 && type != null) { step_848 = 1 };
			if (step_848 == 1) {
				const temp_849 = (type);
				switch (temp_849&&temp_849[0]) {
				case 3: {
					const t_850 = temp_849[1];
					{
						{
							let step_851 = 0;
							const setup = callback_847;
							if (step_851 == 0 && setup != null) { step_851 = 1 };
							if (step_851 == 1) { setup(t_850) };
						};
						return t_850;
					}
				} break;
				};
			} else {
				const typeName = DataHelper.nameOf(node_846);
				const type_852 = (() => {
					const temp_853 = typeName;
					switch (temp_853) {
					case 'Int': {
						return this.typeIntClass
					} break;
					
					case 'Array': {
						return this.typeArray
					} break;
					
					case 'Any': {
						return this.typeAnyClass
					} break;
					
					default: 
					return new ClassType()
					};
				})();
				const _thisType = this.thisType;
				const _thisNode = this.thisNode;
				this.thisType = type_852.instantiate();
				this.thisNode = node_846;
				type_852.parent = node_846;
				type_852.name = typeName;
				this.types.set(node_846, /*Class*/[3,type_852]);
				{
					let step_854 = 0;
					const setup_855 = callback_847;
					if (step_854 == 0 && setup_855 != null) { step_854 = 1 };
					if (step_854 == 1) { setup_855(type_852) };
				};
				{
					const temp_856 = type_852.name;
					switch (temp_856) {
					case 'Int': {
						{
						}
					} break;
					
					case 'Bool': {
						this.typeBool = type_852.instantiate()
					} break;
					
					case 'Float': {
						this.typeFloat = type_852.instantiate()
					} break;
					
					case 'String': {
						this.typeString = type_852.instantiate()
					} break;
					
					case 'Array': {
						this.typeArray = type_852
					} break;
					
					case 'Map': {
						this.typeMap = type_852
					} break;
					
					case 'Any': {
						this.nodeAny = node_846
					} break;
					
					case 'Void': {
						this.typeVoid = type_852.instantiate()
					} break;
					
					case 'UInt8': {
						this.typeUInt8 = type_852.instantiate()
					} break;
					
					case 'UInt16': {
						this.typeUInt16 = type_852.instantiate()
					} break;
					
					case 'UInt32': {
						this.typeUInt32 = type_852.instantiate()
					} break;
					
					case 'UInt64': {
						this.typeUInt64 = type_852.instantiate()
					} break;
					};
				};
				const getRename = (f) => {
					const atts = this.project.mapDecorators.get(f);
					{
						let step_857 = 0;
						const native = DataHelper.getDecorator(atts, 'rename');
						if (step_857 == 0 && native != null) { step_857 = 1 };
						if (step_857 == 1) {
							if ((native.values.length != 1)) { throw '@rename takes one string argument' };
							if ((native != null)) {
								const temp_858 = native.values[0];
								switch (temp_858&&temp_858[0]) {
								case 0: {
									const s = temp_858[1];
									return s
								} break;
								
								default: 
								throw '@rename takes string as argument'
								};
							};
						};
					};
					return null;
				};
				{
					const temp_859 = node_846;
					switch (temp_859&&temp_859[0]) {
					case 25: {
						const t_860 = temp_859[1];
						const extend = temp_859[2];
						const implement = temp_859[3];
						const f_861 = temp_859[4];
						const external = temp_859[5];
						{
							{
								const temp_862 = t_860;
								switch (temp_862&&temp_862[0]) {
								case 2: {
									const name_863 = temp_862[1];
									const params = temp_862[2];
									{
										type_852.genericParams.push(DataHelper.extractTypeName(params[0]));
										const names_864 = type_852.genericParams;
										{
											let i_865 = 0;
											let it_866 = 1;
											let at_867 = params.length;
											while (it_866 < at_867) {
												i_865 = it_866;
												it_866++;
												{
													const name_868 = DataHelper.extractTypeName(params[i_865]);
													if ((names_864.includes(name_868))) { this.fail(('Parameter `' + (name_868) + '` already exists in `<T, ...>`'), node_846) };
													names_864.push(name_868);
												};
											};
										};
									}
								} break;
								};
							};
							{
								let step_869 = 0;
								const ext = extend;
								if (step_869 == 0 && ext != null) { step_869 = 1 };
								if (step_869 == 1) { this.toType(ext, node_846) };
							};
							for (const impl of $toIterator(implement)) {
								this.toType(impl, node_846);
							};
							this.pushScope();
							for (const genericParam of $toIterator(type_852.genericParams)) {
								this.addScopeType(genericParam, this.typeAny);
							};
							for (const field of $toIterator(f_861)) {
								{
									const temp_870 = field;
									switch (temp_870&&temp_870[0]) {
									case 22: {
										const name_871 = temp_870[1];
										{
											if ((type_852.fieldNames.includes(name_871))) { this.fail(('Field `' + (name_871) + '` already exists'), field) };
											type_852.fieldNames.push(name_871);
											if ((name_871 == 'new')) { type_852.constructor = type_852.fieldNames.length - 1 } else {
												type_852.fieldRenames[type_852.fieldNames.length - 1] = getRename(field);
											};
											this.addScope(name_871, field);
										}
									} break;
									
									case 24: {
										const name_872 = temp_870[1];
										const t_873 = temp_870[2];
										const e_874 = temp_870[3];
										{
											if ((type_852.fieldNames.includes(name_872))) { this.fail(('Field `' + (name_872) + '` already exists'), field) };
											type_852.fieldNames.push(name_872);
											type_852.fieldInitialized[type_852.fieldNames.length - 1] = false;
											type_852.fieldRenames[type_852.fieldNames.length - 1] = getRename(field);
											this.addScope(name_872, field);
										}
									} break;
									
									case 26: {
										const field = temp_870[1];
										{
											const temp_875 = field;
											switch (temp_875&&temp_875[0]) {
											case 24: {
												const name_876 = temp_875[1];
												{
													if ((type_852.fieldNames.includes(name_876))) { this.fail(('Field `' + (name_876) + '` already exists'), field) };
													type_852.fieldNames.push(name_876);
													this.addScope(name_876, field);
												}
											} break;
											};
										}
									} break;
									
									case 47: {
										const f_877 = temp_870[1];
										{
											const temp_878 = f_877;
											switch (temp_878&&temp_878[0]) {
											case 22: {
												const name_879 = temp_878[1];
												{
													if ((type_852.fieldNames.includes(name_879))) { this.fail(('Field `' + (name_879) + '` already exists'), field) };
													type_852.fieldNames.push(name_879);
													type_852.fieldStatic[type_852.fieldNames.length - 1] = true;
													this.addScope(name_879, field);
												}
											} break;
											
											case 24: {
												const name_880 = temp_878[1];
												{
													if ((type_852.fieldNames.includes(name_880))) { this.fail(('Field `' + (name_880) + '` already exists'), field) };
													type_852.fieldNames.push(name_880);
													type_852.fieldStatic[type_852.fieldNames.length - 1] = true;
													this.addScope(name_880, field);
												}
											} break;
											};
										}
									} break;
									
									default: 
									this.fail('Wrong class field format', field)
									};
								};
								this.parents.set(field, node_846);
							};
							for (const field of $toIterator(f_861)) {
								const temp_881 = field;
								switch (temp_881&&temp_881[0]) {
								case 24: {
									const name_882 = temp_881[1];
									const t_883 = temp_881[2];
									const e_884 = temp_881[3];
									const const_885 = temp_881[4];
									{
										let step_886 = 0;
										const t_887 = t_883;
										if (step_886 == 0 && t_887 != null) { step_886 = 1 };
										if (step_886 == 1) { this.types.set(field, this.toType(t_887, field)) };
									}
								} break;
								
								case 22: {
									const name_888 = temp_881[1];
									const expr_889 = temp_881[2];
									const vars_890 = temp_881[3];
									const rettype_891 = temp_881[4];
									{
										let step_892 = 0;
										const rettype_893 = rettype_891;
										if (step_892 == 0 && rettype_893 != null) { step_892 = 1 };
										if (step_892 == 1) { this.types.set(field, /*Function*/[10,this.varTypes(vars_890),this.toType(rettype_893, field)]) };
									}
								} break;
								
								case 47: {
									const f_894 = temp_881[1];
									{
										const temp_895 = f_894;
										switch (temp_895&&temp_895[0]) {
										case 22: {
											const name_896 = temp_895[1];
											const expr_897 = temp_895[2];
											const vars_898 = temp_895[3];
											const rettype_899 = temp_895[4];
											{
												let step_900 = 0;
												const rettype_901 = rettype_899;
												if (step_900 == 0 && rettype_901 != null) { step_900 = 1 };
												if (step_900 == 1) {
													this.types.set(f_894, /*Function*/[10,this.varTypes(vars_898),this.toType(rettype_901, f_894)]);
													this.types.set(field, this.types.get(f_894));
												};
											}
										} break;
										
										case 24: {
											const name_902 = temp_895[1];
											const t_903 = temp_895[2];
											const e_904 = temp_895[3];
											const const_905 = temp_895[4];
											{
												let step_906 = 0;
												const t_907 = t_903;
												if (step_906 == 0 && t_907 != null) { step_906 = 1 };
												if (step_906 == 1) {
													this.types.set(f_894, this.toType(t_907, f_894));
													this.types.set(field, this.types.get(f_894));
												};
											}
										} break;
										};
									}
								} break;
								};
							};
							for (const field of $toIterator(f_861)) {
								const temp_908 = field;
								switch (temp_908&&temp_908[0]) {
								case 22: {
									const name_909 = temp_908[1];
									const expr_910 = temp_908[2];
									const vars_911 = temp_908[3];
									const rettype_912 = temp_908[4];
									{
										if ((name_909 == 'new')) { type_852.constructor = type_852.fieldNames.length - 1 };
										if ((external) && (expr_910 != null)) { if ((name_909 == 'new')) { this.fail('External class constructor `new()` cannot have a body `{}`', field) } else {
											this.fail(('External class method `function ' + (name_909) + '` cannot have a body `{}`'), field);
										} };
										const _insideClassMethod = this.insideClassMethod;
										const _allowSuper = this.allowSuper;
										this.insideClassMethod = true;
										this.allowSuper = (extend != null);
										if ((!external)) { this.fillFunction(field, expr_910, vars_911, rettype_912) };
										if ((external) && (this.types.get(field) == null)) { this.types.set(field, /*Function*/[10,this.varTypes(vars_911),(rettype_912 != null)? (this.toType(rettype_912, field)) : this.typeVoid]) };
										this.insideClassMethod = _insideClassMethod;
										this.allowSuper = _allowSuper;
									}
								} break;
								
								case 24: {
									const name_913 = temp_908[1];
									const t_914 = temp_908[2];
									const e_915 = temp_908[3];
									const const_916 = temp_908[4];
									{
										if ((external) && (e_915 != null)) { this.fail(('External class field `var ' + (name_913) + '` cannot have `= value`'), field) };
										const _insideClassMethod_917 = this.insideClassMethod;
										this.insideClassMethod = true;
										if (e_915 != null) { this.fillExpression(e_915) };
										this.insideClassMethod = _insideClassMethod_917;
										this.mixVarTypes(t_914, e_915, field);
										type_852.fieldInitialized[type_852.fieldNames.indexOf(name_913)] = true;
										if (this.types.get(field) == null) { this.fail(('Field `var ' + (name_913) + '` initialized, but got no type ') + e_915, field) };
									}
								} break;
								
								case 26: {
									const f_918 = temp_908[1];
									{
										const temp_919 = f_918;
										switch (temp_919&&temp_919[0]) {
										case 24: {
											const name_920 = temp_919[1];
											const t_921 = temp_919[2];
											const e_922 = temp_919[3];
											const const_923 = temp_919[4];
											{
												if ((external) && (e_922 != null)) { this.fail(('External class field `var ' + (name_920) + '` cannot have expression'), field) };
												const _insideClassMethod_924 = this.insideClassMethod;
												this.insideClassMethod = true;
												if (e_922 != null) { this.fillExpression(e_922) };
												this.insideClassMethod = _insideClassMethod_924;
												this.mixVarTypes(t_921, e_922, f_918);
												type_852.fieldInitialized[type_852.fieldNames.indexOf(name_920)] = true;
												if (this.types.get(f_918) == null) { this.fail(('Property `' + (name_920) + '` initialized, but got no type ') + e_922, field) };
												this.types.set(field, this.types.get(f_918));
											}
										} break;
										};
									}
								} break;
								
								case 47: {
									const f_925 = temp_908[1];
									{
										const temp_926 = f_925;
										switch (temp_926&&temp_926[0]) {
										case 22: {
											const name_927 = temp_926[1];
											const expr_928 = temp_926[2];
											const vars_929 = temp_926[3];
											const rettype_930 = temp_926[4];
											{
												if ((external) && (expr_928 != null)) { this.fail(('External class field `static fun ' + (name_927) + '` cannot have a body'), field) };
												const _insideClassMethod_931 = this.insideClassMethod;
												this.insideClassMethod = false;
												if ((!external)) { this.fillFunction(f_925, expr_928, vars_929, rettype_930) };
												if (external) { this.types.set(f_925, /*Function*/[10,this.varTypes(vars_929),(rettype_930 != null)? (this.toType(rettype_930, f_925)) : this.typeVoid]) };
												this.insideClassMethod = _insideClassMethod_931;
												if ((this.types.get(f_925) == null)) { this.fail('Function get no type: class ' + DataHelper.nameOf(node_846) + ' static ' + name_927, f_925) };
												this.types.set(field, this.types.get(f_925));
											}
										} break;
										
										case 24: {
											const name_932 = temp_926[1];
											const t_933 = temp_926[2];
											const e_934 = temp_926[3];
											const const_935 = temp_926[4];
											{
												if ((external) && (e_934 != null)) { this.fail(('External class field `static var ' + (name_932) + '` cannot have expression'), field) };
												if ((e_934 != null)) { this.fillExpression(e_934) };
												this.mixVarTypes(t_933, e_934, f_925);
												this.types.set(field, this.types.get(f_925));
											}
										} break;
										};
									}
								} break;
								
								default: 
								this.fail('Wrong class field format', node_846)
								};
							};
							this.popScope();
						}
					} break;
					
					default: 
					this.fail('ClassType expects (declare) class node, but got ' + node_846, node_846)
					};
				};
				this.thisType = _thisType;
				this.thisNode = _thisNode;
				return type_852;
			};
		};
		registerEnumType(node_936) {
			let step_937 = 0;
			const type_938 = this.types.get(node_936);
			if (step_937 == 0 && type_938 != null) { step_937 = 1 };
			if (step_937 == 1) {
				const temp_939 = (type_938);
				switch (temp_939&&temp_939[0]) {
				case 6: {
					const t_940 = temp_939[1];
					return t_940
				} break;
				};
			} else {
				const type_941 = new EnumType();
				type_941.parent = node_936;
				type_941.name = DataHelper.nameOf(node_936);
				this.types.set(node_936, /*Enum*/[6,type_941]);
				{
					const temp_942 = node_936;
					switch (temp_942&&temp_942[0]) {
					case 39: {
						const t_943 = temp_942[1];
						const f_944 = temp_942[2];
						const valuesType = temp_942[3];
						const extend_945 = temp_942[4];
						{
							this.pushScope();
							{
								let step_946 = 0;
								const valuesType_947 = valuesType;
								if (step_946 == 0 && valuesType_947 != null) { step_946 = 1 };
								if (step_946 == 1) { type_941.fieldsTypeSimple = this.toType(valuesType_947, node_936) };
							};
							if ((type_941.fieldsTypeSimple != null) && (type_941.fieldsTypeSimple != this.typeInt) && (type_941.fieldsTypeSimple != this.typeString)) { this.fail('Simple enums may be only of types `Int` and `String`', node_936) };
							if ((f_944.length == 0) && (extend_945 == null)) { this.fail(('Enum `' + (type_941.name) + '` must have at least one value `enum ' + (type_941.name) + ' { Value }`'), node_936) };
							for (const field of $toIterator(f_944)) {
								{
									const temp_948 = field;
									switch (temp_948&&temp_948[0]) {
									case 51: {
										const t_949 = temp_948[1];
										{
											const temp_950 = t_949;
											switch (temp_950&&temp_950[0]) {
											case 1: {
												const name_951 = temp_950[1];
												{
													if ((type_941.fieldNames.includes(name_951))) { throw this.fail(('Field `' + (name_951) + '` already exists'), node_936) };
													type_941.fieldNames.push(name_951);
													type_941.fieldEnumConstructor[type_941.fieldNames.length - 1] = true;
													type_941.tagBindVars[type_941.fieldNames.length - 1] = [];
													type_941.tagBindVarsNames[type_941.fieldNames.length - 1] = [];
													type_941.fieldType[type_941.fieldNames.length - 1] = /*EnumInstance*/[7,type_941,type_941.fieldNames.length - 1];
												}
											} break;
											
											default: 
											this.fail('Wrong enum constructor format, should be `Name`', node_936)
											};
										}
									} break;
									
									case 13: {
										const e_952 = temp_948[1];
										const args = temp_948[2];
										const argNames = temp_948[3];
										{
											if ((valuesType != null)) { throw this.fail('Cannot use `Value(args)` format for simple enum', node_936) };
											{
												const temp_953 = e_952;
												switch (temp_953&&temp_953[0]) {
												case 51: {
													const t_954 = temp_953[1];
													{
														const temp_955 = t_954;
														switch (temp_955&&temp_955[0]) {
														case 1: {
															const name_956 = temp_955[1];
															{
																if ((type_941.fieldNames.includes(name_956))) { throw this.fail(('Field `' + (name_956) + '` already exists'), node_936) };
																type_941.fieldNames.push(name_956);
																type_941.fieldEnumConstructor[type_941.fieldNames.length - 1] = true;
																type_941.fieldType[type_941.fieldNames.length - 1] = /*EnumConstructor*/[8,type_941,type_941.fieldNames.length - 1];
																const tagBindVars = [];
																const tagBindVarsNames = [];
																type_941.tagBindVars[type_941.fieldNames.length - 1] = tagBindVars;
																type_941.tagBindVarsNames[type_941.fieldNames.length - 1] = tagBindVarsNames;
																if ((args.length == 0)) { this.fail('Enum constructor expects more than zero arguments `(value: Type)`', e_952) };
																{
																	let i_957 = 0;
																	let it_958 = 0;
																	let at_959 = args.length;
																	while (it_958 < at_959) {
																		i_957 = it_958;
																		it_958++;
																		{
																			if ((argNames[i_957] == null)) { this.fail('Enum constructor arguments should have names `E(name1: T, name2: T)', args[i_957]) };
																			tagBindVars[i_957] = Typer.nodeToNodeType(args[i_957]);
																			if ((tagBindVarsNames.includes(argNames[i_957]))) { this.fail(('Enum constructor argument `' + (argNames[i_957]) + '` already exists'), args[i_957]) };
																			tagBindVarsNames[i_957] = argNames[i_957];
																		};
																	};
																};
															}
														} break;
														
														default: 
														this.fail('Wrong enum constructor format, should be `Name(value: T)`', e_952)
														};
													}
												} break;
												};
											};
										}
									} break;
									
									case 10: {
										const a = temp_948[1];
										const op = temp_948[2];
										const b = temp_948[3];
										{
											if ((op != 91)) { this.fail(('Should use `Value = value` not `Value ' + (Token.stringify(op)) + ' value` format for enum tag value'), node_936) };
											if ((valuesType == null)) { this.fail('Cannot use `Value = value` format for complex enum', node_936) };
											{
												const temp_960 = a;
												switch (temp_960&&temp_960[0]) {
												case 51: {
													const t_961 = temp_960[1];
													{
														const temp_962 = t_961;
														switch (temp_962&&temp_962[0]) {
														case 1: {
															const name_963 = temp_962[1];
															{
																if ((type_941.fieldNames.includes(name_963))) { this.fail(('Field `' + (name_963) + '` already exists'), node_936) };
																type_941.fieldNames.push(name_963);
																type_941.fieldEnumConstructor[type_941.fieldNames.length - 1] = true;
																{
																	const temp_964 = b;
																	switch (temp_964&&temp_964[0]) {
																	case 5: {
																		if ((type_941.fieldsTypeSimple != this.typeInt)) { this.fail(('`' + (name_963) + ' = value` expects constant value of type `' + (Type.stringify(type_941.fieldsTypeSimple)) + '`'), b) }
																	} break;
																	
																	case 0: {
																		if ((type_941.fieldsTypeSimple != this.typeString)) { this.fail(('`' + (name_963) + ' = value` expects constant value of type `' + (Type.stringify(type_941.fieldsTypeSimple)) + '`'), b) }
																	} break;
																	};
																};
																this.fillExpression(b);
																type_941.fieldType[type_941.fieldNames.length - 1] = /*EnumInstance*/[7,type_941,type_941.fieldNames.length - 1];
															}
														} break;
														};
													}
												} break;
												};
											};
										}
									} break;
									
									case 1: {
										const name_965 = temp_948[1];
										this.fail(('Cannot use lowercase `' + (name_965) + '` format for enum values'), node_936)
									} break;
									
									case 47: {
										const f_966 = temp_948[1];
										{
											const temp_967 = f_966;
											switch (temp_967&&temp_967[0]) {
											case 22: {
												const name_968 = temp_967[1];
												{
													if ((type_941.fieldNames.includes(name_968))) { this.fail(('Field `' + (name_968) + '` already exists'), node_936) };
													type_941.fieldNames.push(name_968);
													type_941.fieldStatic[type_941.fieldNames.length - 1] = true;
													this.addScope(name_968, field);
												}
											} break;
											
											case 24: {
												const name_969 = temp_967[1];
												{
													if ((type_941.fieldNames.includes(name_969))) { this.fail(('Field `' + (name_969) + '` already exists'), node_936) };
													type_941.fieldNames.push(name_969);
													type_941.fieldStatic[type_941.fieldNames.length - 1] = true;
													this.addScope(name_969, field);
												}
											} break;
											};
										}
									} break;
									
									default: 
									this.fail('Wrong enum field format', field)
									};
								};
								this.parents.set(field, node_936);
							};
							for (const field of $toIterator(f_944)) {
								const temp_970 = field;
								switch (temp_970&&temp_970[0]) {
								case 22: {
									const name_971 = temp_970[1];
									const expr_972 = temp_970[2];
									const vars_973 = temp_970[3];
									const rettype_974 = temp_970[4];
									this.fillFunction(field, expr_972, vars_973, rettype_974)
								} break;
								
								case 24: {
									const name_975 = temp_970[1];
									{
									}
								} break;
								
								case 47: {
									const f_976 = temp_970[1];
									{
										const temp_977 = f_976;
										switch (temp_977&&temp_977[0]) {
										case 22: {
											const name_978 = temp_977[1];
											const expr_979 = temp_977[2];
											const vars_980 = temp_977[3];
											const rettype_981 = temp_977[4];
											{
												const _insideClassMethod_982 = this.insideClassMethod;
												this.insideClassMethod = false;
												if ((rettype_981 != null)) { this.types.set(f_976, /*Function*/[10,[],this.toType(rettype_981, f_976)]) } else {
													this.types.set(f_976, /*Function*/[10,[],this.typeVoid]);
												};
												this.types.set(field, this.types.get(f_976));
												this.fillFunction(f_976, expr_979, vars_980, rettype_981);
												this.insideClassMethod = _insideClassMethod_982;
												if ((this.types.get(f_976) == null)) { this.fail('Function get no type: enum ' + DataHelper.nameOf(node_936) + ' static ' + name_978, f_976) };
												this.types.set(field, this.types.get(f_976));
											}
										} break;
										
										case 24: {
											const name_983 = temp_977[1];
											const t_984 = temp_977[2];
											const e_985 = temp_977[3];
											const const_986 = temp_977[4];
											{
												if ((e_985 != null)) { this.fillExpression(e_985) };
												this.mixVarTypes(t_984, e_985, f_976);
												this.types.set(field, this.types.get(f_976));
											}
										} break;
										};
									}
								} break;
								
								case 51: {
									{
									}
								} break;
								
								case 13: {
									{
									}
								} break;
								
								case 10: {
									{
									}
								} break;
								
								default: 
								this.fail('Unknown enum field format', field)
								};
							};
							this.popScope();
						}
					} break;
					
					default: 
					this.fail('EnumType expects (declare) enum node, but got ' + node_936, node_936)
					};
				};
				return type_941;
			};
		};
		fail(msg, node_987) {
			this.failNonFatal(msg, node_987);
			const errors_988 = Typer.failures.slice();
			Typer.failures = [];
			throw new CompilerErrors(errors_988);
		};
		failNonFatal(msg_989, node_990) {
			const data = this.project.data.get(node_990);
			{
				let step_991 = 0;
				const data_992 = data;
				if (step_991 == 0 && data_992 != null) { step_991 = 1 };
				if (step_991 == 1) { Typer.failures.push(new CompilerError(3, msg_989, data_992.line, data_992.column, data_992.fileName)) } else {
					Typer.failures.push(new CompilerError(3, msg_989, 0, 0, ''));
				};
			};
		};
		positionOf(node_993) {
			const data_994 = this.project.data.get(node_993);
			if ((data_994 == null)) { return '[Unknown]: ' };
			return '[' + data_994.fileName + ':' + data_994.line + ':' + data_994.column + ']: ';
		};
		nameOfModuleItem(node_1002) {
			const temp_1003 = node_1002;
			switch (temp_1003&&temp_1003[0]) {
			case 24: {
				const name_1004 = temp_1003[1];
				return name_1004
			} break;
			
			case 22: {
				const name_1005 = temp_1003[1];
				{
					let step_1006 = 0;
					const named_1007 = name_1005;
					if (step_1006 == 0 && named_1007 != null) { step_1006 = 1 };
					if (step_1006 == 1) { return named_1007 } else {
						throw 'Module function should have a name';
					};
				}
			} break;
			
			case 48: {
				const node_1008 = temp_1003[1];
				{
					const temp_1009 = node_1008;
					switch (temp_1009&&temp_1009[0]) {
					case 25: {
						const t_1010 = temp_1009[1];
						{
							const temp_1011 = t_1010;
							switch (temp_1011&&temp_1011[0]) {
							case 1: {
								const name_1012 = temp_1011[1];
								return name_1012
							} break;
							
							case 2: {
								const name_1013 = temp_1011[1];
								return name_1013
							} break;
							};
						}
					} break;
					};
				}
			} break;
			
			case 25: {
				const t_1014 = temp_1003[1];
				{
					const temp_1015 = t_1014;
					switch (temp_1015&&temp_1015[0]) {
					case 1: {
						const name_1016 = temp_1015[1];
						return name_1016
					} break;
					
					case 2: {
						const name_1017 = temp_1015[1];
						return name_1017
					} break;
					};
				}
			} break;
			
			case 39: {
				const t_1018 = temp_1003[1];
				{
					const temp_1019 = t_1018;
					switch (temp_1019&&temp_1019[0]) {
					case 1: {
						const name_1020 = temp_1019[1];
						return name_1020
					} break;
					
					case 2: {
						const name_1021 = temp_1019[1];
						return name_1021
					} break;
					};
				}
			} break;
			
			case 9: {
				const t_1022 = temp_1003[1];
				{
					const temp_1023 = t_1022;
					switch (temp_1023&&temp_1023[0]) {
					case 1: {
						const name_1024 = temp_1023[1];
						return name_1024
					} break;
					
					case 2: {
						const name_1025 = temp_1023[1];
						return name_1025
					} break;
					};
				}
			} break;
			
			default: 
			this.fail('Improper module item format, wrap expressions as `{ expressions }`', node_1002)
			};
		};
		findInNamespaceRoots(name_1026) {
			{
				let step_1027 = 0;
				const node_1028 = this.currentModule.imported.get(name_1026);
				if (step_1027 == 0 && node_1028 != null) { step_1027 = 1 };
				if (step_1027 == 1) { return node_1028 };
			};
			{
				let step_1029 = 0;
				const node_1030 = this.currentModule.exported.get(name_1026);
				if (step_1029 == 0 && node_1030 != null) { step_1029 = 1 };
				if (step_1029 == 1) { return node_1030 };
			};
			{
				let step_1031 = 0;
				const node_1032 = this.project.globals.get(name_1026);
				if (step_1031 == 0 && node_1032 != null) { step_1031 = 1 };
				if (step_1031 == 1) { return node_1032 };
			};
			return null;
			if ((this.namespaces.get(name_1026) != null)) { return this.namespaces.get(name_1026) };
			let m = this.namespaces.get('');
			let el_1033 = (null);
			{
				const temp_1034 = (m);
				switch (temp_1034&&temp_1034[0]) {
				case 35: {
					const els_1035 = temp_1034[2];
					el_1033 = els_1035
				} break;
				
				default: 
				return null
				};
			};
			for (const e of $toIterator(el_1033)) {
				if ((name_1026 == this.nameOfModuleItem(e))) { return e };
			};
			return null;
		};
		pushScope() {
			this.scopes.push(new Map());
			this.scopeTypes.push(new Map());
		};
		popScope() {
			this.scopes.pop();
			this.scopeTypes.pop();
		};
		addScope(name_1036, node_1037) { this.scopes[this.scopes.length - 1].set(name_1036, node_1037) };
		addScopeType(name_1038, type_1039) { this.scopeTypes[this.scopeTypes.length - 1].set(name_1038, type_1039) };
		unify(to_1040, fromValue, node_1041) {
			if ((to_1040 == fromValue)) { return to_1040 };
			if ((to_1040 == this.typeAny)) { return to_1040 };
			if ((fromValue == this.typeVoid)) { this.fail(('Incompatible types `' + (Type.stringify(to_1040)) + '` and non-value type `Void`'), node_1041) };
			if ((to_1040 == this.typeFloat) && (fromValue == this.typeInt)) { return this.typeFloat };
			const isNullable = (t_1042) => {
				{
					const temp_1043 = t_1042;
					switch (temp_1043&&temp_1043[0]) {
					case 1: {
						return true
					} break;
					
					case 2: {
						return true
					} break;
					};
				};
				return false;
			};
			const instanceOfClass = (t_1044) => {
				{
					const temp_1045 = Type.unwrapNullable(t_1044);
					switch (temp_1045&&temp_1045[0]) {
					case 4: {
						const t_1046 = temp_1045[1];
						return t_1046
					} break;
					
					case 3: {
						const t_1047 = temp_1045[1];
						this.fail(('Cannot take classes `class ' + (t_1047.name) + '` as values'), node_1041)
					} break;
					};
				};
				return null;
			};
			const instanceOfEnum = (t_1048) => {
				{
					const temp_1049 = Type.unwrapNullable(t_1048);
					switch (temp_1049&&temp_1049[0]) {
					case 7: {
						const t_1050 = temp_1049[1];
						return t_1050
					} break;
					
					case 6: {
						const t_1051 = temp_1049[1];
						return t_1051
					} break;
					};
				};
				return null;
			};
			{
				const temp_1052 = to_1040;
				switch (temp_1052&&temp_1052[0]) {
				case 1: {
					const handle = temp_1052[1];
					if ((handle.value == null)) { handle.value = (() => {
						const temp_1053 = fromValue;
						switch (temp_1053&&temp_1053[0]) {
						case 1: {
							const handle_1054 = temp_1053[1];
							return handle_1054.value
						} break;
						
						case 2: {
							const t_1055 = temp_1053[1];
							return t_1055
						} break;
						
						default: 
						return fromValue
						};
					})() }
				} break;
				};
			};
			let toNullable = isNullable(to_1040);
			let fromNullable = isNullable(fromValue);
			let toInstance = instanceOfClass(to_1040);
			let fromInstance = instanceOfClass(fromValue);
			let toEnumInstance = instanceOfEnum(to_1040);
			let fromEnumInstance = instanceOfEnum(fromValue);
			if (((toInstance == null && toEnumInstance == null) || (fromInstance == null && fromEnumInstance == null))) { return (() => {
				const result_1056 = to_1040;
				if (result_1056 != null) { return result_1056 };
				return fromValue;
			})() };
			if ((toInstance != fromInstance) && (Type.unwrapNullable(to_1040) != this.typeAny) && (Type.unwrapNullable(fromValue) != this.typeAny)) { this.fail(('Incompatible types `' + (Type.stringify(to_1040)) + '` and value of `' + (Type.stringify(fromValue)) + '`'), node_1041) };
			if ((toEnumInstance != fromEnumInstance) && (Type.unwrapNullable(to_1040) != this.typeAny) && (Type.unwrapNullable(fromValue) != this.typeAny)) {};
			return (() => {
				const result_1057 = to_1040;
				if (result_1057 != null) { return result_1057 };
				return fromValue;
			})();
		};
		findType(name_1058) {
			{
				let i_1059 = 0;
				let it_1060 = 0;
				let at_1061 = this.scopes.length;
				while (it_1060 < at_1061) {
					i_1059 = it_1060;
					it_1060++;
					{
						let step_1062 = 0;
						const subj_1063 = this.scopes[this.scopes.length - i_1059 - 1].get(name_1058);
						if (step_1062 == 0 && subj_1063 != null) { step_1062 = 1 };
						if (step_1062 == 1) { return subj_1063 };
					};
				};
			};
			const rooted = this.findInNamespaceRoots(name_1058);
			if ((rooted == null)) {};
			return rooted;
		};
		findActualType(name_1064) {
			{
				let i_1065 = 0;
				let it_1066 = 0;
				let at_1067 = this.scopeTypes.length;
				while (it_1066 < at_1067) {
					i_1065 = it_1066;
					it_1066++;
					{
						let step_1068 = 0;
						const subj_1069 = this.scopeTypes[this.scopeTypes.length - i_1065 - 1].get(name_1064);
						if (step_1068 == 0 && subj_1069 != null) { step_1068 = 1 };
						if (step_1068 == 1) { return subj_1069 };
					};
				};
			};
			return null;
		};
		toType(t_1070, node_1071) {
			const temp_1072 = t_1070;
			switch (temp_1072&&temp_1072[0]) {
			case 1: {
				const name_1073 = temp_1072[1];
				const path_1074 = temp_1072[2];
				{
					let nodeType = null;
					{
						let step_1075 = 0;
						const path_1076 = path_1074;
						if (step_1075 == 0 && path_1076 != null) { step_1075 = 1 };
						if (step_1075 == 1) {
							const temp_1077 = (this.currentModule.imported.get(path_1076));
							switch (temp_1077&&temp_1077[0]) {
							case 36: {
								const handle_1078 = temp_1077[1];
								{
									nodeType = handle_1078.exported.get(name_1073);
									if (nodeType == null) {
										const file = handle_1078.file;
										this.fail(('Namespace `' + (path_1076) + '` does not export type `' + (name_1073) + '` (aliased module is `' + (file) + '`)'), node_1071);
									};
								}
							} break;
							
							default: 
							this.fail(('Cannot find supposedly imported namespace `' + (path_1076) + '` of type `' + (name_1073) + '`'), node_1071)
							};
						} else {
							nodeType = (() => {
								const result_1079 = this.findType(name_1073);
								if (result_1079 != null) { return result_1079 };
								return (() => {
									const result_1080 = this.currentModule.exported.get(name_1073);
									if (result_1080 != null) { return result_1080 };
									return this.currentModule.imported.get(name_1073);
								})();
							})();
						};
					};
					if ((this.types.get(nodeType) == null)) {
						const temp_1081 = nodeType;
						switch (temp_1081&&temp_1081[0]) {
						case 25: {
							{
								const mod_1082 = this.currentModule;
								this.registerClassType(nodeType);
								this.currentModule = mod_1082;
							}
						} break;
						
						case 39: {
							this.registerEnumType(nodeType)
						} break;
						
						case null: case undefined: {
							{
							}
						} break;
						
						default: 
						{
						}
						};
					};
					const type_1083 = (() => {
						const result_1084 = this.findActualType(name_1073);
						if (result_1084 != null) { return result_1084 };
						return this.types.get(nodeType);
					})();
					{
						const temp_1085 = type_1083;
						switch (temp_1085&&temp_1085[0]) {
						case 3: {
							const type_1086 = temp_1085[1];
							{
								if ((type_1086.genericParams.length > 0)) { this.fail(('The type `' + (type_1086.name) + '` requires `<' + (type_1086.genericParams) + '>` generic parameters'), node_1071) };
								return type_1086.instantiate();
							}
						} break;
						
						case 6: {
							const type_1087 = temp_1085[1];
							return this.types.get(nodeType)
						} break;
						
						case null: case undefined: {
							{
								const available_1088 = [];
								for (const name of $toIterator(this.currentModule.imported.keys())) {
									available_1088.push(name);
								};
								for (const name of $toIterator(this.currentModule.exported.keys())) {
									available_1088.push(name);
								};
								this.fail(('Cannot find type `' + (name_1073) + '`\n') + this.proposeSimilar(available_1088.filter((named_1089) => (DataHelper.isTitleCase(named_1089))), name_1073, 'types'), node_1071);
							}
						} break;
						
						default: 
						{
							if ((type_1083 == this.typeAny)) { return this.typeAny };
							this.fail(('Unsupported type `' + (name_1073) + '`'), node_1071);
						}
						};
					};
				}
			} break;
			
			case 2: {
				const name_1090 = temp_1072[1];
				const params_1091 = temp_1072[2];
				const path_1092 = temp_1072[3];
				{
					const nodeType_1093 = (() => {
						const result_1094 = this.findType(name_1090);
						if (result_1094 != null) { return result_1094 };
						return (() => {
							const result_1095 = this.currentModule.exported.get(name_1090);
							if (result_1095 != null) { return result_1095 };
							return this.currentModule.imported.get(name_1090);
						})();
					})();
					if ((this.types.get(nodeType_1093) == null)) {
						const temp_1096 = nodeType_1093;
						switch (temp_1096&&temp_1096[0]) {
						case 25: {
							{
								const mod_1097 = this.currentModule;
								this.registerClassType(nodeType_1093);
								this.currentModule = mod_1097;
							}
						} break;
						
						case 39: {
							this.registerEnumType(nodeType_1093)
						} break;
						};
					};
					const type_1098 = (() => {
						const result_1099 = this.findActualType(name_1090);
						if (result_1099 != null) { return result_1099 };
						return this.types.get(nodeType_1093);
					})();
					{
						const temp_1100 = type_1098;
						switch (temp_1100&&temp_1100[0]) {
						case 3: {
							const type_1101 = temp_1100[1];
							{
								if ((type_1101.genericParams.length == 0)) { this.fail(('The type `' + (type_1101.name) + '` requires zero generic parameters'), node_1071) };
								if ((type_1101.genericParams.length != params_1091.length)) { this.fail(('The type `' + (type_1101.name) + '` requires `<' + (type_1101.genericParams) + '>` generic parameters'), node_1071) };
								return type_1101.instantiateGeneric((() => {
									const result_1102 = [];
									const value_1103 = params_1091;
									for (const p of $toIterator(value_1103)) result_1102.push(this.toType(p, node_1071));
									return result_1102;
								})());
							}
						} break;
						
						case null: case undefined: {
							this.fail(('Cannot find type +`' + (name_1090) + '`'), node_1071)
						} break;
						
						default: 
						{
							if ((type_1098 == this.typeAny)) { return this.typeAny };
							this.fail(('Unsupported type `' + (name_1090) + '`'), node_1071);
						}
						};
					};
				}
			} break;
			
			case 0: {
				const t_1104 = temp_1072[1];
				return /*Nullable*/[2,this.toType(t_1104, node_1071)]
			} break;
			
			case 3: {
				const args_1105 = temp_1072[1];
				const ret = temp_1072[2];
				return /*Function*/[10,(() => {
					const result_1106 = [];
					const value_1107 = args_1105;
					for (const arg of $toIterator(value_1107)) result_1106.push(this.toType(arg, node_1071));
					return result_1106;
				})(),this.toType(ret, node_1071)]
			} break;
			
			case 5: {
				const names_1108 = temp_1072[1];
				const el_1109 = temp_1072[2];
				{
					const els_1110 = (() => {
						const result_1111 = [];
						const value_1112 = el_1109;
						for (const e of $toIterator(value_1112)) result_1111.push(this.toType(e, node_1071));
						return result_1111;
					})();
					return /*Struct*/[11,names_1108,els_1110];
				}
			} break;
			
			default: 
			this.fail('Unsupported node type ' + t_1070 + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_1071)
			};
		};
		mixVarTypes(t_1113, e_1114, node_1115) {
			if ((t_1113 != null) && (e_1114 != null)) { this.types.set(node_1115, this.unify(this.toType(t_1113, node_1115), this.types.get(e_1114), e_1114)) };
			if ((t_1113 == null) && (e_1114 != null)) { this.types.set(node_1115, this.types.get(e_1114)) };
			if ((t_1113 == null) && (e_1114 == null)) { this.types.set(node_1115, /*UnknownNullable*/[1,{value:null}]) };
			if ((t_1113 != null) && (e_1114 == null)) { this.types.set(node_1115, this.toType(t_1113, node_1115)) };
		};
		varTypes(vars_1116) {
			const varTypes = [];
			for (const v of $toIterator(vars_1116)) {
				const temp_1117 = v;
				switch (temp_1117&&temp_1117[0]) {
				case 24: {
					const t_1118 = temp_1117[2];
					{
						let step_1119 = 0;
						const t_1120 = t_1118;
						if (step_1119 == 0 && t_1120 != null) { step_1119 = 1 };
						if (step_1119 == 1) { varTypes.push(this.toType(t_1120, v)) } else {
							varTypes.push(/*Unknown*/[0,{value:null}]);
						};
					}
				} break;
				};
			};
			return varTypes;
		};
		booleanable(type_1121) { return (type_1121 == this.typeBool) || (type_1121 == this.typeAny) };
		fillFunction(node_1122, expr_1123, vars_1124, rettype_1125, arrow) {
			this.pushScope();
			const _insideFunction = this.insideFunction;
			const _functionAllowedToThrow = this.functionAllowedToThrow;
			const _functionThrows = this.functionThrows;
			const _functionReturnsAType = this.functionReturnsAType;
			const _functionActuallyReturns = this.functionActuallyReturns;
			const _insideTry = this.insideTry;
			{
				let i_1126 = 0;
				let it_1127 = 0;
				let at_1128 = vars_1124.length;
				while (it_1127 < at_1128) {
					i_1126 = it_1127;
					it_1127++;
					{
						const v = vars_1124[i_1126];
						{
							const temp_1129 = v;
							switch (temp_1129&&temp_1129[0]) {
							case 24: {
								const vname = temp_1129[1];
								const t_1130 = temp_1129[2];
								const e_1131 = temp_1129[3];
								const const_1132 = temp_1129[4];
								{
									if ((t_1130 != null) && (this.toType(t_1130, v) == this.typeVoid)) { this.fail('Argument cannot be of type `Void`', v) };
									if ((t_1130 != null)) { this.types.set(v, this.toType(t_1130, v)) };
									if ((e_1131 != null)) {
										this.fillExpression(e_1131);
										{
											let step_1133 = 0;
											const t_1134 = this.types.get(v);
											if (step_1133 == 0 && t_1134 != null) { step_1133 = 1 };
											if (step_1133 == 1) { this.unify(this.types.get(e_1131), t_1134, e_1131) };
										};
									};
									this.addScope(vname, v);
								}
							} break;
							};
						};
					};
				};
			};
			let ret_1135 = null;
			{
				let step_1136 = 0;
				const rt = rettype_1125;
				if (step_1136 == 0 && rt != null) { step_1136 = 1 };
				if (step_1136 == 1) { ret_1135 = this.toType(rt, node_1122) };
			};
			this.functionReturnsAType = ret_1135;
			this.functionActuallyReturns = false;
			const atts_1137 = this.project.mapDecorators.get(node_1122);
			{
				let step_1138 = 0;
				const noThrow = DataHelper.getDecorator(atts_1137, 'noThrow');
				if (step_1138 == 0 && noThrow != null) { step_1138 = 1 };
				if (step_1138 == 1) {
					if ((noThrow.values.length > 0)) { this.fail('Decorator `@noThrow` should have no parameters', node_1122) };
					this.functionAllowedToThrow = false;
				} else {
					this.functionAllowedToThrow = true;
				};
			};
			{
				let step_1139 = 0;
				const throws = DataHelper.getDecorator(atts_1137, 'throws');
				if (step_1139 == 0 && throws != null) { step_1139 = 1 };
				if (step_1139 == 1) {
					if ((this.functionAllowedToThrow == false)) { this.fail('Decorator `@noThrow` cannot be used with `@throws`', node_1122) };
					this.functionThrows = true;
				} else {
					this.functionThrows = false;
				};
			};
			this.insideFunction = true;
			this.insideTry = false;
			if ((arrow) && (expr_1123 != null)) { this.fillExpression(expr_1123) };
			if (((!arrow)) && (expr_1123 != null)) { this.fill(expr_1123) };
			this.popScope();
			ret_1135 = this.functionReturnsAType;
			if (arrow) { if ((arrow) && (ret_1135 == null) && (expr_1123 != null)) { ret_1135 = this.types.get(expr_1123) } else {
				this.unify(this.types.get(expr_1123), ret_1135, expr_1123);
			} } else {
				if ((ret_1135 == null)) { ret_1135 = this.typeVoid };
				if ((ret_1135 != this.typeVoid) && (expr_1123 != null) && (this.functionActuallyReturns == false)) { this.fail(('Function expects result of `' + (Type.stringify(ret_1135)) + '` but never does `return value`'), node_1122) };
			};
			this.insideFunction = _insideFunction;
			this.functionReturnsAType = _functionReturnsAType;
			this.functionActuallyReturns = _functionActuallyReturns;
			this.types.set(node_1122, /*Function*/[10,(() => {
				const result_1140 = [];
				const value_1141 = vars_1124;
				for (const v of $toIterator(value_1141)) result_1140.push(this.types.get(v));
				return result_1140;
			})(),ret_1135]);
		};
		fillModuleTypes(node_1142) {
			const temp_1143 = node_1142;
			switch (temp_1143&&temp_1143[0]) {
			case 25: {
				const t_1144 = temp_1143[1];
				const extend_1145 = temp_1143[2];
				const implement_1146 = temp_1143[3];
				const f_1147 = temp_1143[4];
				const external_1148 = temp_1143[5];
				{
					this.addScope(DataHelper.extractTypeName(t_1144), node_1142);
					const mod_1149 = this.currentModule;
					this.registerClassType(node_1142);
					this.currentModule = mod_1149;
				}
			} break;
			
			case 39: {
				const t_1150 = temp_1143[1];
				const f_1151 = temp_1143[2];
				const valuesType_1152 = temp_1143[3];
				{
					this.addScope(DataHelper.extractTypeName(t_1150), node_1142);
					const mod_1153 = this.currentModule;
					this.registerEnumType(node_1142);
					this.currentModule = mod_1153;
				}
			} break;
			
			case 9: {
				const alias = temp_1143[1];
				const value_1154 = temp_1143[2];
				{
					const type_1155 = new AliasType();
					this.types.set(node_1142, /*Alias*/[9,type_1155]);
					this.addScope(this.nameOfModuleItem(node_1142), node_1142);
				}
			} break;
			};
		};
		fill(node_1156) {
			const temp_1157 = node_1156;
			switch (temp_1157&&temp_1157[0]) {
			case 25: {
				this.fail('Defining classes within blocks not allowed', node_1156)
			} break;
			
			case 39: {
				this.fail('Defining enums within blocks not allowed', node_1156)
			} break;
			
			case 9: {
				const t_1158 = temp_1157[2];
				{
					this.fail('Defining alias within blocks not allowed', node_1156);
					const name_1159 = (() => {
						const temp_1160 = t_1158;
						switch (temp_1160&&temp_1160[0]) {
						case 1: {
							const name_1161 = temp_1160[1];
							return name_1161
						} break;
						
						case 2: {
							const name_1162 = temp_1160[1];
							return name_1162
						} break;
						
						case null: case undefined: {
							return (() => {
								this.fail('Type has no name: ' + NodeType.stringify(t_1158), node_1156);
								return '';
							})()
						} break;
						
						default: 
						return (() => {
							this.fail('Wrong alias format: ' + NodeType.stringify(t_1158), node_1156);
							return '';
						})()
						};
					})();
					const type_1163 = this.findActualType(name_1159);
					this.types.set(node_1156, /*Alias*/[9,type_1163]);
					this.addScope(this.nameOfModuleItem(node_1156), node_1156);
				}
			} break;
			
			case 12: {
				const el_1164 = temp_1157[1];
				{
					this.pushScope();
					for (const e of $toIterator(el_1164)) {
						{
							const temp_1165 = e;
							switch (temp_1165&&temp_1165[0]) {
							case 1: {
								const name_1166 = temp_1165[1];
								{
								}
							} break;
							};
						};
						this.fill(e);
					};
					this.popScope();
				}
			} break;
			
			case 24: {
				const name_1167 = temp_1157[1];
				const t_1168 = temp_1157[2];
				const e_1169 = temp_1157[3];
				const const_1170 = temp_1157[4];
				const external_1171 = temp_1157[5];
				{
					if ((e_1169 == null) && (const_1170) && ((!external_1171))) { this.fail(('Constant should have a value `let ' + (name_1167) + ' = value`'), node_1156) };
					if ((e_1169 != null) && (external_1171)) { this.fail(('External variable should not have a value `declare let ' + (name_1167) + '`'), node_1156) };
					if ((t_1168 == null) && (external_1171)) { this.fail(('External variable should have a type `declare let ' + (name_1167) + ': T`'), node_1156) };
					if (e_1169 != null) {
						this.pushScope();
						this.fillExpression(e_1169);
						this.popScope();
					};
					if (name_1167 == 'aazz') { console.log('before', t_1168 != null, e_1169 != null, node_1156 != null) };
					this.mixVarTypes(t_1168, e_1169, node_1156);
					if (name_1167 == 'aazz') { console.log('after') };
					this.addScope(name_1167, node_1156);
				}
			} break;
			
			case 10: {
				const a_1172 = temp_1157[1];
				const op_1173 = temp_1157[2];
				const b_1174 = temp_1157[3];
				{
					this.fillExpression(node_1156);
					let parent = this.parents.get(a_1172);
					if ((op_1173 == 91)) {
						const temp_1175 = parent;
						switch (temp_1175&&temp_1175[0]) {
						case null: case undefined: {
							{
							}
						} break;
						
						case 24: {
							const name_1176 = temp_1175[1];
							const const_1177 = temp_1175[4];
							{
								if (const_1177) { this.fail(('Cannot reassign a constant `let ' + (name_1176) + '`, redefine it as `var ' + (name_1176) + '` to allow reassignment\n') + this.positionOf(parent) + ('`let ' + (name_1176) + '` is defined here'), node_1156) };
								this.types.set(node_1156, this.unify(this.types.get(a_1172), this.types.get(b_1174), b_1174));
							}
						} break;
						
						case 1: {
							const name_1178 = temp_1175[1];
							this.fail(('Cannot reassign case parameter `' + (name_1178) + '`'), node_1156)
						} break;
						
						case 22: {
							const name_1179 = temp_1175[1];
							this.fail(('Cannot reassign a function `' + (name_1179) + '`'), node_1156)
						} break;
						
						case 25: {
							this.fail('Cannot reassign class', node_1156)
						} break;
						
						case 39: {
							this.fail('Cannot reassign enum', node_1156)
						} break;
						
						case 49: {
							const name_1180 = temp_1175[1];
							this.fail(('Cannot reassign iterator value `' + (name_1180) + '` of for loop\n') + this.positionOf(parent) + ('`for ' + (name_1180) + ' in ...` is defined here'), node_1156)
						} break;
						
						case 47: {
							{
							}
						} break;
						
						case 4: {
							this.fail('Cannot reassign `super`', node_1156)
						} break;
						
						default: 
						this.fail('`=` not implemented for: ' + parent, node_1156)
						};
					};
				}
			} break;
			
			case 18: {
				if (((!this.allowBreakAndContinue))) { this.fail('Cannot use `break` outside of loop', node_1156) }
			} break;
			
			case 49: {
				const name_1181 = temp_1157[1];
				const over = temp_1157[2];
				const by = temp_1157[3];
				const range = temp_1157[4];
				{
					this.pushScope();
					this.fillExpression(over);
					const overType = this.types.get(over);
					{
						const temp_1182 = overType;
						switch (temp_1182&&temp_1182[0]) {
						case 4: {
							const type_1183 = temp_1182[1];
							const generic = temp_1182[2];
							if ((generic != null) && (generic.length == 1)) { this.types.set(node_1156, generic[0]) } else if (overType == this.typeInt) { this.types.set(node_1156, this.typeInt) } else if (((overType == this.typeUInt32) || (overType == this.typeUInt64))) { this.types.set(node_1156, overType) } else {
								this.fail('Type of iterable is neither Int nor Array, but ' + Type.stringify(overType), over);
							}
						} break;
						
						case 2: {
							this.fail('Type of iterable should not be nullable', over)
						} break;
						
						case 1: {
							this.fail('Type of iterable should not be nullable', over)
						} break;
						
						case null: case undefined: {
							{
							}
						} break;
						
						default: 
						this.fail('Type of iterable is neiter Int nor Array', over)
						};
					};
					{
						let step_1184 = 0;
						const range_1185 = range;
						if (step_1184 == 0 && range_1185 != null) { step_1184 = 1 };
						if (step_1184 == 1) {
							this.fillExpression(range_1185);
							if ((this.types.get(range_1185) != this.typeInt)) { this.fail('Range end must be of Int type', range_1185) };
							if ((overType != this.typeInt)) { this.fail('Range start must be of Int type', over) };
							this.types.set(node_1156, this.typeInt);
						};
					};
					this.addScope(name_1181, node_1156);
					const _allowBreakAndContinue = this.allowBreakAndContinue;
					this.allowBreakAndContinue = true;
					{
						const temp_1186 = by;
						switch (temp_1186&&temp_1186[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						this.fail('Loop body must be a `{` block `}`', by)
						};
					};
					this.fill(by);
					this.allowBreakAndContinue = _allowBreakAndContinue;
					this.popScope();
				}
			} break;
			
			case 22: {
				const name_1187 = temp_1157[1];
				const expr_1188 = temp_1157[2];
				const vars_1189 = temp_1157[3];
				const rettype_1190 = temp_1157[4];
				const external_1191 = temp_1157[5];
				{
					if (((!external_1191)) && (expr_1188 == null)) { this.fail(('Non-external function `' + (name_1187) + '` should have a body'), node_1156) };
					if ((external_1191) && (rettype_1190 == null)) { this.fail(('External function `' + (name_1187) + '` should have a returning type'), node_1156) };
					this.addScope(name_1187, node_1156);
					this.fillFunction(node_1156, expr_1188, vars_1189, rettype_1190);
					if (false) {
						const _insideFunction_1192 = this.insideFunction;
						this.insideFunction = true;
						this.pushScope();
						if ((expr_1188 != null)) { this.fill(expr_1188) };
						this.popScope();
						this.insideFunction = _insideFunction_1192;
					};
				}
			} break;
			
			case 14: {
				const econd = temp_1157[1];
				const eif = temp_1157[2];
				const eelse = temp_1157[3];
				{
					let depth = 0;
					for (const e of $toIterator(econd)) {
						const temp_1193 = e;
						switch (temp_1193&&temp_1193[0]) {
						case 24: {
							const name_1194 = temp_1193[1];
							const t_1195 = temp_1193[2];
							const expr_1196 = temp_1193[3];
							const const_1197 = temp_1193[4];
							{
								if (((!const_1197))) { this.fail('Only if-let bindings supported, not if-var', node_1156) };
								if ((t_1195 != null)) { this.fail('Do not specify a type `: T` in if-let bindings', node_1156) };
								if ((expr_1196 == null)) { this.fail(('if-let binding should have a value `' + (name_1194) + ' = value'), node_1156) };
								depth++;
								this.pushScope();
								this.pushScope();
								this.fillExpression(expr_1196);
								this.popScope();
								{
									const temp_1198 = (this.types.get(expr_1196));
									switch (temp_1198&&temp_1198[0]) {
									case 2: {
										const t_1199 = temp_1198[1];
										this.types.set(e, t_1199)
									} break;
									
									case 1: {
										const handle_1200 = temp_1198[1];
										{
											let step_1201 = 0;
											const t_1202 = handle_1200.value;
											if (step_1201 == 0 && t_1202 != null) { step_1201 = 1 };
											if (step_1201 == 1) { this.types.set(e, t_1202) } else {
												this.fail('if-let cannot bind not fully known nullable type', node_1156);
											};
										}
									} break;
									
									default: 
									this.types.set(e, this.types.get(expr_1196))
									};
								};
								this.addScope(name_1194, e);
							}
						} break;
						
						default: 
						{
							this.fillExpression(e);
							const type_1203 = this.types.get(e);
							if ((type_1203 != this.typeBool) && (type_1203 != this.typeAny) && (type_1203 != null)) { this.fail('`if (value)` expects `value` only of type `Bool`, but got `' + Type.stringify(this.types.get(e)) + '`', e) };
						}
						};
					};
					this.fill(eif);
					while (depth > 0) {
						depth--;
						this.popScope();
					};
					if (eelse != null) { this.fill(eelse) };
				}
			} break;
			
			case 34: {
				const exprs = temp_1157[1];
				const conds = temp_1157[2];
				const guards = temp_1157[3];
				const cases = temp_1157[4];
				this.fillSwitch(node_1156, false)
			} break;
			
			case 27: {
				const e_1204 = temp_1157[1];
				const t_1205 = temp_1157[2];
				const v_1206 = temp_1157[3];
				const ca = temp_1157[4];
				{
					const _insideTry_1207 = this.insideTry;
					this.insideTry = true;
					{
						const temp_1208 = e_1204;
						switch (temp_1208&&temp_1208[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						this.fail('Try body must be a `{ block }`', e_1204)
						};
					};
					this.fill(e_1204);
					this.insideTry = _insideTry_1207;
					{
						let i_1209 = 0;
						let it_1210 = 0;
						let at_1211 = ca.length;
						while (it_1210 < at_1211) {
							i_1209 = it_1210;
							it_1210++;
							{
								const type_1212 = this.toType(t_1205[i_1209], ca[i_1209]);
								{
									const temp_1213 = type_1212;
									switch (temp_1213&&temp_1213[0]) {
									case 11: {
										this.fail('Catch type must be a specific class, not `{}`', ca[i_1209])
									} break;
									
									case 10: {
										this.fail('Catch type must be a specific class, not function', ca[i_1209])
									} break;
									};
								};
								this.types.set(t_1205[i_1209], type_1212);
								this.pushScope();
								this.scopes[this.scopes.length - 1].set(DataHelper.varName(v_1206[i_1209]), v_1206[i_1209]);
								{
									const temp_1214 = ca[i_1209];
									switch (temp_1214&&temp_1214[0]) {
									case 12: {
										{
										}
									} break;
									
									default: 
									this.fail('Catch body must be a `{ block }`', ca[i_1209])
									};
								};
								this.fill(ca[i_1209]);
								this.popScope();
							};
						};
					};
				}
			} break;
			
			case 21: {
				const econd_1215 = temp_1157[1];
				const e_1216 = temp_1157[2];
				const pre = temp_1157[3];
				{
					if ((pre == true)) { this.fillExpression(econd_1215) };
					const _allowBreakAndContinue_1217 = this.allowBreakAndContinue;
					this.allowBreakAndContinue = true;
					{
						const temp_1218 = e_1216;
						switch (temp_1218&&temp_1218[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						this.fail('`while` statements must be wrapped with a `{` block `}`', e_1216)
						};
					};
					this.fill(e_1216);
					this.allowBreakAndContinue = _allowBreakAndContinue_1217;
					if ((pre == false)) { this.fillExpression(econd_1215) };
					this.types.set(node_1156, this.typeVoid);
				}
			} break;
			
			case 19: {
				{
					this.types.set(node_1156, this.typeVoid);
					if (((!this.allowBreakAndContinue))) { this.fail('Cannot use `continue` outside of loop', node_1156) };
				}
			} break;
			
			default: 
			this.fillExpression(node_1156)
			};
		};
		fillExpression(node_1219) {
			const temp_1220 = node_1219;
			switch (temp_1220&&temp_1220[0]) {
			case 1: {
				const name_1221 = temp_1220[1];
				{
					let subj_1222 = null;
					{
						let i_1223 = 0;
						let it_1224 = 0;
						let at_1225 = this.scopes.length;
						while (it_1224 < at_1225) {
							i_1223 = it_1224;
							it_1224++;
							{
								subj_1222 = this.scopes[this.scopes.length - i_1223 - 1].get(name_1221);
								if ((subj_1222 != null)) { break };
							};
						};
					};
					if (subj_1222 == null) { subj_1222 = this.findInNamespaceRoots(name_1221) };
					if ((subj_1222 == null) && (name_1221 == 'const')) { this.fail('No variable named `const` found. Are you trying to use `const` as a keyword? Use `let varname` syntax instead.', node_1219) };
					if (subj_1222 == null) { this.fail(('Cannot find variable with name `' + (name_1221) + '`'), node_1219) };
					if ((this.parents.get(node_1219) != null) && (this.parents.get(node_1219) != subj_1222)) { this.fail(('Parent overwitten from ' + (this.parents.get(node_1219)) + ' to ' + (subj_1222) + ' for node ' + (node_1219) + '') + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_1219) };
					this.parents.set(node_1219, subj_1222);
					{
						let step_1226 = 0;
						const type_1227 = this.types.get(subj_1222);
						if (step_1226 == 0 && type_1227 != null) { step_1226 = 1 };
						if (step_1226 == 1) { this.types.set(node_1219, type_1227) };
					};
				}
			} break;
			
			case 23: {
				const expr_1228 = temp_1220[1];
				const vars_1229 = temp_1220[2];
				const rettype_1230 = temp_1220[3];
				{
					this.fillFunction(node_1219, expr_1228, vars_1229, rettype_1230, true);
					if (false) {
						this.pushScope();
						const _insideFunction_1231 = this.insideFunction;
						this.insideFunction = true;
						this.fillExpression(expr_1228);
						this.popScope();
						this.insideFunction = _insideFunction_1231;
					};
				}
			} break;
			
			case 22: {
				const name_1232 = temp_1220[1];
				const expr_1233 = temp_1220[2];
				const vars_1234 = temp_1220[3];
				const rettype_1235 = temp_1220[4];
				const external_1236 = temp_1220[5];
				{
					if (external_1236) { this.fail(('External function `declare fun ' + (name_1232) + '` cannot be taken as a value'), node_1219) };
					this.fillFunction(node_1219, expr_1233, vars_1234, rettype_1235);
					if (false) {
						this.pushScope();
						this.addScope(name_1232, node_1219);
						const _insideFunction_1237 = this.insideFunction;
						this.insideFunction = true;
						if ((expr_1233 != null)) { this.fill(expr_1233) };
						this.popScope();
						this.insideFunction = _insideFunction_1237;
					};
				}
			} break;
			
			case 31: {
				const el_1238 = temp_1220[1];
				{
					const temp_1239 = el_1238[0];
					switch (temp_1239&&temp_1239[0]) {
					case 49: {
						const name_1240 = temp_1239[1];
						const over_1241 = temp_1239[2];
						const by_1242 = temp_1239[3];
						const range_1243 = temp_1239[4];
						{
							if ((el_1238.length > 1)) { this.fail('Cannot use loop `for` within array of more than one element `[for, ...]`', el_1238[1]) };
							if ((range_1243 != null)) { this.fail('Ranges `...range` are not supported here yet', range_1243) };
							this.pushScope();
							this.fillExpression(over_1241);
							const overType_1244 = this.types.get(over_1241);
							{
								const temp_1245 = overType_1244;
								switch (temp_1245&&temp_1245[0]) {
								case 4: {
									const type_1246 = temp_1245[1];
									const generic_1247 = temp_1245[2];
									if ((generic_1247 != null) && (generic_1247.length == 1)) { this.types.set(el_1238[0], generic_1247[0]) } else if (overType_1244 == this.typeInt) { this.types.set(el_1238[0], this.typeInt) } else if (((overType_1244 == this.typeUInt32) || (overType_1244 == this.typeUInt64))) { this.types.set(el_1238[0], overType_1244) } else {
										this.fail('Type of iterable is neither Int nor Array, but ' + Type.stringify(overType_1244), over_1241);
									}
								} break;
								
								case 2: {
									this.fail('Type of iterable should not be nullable', over_1241)
								} break;
								
								case 1: {
									this.fail('Type of iterable should not be nullable', over_1241)
								} break;
								
								case null: case undefined: {
									{
									}
								} break;
								
								default: 
								this.fail('Type of iterable is neiter Int nor Array', over_1241)
								};
							};
							this.addScope(name_1240, el_1238[0]);
							const _allowBreakAndContinue_1248 = this.allowBreakAndContinue;
							this.allowBreakAndContinue = false;
							this.fillExpression(by_1242);
							this.allowBreakAndContinue = _allowBreakAndContinue_1248;
							this.popScope();
							this.types.set(node_1219, this.typeArray.instantiateGeneric([this.types.get(by_1242)]));
						}
					} break;
					
					default: 
					{
						for (const e of $toIterator(el_1238)) {
							this.fillExpression(e);
						};
						this.types.set(node_1219, this.typeArray.instantiateGeneric([((el_1238.length > 0))? (this.types.get(el_1238[0])) : /*Unknown*/[0,{value:null}]]));
					}
					};
				}
			} break;
			
			case 32: {
				const keys = temp_1220[1];
				const values = temp_1220[2];
				{
					if ((keys.length == 0)) {
						this.types.set(node_1219, this.typeMap.instantiateGeneric([/*Unknown*/[0,{value:null}], /*Unknown*/[0,{value:null}]]));
						return;
					};
					{
						let i_1249 = 0;
						let it_1250 = 0;
						let at_1251 = keys.length;
						while (it_1250 < at_1251) {
							i_1249 = it_1250;
							it_1250++;
							{
								this.fillExpression(keys[i_1249]);
								this.fillExpression(values[i_1249]);
							};
						};
					};
					this.types.set(node_1219, this.typeMap.instantiateGeneric([this.types.get(keys[0]), this.types.get(values[0])]));
				}
			} break;
			
			case 44: {
				const e_1252 = temp_1220[1];
				const kind = temp_1220[2];
				const t_1253 = temp_1220[3];
				{
					const type_1254 = this.toType(t_1253, node_1219);
					if ((type_1254 == this.typeVoid)) { this.fail('Conversion `as Void` makes no sense', e_1252) };
					this.fillExpression(e_1252);
					if ((this.types.get(e_1252) == this.typeVoid)) { this.fail(('Conversion of `value as ' + (Type.stringify(t_1253)) + '` where `value` is of type `Void` makes no sense'), e_1252) };
					this.types.set(t_1253, type_1254);
					this.types.set(node_1219, type_1254);
				}
			} break;
			
			case 43: {
				const e_1255 = temp_1220[1];
				const t_1256 = temp_1220[2];
				{
					const type_1257 = this.toType(t_1256, node_1219);
					if ((type_1257 == this.typeAny)) { this.fail('Comparing `is Any` makes no sense, always true', e_1255) };
					if ((type_1257 == this.typeVoid)) { this.fail('Comparing `is Void` makes no sense', e_1255) };
					this.fillExpression(e_1255);
					this.types.set(t_1256, type_1257);
					this.types.set(node_1219, this.typeBool);
				}
			} break;
			
			case 12: {
				const el_1258 = temp_1220[1];
				if ((el_1258.length == 0)) { this.types.set(node_1219, /*Struct*/[11,[],[]]) } else {
					this.pushScope();
					{
						let i_1259 = 0;
						let it_1260 = 0;
						let at_1261 = el_1258.length;
						while (it_1260 < at_1261) {
							i_1259 = it_1260;
							it_1260++;
							{
								if ((i_1259 < el_1258.length - 1)) { this.fill(el_1258[i_1259]) };
							};
						};
					};
					const latest = el_1258[el_1258.length - 1];
					this.fillExpression(latest);
					this.types.set(node_1219, this.types.get(latest));
					this.popScope();
				}
			} break;
			
			case 28: {
				const e_1262 = temp_1220[1];
				const n = temp_1220[2];
				{
					{
						const temp_1263 = e_1262;
						switch (temp_1263&&temp_1263[0]) {
						case 4: {
							if (((!this.allowSuper))) { this.fail('Cannot access `super` here', node_1219) }
						} break;
						
						default: 
						this.fillExpression(e_1262)
						};
					};
					{
						let step_1264 = 0;
						const etype = (this.types.get(e_1262));
						if (step_1264 == 0 && etype != null) { step_1264 = 1 };
						if (step_1264 == 1) {
							const temp_1265 = etype;
							switch (temp_1265&&temp_1265[0]) {
							case 4: {
								const type_1266 = temp_1265[1];
								{
									type_1266.useless = false;
									if ((etype == this.typeAny)) {
										this.types.set(node_1219, this.typeAny);
										return;
									};
									const index_1267 = type_1266.fieldNames.indexOf(n);
									const named_1268 = this.nameOfModuleItem(type_1266.parent);
									if ((index_1267 < 0)) { this.fail(('Class `' + (named_1268) + '` has no field `.' + (n) + '`\n') + this.positionOf(type_1266.parent) + ('`' + (named_1268) + '` is defined here\n') + this.proposeSimilar(type_1266.fieldNames, n, 'fields'), (() => {
										const result_1269 = e_1262;
										if (result_1269 != null) { return result_1269 };
										return node_1219;
									})()) };
									if ((type_1266.fieldStatic[index_1267] == true)) { this.fail(('Class `' + (named_1268) + '` field `.' + (n) + '` is static'), node_1219) };
									{
										const temp_1270 = type_1266.parent;
										switch (temp_1270&&temp_1270[0]) {
										case 25: {
											const t_1271 = temp_1270[1];
											const extend_1272 = temp_1270[2];
											const implement_1273 = temp_1270[3];
											const fields = temp_1270[4];
											const external_1274 = temp_1270[5];
											{
												const mod_1275 = this.currentModule;
												this.registerClassType(type_1266.parent);
												this.currentModule = mod_1275;
												for (const field of $toIterator(fields)) {
													if ((DataHelper.nameOf(field) == n)) {
														this.types.set(node_1219, this.types.get(field));
														this.parents.set(node_1219, field);
														if ((this.types.get(field) == null)) {
															console.log(this.positionOf(node_1219) + ('Note: field fieldInitialized[' + (n) + '] ='), type_1266.fieldInitialized[type_1266.fieldNames.indexOf(n)]);
															this.fail('Type for this field is null: ' + n, field);
														};
													};
												};
											}
										} break;
										
										default: 
										this.fail('type.parent not a class, internal error', type_1266.parent)
										};
									};
								}
							} break;
							
							case 3: {
								const type_1276 = temp_1265[1];
								{
									type_1276.useless = false;
									const index_1277 = type_1276.fieldNames.indexOf(n);
									if ((index_1277 < 0)) { this.fail(('Class `' + (this.nameOfModuleItem(type_1276.parent)) + '` has no static field `.' + (n) + '`\nAvailable fields are: ') + type_1276.fieldNames.join(', '), node_1219) };
									if ((type_1276.fieldStatic[index_1277] != true)) { this.fail(('Class `' + (this.nameOfModuleItem(type_1276.parent)) + '` field `.' + (n) + '` is not static'), node_1219) };
									{
										const temp_1278 = type_1276.parent;
										switch (temp_1278&&temp_1278[0]) {
										case 25: {
											const t_1279 = temp_1278[1];
											const extend_1280 = temp_1278[2];
											const implement_1281 = temp_1278[3];
											const fields_1282 = temp_1278[4];
											const external_1283 = temp_1278[5];
											for (const field of $toIterator(fields_1282)) {
												if ((DataHelper.nameOf(field) == n)) {
													this.types.set(node_1219, this.types.get(field));
													this.parents.set(node_1219, field);
												};
											}
										} break;
										
										default: 
										this.fail('type.parent not a class, internal error', type_1276.parent)
										};
									};
								}
							} break;
							
							case 6: {
								const type_1284 = temp_1265[1];
								{
									const index_1285 = type_1284.fieldNames.indexOf(n);
									if ((index_1285 < 0)) { this.fail(('Enum `' + (type_1284.name) + '` has no field `.' + (n) + '`'), node_1219) };
									if ((type_1284.fieldStatic[index_1285] != true)) { this.fail(('Enum field `.' + (n) + '` is not static'), node_1219) };
									{
										const temp_1286 = type_1284.parent;
										switch (temp_1286&&temp_1286[0]) {
										case 39: {
											const t_1287 = temp_1286[1];
											const fields_1288 = temp_1286[2];
											const valuesType_1289 = temp_1286[3];
											for (const field of $toIterator(fields_1288)) {
												const temp_1290 = field;
												switch (temp_1290&&temp_1290[0]) {
												case 13: {
													{
													}
												} break;
												
												case 51: {
													{
													}
												} break;
												
												case 10: {
													{
													}
												} break;
												
												default: 
												if ((DataHelper.nameOf(field) == n)) {
													this.types.set(node_1219, this.types.get(field));
													this.parents.set(node_1219, field);
												}
												};
											}
										} break;
										
										default: 
										this.fail('type.parent not an enum, internal error', type_1284.parent)
										};
									};
								}
							} break;
							
							case 11: {
								const names_1291 = temp_1265[1];
								const els_1292 = temp_1265[2];
								{
									const index_1293 = names_1291.indexOf(n);
									if ((index_1293 < 0)) {
										let object = '';
										{
											const temp_1294 = e_1262;
											switch (temp_1294&&temp_1294[0]) {
											case 1: {
												const name_1295 = temp_1294[1];
												object = (' `' + (name_1295) + '`')
											} break;
											
											default: 
											{
											}
											};
										};
										if ((names_1291.length == 0)) { this.fail(('Object' + (object) + ' is empty `{}` and has no fields. Create object with all fields defined upfront, like this: `obj = { ' + (n) + ': value }`'), node_1219) };
										if ((names_1291.length != 0)) { this.fail(('Object' + (object) + ' has no field `.' + (n) + '`\nAvailable fields are: ') + names_1291.join(', '), node_1219) };
									};
									this.types.set(node_1219, els_1292[index_1293]);
								}
							} break;
							
							case 1: {
								const handle_1296 = temp_1265[1];
								{
									this.failNonFatal(('Cannot access `.' + (n) + '` of nullable type `' + (Type.stringify(etype)) + '`, try to unwrap it with `if let`'), node_1219);
									this.types.set(node_1219, this.typeAny);
								}
							} break;
							
							case 2: {
								const type_1297 = temp_1265[1];
								{
									this.failNonFatal(('Cannot access `.' + (n) + '` of nullable type `' + (Type.stringify(etype)) + '`, try to unwrap it with `if let`'), node_1219);
									this.types.set(node_1219, this.typeAny);
								}
							} break;
							
							case 0: {
								const handle_1298 = temp_1265[1];
								{
									let step_1299 = 0;
									const type_1300 = handle_1298.value;
									if (step_1299 == 0 && type_1300 != null) { step_1299 = 1 };
									if (step_1299 == 1) {} else {
										this.failNonFatal(('Cannot access `.' + (n) + '` due to type of value being unknown, try to specify a proper type (set full type `[T]` if this value coming from array)'), node_1219);
										this.types.set(node_1219, this.typeAny);
									};
								}
							} break;
							
							case null: case undefined: {
								this.fail(('Cannot access `.' + (n) + '` due to type being `null`, seems to be internal compiler error'), node_1219)
							} break;
							
							default: 
							this.fail(('Cannot access `.' + (n) + '` due to type being unhandled `' + (Type.stringify(etype)) + '`, seems to be internal compiler error'), node_1219)
							};
						} else {
							this.types.set(node_1219, this.typeAny);
						};
					};
				}
			} break;
			
			case 29: {
				const e_1301 = temp_1220[1];
				const n_1302 = temp_1220[2];
				{
					{
						const temp_1303 = e_1301;
						switch (temp_1303&&temp_1303[0]) {
						case 4: {
							this.fail('Cannot access `super` here', node_1219)
						} break;
						};
					};
					this.fillExpression(e_1301);
					{
						const temp_1304 = (this.types.get(e_1301));
						switch (temp_1304&&temp_1304[0]) {
						case 3: {
							const type_1305 = temp_1304[1];
							{
								const index_1306 = type_1305.fieldNames.indexOf(n_1302);
								if ((index_1306 < 0)) { this.fail(('Class has no field `.' + (n_1302) + '`'), node_1219) };
								if ((type_1305.fieldStatic[index_1306] != true)) { this.fail(('Class field `.' + (n_1302) + '` is not static'), node_1219) };
							}
						} break;
						
						case 6: {
							const type_1307 = temp_1304[1];
							{
								const index_1308 = type_1307.fieldNames.indexOf(n_1302);
								if ((index_1308 < 0)) { this.fail(('Enum has no value constructor `.' + (n_1302) + '`\n') + this.proposeSimilar(type_1307.fieldNames.filter((element, index_1309) => (type_1307.fieldEnumConstructor[index_1309])), n_1302, 'constructors'), node_1219) };
								if ((type_1307.fieldEnumConstructor[index_1308] != true)) { this.fail(('Enum field `.' + (n_1302) + '` is not a value constructor'), node_1219) };
								{
									let step_1310 = 0;
									const fieldType = type_1307.fieldType[index_1308];
									if (step_1310 == 0 && fieldType != null) { step_1310 = 1 };
									if (step_1310 == 1) { this.types.set(node_1219, fieldType) } else {
										this.fail(('Enum field type is null for `' + (Node.stringify(node_1219)) + '`'), node_1219);
									};
								};
							}
						} break;
						
						case null: case undefined: {
							this.fail(('Doing .Upper `' + (Node.stringify(node_1219)) + '` over `' + (Node.stringify(e_1301)) + '` (' + (e_1301) + ') of type null'), node_1219)
						} break;
						
						default: 
						{
						}
						};
					};
				}
			} break;
			
			case 51: {
				const t_1311 = temp_1220[1];
				{
					const temp_1312 = t_1311;
					switch (temp_1312&&temp_1312[0]) {
					case 1: {
						const name_1313 = temp_1312[1];
						{
							const subj_1314 = this.find(name_1313);
							if ((subj_1314 == null)) { this.fail(('Cannot find type with name `' + (name_1313) + '`'), node_1219) };
							if ((this.parents.get(node_1219) != null) && (this.parents.get(node_1219) != subj_1314)) { this.fail(('Parent overwitten from ' + (this.parents.get(node_1219)) + ' to ' + (subj_1314) + ' for node ' + (node_1219) + '') + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_1219) };
							this.parents.set(node_1219, subj_1314);
							{
								let step_1315 = 0;
								const type_1316 = this.types.get(subj_1314);
								if (step_1315 == 0 && type_1316 != null) { step_1315 = 1 };
								if (step_1315 == 1) { this.types.set(node_1219, type_1316) } else {
									{
										const temp_1317 = subj_1314;
										switch (temp_1317&&temp_1317[0]) {
										case 25: {
											{
												const mod_1318 = this.currentModule;
												this.registerClassType(subj_1314);
												this.currentModule = mod_1318;
											}
										} break;
										
										case 39: {
											this.registerEnumType(subj_1314)
										} break;
										};
									};
									{
										let step_1319 = 0;
										const type_1320 = this.types.get(subj_1314);
										if (step_1319 == 0 && type_1320 != null) { step_1319 = 1 };
										if (step_1319 == 1) { this.types.set(node_1219, type_1320) } else {
											console.log(this.positionOf(subj_1314) + ('' + (name_1313) + ' is here'));
											this.fail(('Cannot find type for `' + (name_1313) + '` even after late build') + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_1219);
										};
									};
								};
							};
						}
					} break;
					
					case 2: {
						const name_1321 = temp_1312[1];
						this.fail(('Cannot use generic type `' + (name_1321) + '` as a value'), node_1219)
					} break;
					
					default: 
					this.fail('Cannot use this type as a value', node_1219)
					};
				}
			} break;
			
			case 30: {
				const path_1322 = temp_1220[1];
				const t_1323 = temp_1220[2];
				const el_1324 = temp_1220[3];
				const names_1325 = temp_1220[4];
				const values_1326 = temp_1220[5];
				{
					const type_1327 = this.toType(t_1323, node_1219);
					const subj_1328 = this.find(DataHelper.extractTypeName(t_1323));
					this.parents.set(node_1219, subj_1328);
					for (const e of $toIterator(el_1324)) {
						this.fillExpression(e);
					};
					{
						const temp_1329 = type_1327;
						switch (temp_1329&&temp_1329[0]) {
						case 4: {
							const type_1330 = temp_1329[1];
							{
								if ((type_1330.constructor == (-1))) { this.fail('Cannot construct class without `new () {}` constructor', node_1219) };
								type_1330.useless = false;
							}
						} break;
						
						default: 
						this.fail('Constructor `new` may instantiate only classes', node_1219)
						};
					};
					this.types.set(node_1219, type_1327);
				}
			} break;
			
			case 38: {
				const names_1331 = temp_1220[1];
				const el_1332 = temp_1220[2];
				{
					{
						let name_1333 = 0;
						let it_1334 = 0;
						let at_1335 = names_1331.length;
						while (it_1334 < at_1335) {
							name_1333 = it_1334;
							it_1334++;
							{
								if ((names_1331.indexOf(names_1331[name_1333]) != name_1333)) { this.fail(('Field `' + (names_1331[name_1333]) + '` already exists'), node_1219) };
							};
						};
					};
					for (const e of $toIterator(el_1332)) {
						this.fillExpression(e);
					};
					const els_1336 = (() => {
						const result_1337 = [];
						const value_1338 = el_1332;
						for (const e of $toIterator(value_1338)) result_1337.push(this.types.get(e));
						return result_1337;
					})();
					this.types.set(node_1219, /*Struct*/[11,names_1331,els_1336]);
				}
			} break;
			
			case 27: {
				const e_1339 = temp_1220[1];
				const t_1340 = temp_1220[2];
				const v_1341 = temp_1220[3];
				const ca_1342 = temp_1220[4];
				{
					const _insideTry_1343 = this.insideTry;
					this.insideTry = true;
					this.fillExpression(e_1339);
					this.insideTry = _insideTry_1343;
					{
						let i_1344 = 0;
						let it_1345 = 0;
						let at_1346 = ca_1342.length;
						while (it_1345 < at_1346) {
							i_1344 = it_1345;
							it_1345++;
							{
								this.pushScope();
								this.scopes[this.scopes.length - 1].set(DataHelper.varName(v_1341[i_1344]), v_1341[i_1344]);
								this.fill(ca_1342[i_1344]);
								this.popScope();
							};
						};
					};
					this.types.set(node_1219, this.types.get(e_1339));
				}
			} break;
			
			case 14: {
				const econd_1347 = temp_1220[1];
				const eif_1348 = temp_1220[2];
				const eelse_1349 = temp_1220[3];
				const ternary = temp_1220[4];
				{
					if ((econd_1347.length > 1)) { this.fail('More than one condition is not yet supported', econd_1347[1]) };
					{
						const temp_1350 = econd_1347[0];
						switch (temp_1350&&temp_1350[0]) {
						case 24: {
							this.fail('Variable bindings in ternary conditions are not yet supported', econd_1347[0])
						} break;
						};
					};
					if (eelse_1349 == null) { this.fail('Expression `if` should have an `else` clause', eif_1348) };
					this.fillExpression(econd_1347[0]);
					if (ternary == false) {
						{
							const temp_1351 = eif_1348;
							switch (temp_1351&&temp_1351[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							this.fail('Ternary `if` should have a `{ block }` as a body', eif_1348)
							};
						};
						{
							const temp_1352 = eelse_1349;
							switch (temp_1352&&temp_1352[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							this.fail('Ternary `else` should have a `{ block }` as a body', eelse_1349)
							};
						};
					};
					this.fillExpression(eif_1348);
					this.fillExpression(eelse_1349);
					this.types.set(node_1219, this.unify(this.types.get(eif_1348), this.types.get(eelse_1349), eelse_1349));
				}
			} break;
			
			case 8: {
				this.types.set(node_1219, /*UnknownNullable*/[1,{value:null}])
			} break;
			
			case 0: {
				this.types.set(node_1219, this.typeString)
			} break;
			
			case 2: {
				this.types.set(node_1219, this.typeBool)
			} break;
			
			case 5: {
				this.types.set(node_1219, this.typeInt)
			} break;
			
			case 6: {
				const meta = temp_1220[2];
				{
					const temp_1353 = meta;
					switch (temp_1353) {
					case 1: {
						this.types.set(node_1219, this.typeBigInt)
					} break;
					
					case 2: {
						this.types.set(node_1219, this.typeInt32)
					} break;
					
					case 3: {
						this.types.set(node_1219, this.typeInt64)
					} break;
					
					case 4: {
						this.types.set(node_1219, this.typeInt16)
					} break;
					
					case 5: {
						this.types.set(node_1219, this.typeInt8)
					} break;
					
					case 6: {
						this.types.set(node_1219, this.typeUInt32)
					} break;
					
					case 7: {
						this.types.set(node_1219, this.typeUInt64)
					} break;
					
					case 8: {
						this.types.set(node_1219, this.typeUInt16)
					} break;
					
					case 9: {
						this.types.set(node_1219, this.typeUInt8)
					} break;
					
					case 10: {
						this.types.set(node_1219, this.typeFloat32)
					} break;
					
					default: 
					this.fail('Unhandled meta type of number', node_1219)
					};
				}
			} break;
			
			case 7: {
				this.types.set(node_1219, this.typeFloat)
			} break;
			
			case 15: {
				const e_1354 = temp_1220[1];
				{
					this.fillExpression(e_1354);
					this.types.set(node_1219, this.types.get(e_1354));
				}
			} break;
			
			case 50: {
				const a_1355 = temp_1220[1];
				const b_1356 = temp_1220[2];
				{
					this.fillExpression(a_1355);
					this.fillExpression(b_1356);
					this.unify(this.types.get(a_1355), this.types.get(b_1356), b_1356);
					this.types.set(node_1219, this.types.get(b_1356));
				}
			} break;
			
			case 13: {
				const e_1357 = temp_1220[1];
				const el_1358 = temp_1220[2];
				const elNames = temp_1220[3];
				{
					{
						const temp_1359 = e_1357;
						switch (temp_1359&&temp_1359[0]) {
						case 4: {
							if (((!this.allowSuper))) { this.fail('Cannot access `super` here', node_1219) }
						} break;
						
						default: 
						this.fillExpression(e_1357)
						};
					};
					for (const e of $toIterator(el_1358)) {
						this.fillExpression(e);
					};
					{
						const temp_1360 = (this.types.get(e_1357));
						switch (temp_1360&&temp_1360[0]) {
						case 10: {
							const args_1361 = temp_1360[1];
							const returns = temp_1360[2];
							{
								{
									let i_1362 = 0;
									let it_1363 = 0;
									let at_1364 = el_1358.length;
									while (it_1363 < at_1364) {
										i_1362 = it_1363;
										it_1363++;
										{
											let step_1365 = 0;
											const arg = args_1361[i_1362];
											if (step_1365 == 0 && arg != null) { step_1365 = 1 };
											if (step_1365 == 1) { this.unify(arg, this.types.get(el_1358[i_1362]), el_1358[i_1362]) };
										};
									};
								};
								this.types.set(node_1219, returns);
							}
						} break;
						
						case 8: {
							const type_1366 = temp_1360[1];
							const tag = temp_1360[2];
							{
								const name_1367 = type_1366.fieldNames[tag];
								if ((el_1358.length < type_1366.tagBindVars[tag].length)) { this.fail(('Not enough enum parameters, required `' + (name_1367) + '` parameters are: ') + type_1366.tagBindVarsNames[tag].join(', '), node_1219) };
								if ((el_1358.length > type_1366.tagBindVars[tag].length)) { this.fail(('Too many enum parameters, required `' + (name_1367) + '` parameters are: ') + type_1366.tagBindVarsNames[tag].join(', '), node_1219) };
								if ((el_1358.length == 0)) { this.fail('Use syntax without empty `()`', node_1219) };
								this.types.set(node_1219, /*EnumInstance*/[7,type_1366,tag]);
							}
						} break;
						
						case null: case undefined: {
							{
							}
						} break;
						
						default: 
						if ((this.types.get(e_1357) == this.typeAny)) { this.types.set(node_1219, this.typeAny) } else {
							this.fail('Calling *not* a function, type is `' + Type.stringify(this.types.get(e_1357)) + '`', e_1357);
						}
						};
					};
				}
			} break;
			
			case 10: {
				const a_1368 = temp_1220[1];
				const op_1369 = temp_1220[2];
				const b_1370 = temp_1220[3];
				{
					this.fillExpression(a_1368);
					this.fillExpression(b_1370);
					const typeA = this.types.get(a_1368);
					const typeB = this.types.get(b_1370);
					if ((op_1369 == 111) && (typeA == this.typeString)) { this.types.set(node_1219, this.typeString) } else if ((op_1369 == 92 || op_1369 == 93)) {
						const token = (op_1369 == 92)? ('and') : 'or';
						if ((!this.booleanable(typeA))) { this.fail(('Operator `a ' + (token) + ' b` takes `a` of type `Bool` only, but got `' + (Type.stringify(typeA)) + '`'), a_1368) };
						if ((!this.booleanable(typeB))) { this.fail(('Operator `a ' + (token) + ' b` takes `b` of type `Bool` only, but got `' + (Type.stringify(typeB)) + '`'), b_1370) };
						this.types.set(node_1219, this.typeBool);
					} else if (((op_1369 == 97) || (op_1369 == 96) || (op_1369 == 100) || (op_1369 == 99) || (op_1369 == 95) || (op_1369 == 103))) { this.types.set(node_1219, this.typeBool) } else {
						this.types.set(node_1219, (() => {
							const result_1371 = this.types.get(b_1370);
							if (result_1371 != null) { return result_1371 };
							return this.types.get(a_1368);
						})());
					};
				}
			} break;
			
			case 20: {
				const op_1372 = temp_1220[1];
				const postfix = temp_1220[2];
				const e_1373 = temp_1220[3];
				{
					this.fillExpression(e_1373);
					if ((op_1372 == 89) && ((!postfix))) {
						const type_1374 = this.types.get(e_1373);
						if ((!this.booleanable(type_1374))) { this.fail(('Operator `!value` takes `value` of type `Bool` only, but got `' + (Type.stringify(this.types.get(e_1373))) + '`'), e_1373) };
						this.types.set(node_1219, this.typeBool);
						return;
					};
					this.types.set(node_1219, this.types.get(e_1373));
					const mutates = op_1372 == 87 || op_1372 == 86;
					if (((!mutates))) { return };
					let parent_1375 = this.parents.get(e_1373);
					{
						const temp_1376 = parent_1375;
						switch (temp_1376&&temp_1376[0]) {
						case 24: {
							const name_1377 = temp_1376[1];
							const const_1378 = temp_1376[4];
							if (const_1378) { this.fail(('Cannot change a constant `let ' + (name_1377) + '`, redefine it as `var ' + (name_1377) + '` to allow value changes\n') + this.positionOf(parent_1375) + ('`let ' + (name_1377) + '` is defined here'), node_1219) }
						} break;
						
						case 22: {
							const name_1379 = temp_1376[1];
							this.fail(('Cannot `' + (Token.stringify(op_1372)) + '` a function `' + (name_1379) + '`'), node_1219)
						} break;
						
						case 49: {
							const name_1380 = temp_1376[1];
							this.fail(('Cannot change iterator value `' + (name_1380) + '` of for loop\n') + this.positionOf(parent_1375) + ('`for ' + (name_1380) + ' in ...` is defined here'), node_1219)
						} break;
						
						case 47: {
							const f_1381 = temp_1376[1];
							{
								const temp_1382 = f_1381;
								switch (temp_1382&&temp_1382[0]) {
								case 22: {
									const name_1383 = temp_1382[1];
									this.fail(('Cannot `' + (Token.stringify(op_1372)) + '` a `static fun ' + (name_1383) + '`'), node_1219)
								} break;
								
								case 24: {
									const name_1384 = temp_1382[1];
									const const_1385 = temp_1382[4];
									if (const_1385) { this.fail(('Cannot change a constant `static let ' + (name_1384) + '`, redefine it as `static var ' + (name_1384) + '` to allow value changes\n') + this.positionOf(parent_1375) + ('`static let ' + (name_1384) + '` is defined here'), node_1219) }
								} break;
								};
							}
						} break;
						
						default: 
						{
							const temp_1386 = e_1373;
							switch (temp_1386&&temp_1386[0]) {
							case 33: {
								{
								}
							} break;
							
							default: 
							{
								const ops = (87)? ('increment `++`') : 'decrement `--`';
								this.fail(('You can ' + (ops) + ' only a variable, .field or array element'), node_1219);
							}
							};
						}
						};
					};
					let hha = 1;
					{
					};
				}
			} break;
			
			case 33: {
				const e_1387 = temp_1220[1];
				const i_1388 = temp_1220[2];
				{
					this.fillExpression(e_1387);
					this.fillExpression(i_1388);
					let indexableIsAny = false;
					{
						const temp_1389 = (this.types.get(e_1387));
						switch (temp_1389&&temp_1389[0]) {
						case 4: {
							const type_1390 = temp_1389[1];
							const generic_1391 = temp_1389[2];
							if ((type_1390.name == 'Any')) { indexableIsAny = true }
						} break;
						};
					};
					if (((!indexableIsAny))) {
						const temp_1392 = (this.types.get(i_1388));
						switch (temp_1392&&temp_1392[0]) {
						case 4: {
							const type_1393 = temp_1392[1];
							if ((type_1393.name != 'Int') && (type_1393.name != 'Any')) { this.fail('`value[i]` expects `i` only of type `Int`, but got `' + Type.stringify(this.types.get(i_1388)) + '`', e_1387) }
						} break;
						
						case null: case undefined: {
							{
							}
						} break;
						
						default: 
						this.fail('`value[i]`????? expects `i` only of type `Int`, but got `' + Type.stringify(this.types.get(i_1388)) + '`', e_1387)
						};
					};
					{
						const temp_1394 = (this.types.get(e_1387));
						switch (temp_1394&&temp_1394[0]) {
						case 4: {
							const type_1395 = temp_1394[1];
							const generic_1396 = temp_1394[2];
							if ((generic_1396 != null) && (generic_1396.length == 1)) { this.types.set(node_1219, generic_1396[0]) } else if (['Array', 'Buffer', 'Uint8Array', 'Uint32Array'].includes(type_1395.name)) { this.types.set(node_1219, this.toType(/*Type*/[1,'Int',null], node_1219)) } else if (['Any'].includes(type_1395.name)) { this.types.set(node_1219, this.toType(/*Type*/[1,'Any',null], node_1219)) } else {
								this.fail('value[i] generic is null or >1', e_1387);
							}
						} break;
						
						case null: case undefined: {
							{
							}
						} break;
						
						default: 
						{
						}
						};
					};
				}
			} break;
			
			case 11: {
				const a_1397 = temp_1220[1];
				const op_1398 = temp_1220[2];
				const b_1399 = temp_1220[3];
				{
					if ((op_1398 == 95)) { this.fail('`===` not supported, use `strictEqual`', node_1219) };
					if ((op_1398 == 95)) { this.fail('`!==` not supported, use `strictNotEqual`', node_1219) };
					this.fillExpression(a_1397);
					let parent_1400 = this.parents.get(a_1397);
					{
						const temp_1401 = parent_1400;
						switch (temp_1401&&temp_1401[0]) {
						case 24: {
							const name_1402 = temp_1401[1];
							const const_1403 = temp_1401[4];
							if (const_1403) { this.fail(('Cannot change a constant `let ' + (name_1402) + '`, redefine it as `var ' + (name_1402) + '` to allow value changes\n') + this.positionOf(parent_1400) + ('`let ' + (name_1402) + '` is defined here'), node_1219) }
						} break;
						
						case 22: {
							const name_1404 = temp_1401[1];
							this.fail(('Cannot reassign a function `' + (name_1404) + '`'), node_1219)
						} break;
						
						case 49: {
							const name_1405 = temp_1401[1];
							this.fail(('Cannot change iterator value `' + (name_1405) + '` of for loop\n') + this.positionOf(parent_1400) + ('`for ' + (name_1405) + ' in ...` is defined here'), node_1219)
						} break;
						
						default: 
						{
						}
						};
					};
					this.fillExpression(b_1399);
					this.types.set(node_1219, this.unify(this.types.get(a_1397), this.types.get(b_1399), b_1399));
				}
			} break;
			
			case 17: {
				const e_1406 = temp_1220[1];
				{
					if (((!this.insideFunction) && (!this.insideTry))) { this.fail('Cannot throw outside of `function` or `try`', node_1219) };
					if ((this.insideFunction && (!this.functionAllowedToThrow))) { this.fail('Cannot throw in a @noThrow function', node_1219) };
					if (this.insideFunction) { this.functionThrows = true };
					this.fillExpression(e_1406);
				}
			} break;
			
			case 3: {
				{
					if (((!this.insideClassMethod))) { this.fail('Cannot access `this` outside of class method', node_1219) };
					if ((this.thisType == null)) { this.fail('Cannot access `this` in class method', node_1219) };
					this.types.set(node_1219, this.thisType);
					this.parents.set(node_1219, this.thisNode);
				}
			} break;
			
			case 4: {
				this.fail('Cannot use `super` as value', node_1219)
			} break;
			
			case 16: {
				const e_1407 = temp_1220[1];
				{
					{
						const temp_1408 = e_1407;
						switch (temp_1408&&temp_1408[0]) {
						case 24: {
							const name_1409 = temp_1408[1];
							const const_1410 = temp_1408[4];
							{
								const prefix = (const_1410)? ('let') : 'var';
								this.fail(('This `return` tries to return a variable `' + (prefix) + ' ' + (name_1409) + '`. Try to wrap it into braces like this `{ return } ' + (prefix) + ' ' + (name_1409) + '`'), node_1219);
							}
						} break;
						
						case 16: {
							this.fail('Cannot return another return. Try to wrap first `{ return } return 2` into braces', node_1219)
						} break;
						};
					};
					if (((!this.insideFunction))) { this.fail('Cannot use `return` outside of function', node_1219) };
					if ((e_1407 != null)) {
						if ((this.functionReturnsAType == this.typeVoid)) { this.fail('Function returns `Void`, cannot return a value here', e_1407) };
						this.fillExpression(e_1407);
						const ret_1411 = this.types.get(e_1407);
						if ((ret_1411 == this.typeVoid)) { this.fail('Cannot `return` a `Void` non-value', node_1219) };
						this.functionReturnsAType = this.unify(this.functionReturnsAType, ret_1411, e_1407);
						this.functionActuallyReturns = true;
					} else {
						let step_1412 = 0;
						const ret_1413 = this.functionReturnsAType;
						if (step_1412 == 0 && ret_1413 != null) { step_1412 = 1 };
						if (step_1412 == 1) { if ((ret_1413 != this.typeVoid)) { this.fail(('Expected `return value` of type `' + (Type.stringify(ret_1413)) + '`'), node_1219) } } else {
							this.functionReturnsAType = this.typeVoid;
						};
					};
				}
			} break;
			
			case 45: {
				this.fail('Cannot use underscore `_` outside of case pattern', node_1219)
			} break;
			
			case 47: {
				this.fail('Cannot use `static` here: only applicable to class fields', node_1219)
			} break;
			
			case 48: {
				this.fail('Cannot use `private` here: only applicable to class fields and module declarations', node_1219)
			} break;
			
			case 35: {
				{
				}
			} break;
			
			case 18: {
				this.fail('Cannot use `break` as a value', node_1219)
			} break;
			
			case 19: {
				this.fail('Cannot use `continue` as a value', node_1219)
			} break;
			
			case 25: {
				this.fail('Cannot use `class` as a value', node_1219)
			} break;
			
			case 39: {
				this.fail('Cannot use `enum` as a value', node_1219)
			} break;
			
			case 9: {
				this.fail('Cannot use `declare` as a value', node_1219)
			} break;
			
			case 37: {
				this.fail('Cannot use `import` as a value', node_1219)
			} break;
			
			case 24: {
				const name_1414 = temp_1220[1];
				const const_1415 = temp_1220[4];
				{
					const prefix_1416 = (const_1415)? ('let') : 'var';
					this.fail(('Cannot use `' + (prefix_1416) + ' ' + (name_1414) + '` as a value'), node_1219);
				}
			} break;
			
			case 34: {
				this.fillSwitch(node_1219, true)
			} break;
			
			case 21: {
				this.fail('Cannot use `while` as a value', node_1219)
			} break;
			
			case 49: {
				this.fail('Cannot use `for` as a value. To build array from loop, surround with `[for]` brackets.', node_1219)
			} break;
			
			case null: case undefined: {
				this.fail('Got null node. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_1219)
			} break;
			
			default: 
			this.fail('Unknown node expression kind to type ' + node_1219 + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_1219)
			};
		};
		fillSwitch(node_1417, value_1418) {
			const temp_1419 = node_1417;
			switch (temp_1419&&temp_1419[0]) {
			case 34: {
				const exprs_1420 = temp_1419[1];
				const conds_1421 = temp_1419[2];
				const guards_1422 = temp_1419[3];
				const cases_1423 = temp_1419[4];
				{
					for (const e of $toIterator(exprs_1420)) {
						this.pushScope();
						this.fillExpression(e);
						this.popScope();
					};
					{
						let step_1424 = 0;
						const expr_1425 = exprs_1420[1];
						if (step_1424 == 0 && expr_1425 != null) { step_1424 = 1 };
						if (step_1424 == 1) { this.fail('Multiple switch values are not yet supported', expr_1425) };
					};
					const unwrapUnknownAndNullable = (type_1426) => {
						{
							const temp_1427 = type_1426;
							switch (temp_1427&&temp_1427[0]) {
							case null: case undefined: {
								return null
							} break;
							
							case 2: {
								const type_1428 = temp_1427[1];
								return unwrapUnknownAndNullable(type_1428)
							} break;
							
							case 0: {
								const type_1429 = temp_1427[1];
								return unwrapUnknownAndNullable(type_1429.value)
							} break;
							
							case 1: {
								const type_1430 = temp_1427[1];
								return unwrapUnknownAndNullable(type_1430.value)
							} break;
							};
						};
						return type_1426;
					};
					const etype_1431 = unwrapUnknownAndNullable(this.types.get(exprs_1420[0]));
					if ((etype_1431 == null)) { this.fail(('Value of switch `' + (Node.stringify(exprs_1420[0])) + '` must have a known type at this postition'), exprs_1420[0]) };
					let enumType = null;
					let shortHandSyntax = false;
					if ((etype_1431 == this.typeBool)) {} else if ((etype_1431 == this.typeInt)) {} else if ((etype_1431 == this.typeString)) {} else if ((etype_1431 == this.typeFloat)) { this.fail('Due to imprecise nature of `Float` type, switching over it is not allowed', exprs_1420[0]) } else {
						const temp_1432 = etype_1431;
						switch (temp_1432&&temp_1432[0]) {
						case 6: {
							const type_1433 = temp_1432[1];
							enumType = type_1433
						} break;
						
						case 7: {
							const type_1434 = temp_1432[1];
							enumType = type_1434
						} break;
						
						default: 
						this.fail(('Cannot switch over `' + (Type.stringify(etype_1431)) + '` type'), exprs_1420[0])
						};
					};
					let tags = [];
					let i_1435 = 0;
					const tagCheck = (currentTag, e_1436) => { if (tags.includes(currentTag)) { this.fail(('Tag `' + (currentTag) + '` already matched'), e_1436) } else {
						tags.push(currentTag);
					} };
					while (i_1435 < cases_1423.length) {
						this.pushScope();
						let e_1437 = conds_1421[i_1435];
						let currentType = null;
						let currentTag_1438 = null;
						let currentTagBind = 0;
						let interval = false;
						const follow = (e_1439) => {
							const temp_1440 = e_1439;
							switch (temp_1440&&temp_1440[0]) {
							case 29: {
								const ex = temp_1440[1];
								const name_1441 = temp_1440[2];
								{
									this.fillExpression(e_1439);
									{
										const temp_1442 = (this.types.get(ex));
										switch (temp_1442&&temp_1442[0]) {
										case 6: {
											const type_1443 = temp_1442[1];
											{
												currentType = type_1443;
												currentTag_1438 = name_1441;
												this.fail(('Use `case ' + (currentTag_1438) + '` instead of `case ' + (type_1443.name) + '.' + (currentTag_1438) + '`'), e_1439);
												if ((tags.includes(currentTag_1438))) { this.fail(('Tag `' + (currentTag_1438) + '` already matched'), e_1439) } else {
													tags.push(currentTag_1438);
												};
											}
										} break;
										};
									};
								}
							} break;
							
							case 15: {
								const e_1444 = temp_1440[1];
								this.fill(e_1444)
							} break;
							
							case 45: {
								{
								}
							} break;
							
							case 8: {
								{
								}
							} break;
							
							case 2: {
								const val = temp_1440[1];
								{
									tagCheck('' + val, e_1439);
									if ((etype_1431 != this.typeBool)) { this.fail('Cannot switch over boolean here', e_1439) };
								}
							} break;
							
							case 5: {
								const val_1445 = temp_1440[1];
								{
									tagCheck('' + val_1445, e_1439);
									if ((etype_1431 != this.typeInt)) { this.fail('Cannot switch over number here', e_1439) };
								}
							} break;
							
							case 0: {
								const val_1446 = temp_1440[1];
								{
									tagCheck(val_1446, e_1439);
									if ((etype_1431 != this.typeString)) { this.fail('Cannot switch over string here', e_1439) };
								}
							} break;
							
							case 13: {
								const ex_1447 = temp_1440[1];
								const args_1448 = temp_1440[2];
								const argNames_1449 = temp_1440[3];
								{
									follow(ex_1447);
									currentTagBind = 0;
									if ((args_1448.length == 0)) { this.fail(('Do not use `()` empty pattern, use `' + (currentTag_1438) + '(...)` syntax to ignore all bindings'), e_1439) };
									{
										let step_1450 = 0;
										const enumType_1451 = enumType;
										let temp_1452 = null;
										if (step_1450 == 0 && enumType_1451 != null) {
											temp_1452 = enumType_1451.fieldsTypeSimple != null;
											step_1450 = 1;
										};
										if (step_1450 == 1 && temp_1452 != false) { step_1450 = 2 };
										if (step_1450 == 2) { this.fail(('The `' + (enumType_1451.name) + '` is simple enum and has no `()` bindings'), e_1439) };
									};
									{
										let step_1453 = 0;
										const enumType_1454 = enumType;
										let temp_1455 = null;
										if (step_1453 == 0 && enumType_1454 != null) {
											temp_1455 = shortHandSyntax == true;
											step_1453 = 1;
										};
										let i_1456 = null;
										if (step_1453 == 1 && temp_1455 != false) {
											i_1456 = enumType_1454.fieldNames.indexOf(currentTag_1438);
											step_1453 = 2;
										};
										let binds = null;
										if (step_1453 == 2 && i_1456 != null) {
											binds = enumType_1454.tagBindVarsNames[i_1456];
											step_1453 = 3;
										};
										let temp_1457 = null;
										if (step_1453 == 3 && binds != null) {
											temp_1457 = binds.length == 0;
											step_1453 = 4;
										};
										if (step_1453 == 4 && temp_1457 != false) { step_1453 = 5 };
										if (step_1453 == 5) {
											const temp_1458 = args_1448[0];
											switch (temp_1458&&temp_1458[0]) {
											case 46: {
												{
												}
											} break;
											
											default: 
											this.fail(('The `' + (currentTag_1438) + '` has no `()` bindings, use `' + (currentTag_1438) + '(...)` syntax to ignore all future bindings added'), e_1439)
											};
										};
									};
									for (const ee of $toIterator(args_1448)) {
										if (interval) { this.fail('Do not match any patterns after `...` interval', ee) };
										{
											const temp_1459 = ee;
											switch (temp_1459&&temp_1459[0]) {
											case 46: {
												interval = true
											} break;
											
											case 1: {
												const name_1460 = temp_1459[1];
												{
													follow(ee);
													currentTagBind++;
												}
											} break;
											
											case 45: {
												{
													{
														let step_1461 = 0;
														const enumType_1462 = enumType;
														let temp_1463 = null;
														if (step_1461 == 0 && enumType_1462 != null) {
															temp_1463 = shortHandSyntax == true;
															step_1461 = 1;
														};
														let i_1464 = null;
														if (step_1461 == 1 && temp_1463 != false) {
															i_1464 = enumType_1462.fieldNames.indexOf(currentTag_1438);
															step_1461 = 2;
														};
														let binds_1465 = null;
														if (step_1461 == 2 && i_1464 != null) {
															binds_1465 = enumType_1462.tagBindVarsNames[i_1464];
															step_1461 = 3;
														};
														let temp_1466 = null;
														if (step_1461 == 3 && binds_1465 != null) {
															temp_1466 = binds_1465.length <= currentTagBind;
															step_1461 = 4;
														};
														if (step_1461 == 4 && temp_1466 != false) { step_1461 = 5 };
														if (step_1461 == 5) { this.fail('Too many bindings ignored with `_` for `F` tag, use `...` syntax to ignore all future bindings', e_1439) };
													};
													currentTagBind++;
												}
											} break;
											
											default: 
											this.fail('This case pattern is not supported', e_1439)
											};
										};
									};
								}
							} break;
							
							case 51: {
								const t_1467 = temp_1440[1];
								{
									shortHandSyntax = true;
									{
										const temp_1468 = t_1467;
										switch (temp_1468&&temp_1468[0]) {
										case 1: {
											const name_1469 = temp_1468[1];
											{
												let step_1470 = 0;
												const enumType_1471 = enumType;
												if (step_1470 == 0 && enumType_1471 != null) { step_1470 = 1 };
												if (step_1470 == 1) {
													let step_1472 = 0;
													const i_1473 = enumType_1471.fieldNames.indexOf(name_1469);
													let temp_1474 = null;
													if (step_1472 == 0 && i_1473 != null) {
														temp_1474 = enumType_1471.fieldEnumConstructor[i_1473] == true;
														step_1472 = 1;
													};
													if (step_1472 == 1 && temp_1474 != false) { step_1472 = 2 };
													if (step_1472 == 2) {
														currentType = enumType_1471;
														currentTag_1438 = name_1469;
														if ((tags.includes(currentTag_1438))) { this.fail(('Tag `' + (currentTag_1438) + '` already matched'), e_1439) } else {
															tags.push(currentTag_1438);
														};
													} else {
														this.fail(('The `' + (name_1469) + '` is not an enum constructor of `' + (enumType_1471.name) + '`'), e_1439);
													};
												} else {
													this.fail('This case pattern is not supported over non-enum types', e_1439);
												};
											}
										} break;
										
										default: 
										this.fail('This case pattern is not supported', e_1439)
										};
									};
								}
							} break;
							
							case 1: {
								const name_1475 = temp_1440[1];
								if ((name_1475.charAt(0) == name_1475.charAt(0).toUpperCase())) { this.fill(e_1439) } else {
									this.addScope(name_1475, e_1439);
									{
										let step_1476 = 0;
										const currentType_1477 = currentType;
										if (step_1476 == 0 && currentType_1477 != null) { step_1476 = 1 };
										if (step_1476 == 1) {
											const indexOf = currentType_1477.fieldNames.indexOf(currentTag_1438);
											if ((indexOf == (-1))) { this.fail('currentType.fieldNames.indexOf == -1', e_1439) };
											const type_1478 = currentType_1477.tagBindVars[indexOf][currentTagBind];
											const name_1479 = currentType_1477.tagBindVarsNames[indexOf][currentTagBind];
											if ((name_1479 == null)) {
												const available_1480 = currentType_1477.tagBindVarsNames[indexOf].join(', ');
												if ((available_1480.length == 0)) { this.fail('No bindings available for `.' + currentTag_1438 + '`', e_1439) };
												this.fail(('Too many bindings requested for `' + (currentTag_1438) + '`, available are: ') + available_1480, e_1439);
											};
											if ((type_1478 != null)) { this.types.set(e_1439, this.toType(type_1478, e_1439)) } else {
												this.fail('tagBindVars no type for ' + name_1479, e_1439);
											};
										} else {
											this.fail('No currentType for ' + name_1475, e_1439);
										};
									};
								}
							} break;
							
							case 10: {
								const a_1481 = temp_1440[1];
								const op_1482 = temp_1440[2];
								const b_1483 = temp_1440[3];
								if ((op_1482 == 104)) {
									follow(a_1481);
									follow(b_1483);
								} else {
									this.fail('This case pattern is not supported', e_1439);
								}
							} break;
							
							case 14: {
								const econd_1484 = temp_1440[1];
								{
									this.pushScope();
									this.fill(econd_1484[0]);
									this.popScope();
								}
							} break;
							
							default: 
							this.fail('This case pattern is not supported', e_1439)
							};
						};
						follow(e_1437);
						let e_1485 = cases_1423[i_1435];
						this.pushScope();
						{
							let step_1486 = 0;
							const guard = guards_1422[i_1435];
							if (step_1486 == 0 && guard != null) { step_1486 = 1 };
							if (step_1486 == 1) {
								this.fillExpression(guard);
								if ((this.types.get(guard) != this.typeBool)) { this.fail('Case guard must be a simple boolean expression', guard) };
							};
						};
						if ((value_1418 == false)) { this.fill(e_1485) };
						if ((value_1418 == true)) {
							this.fillExpression(e_1485);
							if ((this.types.get(node_1417) == null)) { this.types.set(node_1417, this.types.get(e_1485)) } else {
								this.types.set(node_1417, this.unify(this.types.get(node_1417), this.types.get(e_1485), e_1485));
							};
						};
						this.popScope();
						this.popScope();
						i_1435++;
					};
				}
			} break;
			};
		};
	}
	Typer.never = '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.'
	Typer.failures = []
	Typer.nodeToNodeType = (node_995) => {
			const temp_996 = node_995;
			switch (temp_996&&temp_996[0]) {
			case 31: {
				const el = temp_996[1];
				{
					if ((el.length > 1)) { this.fail('Array type `[T]` cannot have more than 1 parameter `T`', el[1]) };
					return /*ParametricType*/[2,'Array',[Typer.nodeToNodeType(el[0])],null];
				}
			} break;
			
			case 51: {
				const t_997 = temp_996[1];
				return t_997
			} break;
			
			case 38: {
				const names_998 = temp_996[1];
				const el_999 = temp_996[2];
				{
					const types = (() => {
						const result_1000 = [];
						const value_1001 = el_999;
						for (const e of $toIterator(value_1001)) result_1000.push(Typer.nodeToNodeType(e));
						return result_1000;
					})();
					return /*Object*/[5,names_998,types];
				}
			} break;
			
			default: 
			this.fail('Cannot nodeToNodeType of ' + Node.stringify(node_995), node_995)
			};
		};
	var Tokens = class {
		constructor(tokens, length, values, lines, columns, fileName, meta) { 
		{
			this.token = tokens;
			this.length = length;
			this.value = values;
			this.line = lines;
			this.column = columns;
			this.fileName = fileName;
			this.meta = meta;
		} };
	}
	var Lexer = class {
	}
	Lexer.isident = Buffer.alloc(256)
	Lexer.isUpper = Buffer.alloc(256)
	Lexer.ops8a = Buffer.alloc(256)
	Lexer.op16token = Buffer.alloc(768)
	Lexer.kwd
	Lexer.tokenize = (bytes, fileName_1487) => {
			let position = 0;
			const len = bytes.length;
			let to = 0;
			let s = '';
			let p = 0;
			let line = 1;
			let columnBase = 0;
			const params = [];
			const meta_1488 = [];
			const tokens_1489 = Buffer.alloc(len + 1);
			let lines_1490 = [];
			let columns_1491 = [];
			const add = (t) => {
				tokens_1489[(to++)] = t;
				lines_1490.push(line);
				columns_1491.push(position - columnBase - 1);
			};
			const addn = (t_1492, p_1493) => {
				params[to] = p_1493;
				add(t_1492);
			};
			const addm = (t_1494, p_1495, m) => {
				params[to] = p_1495;
				meta_1488[to] = m;
				add(t_1494);
			};
			const curPos = () => { return position - columnBase - 1 };
			const get_8 = (pos) => { return bytes[pos] };
			const not_eof = () => { return (position < len) };
			const new_line = () => {
				line++;
				columnBase = position;
			};
			const fail = (message, erline = null, column = null, filename = null) => {
				let erline_1496 = (erline != null)? (erline) : line;
				let column_1497 = (column != null)? (column) : curPos();
				let filename_1498 = (filename != null)? (filename) : fileName_1487;
				return new CompilerErrors([new CompilerError(2, message, erline_1496, column_1497, filename_1498)]);
			};
			if ((len > 2) && (get_8(0) == 239) && (get_8(1) == 187) && (get_8(2) == 191)) { position += 3 };
			if ((len > 2) && (get_8(0) == 35) && (get_8(1) == 33)) { while (position < len && get_8(position) != 10) {
				position++;
			} };
			while (position < len) {
				let _8 = 0;
				do {{
					_8 = get_8(position);
					if ((_8 == 10)) { new_line() };
				}} while (_8 <= 32 && ((++position) < len));
				if ((!not_eof())) { break };
				let _16 = ((len - position) > 1)? (_8 | (get_8(position + 1) << 8)) : _8;
				if (_8 == 47) {
					if ((_16 == 12079)) {
						let pos_1499 = position + 2;
						while (get_8(position) != 10 && not_eof()) {
							position++;
						};
						continue;
					};
					if ((_16 == 10799 && get_8(position + 2) == 42)) {
						position += 3;
						p = position;
						while (not_eof()) {
							let _32 = ((len - position) > 3)? (bytes.readUInt32LE(position)) : get_8(position);
							if (((_32 & 255) == 10)) { new_line() } else if (((_32 & 16777215) == 3090986)) { break };
							position++;
						};
						if ((!not_eof())) { throw fail('Unclosed doc-comment') };
						addn(65, bytes.toString('utf8', p, position));
						position += 3;
						continue;
					};
					if (_16 == 10799) {
						let pos_1500 = position + 2;
						p = 0;
						position += 2;
						while (not_eof()) {
							_16 = ((len - position) > 1)? (bytes.readUInt16LE(position)) : get_8(position);
							if (((_16 & 255) == 10)) { new_line() } else if ((_16 == 12074 && p > 0)) { p-- } else if ((_16 == 10799)) { p++ } else if ((_16 == 12074 && p == 0)) { break };
							position++;
						};
						position += 2;
						continue;
					};
				};
				if ((((_8 & 95) >= 65 && (_8 & 95) <= 90) || (_8 == 95))) {
					const titlechar = _8;
					p = position + 1;
					_8 = get_8(p);
					while (p < len && Lexer.isident[_8] != 0) {
						_8 = get_8((++p));
					};
					s = bytes.toString('ascii', position, p);
					const t_1501 = (((_16 & 255) <= 90))? (null) : Lexer.kwd.get(s);
					{
						let step = 0;
						const t_1502 = t_1501;
						if (step == 0 && t_1502 != null) { step = 1 };
						if (step == 1) { add(t_1502) } else {
							if ((titlechar >= 65 && titlechar <= 90)) { addn(61, s) } else {
								addn(62, s);
							};
						};
					};
					position = p;
					continue;
				};
				if ((_8 == 96)) {
					position++;
					const pos_1503 = position;
					while (not_eof()) {
						if ((get_8(position) == 96) && (get_8(position + 1) == 96)) {
							position++;
							position++;
							continue;
						};
						if ((get_8(position) == 96)) { break };
						if ((get_8(position) == 10)) { new_line() };
						position++;
					};
					let result = bytes.toString('utf8', pos_1503, position);
					if ((result.indexOf('``') != (-1))) { result = result.split('``').join('') };
					addn(66, result);
					position++;
					continue;
				};
				if ((_16 == 11822 && (get_8(position + 2) == 46))) {
					add(98);
					position += 3;
					continue;
				};
				if ((_16 == 15934 && (get_8(position + 2) == 62))) {
					add(108);
					position += 3;
					continue;
				};
				const hash = Lexer.simplehash(_16);
				if ((_16 == Lexer.op16token.readUInt16LE(hash * 2))) {
					add((Lexer.op16token[hash + 512]));
					position += 2;
					continue;
				};
				const found = (Lexer.ops8a[_8]);
				if ((found != 0)) {
					add(found);
					position++;
					continue;
				};
				if ((_8 < 40)) {
					p = _8;
					position++;
					const pos_1504 = position;
					while (get_8(position) != p && not_eof()) {
						if (get_8(position) == 10) { new_line() };
						if (get_8(position) == '\\'.charCodeAt(0)) {
							position += 2;
							continue;
						};
						_16 = ((len - position) > 1)? (bytes.readUInt16LE(position)) : get_8(position);
						position++;
					};
					let result_1505 = bytes.toString('utf8', pos_1504, position);
					if (result_1505.indexOf('\r\n') != (-1)) { result_1505 = result_1505.split('\r\n').join('\n') };
					addn(64, result_1505);
					position++;
					continue;
				};
				if (_16 == 30768) {
					p = position;
					p += 2;
					_8 = get_8(position);
					while ((_8 >= 65 && _8 <= 70) || (_8 >= 48 && _8 <= 57) || (_8 >= 97 && _8 <= 102)) {
						_8 = get_8((++p));
					};
					if (p - position == 2) { throw fail('Integer `0x` not allowed!') };
					let m_1506 = 0;
					let offset = 0;
					if (get_8(p) == 110) {
						m_1506 = 1;
						offset = 1;
					} else if (get_8(p) == 105) {
						const header = bytes.readUInt16LE(p + 1);
						if (get_8(p + 1) == 56) {
							m_1506 = 5;
							offset = 2;
						} else if ((header == 51 + 50 * 256)) {
							m_1506 = 2;
							offset = 3;
						} else if ((header == 54 + 52 * 256)) {
							m_1506 = 3;
							offset = 3;
						} else if ((header == 49 + 54 * 256)) {
							m_1506 = 4;
							offset = 3;
						};
					} else if ((get_8(p) == 117)) {
						const header_1507 = bytes.readUInt16LE(p + 1);
						if ((get_8(p + 1) == 56)) {
							m_1506 = 9;
							offset = 2;
						} else if ((header_1507 == 51 + 50 * 256)) {
							m_1506 = 6;
							offset = 3;
						} else if ((header_1507 == 54 + 52 * 256)) {
							m_1506 = 7;
							offset = 3;
						} else if ((header_1507 == 49 + 54 * 256)) {
							m_1506 = 8;
							offset = 3;
						};
					};
					addm(63, bytes.toString('ascii', position, p), m_1506);
					position = p + offset;
					continue;
				};
				if ((_8 < 58)) {
					p = position;
					_8 = get_8(p);
					let found_1508 = 63;
					while (_8 >= 48 && _8 <= 57) {
						_8 = get_8((++p));
					};
					if ((_8 == 46 && get_8(p + 1) != 46)) {
						_8 = get_8((++p));
						while (_8 >= 48 && _8 <= 57) {
							_8 = get_8((++p));
						};
						found_1508 = 60;
					};
					if (_8 == 101 || _8 == 69) {
						_8 = get_8((++p));
						if (_8 == 43 || _8 == 45) { _8 = get_8((++p)) };
						while (_8 >= 48 && _8 <= 57) {
							_8 = get_8((++p));
						};
						found_1508 = 60;
					};
					let m_1509 = 0;
					let offset_1510 = 0;
					if (get_8(p) == 110) {
						m_1509 = 1;
						offset_1510 = 1;
					} else if (get_8(p) == 105) {
						const header_1511 = bytes.readUInt16LE(p + 1);
						if ((get_8(p + 1) == 56)) {
							m_1509 = 5;
							offset_1510 = 2;
						} else if ((header_1511 == 51 + 50 * 256)) {
							m_1509 = 2;
							offset_1510 = 3;
						} else if ((header_1511 == 54 + 52 * 256)) {
							m_1509 = 3;
							offset_1510 = 3;
						} else if ((header_1511 == 49 + 54 * 256)) {
							m_1509 = 4;
							offset_1510 = 3;
						};
					} else if ((get_8(p) == 117)) {
						const header_1512 = bytes.readUInt16LE(p + 1);
						if ((get_8(p + 1) == 56)) {
							m_1509 = 9;
							offset_1510 = 2;
						} else if ((header_1512 == 51 + 50 * 256)) {
							m_1509 = 6;
							offset_1510 = 3;
						} else if ((header_1512 == 54 + 52 * 256)) {
							m_1509 = 7;
							offset_1510 = 3;
						} else if ((header_1512 == 49 + 54 * 256)) {
							m_1509 = 8;
							offset_1510 = 3;
						};
					} else if ((get_8(p) == 102)) {
						const header_1513 = bytes.readUInt16LE(p + 1);
						if ((header_1513 == 51 + 50 * 256)) {
							m_1509 = 10;
							offset_1510 = 3;
						};
					};
					addm(found_1508, bytes.toString('ascii', position, p), m_1509);
					position = p + offset_1510;
					continue;
				};
				if ((position >= len)) { break };
				throw fail('Unexpected character ' + String.fromCharCode(_8));
				break;
			};
			add(0);
			return new Tokens(tokens_1489, to, params, lines_1490, columns_1491, fileName_1487, meta_1488);
		};
	Lexer.init = () => {
			{
				let _8_1514 = 0;
				let it = 0;
				while (it < 256) {
					_8_1514 = it;
					it++;
					{
						Lexer.isident[_8_1514] = (((_8_1514 >= 65 && _8_1514 <= 90) || (_8_1514 >= 48 && _8_1514 <= 57) || (_8_1514 >= 97 && _8_1514 <= 122) || _8_1514 == 95))? (128) : 0;
					};
				};
			};
			{
				let _8_1515 = 0;
				let it_1516 = 0;
				while (it_1516 < 256) {
					_8_1515 = it_1516;
					it_1516++;
					{
						Lexer.isident[_8_1515] = (((_8_1515 >= 65 && _8_1515 <= 90) || (_8_1515 >= 48 && _8_1515 <= 57) || (_8_1515 >= 97 && _8_1515 <= 122) || _8_1515 == 95))? (128) : 0;
					};
				};
			};
			Lexer.kwd = new Map([['_', 1], ['as', 58], ['break', 3], ['case', 4], ['catch', 6], ['class', 7], ['continue', 8], ['do', 9], ['else', 10], ['enum', 11], ['extends', 12], ['declare', 13], ['false', 14], ['for', 15], ['fun', 21], ['if', 17], ['implements', 18], ['import', 2], ['in', 20], ['interface', 22], ['let', 23], ['new', 25], ['null', 26], ['private', 29], ['return', 31], ['static', 32], ['super', 59], ['switch', 33], ['this', 34], ['throw', 35], ['true', 36], ['try', 37], ['var', 40], ['while', 41], ['and', 92], ['or', 93], ['not', 89], ['is', 57]]);
			const ops8 = new Map([[64, 70], [36, 83], [35, 78], [33, 89], [37, 101], [38, 112], [40, 80], [41, 79], [42, 102], [43, 111], [44, 75], [45, 107], [46, 77], [47, 94], [58, 76], [59, 82], [60, 99], [61, 91], [62, 96], [63, 81], [91, 72], ['\\'.charCodeAt(0), 110], [93, 71], [94, 109], [123, 74], [124, 104], [125, 73], [126, 88]]);
			for (const key of $toIterator(ops8.keys())) {
				Lexer.ops8a[key] = ops8.get(key);
			};
			const ops16 = new Map([[11051, 87], [11565, 86], [15420, 105], [15649, 103], [15676, 100], [15677, 95], [15678, 97], [15934, 106], [31868, 93], [9766, 92], [15933, 90], [11839, 113]]);
			for (const key1 of $toIterator(ops16.keys())) {
				for (const key2 of $toIterator(ops16.keys())) {
					if ((key1 != key2 && Lexer.simplehash(key1) == Lexer.simplehash(key2))) { throw new CompilerError(2, '2-byte op hash collision: ' + key1 + ' ' + key2, 0, 0, 'INTERNAL') };
				};
			};
			for (const key of $toIterator(ops16.keys())) {
				const hash_1517 = Lexer.simplehash(key);
				Lexer.op16token.writeUInt16LE(key, hash_1517 * 2);
				Lexer.op16token[hash_1517 + 512] = ops16.get(key);
			};
			return;
		};
	Lexer.simplehash = (val) => { return ((val & 255) + (((val >> (8 * 1)) & 255) << 3)) & 239 };
	var Preprocessor = class {
	}
	Preprocessor.process_6 = (tokens, project) => {
			let i = 0;
			let token = tokens.token[0];
			while (i < tokens.length && token != 0) {
				if (token == 78) { return Preprocessor.processTokens(tokens, 0, project) };
				i++;
				token = tokens.token[i];
			};
			return tokens;
		};
	Preprocessor.fail = (lex, i_1518, message) => {
			const line = lex.line[i_1518];
			const column = lex.column[i_1518];
			const filename = lex.fileName;
			throw new CompilerErrors([new CompilerError(0, message, line, column, filename)]);
		};
	Preprocessor.processTokens = (tokens_1519, i_1520, project_1521) => {
			let i_1522 = i_1520;
			let token_1523 = tokens_1519.token[0];
			const bytes = tokens_1519.token.slice();
			const params = tokens_1519.value.slice();
			const lines = tokens_1519.line.slice();
			const columns = tokens_1519.column.slice();
			const meta = tokens_1519.meta.slice();
			let to = i_1522;
			const states = [0];
			let state = 0;
			const evaluateCondition = () => {
				if (tokens_1519.token[i_1522] != 62) { Preprocessor.fail(tokens_1519, i_1522, 'Incorrect `#if` syntax') };
				const defName = tokens_1519.value[i_1522];
				const def = project_1521.defines[defName];
				if (def == null) { Preprocessor.fail(tokens_1519, i_1522, '`#if` looks for the `' + defName + '` parameter which is *not* defined in project file.' + (' Add `\"define\": { \"' + (defName) + '\": false }` to `hexa.json` or `--define ' + (defName) + '=false` to suppress this message.')) };
				i_1522++;
				if (def == true) { return true };
				return false;
			};
			while (i_1522 < tokens_1519.length && token_1523 != 0) {
				if (token_1523 == 78) {
					i_1522++;
					token_1523 = tokens_1519.token[i_1522];
					if (token_1523 == 17) {
						i_1522++;
						if (evaluateCondition()) { states.push(1) } else {
							states.push(4);
						};
						state = states[states.length - 1];
					} else if ((token_1523 == 62) && (tokens_1519.value[i_1522] == 'end')) {
						i_1522++;
						{
							const temp = state;
							switch (temp) {
							case 1: {
								{
								}
							} break;
							
							case 2: {
								{
								}
							} break;
							
							case 3: {
								{
								}
							} break;
							
							case 4: {
								{
								}
							} break;
							
							default: 
							Preprocessor.fail(tokens_1519, i_1522 - 1, 'Unexpected `#end`')
							};
						};
						states.pop();
						state = states[states.length - 1];
					} else if (token_1523 == 10) {
						i_1522++;
						{
							const temp_1524 = state;
							switch (temp_1524) {
							case 1: {
								state = 3
							} break;
							
							case 4: {
								state = 2
							} break;
							
							default: 
							Preprocessor.fail(tokens_1519, i_1522 - 1, 'Unexpected `#else`')
							};
						};
						states[states.length - 1] = state;
					} else {
						Preprocessor.fail(tokens_1519, i_1522, 'Incorrect `#` syntax');
					};
				} else {
					const temp_1525 = state;
					switch (temp_1525) {
					case 0: case 1: case 2: {
						{
							bytes[to] = tokens_1519.token[i_1522];
							params[to] = tokens_1519.value[i_1522];
							lines[to] = tokens_1519.line[i_1522];
							columns[to] = tokens_1519.column[i_1522];
							meta[to] = tokens_1519.meta[i_1522];
							i_1522++;
							to++;
						}
					} break;
					
					default: 
					i_1522++
					};
				};
				token_1523 = tokens_1519.token[i_1522];
			};
			return new Tokens(bytes, to, params, lines, columns, tokens_1519.fileName, meta);
		};
	var Parser = class {
		constructor(lexe_1526, project_1527, lint_1528) { 
			this.lint = false
			this.i = 0
			this.endif = 0
			this.lasttok = (-1)
			this.lasttokchecks = 10
			this.hints = []
			this.classExternal = false
			this.parametricTypeNesting = 0
			this.parametricTypeNestingToken = 0
		{
			this.lex = Preprocessor.process_6(lexe_1526, project_1527);
			this.lint = lint_1528;
			this.project = project_1527;
			this.nodes = [];
			while (this.i < this.lex.length && this.tok() != 0) {
				this.nodes.push(this.parseExpr());
			};
		} };
		parseFields() {
			let fields = [];
			while (this.tok() != 73) {
				let atts = [];
				while (this.tok() == 70) {
					atts.push(this.parseDecorator());
				};
				const pos = {line:this.lex.line[this.i], column:this.lex.column[this.i]};
				const pos_1529 = new NodeData(pos.line, pos.column, this.lex.fileName);
				let _static = false;
				if ((this.tok() == 32)) {
					_static = true;
					this.i++;
				};
				{
					const temp = this.tok();
					switch (temp) {
					case 29: {
						this.i++
					} break;
					
					case 40: {
						{
							let f = this.parseExpr();
							this.project.data.set(f, pos_1529);
							if (_static) {
								f = /*Static*/[47,f];
								this.project.data.set(f, pos_1529);
							};
							this.project.mapDecorators.set(f, atts);
							fields.push(f);
						}
					} break;
					
					case 21: {
						{
							let f_1530 = this.parseExpr();
							this.project.data.set(f_1530, pos_1529);
							if (_static) {
								f_1530 = /*Static*/[47,f_1530];
								this.project.data.set(f_1530, pos_1529);
							};
							this.project.mapDecorators.set(f_1530, atts);
							fields.push(f_1530);
						}
					} break;
					
					case 23: {
						{
							let f_1531 = this.parseExpr();
							this.project.data.set(f_1531, pos_1529);
							if (_static) {
								f_1531 = /*Static*/[47,f_1531];
								this.project.data.set(f_1531, pos_1529);
							};
							this.project.mapDecorators.set(f_1531, atts);
							fields.push(f_1531);
						}
					} break;
					
					case 25: {
						{
							this.i++;
							let expr = null;
							let vars = [];
							let types = [];
							let values = [];
							this.step(80);
							if ((this.tok() != 79)) { while (true) {
								vars.push(this.getgo(62));
								let expr_1532 = null;
								let t = null;
								if ((this.tok() == 76)) {
									this.i++;
									t = this.parseType();
								};
								if ((this.tok() == 91)) {
									this.i++;
									expr_1532 = this.parseExpr();
								};
								types.push(t);
								values.push(expr_1532);
								if ((this.tok() == 75)) { this.i++ } else {
									break;
								};
							} };
							this.step(79);
							let tmp = this.i;
							while (this.tok() == 70) {
								this.parseDecorator();
							};
							if ((this.tok() != 73 && this.tok() != 21)) {
								this.i = tmp;
								expr = this.parseExpr();
							} else {
								this.i = tmp;
							};
							let v = [];
							{
								let i = 0;
								let it = 0;
								let at = vars.length;
								while (it < at) {
									i = it;
									it++;
									{
										v.push(/*Var*/[24,vars[i],types[i],values[i],true,false]);
									};
								};
							};
							{
								const temp_1533 = expr;
								switch (temp_1533&&temp_1533[0]) {
								case null: case undefined: {
									{
									}
								} break;
								
								case 12: {
									{
									}
								} break;
								
								default: 
								{
									this.i--;
									this.fail('Constructor `new` should have a `{ block }` as a body');
								}
								};
							};
							const field = /*Function*/[22,'new',expr,v,null,false];
							this.project.data.set(field, pos_1529);
							fields.push(field);
						}
					} break;
					
					case 62: {
						{
							const name = this.getgo(62);
							if ((name == 'get') && (this.tok() == 62)) {
								const field_1534 = this.getgo(62);
								this.fail(('Use property `var ' + (field_1534) + ' { get { return value } }` instead of `get ' + (field_1534) + '()`'));
							};
							if ((name == 'set') && (this.tok() == 62)) {
								const field_1535 = this.getgo(62);
								this.step(80);
								const value = this.getgo(62);
								this.fail(('Use property `var ' + (field_1535) + ' { set(' + (value) + ') { ... } }` instead of `set ' + (field_1535) + '(' + (value) + ')`'));
							};
							if ((this.tok() == 80)) {
								if ((name == 'constructor')) { this.fail('Use `new()` syntax instead of `constructor()`') };
								if (_static) { this.fail('Use `static fun ' + name + '()` syntax for static methods') } else {
									this.fail('Use `function ' + name + '()` syntax for methods');
								};
							};
							this.fail('Fields should start with `var ' + name + '` or `let ' + name + '`');
						}
					} break;
					
					case 61: {
						this.fail('Fields cannot start with uppercase character `' + this.print() + '` -> `' + this.print().toLowerCase() + '`')
					} break;
					
					case 74: {
						{
							const pos_1536 = {line:this.lex.line[this.i], column:this.lex.column[this.i]};
							const field_1537 = fields.pop();
							let v_1538 = null;
							let t_1539 = null;
							let n = null;
							let onlyGet = false;
							{
								const temp_1540 = field_1537;
								switch (temp_1540&&temp_1540[0]) {
								case 24: {
									const name_1541 = temp_1540[1];
									const type = temp_1540[2];
									const expr_1542 = temp_1540[3];
									const const_1543 = temp_1540[4];
									{
										if ((expr_1542 != null)) { this.fail('Property should not have a `= value`') };
										v_1538 = field_1537;
										t_1539 = type;
										n = name_1541;
										onlyGet = const_1543;
									}
								} break;
								
								default: 
								this.fail('Only `var` and `let` fields may have a getter `let v: T { get() ... }`')
								};
							};
							this.i++;
							if ((this.print() == 'set')) { this.fail('Expected `get` before `set`') };
							if ((this.print() != 'get')) { this.fail('Expected `get`') };
							const kind = this.print();
							let getterExpr = null;
							if ((kind == 'get')) {
								this.i++;
								getterExpr = this.parseExpr();
							};
							const kind_1544 = this.print();
							let setterExpr = null;
							let setterVar = null;
							if ((kind_1544 == 'set') && (onlyGet)) { this.fail('Constants `let` may have only getter `get`') };
							if (kind_1544 == 'set') {
								this.i++;
								this.step(80);
								setterVar = this.getgo(62);
								this.step(79);
								setterExpr = this.parseExpr();
							};
							if ((setterExpr == null) && ((!onlyGet))) { this.fail('Variables `var` should have both getter `get` and setter `set`') };
							this.step(73);
							const getter = ((getterExpr == null))? (null) : /*Function*/[22,'get_' + n,getterExpr,[],t_1539,false];
							const setter = ((setterExpr == null))? (null) : /*Function*/[22,'set_' + n,setterExpr,[/*Var*/[24,setterVar,t_1539,null,true,false]],null,false];
							const property = /*Property*/[26,field_1537,getter,setter];
							this.project.data.set(property, new NodeData(pos_1536.line, pos_1536.column, this.lex.fileName));
							this.project.data.set(getter, new NodeData(pos_1536.line, pos_1536.column, this.lex.fileName));
							this.project.data.set(setter, new NodeData(pos_1536.line, pos_1536.column, this.lex.fileName));
							fields.push(property);
							{
								let step = 0;
								const getter_1545 = getter;
								if (step == 0 && getter_1545 != null) { step = 1 };
								if (step == 1) { fields.push(getter_1545) };
							};
							{
								let step_1546 = 0;
								const setter_1547 = setter;
								if (step_1546 == 0 && setter_1547 != null) { step_1546 = 1 };
								if (step_1546 == 1) { fields.push(setter_1547) };
							};
						}
					} break;
					
					default: 
					this.fail('Fields cannot start with `' + this.print() + '`')
					};
				};
			};
			return fields;
		};
		tok() { return (this.lex.token[this.i]) };
		print() { return Token.stringify((this.lex.token[this.i]), this.lex.value[this.i]) };
		expect(t_1548) { if ((t_1548 != this.tok())) { this.expected(Token.stringify(t_1548)) } };
		fail(message, line, column, filename) {
			const line_1549 = (line != null)? (line) : this.lex.line[this.i];
			const column_1550 = (column != null)? (column) : this.lex.column[this.i];
			const filename_1551 = (filename != null)? (filename) : this.lex.fileName;
			this.hints.push(new CompilerError(0, message, line_1549, column_1550, filename_1551));
			throw new CompilerErrors(this.hints);
		};
		failHint(message_1552, line_1553, column_1554, filename_1555) {
			const line_1556 = (line_1553 != null)? (line_1553) : this.lex.line[this.i];
			const column_1557 = (column_1554 != null)? (column_1554) : this.lex.column[this.i];
			const filename_1558 = (filename_1555 != null)? (filename_1555) : this.lex.fileName;
			this.hints.push(new CompilerError(0, message_1552, line_1556, column_1557, filename_1558));
		};
		getgo(t_1559) {
			this.expect(t_1559);
			return this.lex.value[(this.i++)];
		};
		step(t_1560) {
			this.expect(t_1560);
			this.i++;
		};
		next() { this.i++ };
		offset(v_1561) { return (this.lex.token[this.i + v_1561]) };
		unexpected() {
			let token = Token.stringify((this.lex.token[this.i]), this.lex.value[this.i]);
			let error = ('Unexpected `' + (token) + '`');
			if ((this.tok() == 82)) { error += ' semicolon. Note: Hexa has no semicolons!' };
			if ((this.print() == 'public')) { error += '. Note: Hexa has no `public` keyword!' };
			this.fail(error);
		};
		expected(str) {
			let token_1562 = Token.stringify((this.lex.token[this.i]), this.lex.value[this.i]);
			this.fail(('Expected `' + (str) + '` before `' + (token_1562) + '`'));
		};
		parseExpr() {
			let atts_1563 = [];
			while (this.tok() == 70) {
				atts_1563.push(this.parseDecorator());
			};
			let node = this.tok();
			let nodePosition = {line:this.lex.line[this.i], column:this.lex.column[this.i]};
			let result = null;
			{
				const temp_1564 = node;
				switch (temp_1564) {
				case 13: {
					{
						this.i++;
						{
							const temp_1565 = this.tok();
							switch (temp_1565) {
							case 21: {
								result = this.parseFunction(false, true)
							} break;
							
							case 40: case 23: {
								{
									const parsed = this.parseVar(true);
									if ((parsed.length > 1)) {} else {
										result = parsed[0];
									};
								}
							} break;
							
							case 7: case 22: {
								result = this.parseClass(true)
							} break;
							
							case 61: {
								{
									const alias = this.parseType();
									this.step(91);
									const value_1566 = this.parseType();
									result = /*TypeAlias*/[9,alias,value_1566];
								}
							} break;
							
							default: 
							this.fail(('Wrong `declare` format, got `' + (Token.stringify(this.tok())) + '`'))
							};
						};
					}
				} break;
				
				case 74: {
					{
						this.i++;
						if ((this.tok() == 73)) {
							this.i++;
							result = /*Block*/[12,[]];
						} else if ((this.tok() == 62 && this.lex.token[this.i + 1] == 76)) {
							let names = [];
							let el = [];
							while (true) {
								names.push(this.getgo(62));
								this.step(76);
								el.push(this.parseExpr());
								if ((this.tok() == 75)) {
									this.i++;
									if ((this.tok() == 73)) { this.fail('Unexpected `}`, remove trailing `,` comma') };
									continue;
								} else {
									break;
								};
							};
							if ((this.tok() != 73)) { this.fail(('Expected `}` or `,` before `' + (this.print()) + '`')) };
							this.step(73);
							result = /*Object*/[38,names,el];
						} else {
							let el_1567 = [];
							while (this.tok() != 73) {
								el_1567.push(this.parseExpr());
							};
							this.step(73);
							result = /*Block*/[12,el_1567];
						};
					}
				} break;
				
				case 17: {
					{
						this.i++;
						let econd = [this.parseExpr()];
						while (this.tok() == 75) {
							this.next();
							econd.push(this.parseExpr());
						};
						let eif = null;
						let eifAt = this.i;
						if ((this.tok() != 76)) { eif = this.parseExpr() };
						let eelse = null;
						let eelseAt = this.i;
						if ((this.tok() == 10)) {
							this.i++;
							eelse = this.parseExpr();
						};
						if ((eif != null)) {
							const temp_1568 = eif;
							switch (temp_1568&&temp_1568[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							{
								const temp_1569 = this.i;
								this.i = eifAt;
								this.failHint('`if` body must be a `{` block `}`');
								this.i = temp_1569;
							}
							};
						};
						if ((eelse != null)) {
							const temp_1570 = eelse;
							switch (temp_1570&&temp_1570[0]) {
							case 12: {
								{
								}
							} break;
							
							case 14: {
								{
								}
							} break;
							
							default: 
							{
								const temp_1571 = this.i;
								this.i = eelseAt;
								this.failHint('`else` body must be a `{` block `}`');
								this.i = temp_1571;
							}
							};
						};
						result = /*If*/[14,econd,eif,eelse,false];
					}
				} break;
				
				case 41: {
					{
						this.i++;
						let econd_1572 = this.parseExpr();
						let eAt = this.i;
						let e = this.parseExpr();
						{
							const temp_1573 = e;
							switch (temp_1573&&temp_1573[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							{
								const temp_1574 = this.i;
								this.i = eAt;
								this.failHint('`while` body must be a `{` block `}`');
								this.i = temp_1574;
							}
							};
						};
						result = /*While*/[21,econd_1572,e,true];
					}
				} break;
				
				case 9: {
					{
						this.i++;
						let eAt_1575 = this.i;
						let e_1576 = this.parseExpr();
						{
							const temp_1577 = e_1576;
							switch (temp_1577&&temp_1577[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							{
								const temp_1578 = this.i;
								this.i = eAt_1575;
								this.failHint('`do` body must be a `{` block `}`');
								this.i = temp_1578;
							}
							};
						};
						this.step(41);
						let econd_1579 = this.parseExpr();
						result = /*While*/[21,econd_1579,e_1576,false];
					}
				} break;
				
				case 80: {
					{
						const startsAt = this.i;
						this.next();
						if (((this.tok() == 79 && this.offset(1) == 90) || (this.tok() == 62 && this.offset(1) == 75) || (this.tok() == 62 && this.offset(1) == 76) || (this.tok() == 62 && this.offset(1) == 79 && this.offset(2) == 90))) {
							let vars_1580 = [];
							let types_1581 = [];
							let values_1582 = [];
							while (this.tok() != 79) {
								vars_1580.push(this.getgo(62));
								if ((this.tok() == 76)) {
									this.i++;
									types_1581.push(this.parseType());
								};
								if ((this.tok() == 91)) {
									this.i++;
									values_1582.push(this.parseExpr());
								};
								if ((this.tok() == 75)) { this.i++ };
							};
							this.step(79);
							this.step(90);
							let v_1583 = [];
							{
								let i_1584 = 0;
								let it_1585 = 0;
								let at_1586 = vars_1580.length;
								while (it_1585 < at_1586) {
									i_1584 = it_1585;
									it_1585++;
									{
										v_1583.push(/*Var*/[24,vars_1580[i_1584],types_1581[i_1584],values_1582[i_1584],true,false]);
									};
								};
							};
							result = /*Arrow*/[23,this.parseExpr(),v_1583,null];
						} else {
							if ((this.tok() == 0)) {
								this.i = startsAt;
								this.fail('The parenthesis `(` has got unclosed to the end of the file');
							};
							let expr_1587 = this.parseExpr();
							if ((this.tok() == 0)) {
								this.i = startsAt;
								this.fail('The parenthesis `(` has got unclosed to the end of the file');
							};
							this.step(79);
							result = /*Parenthesis*/[15,expr_1587];
						};
					}
				} break;
				
				case 31: {
					{
						this.i++;
						{
							const temp_1588 = this.tok();
							switch (temp_1588) {
							case 73: {
								result = /*Return*/[16,null]
							} break;
							
							case 40: {
								result = /*Return*/[16,null]
							} break;
							
							case 23: {
								result = /*Return*/[16,null]
							} break;
							
							case 4: {
								result = /*Return*/[16,null]
							} break;
							
							case 3: {
								result = /*Return*/[16,null]
							} break;
							
							case 8: {
								result = /*Return*/[16,null]
							} break;
							
							case 31: {
								result = /*Return*/[16,null]
							} break;
							
							default: 
							result = /*Return*/[16,this.parseExpr()]
							};
						};
					}
				} break;
				
				case 35: {
					{
						this.i++;
						result = /*Throw*/[17,this.parseExpr()];
					}
				} break;
				
				case 8: {
					{
						this.i++;
						result = /*Continue*/[19];
					}
				} break;
				
				case 3: {
					{
						this.i++;
						result = /*Break*/[18];
					}
				} break;
				
				case 1: {
					{
						this.i++;
						result = /*Underscore*/[45];
					}
				} break;
				
				case 98: {
					{
						this.i++;
						result = /*Interval*/[46];
					}
				} break;
				
				case 87: case 86: case 89: case 88: case 107: {
					{
						const id = this.lex.token[this.i];
						this.i++;
						const value_1589 = this.parseExpr();
						const fix = (value_1590) => {
							const temp_1591 = value_1590;
							switch (temp_1591&&temp_1591[0]) {
							case 10: {
								const aa = temp_1591[1];
								const op = temp_1591[2];
								const bb = temp_1591[3];
								{
									const out = /*Binop*/[10,fix(aa),op,bb];
									this.project.data.set(out, this.project.data.get(value_1590));
									return out;
								}
							} break;
							
							default: 
							return /*Unop*/[20,id,false,value_1590]
							};
						};
						result = fix(value_1589);
					}
				} break;
				
				case 60: {
					result = /*Float*/[7,parseFloat(this.getgo(60))]
				} break;
				
				case 63: {
					{
						const meta = this.lex.meta[this.i];
						const value_1592 = this.getgo(63);
						{
							const temp_1593 = meta;
							switch (temp_1593) {
							case 0: {
								{
									const at_1594 = this.i;
									const v_1595 = parseInt(value_1592);
									if ((v_1595 > 2147483647 || v_1595 < (-2147483647))) {
										this.i = at_1594;
										this.fail(('Integer `' + (value_1592) + '` is too large for *signed* 32 bit, use `' + (value_1592) + 'u32` or `' + (value_1592) + 'n`'));
									};
									result = /*Int*/[5,v_1595];
								}
							} break;
							
							default: 
							result = /*MetaInt*/[6,BigInt(value_1592),meta]
							};
						};
					}
				} break;
				
				case 61: {
					if ((this.lex.token[this.i + 1] == 99)) {
						let res = this.parseType();
						result = /*NodeTypeValue*/[51,res];
					} else if ((this.lex.token[this.i + 1] == 81)) {
						let name_1596 = this.getgo(61);
						this.i++;
						result = /*NodeTypeValue*/[51,/*Optional*/[0,/*Type*/[1,name_1596,null]]];
					} else {
						let name_1597 = this.getgo(61);
						result = /*NodeTypeValue*/[51,/*Type*/[1,name_1597,null]];
					}
				} break;
				
				case 62: {
					{
						let name_1598 = this.getgo(62);
						if ((this.tok() == 90)) {
							this.next();
							result = /*Arrow*/[23,this.parseExpr(),[/*Var*/[24,name_1598,null,null,true,false]],null];
						} else {
							result = /*Ident*/[1,name_1598];
						};
					}
				} break;
				
				case 66: {
					result = /*String*/[0,this.getgo(66)]
				} break;
				
				case 64: {
					{
						let str_1599 = this.getgo(64);
						if ((this.hasInterpolation(str_1599))) { result = /*Parenthesis*/[15,this.parseInterpolations(str_1599)] } else {
							result = /*String*/[0,str_1599];
						};
					}
				} break;
				
				case 36: {
					{
						this.i++;
						result = /*Bool*/[2,true];
					}
				} break;
				
				case 14: {
					{
						this.i++;
						result = /*Bool*/[2,false];
					}
				} break;
				
				case 34: {
					{
						this.i++;
						result = /*This*/[3];
					}
				} break;
				
				case 26: {
					{
						this.i++;
						result = /*Null*/[8];
					}
				} break;
				
				case 59: {
					{
						this.i++;
						result = /*Super*/[4];
					}
				} break;
				
				case 40: {
					{
						let parsed_1600 = this.parseVar();
						if ((parsed_1600.length > 1)) {} else {
							result = parsed_1600[0];
						};
					}
				} break;
				
				case 23: {
					{
						let parsed_1601 = this.parseVar();
						if ((parsed_1601.length > 1)) {} else {
							result = parsed_1601[0];
						};
					}
				} break;
				
				case 37: {
					{
						this.i++;
						const exprAt = this.i;
						const expr_1602 = this.parseExpr();
						{
							const temp_1603 = expr_1602;
							switch (temp_1603&&temp_1603[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							{
								const temp_1604 = this.i;
								this.i = exprAt;
								this.failHint('`try` body must be a `{` block `}`');
								this.i = temp_1604;
							}
							};
						};
						let vars_1605 = [];
						let t_1606 = [];
						let v_1607 = [];
						let catches = [];
						while (this.tok() == 6) {
							this.step(6);
							const name_1608 = this.getgo(62);
							vars_1605.push(name_1608);
							this.step(76);
							const type_1609 = this.parseType();
							t_1606.push(type_1609);
							v_1607.push(/*Var*/[24,name_1608,type_1609,null,true,false]);
							const exprAt_1610 = this.i;
							const expr_1611 = this.parseExpr();
							{
								const temp_1612 = expr_1611;
								switch (temp_1612&&temp_1612[0]) {
								case 12: {
									{
									}
								} break;
								
								default: 
								{
									const temp_1613 = this.i;
									this.i = exprAt_1610;
									this.failHint('`catch` body must be a `{` block `}`');
									this.i = temp_1613;
								}
								};
							};
							catches.push(expr_1611);
						};
						result = /*Try*/[27,expr_1602,t_1606,v_1607,catches];
					}
				} break;
				
				case 2: {
					{
						this.i++;
						if ((this.tok() == 64)) {
							result = /*Import*/[37,[],this.getgo(64)];
							this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
							return result;
						};
						let el_1614 = [];
						while (true) {
							if (this.tok() == 62) { el_1614.push(/*Lower*/[0,this.getgo(62)]) } else if ((this.tok() == 61)) { el_1614.push(/*Upper*/[1,this.getgo(61)]) } else if ((this.tok() == 102)) {
								this.i++;
								this.step(58);
								el_1614.push(/*As*/[3,/*AllTheThings*/[2],/*Lower*/[0,this.getgo(62)]]);
							} else {
								this.fail('Incorrect `import` syntax');
							};
							if ((this.tok() == 58)) {
								this.i++;
								if ((this.tok() == 62)) { el_1614.push(/*As*/[3,el_1614.pop(),/*Lower*/[0,this.getgo(62)]]) } else if ((this.tok() == 61)) { el_1614.push(/*As*/[3,el_1614.pop(),/*Upper*/[1,this.getgo(61)]]) } else {
									this.fail('Incorrect `import x as y` syntax');
								};
							};
							if ((this.tok() == 75)) { this.i++ } else {
								break;
							};
						};
						this.step(20);
						result = /*Import*/[37,el_1614,this.getgo(64)];
						this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
						return result;
					}
				} break;
				
				case 11: {
					{
						this.i++;
						let t_1615 = this.parseType();
						let valuesType = null;
						if ((this.tok() == 76)) {
							this.i++;
							valuesType = this.parseType();
						};
						let extend = null;
						if ((this.tok() == 12)) {
							this.i++;
							extend = this.parseType();
						};
						this.step(74);
						let names_1616 = [];
						while (this.tok() != 73) {
							while (this.tok() == 70) {
								atts_1563.push(this.parseDecorator());
							};
							atts_1563 = [];
							names_1616.push(this.parseExpr());
						};
						this.step(73);
						result = /*Enum*/[39,t_1615,names_1616,valuesType,extend];
					}
				} break;
				
				case 7: case 22: {
					{
						let att = atts_1563;
						atts_1563 = [];
						const me = this.parseClass();
						this.project.mapDecorators.set(me, att);
						result = me;
					}
				} break;
				
				case 21: {
					result = this.parseFunction()
				} break;
				
				case 72: {
					{
						this.i++;
						let el_1617 = [];
						let values_1618 = [];
						let isMap = false;
						if (this.tok() != 71) { while (true) {
							if ((this.tok() == 76)) {
								isMap = true;
								this.next();
								break;
							};
							el_1617.push(this.parseExpr());
							if ((this.tok() == 76)) {
								this.i++;
								values_1618.push(this.parseExpr());
								isMap = true;
							};
							if ((this.tok() == 75)) {
								this.i++;
								if ((this.tok() == 71)) { this.fail('Unexpected `]`, remove trailing comma `,` before `]` or add a value after `,` if required') };
							} else {
								break;
							};
						} };
						this.step(71);
						if (isMap) { result = /*Map*/[32,el_1617,values_1618] } else {
							result = /*Array*/[31,el_1617];
						};
					}
				} break;
				
				case 25: {
					{
						this.i++;
						let t_1619 = this.parseType();
						let names_1620 = [];
						let values_1621 = [];
						if ((this.tok() == 74)) {
							this.i++;
							if ((this.tok() == 73)) { this.step(73) } else if ((this.tok() == 62 && this.lex.token[this.i + 1] == 76)) {
								while (this.tok() != 73) {
									names_1620.push(this.getgo(62));
									this.step(76);
									values_1621.push(this.parseExpr());
									if ((this.tok() == 75)) { this.i++ };
								};
								this.step(73);
							};
						};
						this.step(80);
						let args = [];
						let argNames = [];
						if ((this.tok() != 79)) { while (true) {
							{
								const temp_1622 = this.tok();
								switch (temp_1622) {
								case 79: {
									this.fail('Unexpected `)`, remove trailing `,` comma')
								} break;
								
								case 61: {
									{
										argNames.push(null);
										args.push(this.parseExpr());
										if ((this.tok() == 76)) {
											this.step(76);
											this.parseType();
										};
									}
								} break;
								
								default: 
								{
									if ((this.lex.token[this.i + 1] == 76)) {
										argNames.push(this.getgo(62));
										this.step(76);
									} else {
										argNames.push(null);
									};
									args.push(this.parseExpr());
								}
								};
							};
							if ((this.tok() == 75)) { this.i++ } else {
								break;
							};
						} };
						this.step(79);
						result = /*New*/[30,[],t_1619,args,names_1620,values_1621,argNames];
					}
				} break;
				
				case 33: {
					{
						this.i++;
						let exprs = [this.parseExpr()];
						while (this.tok() == 75) {
							this.i++;
							exprs.push(this.parseExpr());
						};
						this.step(74);
						let cases = [];
						let conds = [];
						let guards = [];
						while (this.tok() != 73) {
							this.step(4);
							if ((this.tok() == 1)) {
								conds.push(/*Underscore*/[45]);
								this.i++;
							} else {
								conds.push(this.parseExpr());
							};
							if ((this.tok() == 17)) {
								this.i++;
								guards.push(this.parseExpr());
							} else {
								guards.push(null);
							};
							this.step(76);
							let exs = [];
							while (this.tok() != 4 && this.tok() != 73) {
								exs.push(this.parseExpr());
							};
							cases.push(/*Block*/[12,exs]);
						};
						this.step(73);
						result = /*Switch*/[34,exprs,conds,guards,cases];
					}
				} break;
				
				case 15: {
					{
						this.i++;
						if ((this.tok() == 23 || this.tok() == 40)) {
							this.i++;
							let name_1623 = this.getgo(62);
							{
								if (this.print() == 'of' || this.print() == 'in') {
									this.i++;
									let values_1624 = this.print();
									this.i++;
									while (this.tok() != 79 && this.tok() != 0) {
										if ((this.tok() == 107 || this.tok() == 111)) { values_1624 += ' ' + this.print() + ' ' } else {
											values_1624 += this.print();
										};
										this.i++;
									};
									this.fail(('This loop should be replaced to `for ' + (name_1623) + ' in ' + (values_1624) + '`'));
								};
							};
							let classic = true;
							if ((this.tok() == 91)) { this.i++ } else {
								classic = false;
							};
							let specialCase = '';
							if ((this.tok() == 63) && (this.lex.value[this.i] == '0')) { this.i++ } else {
								while (this.tok() == 62 || this.tok() == 61 || this.tok() == 80 || this.tok() == 79 || this.tok() == 111 || this.tok() == 107 || this.tok() == 63 || this.tok() == 102 || this.tok() == 77) {
									if ((this.tok() == 107 || this.tok() == 111)) { specialCase += ' ' + this.print() + ' ' } else {
										specialCase += this.print();
									};
									this.i++;
								};
							};
							if ((this.tok() == 82)) { this.i++ } else {
								classic = false;
							};
							if ((this.tok() == 62) && (this.lex.value[this.i] == name_1623)) { this.i++ } else {
								classic = false;
							};
							let lesserOrEqual = false;
							if ((this.tok() == 99)) { this.i++ } else if ((this.tok() == 100)) {
								this.i++;
								lesserOrEqual = true;
							} else {
								classic = false;
							};
							let values_1625 = this.print();
							this.i++;
							while (this.tok() == 62 || this.tok() == 61 || this.tok() == 80 || this.tok() == 79 || this.tok() == 111 || this.tok() == 107 || this.tok() == 63 || this.tok() == 102 || this.tok() == 77) {
								if ((this.tok() == 107 || this.tok() == 111)) { values_1625 += ' ' + this.print() + ' ' } else {
									values_1625 += this.print();
								};
								this.i++;
							};
							if (lesserOrEqual) { values_1625 += ' + 1' };
							if ((this.tok() == 82)) { this.i++ } else {
								classic = false;
							};
							if ((this.tok() == 62) && (this.lex.value[this.i] == name_1623)) {
								this.i++;
								if ((this.tok() == 87)) { this.i++ } else {
									classic = false;
								};
							} else if ((this.tok() == 87)) {
								this.i++;
								if ((this.tok() == 62) && (this.lex.value[this.i] == name_1623)) { this.i++ } else {
									classic = false;
								};
							} else {
								classic = false;
							};
							if ((this.tok() == 79)) {} else {
								classic = false;
							};
							if ((classic) && (specialCase == '')) { this.fail(('This loop should be replaced to `for ' + (name_1623) + ' in ' + (values_1625) + '`')) };
							if (classic) { this.fail(('This loop should be replaced to `for ' + (name_1623) + ' in ' + (specialCase) + ' ... ' + (values_1625) + '`')) };
							this.fail(('Hexa has only `for ' + (name_1623) + ' in values` syntax'));
						};
						let name_1626 = this.getgo(62);
						this.step(20);
						let values_1627 = this.parseExpr();
						let range = null;
						if ((this.tok() == 98)) {
							this.i++;
							range = this.parseExpr();
						};
						let expression = this.parseExpr();
						result = /*For*/[49,name_1626,values_1627,expression,range];
					}
				} break;
				
				case 32: {
					{
						this.next();
						result = /*Static*/[47,this.parseExpr()];
					}
				} break;
				
				case 29: {
					{
						this.next();
						result = /*Private*/[48,this.parseExpr()];
					}
				} break;
				
				default: 
				this.unexpected()
				};
			};
			if ((result == null)) {
				process_99.stdout.write('\n');
				this.fail('Expression is incomplete, current token is: ' + Token.stringify(this.tok()));
			};
			this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
			if ((atts_1563.length > 0)) {
				this.project.mapDecorators.set(result, atts_1563);
				atts_1563 = [];
			};
			let done = this.i >= this.lex.length;
			while ((!done)) {
				this.project.data.set(result, new NodeData(this.lex.line[this.i], this.lex.column[this.i], this.lex.fileName));
				{
					const temp_1628 = this.tok();
					switch (temp_1628) {
					case 0: {
						done = true
					} break;
					
					case 72: {
						{
							this.i++;
							let index = this.parseExpr();
							if ((this.tok() == 75)) { this.fail('Expected `]` instead of `,` comma. Hexa supports only one `[index]` value.\n' + ('Note, you are indexing this expression: `' + (Node.stringify(result)) + '[' + (Node.stringify(index)) + ']`\n') + ('To create array here, wrap it with `{` as `{[' + (Node.stringify(index)) + ', ...]}` so it doesn\'t index previous expression.')) };
							this.step(71);
							result = /*Index*/[33,result,index];
						}
					} break;
					
					case 57: {
						{
							this.i++;
							{
								const temp_1629 = this.tok();
								switch (temp_1629) {
								case 61: {
									result = /*Is*/[43,result,this.parseType()]
								} break;
								
								default: 
								this.fail('Cannot parse type `' + Token.stringify(this.tok()) + '`')
								};
							};
						}
					} break;
					
					case 58: {
						{
							this.i++;
							let kind_1630 = this.tok();
							if ((this.tok() == 89)) { this.i++ } else if ((this.tok() == 81)) { this.i++ } else {
								kind_1630 = 123;
							};
							result = /*As*/[44,result,kind_1630,this.parseType()];
						}
					} break;
					
					case 80: {
						{
							let args_1631 = [];
							let argNames_1632 = [];
							this.i++;
							if (this.tok() != 79) { while (true) {
								{
									const temp_1633 = this.tok();
									switch (temp_1633) {
									case 79: {
										this.fail('Unexpected `)`, remove trailing `,` comma')
									} break;
									
									case 61: {
										{
											argNames_1632.push(null);
											args_1631.push(this.parseExpr());
											if ((this.tok() == 76)) {
												this.step(76);
												this.parseType();
											};
										}
									} break;
									
									default: 
									{
										if ((this.tok() == 62) && (this.lex.token[this.i + 1] == 76)) {
											argNames_1632.push(this.getgo(62));
											this.step(76);
										} else {
											argNames_1632.push(null);
										};
										args_1631.push(this.parseExpr());
									}
									};
								};
								if ((this.tok() == 75)) { this.i++ } else {
									break;
								};
							} };
							this.step(79);
							result = /*Call*/[13,result,args_1631,argNames_1632];
						}
					} break;
					
					case 90: {
						{
							this.next();
							result = /*Arrow*/[23,this.parseExpr(),[result],null];
						}
					} break;
					
					case 87: {
						{
							{
								const temp_1634 = result;
								switch (temp_1634&&temp_1634[0]) {
								case 20: {
									return result
								} break;
								};
							};
							this.i++;
							result = /*Unop*/[20,87,true,result];
						}
					} break;
					
					case 86: {
						{
							{
								const temp_1635 = result;
								switch (temp_1635&&temp_1635[0]) {
								case 20: {
									return result
								} break;
								};
							};
							this.i++;
							result = /*Unop*/[20,86,true,result];
						}
					} break;
					
					case 77: {
						{
							this.i++;
							{
								const temp_1636 = this.tok();
								switch (temp_1636) {
								case 61: {
									result = /*DotUpper*/[29,result,this.getgo(61)]
								} break;
								
								default: 
								result = /*Dot*/[28,result,this.getgo(62)]
								};
							};
						}
					} break;
					
					case 81: {
						{
							this.i++;
							if ((this.tok() == 77)) {
								let name_1637 = this.getgo(62);
								result = /*Dot*/[28,result,name_1637];
							} else if ((this.tok() == 81)) {
								this.i++;
								result = /*Elvis*/[50,result,this.parseExpr()];
							} else {
								let eif_1638 = this.parseExpr();
								this.step(76);
								let eelse_1639 = this.parseExpr();
								result = /*If*/[14,[result],eif_1638,eelse_1639,true];
							};
						}
					} break;
					
					case 113: {
						{
							this.i++;
							result = this.parseExpr();
						}
					} break;
					
					default: 
					{
						const t_1640 = this.tok();
						if ((Parser.isBinop(t_1640) && this.offset(1) == 91)) {
							let op_1641 = this.tok();
							this.i++;
							this.i++;
							let b = this.parseExpr();
							result = /*AssignOp*/[11,result,op_1641,b];
						} else if ((Parser.isBinop(t_1640))) {
							this.i++;
							let b_1642 = this.parseExpr();
							let a = result;
							{
								const temp_1643 = b_1642;
								switch (temp_1643&&temp_1643[0]) {
								case 10: {
									const aa_1644 = temp_1643[1];
									const op_1645 = temp_1643[2];
									const bb_1646 = temp_1643[3];
									{
										let tp = Parser.precedence(t_1640);
										let tLeft = tp > 99;
										tp = tp % 100;
										let bp = Parser.precedence(op_1645);
										let bLeft = bp > 99;
										bp = bp % 100;
										if ((bp > tp)) {
											const eb = /*Binop*/[10,result,t_1640,aa_1644];
											this.project.data.set(eb, (() => {
												const result_1647 = this.project.data.get(result);
												if (result_1647 != null) { return result_1647 };
												return (() => {
													const result_1648 = this.project.data.get(b_1642);
													if (result_1648 != null) { return result_1648 };
													return this.project.data.get(aa_1644);
												})();
											})());
											result = /*Binop*/[10,eb,op_1645,bb_1646];
										} else {
											result = /*Binop*/[10,result,t_1640,b_1642];
										};
									}
								} break;
								
								case 14: {
									const econd_1649 = temp_1643[1];
									const eif_1650 = temp_1643[2];
									const eelse_1651 = temp_1643[3];
									const ternary = temp_1643[4];
									if ((ternary == true && t_1640 != 91)) { result = /*If*/[14,[/*Binop*/[10,result,t_1640,econd_1649[0]]],eif_1650,eelse_1651,true] } else {
										result = /*Binop*/[10,result,t_1640,b_1642];
									}
								} break;
								
								default: 
								result = /*Binop*/[10,result,t_1640,b_1642]
								};
							};
						} else {
							done = true;
						};
					}
					};
				};
			};
			if ((result == null)) {
				process_99.stdout.write('\n');
				this.fail('Expression postfix is incomplete');
			};
			if ((atts_1563.length > 0)) {
				this.project.mapDecorators.set(result, atts_1563);
				atts_1563 = [];
			};
			this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
			return result;
		};
		parseVar(external) {
			let const_1652 = this.tok() == 23;
			this.i++;
			let vars_1653 = [];
			if ((this.tok() == 83)) {
				this.i++;
				const name_1654 = ((this.tok() == 62))? (this.print()) : 'name';
				const prefix = (const_1652)? ('let') : 'var';
				this.fail(('Hexa doesn\'t support PHP-style variables, replace it to `' + (prefix) + ' ' + (name_1654) + '`'));
			};
			const parseSingleVar = () => {
				let varname = this.getgo(62);
				if ((varname.endsWith('___'))) { this.fail('Variables can\'t end with `___`, it is reserved.') };
				let type_1655 = null;
				if ((this.tok() == 76)) {
					this.i++;
					type_1655 = this.parseType();
				};
				let expr_1656 = null;
				if ((this.tok() == 91)) {
					this.i++;
					expr_1656 = this.parseExpr();
				};
				return /*Var*/[24,varname,type_1655,expr_1656,const_1652,(() => {
					const result_1657 = external;
					if (result_1657 != null) { return result_1657 };
					return false;
				})()];
			};
			const parseSingleBinding = () => {
				let path = [];
				while (this.tok() == 62 && this.offset(1) == 77) {
					path.push(this.getgo(62));
					this.i++;
				};
				path.push(this.getgo(61));
				this.step(77);
				path.push(this.getgo(61));
				if ((this.tok() == 80 && this.offset(1) == 79)) { this.fail('Don\'t use empty parenthesis for `let ' + path.join('.') + '()` bindings') };
				let bind = [];
				if ((this.tok() == 80)) {
					do {{
						this.i++;
						if ((this.tok() == 1)) {
							this.i++;
							bind.push(null);
						} else {
							bind.push(/*Var*/[24,this.getgo(62),null,null,const_1652,false]);
						};
					}} while (this.tok() == 75);
					this.step(79);
				};
				this.step(91);
				let expr_1658 = this.parseExpr();
				return /*EnumExtract*/[40,path,bind,expr_1658];
			};
			vars_1653.push(parseSingleVar());
			return vars_1653;
			let const_1659 = this.tok() == 23;
			this.i++;
			let vars_1660 = [];
			{
				const temp_1661 = this.tok();
				switch (temp_1661) {
				case 62: {
					while (true) {
						let varname_1662 = this.getgo(62);
						if ((varname_1662.endsWith('___'))) { this.fail('Variables can\'t end with `___`, it is reserved.') };
						let type_1663 = null;
						if ((this.tok() == 76)) {
							this.i++;
							type_1663 = this.parseType();
						};
						let expr_1664 = null;
						if ((this.tok() == 91)) {
							this.i++;
							expr_1664 = this.parseExpr();
						};
						vars_1660.push(/*Var*/[24,varname_1662,type_1663,expr_1664,const_1659,external]);
						if ((this.tok() == 75 && this.offset(1) == 62 && (this.offset(2) == 91 || this.offset(2) == 76))) { this.i++ } else {
							break;
						};
					}
				} break;
				
				case 61: {
					{
						let left = /*Ident*/[1,this.getgo(61)];
						let res_1665 = left;
						while (this.tok() == 77) {
							res_1665 = /*Dot*/[28,res_1665,this.getgo(61)];
						};
						{
							const temp_1666 = this.tok();
							switch (temp_1666) {
							case 80: {
								{
									let args_1667 = [];
									while (this.tok() != 79) {
										args_1667.push(this.getgo(62));
									};
									this.step(91);
									let varname_1668 = this.getgo(62);
								}
							} break;
							
							case 91: {
								{
								}
							} break;
							
							default: 
							this.fail('Wrong syntax')
							};
						};
					}
				} break;
				
				default: 
				this.fail('Wrong syntax')
				};
			};
			return vars_1660;
		};
		parseFunction(parseBody, external_1669) {
			const parseBody_1670 = ((parseBody != null))? (parseBody) : true;
			this.i++;
			let expr_1671 = null;
			let name_1672 = null;
			let vars_1673 = [];
			let atts_1674 = [];
			let types_1675 = [];
			let values_1676 = [];
			let pos_1677 = [];
			{
				const temp_1678 = this.tok();
				switch (temp_1678) {
				case 62: {
					name_1672 = this.getgo(62)
				} break;
				
				case 61: {
					this.fail(('Function names can\'t start with uppercase `' + (this.print()) + '` -> `' + (this.print().toLowerCase()) + '`'))
				} break;
				
				default: 
				{
				}
				};
			};
			this.step(80);
			{
				if (this.tok() != 79) { while (true) {
					const decorators = [];
					while (this.tok() == 70) {
						decorators.push(this.parseDecorator());
					};
					let expr_1679 = null;
					let t_1680 = null;
					if ((this.tok() == 98)) { this.i++ };
					pos_1677.push({line:this.lex.line[this.i], column:this.lex.column[this.i]});
					let name_1681 = this.getgo(62);
					if ((this.tok() == 76)) {
						this.i++;
						t_1680 = this.parseType();
					};
					if ((this.tok() == 91)) {
						this.i++;
						expr_1679 = this.parseExpr();
					};
					vars_1673.push(name_1681);
					atts_1674.push(decorators);
					types_1675.push(t_1680);
					values_1676.push(expr_1679);
					if ((this.tok() == 75)) { this.i++ } else {
						break;
					};
				} };
				this.step(79);
			};
			let rettype = null;
			if ((this.tok() == 76)) {
				this.i++;
				rettype = this.parseType();
			};
			if (parseBody_1670) {
				const temp_1682 = this.tok();
				switch (temp_1682) {
				case 25: {
					if ((this.lex.token[this.i + 1] == 80)) {} else {
						expr_1671 = this.parseExpr();
					}
				} break;
				
				case 73: {
					{
					}
				} break;
				
				case 32: {
					{
					}
				} break;
				
				case 29: {
					{
					}
				} break;
				
				case 21: {
					{
					}
				} break;
				
				case 40: {
					{
					}
				} break;
				
				case 23: {
					{
					}
				} break;
				
				case 70: {
					{
						let tmp_1683 = this.i;
						while (this.tok() == 70) {
							this.parseDecorator();
						};
						if ((this.tok() != 73 && this.tok() != 32 && this.tok() != 29 && this.tok() != 21)) {
							this.i = tmp_1683;
							expr_1671 = this.parseExpr();
						} else {
							this.i = tmp_1683;
						};
					}
				} break;
				
				default: 
				expr_1671 = this.parseExpr()
				};
			};
			let v_1684 = [];
			{
				let i_1685 = 0;
				let it_1686 = 0;
				let at_1687 = vars_1673.length;
				while (it_1686 < at_1687) {
					i_1685 = it_1686;
					it_1686++;
					{
						const n_1688 = /*Var*/[24,vars_1673[i_1685],types_1675[i_1685],values_1676[i_1685],true,false];
						this.project.data.set(n_1688, new NodeData(pos_1677[i_1685].line, pos_1677[i_1685].column, this.lex.fileName));
						{
							let step_1689 = 0;
							const decorators_1690 = atts_1674[i_1685];
							if (step_1689 == 0 && decorators_1690 != null) { step_1689 = 1 };
							if (step_1689 == 1) { this.project.mapDecorators.set(n_1688, decorators_1690) };
						};
						v_1684.push(n_1688);
					};
				};
			};
			{
				const temp_1691 = expr_1671;
				switch (temp_1691&&temp_1691[0]) {
				case null: case undefined: {
					{
					}
				} break;
				
				case 12: {
					{
					}
				} break;
				
				default: 
				{
					const named = (() => {
						const result_1692 = name_1672;
						if (result_1692 != null) { return result_1692 };
						return 'fun';
					})();
					this.i--;
					this.fail(('Function `' + (named) + '` should have a `{ block }` as a body'));
				}
				};
			};
			return /*Function*/[22,name_1672,expr_1671,v_1684,rettype,external_1669];
		};
		parseClass(external_1693) {
			const _classExternal = this.classExternal;
			this.classExternal = external_1693;
			let isInterface = (this.tok() == 22)? (1) : 0;
			this.i++;
			let t_1694 = this.parseType();
			let ext = ((this.tok() == 12))? ((() => {
				this.i++;
				return this.parseType();
			})()) : (null);
			let impl = [];
			while (this.tok() == 18) {
				this.i++;
				impl.push(this.parseType());
			};
			this.step(74);
			let fields_1695 = this.parseFields();
			this.step(73);
			let me_1696 = /*Class*/[25,t_1694,ext,impl,fields_1695,(() => {
				const result_1697 = external_1693;
				if (result_1697 != null) { return result_1697 };
				return false;
			})(),isInterface];
			this.classExternal = _classExternal;
			return me_1696;
		};
		hasInterpolation(str_1698) {
			let chars = str_1698.split('');
			let i_1699 = 0;
			while (i_1699 < chars.length) {
				if ((chars[i_1699] == '\\')) { if ((i_1699 + 1 < chars.length)) { if ((chars[i_1699 + 1] == '\\')) { i_1699++ } else if ((chars[i_1699 + 1] == '(')) { return true } } };
				i_1699++;
			};
			return false;
		};
		parseInterpolations(str_1700) {
			const interpolate = (s) => {
				let out_1701 = ['"'];
				if (s.length < 2) { return s };
				let i_1702 = 0;
				const s_1703 = s.split('"').join('\\"');
				const pushInterpolator = () => {
					i_1702++;
					i_1702++;
					const pushParen = () => {
						i_1702++;
						while (i_1702 < s_1703.length) {
							out_1701.push(s_1703.charAt(i_1702));
							if (s_1703.charAt(i_1702) == '(') {
								pushParen();
								continue;
							};
							if (s_1703.charAt(i_1702) == ')') {
								i_1702++;
								return;
							};
							i_1702++;
						};
						throw 'String interpolation error: unclosed inner parenthesis';
					};
					while (i_1702 < s_1703.length) {
						out_1701.push(s_1703.charAt(i_1702));
						if ((s_1703.charAt(i_1702) == '(')) {
							pushParen();
							continue;
						};
						if ((s_1703.charAt(i_1702) == ')')) {
							i_1702++;
							return;
						};
						i_1702++;
					};
					throw 'String interpolation error: unclosed parenthesis';
				};
				let result_1704 = ['"'];
				while (i_1702 < s_1703.length) {
					if (s_1703.charAt(i_1702) == '\\' && s_1703.charAt(i_1702 + 1) == '(') {
						result_1704.push('" + ');
						out_1701.push('" + (');
						let ii = i_1702 + 1;
						pushInterpolator();
						result_1704.push(s_1703.substring(ii, i_1702 + 1));
						result_1704.push(' + "');
						out_1701.push(' + "');
					} else {
						out_1701.push(s_1703.charAt(i_1702));
						result_1704.push(s_1703.charAt(i_1702));
						i_1702++;
					};
				};
				result_1704.push('"');
				out_1701.push('"');
				return out_1701.join('');
			};
			let resStr = interpolate(str_1700);
			let tokens = Lexer.tokenize(Buffer.from(resStr), this.lex.fileName);
			try {
				let parsed_1706 = Parser.toNode(Parser.parseNodes(tokens, this.project));
				{
					const temp_1707 = parsed_1706;
					switch (temp_1707&&temp_1707[0]) {
					case 12: {
						throw 'Parse interpolation error: got a block'
					} break;
					
					default: 
					return parsed_1706
					};
				};
			} catch (temp_1705) {
				if (true) { 
				const e = temp_1705
				{
					this.fail('Parse interpolation error: ' + e);
				} } else
				
				throw temp_1705;
			};
		};
		parseDecorator() {
			this.i++;
			let name_1708 = this.getgo(62);
			let values_1709 = [];
			if (this.tok() == 80) {
				this.i++;
				if (this.tok() != 79) { while (true) {
					values_1709.push(this.parseExpr());
					if (this.tok() == 75) { this.i++ } else {
						break;
					};
				} };
				this.step(79);
			};
			return new Decorator(name_1708, values_1709);
		};
		parseType() {
			if ((this.tok() == 63)) { return /*Int*/[6,parseInt(this.getgo(63))] };
			if ((this.tok() == 60)) { return /*Float*/[7,parseFloat(this.getgo(60))] };
			if ((this.tok() == 64)) { return /*String*/[8,this.getgo(64)] };
			if ((this.tok() == 62 && this.offset(1) == 80)) {
				const name_1710 = this.getgo(62);
				this.i++;
				const argNames_1711 = [];
				const values_1712 = [];
				while (this.tok() != 79) {
					if (this.tok() == 62) {
						argNames_1711.push(this.getgo(62));
						this.step(76);
					} else {
						argNames_1711.push(null);
					};
					values_1712.push(this.parseType());
					if (this.tok() == 79) { break } else {
						this.step(75);
					};
				};
				this.step(79);
				return /*Call*/[9,name_1710,argNames_1711,values_1712];
			};
			const path_1713 = ((this.tok() == 62 && this.offset(1) == 77))? ((() => {
				const result_1714 = this.getgo(62);
				this.i++;
				return result_1714;
			})()) : null;
			let result_1715 = null;
			{
				const temp_1716 = this.tok();
				switch (temp_1716) {
				case 61: {
					{
						let name_1717 = this.getgo(61);
						while (this.tok() == 77) {
							this.i++;
							this.getgo(61);
						};
						let sresult = (this.tok() == 99)? ((() => {
							this.i++;
							this.parametricTypeNesting++;
							let params = [this.parseType()];
							while (this.tok() == 75) {
								this.i++;
								params.push(this.parseType());
							};
							if (this.parametricTypeNestingToken == 0) { this.parametricTypeNestingToken = this.tok() };
							{
								const temp_1718 = this.parametricTypeNestingToken;
								switch (temp_1718) {
								case 96: {
									{
										this.parametricTypeNesting -= 1;
										this.parametricTypeNestingToken = 0;
										this.i++;
									}
								} break;
								
								case 106: {
									{
										this.parametricTypeNesting -= 1;
										this.parametricTypeNestingToken = 96;
									}
								} break;
								
								case 108: {
									{
										this.parametricTypeNesting -= 1;
										this.parametricTypeNestingToken = 108;
									}
								} break;
								
								default: 
								this.unexpected()
								};
							};
							if ((this.parametricTypeNesting < 0)) { this.fail('parametricTypeNesting < 0') };
							return /*ParametricType*/[2,name_1717,params,path_1713];
						})()) : /*Type*/[1,name_1717,path_1713];
						if ((this.tok() == 90)) {
							this.i++;
							sresult = /*Function*/[3,[sresult],this.parseType()];
						};
						result_1715 = sresult;
					}
				} break;
				
				case 72: {
					{
						if (path_1713 != null) { this.fail('This path syntax is incorrect') };
						this.i++;
						let res_1719 = null;
						{
							const temp_1720 = this.tok();
							switch (temp_1720) {
							case 71: {
								{
									this.i++;
									res_1719 = /*ParametricType*/[2,'Array',[/*Object*/[5,[],[]]],path_1713];
								}
							} break;
							
							case 76: {
								{
									this.i++;
									if ((this.tok() == 71)) {
										this.i++;
										res_1719 = /*ParametricType*/[2,'Map',[/*Object*/[5,[],[]], /*Object*/[5,[],[]]],path_1713];
									} else {
										res_1719 = /*ParametricType*/[2,'Map',[/*Object*/[5,[],[]], this.parseType()],path_1713];
									};
								}
							} break;
							
							default: 
							{
								let key = this.parseType();
								let innerRes = ((this.tok() == 76))? ((() => {
									this.i++;
									return /*ParametricType*/[2,'Map',[key, this.parseType()],path_1713];
								})()) : /*ParametricType*/[2,'Array',[key],path_1713];
								this.step(71);
								if ((this.tok() == 90)) {
									this.i++;
									innerRes = /*Function*/[3,[res_1719],this.parseType()];
								};
								res_1719 = innerRes;
							}
							};
						};
						result_1715 = res_1719;
					}
				} break;
				
				case 74: {
					{
						if (path_1713 != null) { this.fail('This path syntax is incorrect') };
						this.i++;
						let sresult_1721 = ((this.tok() == 73))? (/*Object*/[5,[],[]]) : (() => {
							let names_1722 = [];
							let types_1723 = [];
							while (this.tok() != 73) {
								names_1722.push(this.getgo(62));
								if ((this.tok() == 76)) {
									this.i++;
									types_1723.push(this.parseType());
								};
								if ((this.tok() == 75)) { this.i++ };
							};
							return /*Object*/[5,names_1722,types_1723];
						})();
						this.step(73);
						if ((this.tok() == 90)) {
							this.i++;
							sresult_1721 = /*Function*/[3,[sresult_1721],this.parseType()];
						};
						result_1715 = sresult_1721;
					}
				} break;
				
				case 80: {
					{
						if (path_1713 != null) { this.fail('This path syntax is incorrect') };
						this.i++;
						let args_1724 = [];
						while (this.tok() != 79) {
							if (this.tok() == 62) {
								this.step(62);
								this.step(76);
							};
							args_1724.push(this.parseType());
							if (this.tok() == 75) { this.i++ };
						};
						this.step(79);
						this.step(90);
						result_1715 = /*Function*/[3,args_1724,this.parseType()];
					}
				} break;
				
				case 62: {
					{
						let res_1725 = null;
						{
							const temp_1726 = this.offset(1);
							switch (temp_1726) {
							case 76: {
								{
									let argName = this.getgo(this.tok());
									this.step(76);
									let argType = this.parseType();
									res_1725 = /*FunctionArg*/[4,argName,argType,null];
								}
							} break;
							
							default: 
							this.fail(('Type name `' + (this.print()) + '` can not start with lowercase'))
							};
						};
						result_1715 = res_1725;
					}
				} break;
				
				default: 
				this.fail('Expected type, parsed `' + Token.stringify(this.tok()) + '`')
				};
			};
			if (this.tok() == 81) { result_1715 = /*Optional*/[0,result_1715] };
			while (this.tok() == 81) {
				this.i++;
			};
			if (this.tok() == 90) {
				this.i++;
				result_1715 = /*Function*/[3,[result_1715],this.parseType()];
			};
			return result_1715;
		};
	}
	Parser.toNode = (nodes) => {
			if ((nodes.length == 0)) { return null };
			if ((nodes.length > 1)) { return /*Block*/[12,nodes] };
			return nodes[0];
		};
	Parser.parseNodes = (lexe, project, lint = false) => {
			const parser = new Parser(lexe, project, lint);
			if ((parser.hints.length > 0)) { throw new CompilerErrors(parser.hints) };
			return parser.nodes;
		};
	Parser.precedence = (op_1727) => {
			const left_1728 = 100;
			const right = 0;
			{
				const temp_1729 = op_1727;
				switch (temp_1729) {
				case 101: {
					return 100
				} break;
				
				case 102: {
					return 101
				} break;
				
				case 94: {
					return 101
				} break;
				
				case 110: {
					return 101
				} break;
				
				case 111: {
					return 102
				} break;
				
				case 107: {
					return 102
				} break;
				
				case 105: {
					return 103
				} break;
				
				case 106: {
					return 103
				} break;
				
				case 108: {
					return 103
				} break;
				
				case 104: {
					return 104
				} break;
				
				case 112: {
					return 104
				} break;
				
				case 109: {
					return 104
				} break;
				
				case 95: {
					return 105
				} break;
				
				case 103: {
					return 105
				} break;
				
				case 96: {
					return 105
				} break;
				
				case 99: {
					return 105
				} break;
				
				case 97: {
					return 105
				} break;
				
				case 100: {
					return 105
				} break;
				
				case 92: {
					return 107
				} break;
				
				case 93: {
					return 108
				} break;
				
				case 91: {
					return 10
				} break;
				
				default: 
				this.fail('No precedence for ' + Token.stringify(op_1727))
				};
			};
		};
	Parser.isBinop = (t_1730) => {
			const temp_1731 = t_1730;
			switch (temp_1731) {
			case 111: {
				return true
			} break;
			
			case 102: {
				return true
			} break;
			
			case 94: {
				return true
			} break;
			
			case 110: {
				return true
			} break;
			
			case 107: {
				return true
			} break;
			
			case 91: {
				return true
			} break;
			
			case 95: {
				return true
			} break;
			
			case 103: {
				return true
			} break;
			
			case 96: {
				return true
			} break;
			
			case 97: {
				return true
			} break;
			
			case 99: {
				return true
			} break;
			
			case 100: {
				return true
			} break;
			
			case 112: {
				return true
			} break;
			
			case 104: {
				return true
			} break;
			
			case 109: {
				return true
			} break;
			
			case 92: {
				return true
			} break;
			
			case 93: {
				return true
			} break;
			
			case 105: {
				return true
			} break;
			
			case 106: {
				return true
			} break;
			
			case 108: {
				return true
			} break;
			
			case 101: {
				return true
			} break;
			
			default: 
			return false
			};
		};
	var TestParser = class {
	}
	TestParser.passed = 0
	TestParser.overall = 0
	TestParser.test = () => {
			console.log('TestParser begin');
			TestParser.shouldAllEqual(new Map([['', '<!--null-->'], ['  ', '<!--null-->'], ['	', '<!--null-->'], ['   	', '<!--null-->'], ['\n', '<!--null-->'], ['\n\n', '<!--null-->'], ['\r\r\n\r\n\r\t', '<!--null-->'], ['{}', 'Block([])'], ['{{}}', 'Block([Block([])])'], ['{ 0 0 0 }', 'Block([Int(0),Int(0),Int(0)])'], ['0', 'Int(0)'], [' 0 ', 'Int(0)'], ['123', 'Int(123)'], ['12', 'Int(12)'], ['0x1', 'Int(1)'], ['0x0', 'Int(0)'], ['0xF', 'Int(15)'], ['0xFA', 'Int(250)'], ['0xFABCDEF', 'Int(262917615)'], ['0.0', 'Float(0)'], ['0.123', 'Float(0.123)'], ['\'s\'', 'String(s)'], ['\"s\"', 'String(s)']]));
			TestParser.shouldAllEqual(new Map([['i ++ ++ i', 'Block([Unop(++,true,Ident(i)),Unop(++,false,Ident(i))])'], ['a + b', 'Binop(Ident(a),+,Ident(b))'], ['a += b', 'AssignOp(Ident(a),+,Ident(b))']]));
			TestParser.shouldAllEqual(new Map([['"\\\\(v)"', 'String(\\\\(v))']]));
			TestParser.shouldAllEqualWithoutTrim([]);
			TestParser.shouldAllEqual(new Map([['import "test"', 'Import([],test)'], ['import xxx in "test"', 'Import([Lower(xxx)],test)'], ['import xxx as yyy in "test"', 'Import([Lower(xxx){as}Lower(yyy)],test)'], ['import XXX as YYY in "test"', 'Import([Upper(XXX){as}Upper(YYY)],test)'], ['import * as mmm in "test"', 'Import([*{as}Lower(mmm)],test)'], ['import XXX, YYY as ZZZ, www in "test"', 'Import([Upper(XXX),Upper(YYY){as}Upper(ZZZ),Lower(www)],test)']]));
			TestParser.shouldAllError(['import', 'import hehe', 'import _ as B in "test"', 'import * in "test"', 'import * as B in "test"']);
			TestParser.shouldAllEqual(new Map([['var a = new Array<A>()', 'Var(a,null,New([],ParametricType(Array,[Type(A)]),[],[],[],[]),false,false)'], ['a = Array<A>.staticField()', 'Binop(Ident(a),=,Call(Dot(NodeTypeValue(ParametricType(Array,[Type(A)])),staticField),[]))'], ['a = EnumTest.EnumField', 'Binop(Ident(a),=,DotUpper(NodeTypeValue(Type(EnumTest)),EnumField))'], ['a = EnumTest.EnumField(arg)', 'Binop(Ident(a),=,Call(DotUpper(NodeTypeValue(Type(EnumTest)),EnumField),[Ident(arg)]))'], ['a = EnumTest.EnumField(argName: argValue, arg2, arg3: arg3)', 'Binop(Ident(a),=,Call(DotUpper(NodeTypeValue(Type(EnumTest)),EnumField),[argName:Ident(argValue),Ident(arg2),arg3:Ident(arg3)]))'], ['a = EnumTest<A,B>.EnumField', 'Binop(Ident(a),=,DotUpper(NodeTypeValue(ParametricType(EnumTest,[Type(A),Type(B)])),EnumField))'], ['var a = b as B var c = d as! B var e = f as? B', 'Block([Var(a,null,As(Ident(b),<!--default-->,Type(B)),false,false),Var(c,null,As(Ident(d),!,Type(B)),false,false),Var(e,null,As(Ident(f),?,Type(B)),false,false)])'], ['var a = b is B var c = d is B var e = f is B', 'Block([Var(a,null,As(Ident(b),Type(B)),false,false),Var(c,null,As(Ident(d),Type(B)),false,false),Var(e,null,As(Ident(f),Type(B)),false,false)])']]));
			TestParser.shouldAllEqual(new Map([['var x:[Array<T>]', 'Var(x,ParametricType(Array,[ParametricType(Array,[Type(T)])]),null,false,false)'], ['var x:[Map<K,V> : Array<T>]', 'Var(x,ParametricType(Map,[ParametricType(Map,[Type(K),Type(V)]),ParametricType(Array,[Type(T)])]),null,false,false)'], ['var x:{} var y:[] var z:[:] var w:()=>{}', 'Block([Var(x,Object([],[]),null,false,false),Var(y,ParametricType(Array,[Object([],[])]),null,false,false),Var(z,ParametricType(Map,[Object([],[]),Object([],[])]),null,false,false),Var(w,Function([],Object([],[])),null,false,false)])'], ['let x:()=>()=>()=>()=>Void', 'Var(x,Function([],Function([],Function([],Function([],Type(Void))))),null,true,false)']]));
			TestParser.shouldAllEqual(new Map([['enum A {}', 'Enum(Type(A),[])'], ['enum A { A B C }', 'Enum(Type(A),[NodeTypeValue(Type(A)),NodeTypeValue(Type(B)),NodeTypeValue(Type(C))])'], ['enum A { A(v:Int) B C(v:[K:V], a:Array<T>) }', 'Enum(Type(A),[\n					Call(NodeTypeValue(Type(A)),[v:NodeTypeValue(Type(Int))]),\n					NodeTypeValue(Type(B)),\n					Call(NodeTypeValue(Type(C)),[v:Map([NodeTypeValue(Type(K))],[NodeTypeValue(Type(V))]),a:NodeTypeValue(ParametricType(Array,[Type(T)]))])\n					])'], ['enum A { E(v: T<T>?) }', 'Enum(Type(A),[Call(NodeTypeValue(Type(E)),[v:NodeTypeValue(Optional(ParametricType(T,[Type(T)])))])])'], ['enum A { E(v: T<T?>) }', 'Enum(Type(A),[Call(NodeTypeValue(Type(E)),[v:NodeTypeValue(ParametricType(T,[Optional(Type(T))]))])])'], ['enum A { E(v: T?) }', 'Enum(Type(A),[Call(NodeTypeValue(Type(E)),[v:NodeTypeValue(Optional(Type(T)))])])']]));
			TestParser.shouldAllEqual(new Map([['new A(a: 1, b: 2)', 'New([],Type(A),[Int(1),Int(2)],[],[],[a,b])'], ['class A {} var a = new A { } ()', 'Block([Class(Type(A),null,[],[],false),Var(a,null,New([],Type(A),[],[],[],[]),false,false)])'], ['class A { var field: String } var a = new A { field: "Value" } ()', 'Block([Class(Type(A),null,[],[Var(field,Type(String),null,false,false)],false),Var(a,null,New([],Type(A),[],[field],[String(Value)],[]),false,false)])'], ['class A { var field: String var otherfield: Int } var a = new A { field: "Value", otherfield: 25 } ()', 'Block([Class(Type(A),null,[],[Var(field,Type(String),null,false,false),Var(otherfield,Type(Int),null,false,false)],false),Var(a,null,New([],Type(A),[],[field,otherfield],[String(Value),Int(25)],[]),false,false)])']]));
			TestParser.shouldAllError(['class A { new(a b) {} }', 'class A { new(a, b,) {} }', 'class A { new(,) {} }', 'fun f(a b c) {}', 'fun f(a b) {}', 'fun f(a, b,) {}', 'fun f(a,) {}', 'fun f(,) {}']);
			TestParser.shouldAllError(['class A { var i: Int { set (value) {} } }', 'class A { var i: Int { get {} set () {} } }', 'class A { var i: Int { get {} set {} } }', 'class A { let i: Int { get {} set (value) {} } }', 'class A { let i: Int { get {} set (value, val) {} } }', 'class A { var i: Int { get {} set (Value) {} } }', 'class A { var i: Int { get (value) {} set (value) {} } }', 'class A { var i: Int {} }']);
			TestParser.shouldAllError(['if (,) {}', 'if (a,) {}', 'switch (,) {}', 'switch (a,) {}', '@att(,) x', '@att(a,) x', '@att(a,b,) x', '@att(a b,) x', '@att(a b) x', 'new T(,)', 'new T(a b,)', 'new T(a,b,)', 'new T(a b)', 'call(1 2)', 'call(1 2,)', 'call(1,2,)', 'call(1,)', 'call(a:1,)', 'call(1:1,)', 'call(a:,)', 'call(a:)', 'call(,)', '[1 2]', '[,]', '[1,]', '[1,2,]', '[1:1 2:2]', '[1:1,2:2,]', '{a:1 b:2}', '{,}', '{a:1,}', '{a:1,b:2,}']);
			TestParser.shouldAllError(['=', '= 1']);
			TestParser.shouldAllEqual(new Map([['if this { this }', 'If([This],Block([This]),<!--null-->)'], ['if this, this { this } else { break }', 'If([This,This],Block([This]),Block([Break]))'], ['if this, let a = this { this } else { break }', 'If([This,Var(a,null,This,true,false)],Block([This]),Block([Break]))'], ['if let a = this, let b = this, this { this }', 'If([Var(a,null,This,true,false),Var(b,null,This,true,false),This],Block([This]),<!--null-->)']]));
			TestParser.shouldAllEqual(new Map([['declare var a: T', 'Var(a,Type(T),null,false,true)'], ['declare let a: T', 'Var(a,Type(T),null,true,true)'], ['declare fun name()', 'Function(name,null,[],null,true)'], ['declare fun name() hi()', 'Block([Function(name,null,[],null,true),Call(Ident(hi),[])])'], ['declare fun name() {}', 'Block([Function(name,null,[],null,true),Block([])])'], ['declare class A {}', 'Class(Type(A),null,[],[],true)'], ['declare A = B', 'TypeAlias(Type(A),Type(B))']]));
			TestParser.shouldAllError(['declare var a, b, c', 'declare anything']);
			TestParser.shouldAllEqual(new Map([['push([:])', 'Call(Ident(push),[Map([],[])])'], ['push([])', 'Call(Ident(push),[Array([])])'], ['[].length', 'Dot(Array([]),length)'], ['[:].length', 'Dot(Map([],[]),length)'], ['[[:]]', 'Array([Map([],[])])']]));
			console.log(('TestParser done ' + (Math.round((TestParser.passed / TestParser.overall) * 100)) + '% (' + (TestParser.passed) + '/' + (TestParser.overall) + ')'));
		};
	TestParser.shouldEqual = (input, test) => {
			const test_1733 = TestParser.deepTrim(test);
			TestParser.shouldEqualWithoutTrim(input, test_1733);
		};
	TestParser.shouldEqualWithoutTrim = (input_1734, test_1735) => {
			TestParser.overall++;
			let lexe = Lexer.tokenize(Buffer.from(input_1734), 'TEST');
			try {
				let parsed = Parser.toNode(Parser.parseNodes(lexe, new Project()));
				let res = TestParser.stringify(parsed);
				if (test_1735 != res) { throw ('TestParser test fail: `' + (input_1734) + '`\n!==: `' + (test_1735) + '`\nGot: `' + (res) + '`\nParsed: `' + (parsed) + '`') };
			} catch (temp) {
				if (true) { 
				const e = temp
				{
					console.log(e.toString());
					throw ('TestParser test fail: `' + (input_1734) + '` failed to parse');
				} } else
				
				throw temp;
			};
			TestParser.passed++;
		};
	TestParser.shouldAllEqual = (map) => { for (const input of $toIterator(map.keys())) {
			let test_1736 = map.get(input);
			TestParser.shouldEqual(input, test_1736);
		} };
	TestParser.shouldAllEqualWithoutTrim = (map_1737) => { for (const input of $toIterator(map_1737.keys())) {
			let test_1738 = map_1737.get(input);
			TestParser.shouldEqualWithoutTrim(input, test_1738);
		} };
	TestParser.shouldError = (input_1739) => {
			TestParser.overall++;
			try {
				let lexe_1741 = Lexer.tokenize(Buffer.from(input_1739), 'TEST');
				let parser = Parser.toNode(Parser.parseNodes(lexe_1741, new Project()));
			} catch (temp_1740) {
				if (true) { 
				const e = temp_1740
				{
					TestParser.passed++;
					return;
				} } else
				
				throw temp_1740;
			};
			throw ('TestParser test fail: `' + (input_1739) + '` did not throw exception.');
		};
	TestParser.shouldAllError = (input_1742) => { for (const str of $toIterator(input_1742)) {
			TestParser.shouldError(str);
		} };
	TestParser.deepTrim = (s) => { return s.split('\n').join('').split('\r').join('').split('\t').join('').split(' ').join('') };
	TestParser.stringify = (node) => {
			const temp_1743 = node;
			switch (temp_1743&&temp_1743[0]) {
			case null: case undefined: {
				return '<!--null-->'
			} break;
			
			case 0: {
				const s_1744 = temp_1743[1];
				return ('String(' + (s_1744) + ')')
			} break;
			
			case 1: {
				const s_1745 = temp_1743[1];
				return ('Ident(' + (s_1745) + ')')
			} break;
			
			case 2: {
				const b = temp_1743[1];
				return ('Bool(' + (b) + ')')
			} break;
			
			case 3: {
				return 'This'
			} break;
			
			case 4: {
				return 'Super'
			} break;
			
			case 5: {
				const s_1746 = temp_1743[1];
				return ('Int(' + (s_1746) + ')')
			} break;
			
			case 7: {
				const s_1747 = temp_1743[1];
				return ('Float(' + (s_1747) + ')')
			} break;
			
			case 8: {
				return 'Null'
			} break;
			
			case 18: {
				return 'Break'
			} break;
			
			case 19: {
				return 'Continue'
			} break;
			
			case 43: {
				const expr = temp_1743[1];
				const type = temp_1743[2];
				return 'As(' + TestParser.stringify(expr) + ',' + TestParser.stringifyType(type) + ')'
			} break;
			
			case 44: {
				const expr_1748 = temp_1743[1];
				const kind = temp_1743[2];
				const type_1749 = temp_1743[3];
				return 'As(' + TestParser.stringify(expr_1748) + ',' + Token.stringify(kind) + ',' + TestParser.stringifyType(type_1749) + ')'
			} break;
			
			case 10: {
				const a = temp_1743[1];
				const op = temp_1743[2];
				const b_1750 = temp_1743[3];
				return 'Binop(' + TestParser.stringify(a) + ',' + Token.stringify(op) + ',' + TestParser.stringify(b_1750) + ')'
			} break;
			
			case 11: {
				const a_1751 = temp_1743[1];
				const op_1752 = temp_1743[2];
				const b_1753 = temp_1743[3];
				return 'AssignOp(' + TestParser.stringify(a_1751) + ',' + Token.stringify(op_1752) + ',' + TestParser.stringify(b_1753) + ')'
			} break;
			
			case 12: {
				const els = temp_1743[1];
				return 'Block(' + TestParser.stringifyNodeArray(els) + ')'
			} break;
			
			case 24: {
				const name = temp_1743[1];
				const t = temp_1743[2];
				const expr_1754 = temp_1743[3];
				const const_1755 = temp_1743[4];
				const external = temp_1743[5];
				return ('Var(' + (name) + ',') + (((t != null))? (TestParser.stringifyType(t)) : 'null') + ',' + (((expr_1754 != null))? (TestParser.stringify(expr_1754)) : 'null') + (',' + (const_1755) + ',' + (external) + ')')
			} break;
			
			case 22: {
				const name_1756 = temp_1743[1];
				const expr_1757 = temp_1743[2];
				const vars = temp_1743[3];
				const rettype = temp_1743[4];
				const external_1758 = temp_1743[5];
				return ('Function(' + (name_1756) + ',') + ((expr_1757 == null)? ('null') : TestParser.stringify(expr_1757)) + ',' + TestParser.stringifyNodeArray(vars) + ',' + (((rettype != null))? (TestParser.stringifyType(rettype)) : 'null') + (',' + (external_1758) + ')')
			} break;
			
			case 23: {
				const expr_1759 = temp_1743[1];
				const vars_1760 = temp_1743[2];
				const rettype_1761 = temp_1743[3];
				return 'Arrow(' + ((expr_1759 == null)? ('null') : TestParser.stringify(expr_1759)) + ',' + TestParser.stringifyNodeArray(vars_1760) + ',' + (((rettype_1761 != null))? (TestParser.stringifyType(rettype_1761)) : 'null') + ')'
			} break;
			
			case 13: {
				const e = temp_1743[1];
				const el = temp_1743[2];
				const argNames = temp_1743[3];
				{
					let res_1762 = 'Call(' + TestParser.stringify(e) + ',[';
					{
						let i = 0;
						let it = 0;
						let at = el.length;
						while (it < at) {
							i = it;
							it++;
							{
								res_1762 += ((argNames[i] == null))? ('') : argNames[i] + ':';
								res_1762 += TestParser.stringify(el[i]) + (((i != el.length - 1))? (',') : '');
							};
						};
					};
					return res_1762 + '])';
				}
			} break;
			
			case 15: {
				const e_1763 = temp_1743[1];
				return 'Parenthesis(' + TestParser.stringify(e_1763) + ')'
			} break;
			
			case 16: {
				const e_1764 = temp_1743[1];
				return 'Return(' + TestParser.stringify(e_1764) + ')'
			} break;
			
			case 17: {
				const e_1765 = temp_1743[1];
				return 'Throw(' + TestParser.stringify(e_1765) + ')'
			} break;
			
			case 39: {
				const t_1766 = temp_1743[1];
				const els_1767 = temp_1743[2];
				return 'Enum(' + TestParser.stringifyType(t_1766) + ',' + TestParser.stringifyNodeArray(els_1767) + ')'
			} break;
			
			case 35: {
				const path = temp_1743[1];
				const els_1768 = temp_1743[2];
				return 'Module(' + path + ',' + TestParser.stringifyNodeArray(els_1768) + ')'
			} break;
			
			case 37: {
				const els_1769 = temp_1743[1];
				const path_1770 = temp_1743[2];
				{
					const stringifyImportNode = (node_1771) => {
						const temp_1772 = node_1771;
						switch (temp_1772&&temp_1772[0]) {
						case 0: {
							const name_1773 = temp_1772[1];
							return ('Lower(' + (name_1773) + ')')
						} break;
						
						case 1: {
							const name_1774 = temp_1772[1];
							return ('Upper(' + (name_1774) + ')')
						} break;
						
						case 2: {
							return '*'
						} break;
						
						case 3: {
							const left = temp_1772[1];
							const right = temp_1772[2];
							return stringifyImportNode(left) + '{as}' + stringifyImportNode(right)
						} break;
						};
					};
					return 'Import([' + (() => {
						const result = [];
						const value = els_1769;
						for (const p of $toIterator(value)) result.push(stringifyImportNode(p));
						return result;
					})().join(',') + '],' + path_1770 + ')';
				}
			} break;
			
			case 32: {
				const k = temp_1743[1];
				const v = temp_1743[2];
				return 'Map([' + TestParser.stringifyArray(k) + '],[' + TestParser.stringifyArray(v) + '])'
			} break;
			
			case 25: {
				const type_1775 = temp_1743[1];
				const extend = temp_1743[2];
				const implement = temp_1743[3];
				const fields = temp_1743[4];
				const external_1776 = temp_1743[5];
				{
					let res_1777 = 'Class(' + TestParser.stringifyType(type_1775) + ',';
					res_1777 += ((extend != null))? (TestParser.stringifyType(extend)) : 'null,';
					res_1777 += TestParser.stringifyNodeTypeArray(implement) + ',';
					res_1777 += TestParser.stringifyNodeArray(fields) + ',';
					res_1777 += external_1776 + ')';
					return res_1777;
				}
			} break;
			
			case 30: {
				const path_1778 = temp_1743[1];
				const t_1779 = temp_1743[2];
				const args = temp_1743[3];
				const names = temp_1743[4];
				const values = temp_1743[5];
				const argNames_1780 = temp_1743[6];
				return 'New([' + path_1778.join('.') + '],' + TestParser.stringifyType(t_1779) + ',' + TestParser.stringifyNodeArray(args) + ',[' + names.join(',') + '],' + TestParser.stringifyNodeArray(values) + ',[' + argNames_1780.join(',') + '])'
			} break;
			
			case 51: {
				const type_1781 = temp_1743[1];
				return 'NodeTypeValue(' + TestParser.stringifyType(type_1781) + ')'
			} break;
			
			case 9: {
				const alias = temp_1743[1];
				const value_1782 = temp_1743[2];
				return 'TypeAlias(' + TestParser.stringifyType(alias) + ',' + TestParser.stringifyType(value_1782) + ')'
			} break;
			
			case 28: {
				const l = temp_1743[1];
				const r = temp_1743[2];
				return 'Dot(' + TestParser.stringify(l) + ',' + r + ')'
			} break;
			
			case 29: {
				const l_1783 = temp_1743[1];
				const r_1784 = temp_1743[2];
				return 'DotUpper(' + TestParser.stringify(l_1783) + ',' + r_1784 + ')'
			} break;
			
			case 48: {
				const expr_1785 = temp_1743[1];
				return 'Private(' + TestParser.stringify(expr_1785) + ')'
			} break;
			
			case 14: {
				const econd = temp_1743[1];
				const eif = temp_1743[2];
				const eelse = temp_1743[3];
				return 'If(' + TestParser.stringifyNodeArray(econd) + ',' + TestParser.stringify(eif) + ',' + TestParser.stringify(eelse) + ')'
			} break;
			
			case 31: {
				const el_1786 = temp_1743[1];
				return 'Array(' + TestParser.stringifyNodeArray(el_1786) + ')'
			} break;
			
			case 20: {
				const op_1787 = temp_1743[1];
				const postfix = temp_1743[2];
				const e_1788 = temp_1743[3];
				return 'Unop(' + Token.stringify(op_1787) + ',' + postfix + ',' + TestParser.stringify(e_1788) + ')'
			} break;
			
			default: 
			throw '<!--' + node + '-->'
			};
		};
	TestParser.stringifyArray = (nodes) => { return (() => {
			const result_1789 = [];
			const value_1790 = nodes;
			for (const node of $toIterator(value_1790)) result_1789.push(TestParser.stringify(node));
			return result_1789;
		})().join(',') };
	TestParser.stringifyNodeArray = (arr) => { return '[' + TestParser.stringifyArray(arr) + ']' };
	TestParser.stringifyNodeTypeArray = (arr_1791) => { return '[' + (() => {
			const result_1792 = [];
			const value_1793 = arr_1791;
			for (const e of $toIterator(value_1793)) result_1792.push(TestParser.stringifyType(e));
			return result_1792;
		})().join(',') + ']' };
	TestParser.stringifyType = (node_1794) => {
			const temp_1795 = node_1794;
			switch (temp_1795&&temp_1795[0]) {
			case 1: {
				const s_1796 = temp_1795[1];
				return ('Type(' + (s_1796) + ')')
			} break;
			
			case 2: {
				const name_1797 = temp_1795[1];
				const params = temp_1795[2];
				return ('ParametricType(' + (name_1797) + ',[') + (() => {
					const result_1798 = [];
					const value_1799 = params;
					for (const p of $toIterator(value_1799)) result_1798.push(TestParser.stringifyType(p));
					return result_1798;
				})().join(',') + '])'
			} break;
			
			case 3: {
				const args_1800 = temp_1795[1];
				const rettype_1801 = temp_1795[2];
				return 'Function([' + (() => {
					const result_1802 = [];
					const value_1803 = args_1800;
					for (const e of $toIterator(value_1803)) result_1802.push(TestParser.stringifyType(e));
					return result_1802;
				})().join(',') + '],' + TestParser.stringifyType(rettype_1801) + ')'
			} break;
			
			case 5: {
				const names_1804 = temp_1795[1];
				const types = temp_1795[2];
				return 'Object([' + names_1804.join(',') + '],[' + (() => {
					const result_1805 = [];
					const value_1806 = types;
					for (const e of $toIterator(value_1806)) result_1805.push(TestParser.stringifyType(e));
					return result_1805;
				})().join(',') + '])'
			} break;
			
			case 0: {
				const type_1807 = temp_1795[1];
				return 'Optional(' + TestParser.stringifyType(type_1807) + ')'
			} break;
			
			default: 
			throw '<!--' + node_1794 + '-->'
			};
		};
	var GenJs = class {
		constructor() { 
			this.extension = '.js'
			this.nativeEnums = false
			this.toIterator = false
			this.tabs = '\t\t'
			this.globalAccessor = ''
			this.reserved = ['with', 'const', 'instanceof', 'typeof', 'delete', 'undefined', 'package_TODO', 'async', 'await', 'arguments']
			this.bi = 0
		{
		} };
		perform(normalizer) {
			this.project = normalizer;
			return this.stringify();
		};
		stringify() {
			const out = ['// Generated by Hexa https://hexalang.github.io\n'];
			if ((this.project.package.addLicenseNoticeToOutput)) {
				out.push(('// ' + (this.project.package.name) + '\n'));
				out.push(('// LICENSE ' + (this.project.package.license) + '\n'));
			} else {
				out.push('// The generated code is subject to the original license\n');
			};
			out.push(';(() => {\n\t"use strict"\n\tconst $global = typeof(window) === "undefined"? global : window');
			out.push('\n\tif (typeof($global.require) === "undefined") { $global.require = () => {} };');
			out.push(('\n\tconst selfVersion=\"' + (this.project.package.version) + '\";'));
			const constantsIndex = out.length;
			const constants = [];
			out.push('');
			for (const e of $toIterator(this.project.enumsSimple)) {
				if ((e.staticVars.length + e.staticMethods.length == 0)) { continue };
				out.push('\n\tvar ' + e.name + ' = {');
				for (const v of $toIterator(e.staticMethods)) {
					const temp = v;
					switch (temp&&temp[0]) {
					case 5: {
						const name = temp[1];
						const expr = temp[2];
						const args = temp[3];
						const defaults = temp[4];
						{
							out.push('\n\t\t' + name + ': ');
							out.push(this.printFunctionArguments(args, defaults) + ' => { ' + this.printStatement(expr) + ' }');
							out.push(',');
						}
					} break;
					};
				};
				out.push('\n\t}');
				for (const v of $toIterator(e.staticVars)) {
					const temp_1823 = v;
					switch (temp_1823&&temp_1823[0]) {
					case 3: {
						const name_1824 = temp_1823[1];
						const expr_1825 = temp_1823[2];
						{
							out.push('\n\t' + e.name + '.' + name_1824);
							if ((expr_1825 != null)) { out.push(' = ' + this.printExpression(expr_1825)) };
						}
					} break;
					
					case 4: {
						const name_1826 = temp_1823[1];
						const expr_1827 = temp_1823[2];
						{
							out.push('\n\t' + e.name + '.' + name_1826);
							out.push(' = ' + this.printExpression(expr_1827));
						}
					} break;
					};
				};
			};
			for (const e of $toIterator(this.project.enumsComplex)) {
				if ((e.staticMethods.length == 0) && (e.names.length == 0)) { out.push('\n\tvar ' + e.name + ' = {}') } else {
					out.push('\n\tvar ' + e.name + ' = {');
					for (const v of $toIterator(e.staticMethods)) {
						const temp_1828 = v;
						switch (temp_1828&&temp_1828[0]) {
						case 5: {
							const name_1829 = temp_1828[1];
							const expr_1830 = temp_1828[2];
							const args_1831 = temp_1828[3];
							const defaults_1832 = temp_1828[4];
							{
								out.push('\n\t\t' + name_1829 + ': ');
								out.push(this.printFunctionArguments(args_1831, defaults_1832) + ' => { ' + this.printStatement(expr_1830) + ' }');
								out.push(',');
							}
						} break;
						};
					};
					let i = 0;
					for (const name of $toIterator(e.names)) {
						if ((e.constructors[i] != null)) {
							out.push('\n\t\t' + name + ': ');
							out.push('(' + e.constructors[i].join(',') + ')=>[');
							out.push('' + i + ',' + e.constructors[i].join(','));
							out.push('],');
						};
						i++;
					};
					out.push('\n\t}');
				};
				let i_1833 = 0;
				for (const name of $toIterator(e.names)) {
					if ((e.constructors[i_1833] != null)) {} else {
						out.push('\n\tObject.defineProperty(' + e.name + ', "' + name + '", { get: () => { return [' + i_1833 + '] }})');
					};
					i_1833++;
				};
				for (const v of $toIterator(e.staticVars)) {
					const temp_1834 = v;
					switch (temp_1834&&temp_1834[0]) {
					case 3: {
						const name_1835 = temp_1834[1];
						const expr_1836 = temp_1834[2];
						{
							out.push('\n\t' + e.name + '.' + name_1835);
							if ((expr_1836 != null)) { out.push(' = ' + this.printExpression(expr_1836)) };
						}
					} break;
					
					case 4: {
						const name_1837 = temp_1834[1];
						const expr_1838 = temp_1834[2];
						{
							out.push('\n\t' + e.name + '.' + name_1837);
							out.push(' = ' + this.printExpression(expr_1838));
						}
					} break;
					};
				};
			};
			for (const i of $toIterator(this.project.interfaces)) {
				throw i;
			};
			for (const c of $toIterator(this.project.classes)) {
				if ((c.useless)) { continue };
				if ((c.external)) {
					if ((c.jsRequire != null)) {
						constants.push('\n\t' + 'const ' + c.name + ' = require("' + c.jsRequire + '")');
						continue;
					};
					{
						let step = 0;
						const jsNative = c.jsNative;
						let temp_1839 = null;
						if (step == 0 && jsNative != null) {
							temp_1839 = jsNative != c.name;
							step = 1;
						};
						if (step == 1 && temp_1839 != false) { step = 2 };
						if (step == 2) { out.push('\n\t' + 'var ' + c.name + ' = $global.' + jsNative) };
					};
					continue;
				};
				out.push('\n\t' + 'var ' + c.name + ' = class');
				{
					let step_1840 = 0;
					const extend = c.extend;
					if (step_1840 == 0 && extend != null) { step_1840 = 1 };
					if (step_1840 == 1) { out.push(' extends ' + extend) };
				};
				out.push(' {');
				for (const v of $toIterator(c.methods)) {
					const temp_1841 = v;
					switch (temp_1841&&temp_1841[0]) {
					case 5: {
						const name_1842 = temp_1841[1];
						const expr_1843 = temp_1841[2];
						const args_1844 = temp_1841[3];
						{
							if (name_1842 == null || name_1842 == 'new') { out.push('\n\t\tconstructor') } else {
								out.push('\n\t\t' + name_1842);
							};
							out.push('(' + args_1844.join(', ') + ') ');
							if ((name_1842 == null || name_1842 == 'new') && (c.vars.length > 0)) {
								out.push('{ ');
								for (const v of $toIterator(c.vars)) {
									const temp_1845 = v;
									switch (temp_1845&&temp_1845[0]) {
									case 3: {
										const name_1846 = temp_1845[1];
										const expr_1847 = temp_1845[2];
										if ((expr_1847 != null)) { out.push('\n\t\t\tthis.' + name_1846 + ' = ' + this.printExpression(expr_1847) + '') }
									} break;
									
									case 4: {
										const name_1848 = temp_1845[1];
										const expr_1849 = temp_1845[2];
										if ((expr_1849 != null)) { out.push('\n\t\t\tthis.' + name_1848 + ' = ' + this.printExpression(expr_1849) + '') }
									} break;
									};
								};
								out.push('\n\t\t');
								out.push(this.printStatement(expr_1843) + ' };');
							} else {
								out.push(this.printBlock(expr_1843) + ';');
							};
						}
					} break;
					};
				};
				for (const name of $toIterator(c.property)) {
					out.push('\n\t\tget ' + name + ('() { return this.get_' + (name) + '(); };'));
					out.push('\n\t\tset ' + name + ('(value) { return this.set_' + (name) + '(value); };'));
				};
				out.push('\n\t}');
				for (const v of $toIterator(c.staticVars)) {
					const temp_1850 = v;
					switch (temp_1850&&temp_1850[0]) {
					case 3: {
						const name_1851 = temp_1850[1];
						const expr_1852 = temp_1850[2];
						{
							out.push('\n\t' + c.name + '.' + name_1851);
							if ((expr_1852 != null)) { out.push(' = ' + this.printExpression(expr_1852)) };
						}
					} break;
					
					case 4: {
						const name_1853 = temp_1850[1];
						const expr_1854 = temp_1850[2];
						{
							out.push('\n\t' + c.name + '.' + name_1853);
							out.push(' = ' + this.printExpression(expr_1854));
						}
					} break;
					};
				};
				for (const v of $toIterator(c.staticMethods)) {
					const temp_1855 = v;
					switch (temp_1855&&temp_1855[0]) {
					case 5: {
						const name_1856 = temp_1855[1];
						const expr_1857 = temp_1855[2];
						const args_1858 = temp_1855[3];
						const defaults_1859 = temp_1855[4];
						{
							out.push('\n\t' + c.name + '.' + name_1856 + ' = ');
							out.push(this.printFunctionArguments(args_1858, defaults_1859) + ' => ' + this.printBlock(expr_1857) + ';');
						}
					} break;
					};
				};
			};
			for (const g of $toIterator(this.project.globalFuncs)) {
				const temp_1860 = g;
				switch (temp_1860&&temp_1860[0]) {
				case 5: {
					const name_1861 = temp_1860[1];
					const expr_1862 = temp_1860[2];
					const args_1863 = temp_1860[3];
					const defaults_1864 = temp_1860[4];
					{
						out.push('\n\tfunction ' + name_1861);
						out.push(this.printFunctionArguments(args_1863, defaults_1864) + ' ' + this.printBlock(expr_1862) + ';');
					}
				} break;
				};
			};
			for (const g of $toIterator(this.project.globalVars)) {
				const temp_1865 = g;
				switch (temp_1865&&temp_1865[0]) {
				case 3: {
					const name_1866 = temp_1865[1];
					const expr_1867 = temp_1865[2];
					{
						out.push('\n\tvar ' + name_1866);
						if ((expr_1867 != null)) { out.push(' = ' + this.printExpression(expr_1867)) } else {
							out.push(' = null');
						};
					}
				} break;
				
				case 4: {
					const name_1868 = temp_1865[1];
					const expr_1869 = temp_1865[2];
					out.push('\n\tvar ' + name_1868 + ' = ' + this.printExpression(expr_1869))
				} break;
				};
			};
			for (const init of $toIterator(this.project.init)) {
				out.push('\n\t{\n\t\t');
				out.push(this.printStatement(init));
				out.push('\n\t}');
			};
			if (this.toIterator) { constants.unshift('\n\tfunction $toIterator(v) { if (typeof(v) === "number") { v = Math.max(v, 0); const i = new Uint32Array(v); let n = 0; while (n < v) i[n] = n++; return i; } return v; };') };
			out[constantsIndex] = constants.join('');
			out.push('\n})();\n');
			return out.join('');
		};
		pushTab() { this.tabs += '\t' };
		popTab() { this.tabs = this.tabs.substring(0, this.tabs.length - 1) };
		printBlock(s) {
			const temp_1870 = s;
			switch (temp_1870&&temp_1870[0]) {
			case 1: {
				const el = temp_1870[1];
				{
					if (el.length == 1) {
						const temp_1871 = el[0];
						switch (temp_1871&&temp_1871[0]) {
						case 1: {
							return this.printStatement(el[0])
						} break;
						};
					};
					if (el.length == 1) { return '{ ' + this.printStatement(el[0]) + ' }' };
					if (el.length == 0) { return '{}' };
					return this.printStatement(s);
				}
			} break;
			
			default: 
			return '{ ' + this.printStatement(s) + ' }'
			};
		};
		printStatement(s_1872) {
			{
				const temp_1873 = s_1872;
				switch (temp_1873&&temp_1873[0]) {
				case 0: {
					const els = temp_1873[1];
					{
						let r = '';
						for (const s of $toIterator(els)) {
							if ((s != null)) { r += '\n' + this.tabs + this.printStatement(s) + ';' };
						};
						return r;
					}
				} break;
				
				case 18: {
					return 'break'
				} break;
				
				case 17: {
					return 'continue'
				} break;
				
				case 1: {
					const el_1874 = temp_1873[1];
					{
						if (el_1874.length == 1) {
							const temp_1875 = el_1874[0];
							switch (temp_1875&&temp_1875[0]) {
							case 1: {
								return this.printStatement(el_1874[0])
							} break;
							};
						};
						this.pushTab();
						let r_1876 = '{';
						for (const e of $toIterator(el_1874)) {
							const temp_1877 = e;
							switch (temp_1877&&temp_1877[0]) {
							case null: case undefined: {
								{
								}
							} break;
							
							case 0: {
								const els_1878 = temp_1877[1];
								for (const s of $toIterator(els_1878)) {
									if ((s != null)) { r_1876 += '\n' + this.tabs + this.printStatement(s) + ';' };
								}
							} break;
							
							default: 
							r_1876 += '\n' + this.tabs + this.printStatement(e) + ';'
							};
						};
						this.popTab();
						return r_1876 + '\n' + this.tabs + '}';
					}
				} break;
				
				case 4: {
					const name_1879 = temp_1873[1];
					const expr_1880 = temp_1873[2];
					return 'const ' + name_1879 + ((expr_1880 == null)? (' = null') : ' = ' + this.printExpression(expr_1880))
				} break;
				
				case 3: {
					const name_1881 = temp_1873[1];
					const expr_1882 = temp_1873[2];
					return 'let ' + name_1881 + ((expr_1882 == null)? ('') : ' = ' + this.printExpression(expr_1882))
				} break;
				
				case 5: {
					const name_1883 = temp_1873[1];
					const expr_1884 = temp_1873[2];
					const args_1885 = temp_1873[3];
					const defaults_1886 = temp_1873[4];
					return 'const ' + name_1883 + ' = ' + this.printFunctionArguments(args_1885, defaults_1886) + ' => ' + this.printBlock(expr_1884)
				} break;
				
				case 6: {
					const e = temp_1873[1];
					{
						if ((e == null)) { return 'return' };
						return 'return ' + this.printExpression(e);
					}
				} break;
				
				case 7: {
					const econd = temp_1873[1];
					const eif = temp_1873[2];
					const eelse = temp_1873[3];
					{
						let r_1887 = 'if (' + this.printExpression(econd) + ') ' + this.printBlock(eif);
						if ((eelse != null)) { r_1887 += ' else ' + this.printStatement(eelse) };
						return r_1887;
					}
				} break;
				
				case 2: {
					const e_1888 = temp_1873[1];
					const args_1889 = temp_1873[2];
					return this.printExpression(e_1888) + this.printCallArguments(args_1889)
				} break;
				
				case 19: {
					const args_1890 = temp_1873[1];
					return 'super' + this.printCallArguments(args_1890)
				} break;
				
				case 8: {
					const expr_1891 = temp_1873[1];
					const t = temp_1873[2];
					const v = temp_1873[3];
					const catches = temp_1873[4];
					const temp_1892 = temp_1873[5];
					{
						let r_1893 = 'try ';
						r_1893 += this.printBlock(expr_1891);
						r_1893 += (' catch (' + (temp_1892) + ') {\n') + this.tabs + '\t';
						this.pushTab();
						{
							let i_1894 = 0;
							let it = 0;
							let at = catches.length;
							while (it < at) {
								i_1894 = it;
								it++;
								{
									let typeof_1895 = 'T';
									{
										const temp_1896 = t[i_1894];
										switch (temp_1896&&temp_1896[0]) {
										case 4: {
											const type = temp_1896[1];
											typeof_1895 = type.name
										} break;
										
										default: 
										throw '' + t[i_1894]
										};
									};
									{
										const temp_1897 = typeof_1895;
										switch (temp_1897) {
										case 'Any': {
											r_1893 += 'if (true) { '
										} break;
										
										case 'String': {
											r_1893 += ('if (typeof(' + (temp_1892) + ') == \"string\") { ')
										} break;
										
										case 'Int': {
											r_1893 += ('if (typeof(' + (temp_1892) + ') == \"number\") { ')
										} break;
										
										case 'Float': {
											r_1893 += ('if (typeof(' + (temp_1892) + ') == \"number\") { ')
										} break;
										
										case 'Bool': {
											r_1893 += ('if (typeof(' + (temp_1892) + ') == \"boolean\") { ')
										} break;
										
										default: 
										r_1893 += ('if (' + (temp_1892) + ' instanceof ' + (typeof_1895) + ') { ')
										};
									};
									r_1893 += '\n' + this.tabs;
									r_1893 += ('const ' + (v[i_1894]) + ' = ' + (temp_1892) + '');
									r_1893 += '\n' + this.tabs;
									r_1893 += this.printStatement(catches[i_1894]);
									r_1893 += ' }';
									r_1893 += ' else';
									r_1893 += '\n' + this.tabs;
								};
							};
						};
						r_1893 += '\n' + this.tabs + ('throw ' + (temp_1892) + ';');
						this.popTab();
						return r_1893 + '\n' + this.tabs + '}';
					}
				} break;
				
				case 10: {
					const a = temp_1873[1];
					const v_1898 = temp_1873[2];
					return this.printExpression(a) + ' = ' + this.printExpression(v_1898)
				} break;
				
				case 9: {
					const e_1899 = temp_1873[1];
					return 'throw ' + this.printExpression(e_1899)
				} break;
				
				case 12: {
					const name_1900 = temp_1873[1];
					const over = temp_1873[2];
					const by = temp_1873[3];
					{
						this.toIterator = true;
						return 'for (const ' + name_1900 + ' of $toIterator(' + this.printExpression(over) + ')) ' + this.printStatement(by);
					}
				} break;
				
				case 14: {
					const e_1901 = temp_1873[1];
					return this.printExpression(e_1901) + '++'
				} break;
				
				case 15: {
					const e_1902 = temp_1873[1];
					return this.printExpression(e_1902) + '--'
				} break;
				
				case 13: {
					const econd_1903 = temp_1873[1];
					const e_1904 = temp_1873[2];
					const pre = temp_1873[3];
					{
						if (pre) { return 'while (' + this.printExpression(econd_1903) + ') ' + this.printStatement(e_1904) };
						return 'do {' + this.printStatement(e_1904) + '} while (' + this.printExpression(econd_1903) + ')';
					}
				} break;
				
				case 11: {
					const a_1905 = temp_1873[1];
					const op = temp_1873[2];
					const value = temp_1873[3];
					return this.printExpression(a_1905) + ' ' + Token.stringify(op) + '= ' + this.printExpression(value)
				} break;
				
				case 16: {
					const expr_1906 = temp_1873[1];
					const cases = temp_1873[2];
					const statements = temp_1873[3];
					const guards = temp_1873[4];
					const binds = temp_1873[5];
					{
						let r_1907 = 'switch (' + this.printExpression(expr_1906) + ') {';
						{
							let i_1908 = 0;
							let it_1909 = 0;
							let at_1910 = cases.length;
							while (it_1909 < at_1910) {
								i_1908 = it_1909;
								it_1909++;
								{
									if ((cases[i_1908].length > 0)) {
										r_1907 += '\n' + this.tabs;
										for (const cc of $toIterator(cases[i_1908])) {
											const temp_1911 = cc;
											switch (temp_1911&&temp_1911[0]) {
											case 7: {
												r_1907 += 'case null: case undefined: '
											} break;
											
											default: 
											r_1907 += 'case ' + this.printExpression(cc) + ': '
											};
										};
										this.pushTab();
										r_1907 += '{\n' + this.tabs;
										{
											let step_1912 = 0;
											const binders = binds[i_1908];
											if (step_1912 == 0 && binders != null) { step_1912 = 1 };
											if (step_1912 == 1) { for (const bind of $toIterator(binders)) {
												r_1907 += this.printStatement(bind) + ';\n' + this.tabs;
											} };
										};
										{
											let step_1913 = 0;
											const guard = guards[i_1908];
											if (step_1913 == 0 && guard != null) { step_1913 = 1 };
											if (step_1913 == 1) {
												this.pushTab();
												r_1907 += 'if (' + this.printExpression(guard) + ') {\n' + this.tabs;
											};
										};
										r_1907 += this.printStatement(statements[i_1908]);
										this.popTab();
										{
											let step_1914 = 0;
											const guard_1915 = guards[i_1908];
											if (step_1914 == 0 && guard_1915 != null) { step_1914 = 1 };
											if (step_1914 == 1) {
												this.popTab();
												r_1907 += '\n\t' + this.tabs + 'break; } }\n' + this.tabs;
											} else {
												r_1907 += '\n' + this.tabs + '} break;\n' + this.tabs;
											};
										};
									};
								};
							};
						};
						{
							let i_1916 = 0;
							let it_1917 = 0;
							let at_1918 = cases.length;
							while (it_1917 < at_1918) {
								i_1916 = it_1917;
								it_1917++;
								{
									if ((cases[i_1916].length == 0)) {
										r_1907 += '\n' + this.tabs + 'default: ';
										r_1907 += '\n' + this.tabs;
										r_1907 += this.printStatement(statements[i_1916]);
										r_1907 += '\n' + this.tabs;
									};
								};
							};
						};
						return r_1907 + '}';
					}
				} break;
				
				case null: case undefined: {
					console.error('Got null statement kind in JavaScript generator, probably unsupported feature was used, ignoring')
				} break;
				
				default: 
				console.error('Unknown statement kind:', s_1872)
				};
			};
			return '{/* undefined */}';
		};
		printCallArguments(args_1919) { return '(' + (() => {
			const result = [];
			const value_1920 = args_1919;
			for (const a of $toIterator(value_1920)) result.push(this.printExpression(a));
			return result;
		})().join(', ') + ')' };
		printFunctionArguments(args_1921, defaults_1922) { return '(' + (() => {
			const result_1923 = [];
			const value_1924 = args_1921.length;
			for (const a of $toIterator(value_1924)) result_1923.push(args_1921[a] + (((defaults_1922 != null && defaults_1922[a] != null))? (' = ' + this.printExpression(defaults_1922[a])) : ''));
			return result_1923;
		})().join(', ') + ')' };
		printExpression(e_1925) {
			{
				const temp_1926 = e_1925;
				switch (temp_1926&&temp_1926[0]) {
				case 7: {
					return 'null'
				} break;
				
				case 8: {
					return 'this'
				} break;
				
				case 6: {
					const name_1927 = temp_1926[1];
					return name_1927
				} break;
				
				case 1: {
					const v_1928 = temp_1926[1];
					return '' + v_1928
				} break;
				
				case 2: {
					const v_1929 = temp_1926[1];
					const meta = temp_1926[2];
					const type_1930 = temp_1926[3];
					return '' + v_1929 + 'n'
				} break;
				
				case 3: {
					const v_1931 = temp_1926[1];
					return '' + v_1931
				} break;
				
				case 0: {
					const s_1932 = temp_1926[1];
					{
						const s_1933 = s_1932.split('');
						const charsOut = [];
						while (s_1933.length > 0) {
							const temp_1934 = s_1933[0];
							switch (temp_1934) {
							case '\'': {
								{
									charsOut.push('\\');
									charsOut.push('\'');
									s_1933.shift();
								}
							} break;
							
							case '\n': {
								{
									charsOut.push('\\n');
									s_1933.shift();
								}
							} break;
							
							case '\r': {
								{
									charsOut.push('\\r');
									s_1933.shift();
								}
							} break;
							
							case '\\': {
								{
									s_1933.shift();
									if ((s_1933[0] == '\'')) {
										charsOut.push('\\\'');
										s_1933.shift();
									} else if ((s_1933[0] == '"')) {
										charsOut.push('\\"');
										s_1933.shift();
									} else if ((s_1933[0] == '\\')) {
										charsOut.push('\\\\');
										s_1933.shift();
									} else {
										charsOut.push('\\');
									};
								}
							} break;
							
							default: 
							{
								charsOut.push(s_1933[0]);
								s_1933.shift();
							}
							};
						};
						return '\'' + charsOut.join('') + '\'';
					}
				} break;
				
				case 4: {
					return 'true'
				} break;
				
				case 5: {
					return 'false'
				} break;
				
				case 9: {
					const expr_1935 = temp_1926[1];
					const name_1936 = temp_1926[2];
					{
						{
							const temp_1937 = expr_1935;
							switch (temp_1937&&temp_1937[0]) {
							case 1: {
								return '(' + this.printExpression(expr_1935) + ').' + name_1936
							} break;
							
							case 3: {
								return '(' + this.printExpression(expr_1935) + ').' + name_1936
							} break;
							};
						};
						return this.printExpression(expr_1935) + '.' + name_1936;
					}
				} break;
				
				case 10: {
					const e_1938 = temp_1926[1];
					const args_1939 = temp_1926[2];
					return this.printExpression(e_1938) + this.printCallArguments(args_1939)
				} break;
				
				case 13: {
					const name_1940 = temp_1926[1];
					const expr_1941 = temp_1926[2];
					const args_1942 = temp_1926[3];
					const defaults_1943 = temp_1926[4];
					{
						if ((name_1940 == null)) { return this.printFunctionArguments(args_1942, defaults_1943) + ' => ' + this.printBlock(expr_1941) };
						return '((() => { const ' + name_1940 + ' = ' + this.printFunctionArguments(args_1942, defaults_1943) + ' => ' + this.printBlock(expr_1941) + '; return ' + name_1940 + ' })())';
					}
				} break;
				
				case 14: {
					const expr_1944 = temp_1926[1];
					const args_1945 = temp_1926[2];
					const defaults_1946 = temp_1926[3];
					return this.printFunctionArguments(args_1945, defaults_1946) + ' => (' + this.printExpression(expr_1944) + ')'
				} break;
				
				case 11: {
					const e_1947 = temp_1926[1];
					const args_1948 = temp_1926[2];
					return 'new ' + this.printExpression(e_1947) + this.printCallArguments(args_1948)
				} break;
				
				case 17: {
					const el_1949 = temp_1926[1];
					return '[' + (() => {
						const result_1950 = [];
						const value_1951 = el_1949;
						for (const a of $toIterator(value_1951)) result_1950.push(this.printExpression(a));
						return result_1950;
					})().join(', ') + ']'
				} break;
				
				case 19: {
					const op_1952 = temp_1926[1];
					const postfix = temp_1926[2];
					const e_1953 = temp_1926[3];
					{
						if (postfix) { return '(' + this.printExpression(e_1953) + Token.stringify(op_1952) + ')' };
						return '(' + Token.stringify(op_1952) + this.printExpression(e_1953) + ')';
					}
				} break;
				
				case 20: {
					const nullable = temp_1926[1];
					const othewise = temp_1926[2];
					return '((' + this.printExpression(nullable) + ') || (' + this.printExpression(othewise) + '))'
				} break;
				
				case 15: {
					const e_1954 = temp_1926[1];
					return '(' + this.printExpression(e_1954) + ')'
				} break;
				
				case 12: {
					const a_1955 = temp_1926[1];
					const op_1956 = temp_1926[2];
					const b = temp_1926[3];
					{
						const bn = (this.bi++);
						return '' + this.printExpression(a_1955) + ' ' + Token.stringify(op_1956) + ' ' + this.printExpression(b) + '';
						return '(' + this.printExpression(a_1955) + ' ' + Token.stringify(op_1956) + ' ' + this.printExpression(b) + ')';
						return ('/*bi' + (bn) + '(*/') + this.printExpression(a_1955) + ' ' + Token.stringify(op_1956) + ' ' + this.printExpression(b) + ('/*)bi' + (bn) + '*/');
					}
				} break;
				
				case 22: {
					const expr_1957 = temp_1926[1];
					const index = temp_1926[2];
					return this.printExpression(expr_1957) + '[' + this.printExpression(index) + ']'
				} break;
				
				case 21: {
					const econd_1958 = temp_1926[1];
					const eif_1959 = temp_1926[2];
					const eelse_1960 = temp_1926[3];
					{
						let r_1961 = '';
						try {
							r_1961 += '(' + this.printExpression(econd_1958) + ')?';
							r_1961 += ' (' + this.printExpression(eif_1959) + ')';
							r_1961 += ' : ' + this.printExpression(eelse_1960);
							return r_1961;
						} catch (temp_1962) {
							if (true) { 
							const error = temp_1962
							{
								console.log('If =>', e_1925, error);
								return r_1961 + '<!-- If => error -->';
							} } else
							
							throw temp_1962;
						};
					}
				} break;
				
				case 27: {
					const expr_1963 = temp_1926[1];
					{
						const e_1964 = this.printExpression(expr_1963);
						return e_1964 + '&&' + e_1964 + '[0]';
					}
				} break;
				
				case 16: {
					const names = temp_1926[1];
					const el_1965 = temp_1926[2];
					return '{' + (() => {
						const result_1966 = [];
						const value_1967 = el_1965.length;
						for (const i of $toIterator(value_1967)) result_1966.push(((names[i]) + ':' + this.printExpression(el_1965[i])));
						return result_1966;
					})().join(', ') + '}'
				} break;
				
				case 18: {
					const keys = temp_1926[1];
					const values = temp_1926[2];
					{
						if ((keys.length == 0)) { return 'new Map()' };
						return 'new Map([' + (() => {
							const result_1968 = [];
							const value_1969 = keys.length;
							for (const i of $toIterator(value_1969)) result_1968.push('[' + this.printExpression(keys[i]) + ', ' + this.printExpression(values[i]) + ']');
							return result_1968;
						})().join(', ') + '])';
					}
				} break;
				
				case 25: {
					const a_1970 = temp_1926[1];
					const op_1971 = temp_1926[2];
					const value_1972 = temp_1926[3];
					return this.printExpression(a_1970) + ' ' + Token.stringify(op_1971) + '= ' + this.printExpression(value_1972)
				} break;
				
				case 26: {
					const kind = temp_1926[1];
					const args_1973 = temp_1926[2];
					const s_1974 = temp_1926[3];
					{
						const temp_1975 = kind;
						switch (temp_1975) {
						case 0: {
							return '((' + this.printExpression(args_1973[0]) + ') ' + s_1974 + ' (' + this.printExpression(args_1973[1]) + '))'
						} break;
						
						case 1: {
							return s_1974 + this.printCallArguments(args_1973)
						} break;
						
						case 2: {
							return '(' + s_1974 + '(' + this.printExpression(args_1973[0]) + '))'
						} break;
						
						case 3: {
							return '((' + this.printExpression(args_1973[1]) + ')' + s_1974 + ')'
						} break;
						};
					}
				} break;
				
				case 23: {
					const e_1976 = temp_1926[1];
					const t_1977 = temp_1926[2];
					return '(' + this.printExpression(e_1976) + ')'
				} break;
				
				case 24: {
					const e_1978 = temp_1926[1];
					const t_1979 = temp_1926[2];
					return '((' + this.printExpression(e_1978) + ') instanceof ' + Type.stringify(t_1979) + ')'
				} break;
				
				case 28: {
					const type_1980 = temp_1926[1];
					const tagName = temp_1926[2];
					const tag = temp_1926[3];
					const args_1981 = temp_1926[4];
					{
						if (args_1981.length == 0) { return ('/*' + (tagName) + '*/[') + this.printExpression(tag) + ']' };
						return (('/*' + (tagName) + '*/[') + this.printExpression(tag) + ',' + (() => {
							const result_1982 = [];
							const value_1983 = args_1981;
							for (const a of $toIterator(value_1983)) result_1982.push(this.printExpression(a));
							return result_1982;
						})().join(',') + ']');
					}
				} break;
				
				case 29: {
					const expr_1984 = temp_1926[1];
					const index_1985 = temp_1926[2];
					return this.printExpression(expr_1984) + '[' + (1 + index_1985) + ']'
				} break;
				
				case null: case undefined: {
					console.error('Got null expression kind in JavaScript generator, probably unsupported feature was used, ignoring')
				} break;
				
				default: 
				console.error('Unknown expression kind:', e_1925)
				};
			};
			return '{/* undefined */}';
		};
	}
	GenJs.spawn = () => { return new GenJs() };
	var NiceProject = class {
		constructor() { 
			this.interfaces = []
			this.classes = []
			this.enumsSimple = []
			this.enumsComplex = []
			this.globalVars = []
			this.globalFuncs = []
			this.init = []
			this.expressionType = new Map()
			this.expressionPosition = new Map()
			this.statementPosition = new Map()
			this.native = new Map()
		{
		} };
	}
	var NiceClass = class {
		constructor() { 
			this.staticMethods = []
			this.staticVars = []
			this.methods = []
			this.vars = []
			this.property = []
			this.jsRequire = null
			this.jsNative = null
		{
		} };
	}
	var NiceSimpleEnum = class {
		constructor() { 
			this.staticMethods = []
			this.staticVars = []
		{
		} };
	}
	var NiceComplexEnum = class {
		constructor() { 
			this.staticMethods = []
			this.staticVars = []
		{
		} };
	}
	var NodeData = class {
		constructor(atLine, atColumn, atFile) { 
		{
			this.line = atLine;
			this.column = atColumn;
			this.fileName = atFile;
		} };
	}
	var Decorator = class {
		constructor(name, values) { 
		{
			this.name = name;
			this.values = values;
		} };
	}
	var DataHelper = class {
	}
	DataHelper.varName = (v_2138) => {
			const temp_2139 = v_2138;
			switch (temp_2139&&temp_2139[0]) {
			case 24: {
				const name_2140 = temp_2139[1];
				return name_2140
			} break;
			
			default: 
			throw ('varName got not a Var, but `' + (v_2138) + '`')
			};
		};
	DataHelper.nameOf = (v_2141) => {
			const temp_2142 = v_2141;
			switch (temp_2142&&temp_2142[0]) {
			case 48: {
				const node_2143 = temp_2142[1];
				return DataHelper.nameOf(node_2143)
			} break;
			
			case 26: {
				const node_2144 = temp_2142[1];
				return DataHelper.nameOf(node_2144)
			} break;
			
			case 24: {
				const name_2145 = temp_2142[1];
				return name_2145
			} break;
			
			case 39: {
				const t_2146 = temp_2142[1];
				{
					{
						const temp_2147 = t_2146;
						switch (temp_2147&&temp_2147[0]) {
						case 1: {
							const name_2148 = temp_2147[1];
							return name_2148
						} break;
						
						case 2: {
							const name_2149 = temp_2147[1];
							return name_2149
						} break;
						};
					};
					throw 'unreachable';
				}
			} break;
			
			case 22: {
				const name_2150 = temp_2142[1];
				return name_2150
			} break;
			
			case 25: {
				const t_2151 = temp_2142[1];
				{
					{
						const temp_2152 = t_2151;
						switch (temp_2152&&temp_2152[0]) {
						case 1: {
							const name_2153 = temp_2152[1];
							return name_2153
						} break;
						
						case 2: {
							const name_2154 = temp_2152[1];
							return name_2154
						} break;
						};
					};
					throw 'unreachable';
				}
			} break;
			
			case 9: {
				const t_2155 = temp_2142[1];
				{
					const temp_2156 = t_2155;
					switch (temp_2156&&temp_2156[0]) {
					case 1: {
						const name_2157 = temp_2156[1];
						return name_2157
					} break;
					
					case 2: {
						const name_2158 = temp_2156[1];
						return name_2158
					} break;
					};
				}
			} break;
			
			case 47: {
				const field_2159 = temp_2142[1];
				return DataHelper.nameOf(field_2159)
			} break;
			
			default: 
			throw ('nameOf expected named node, but got `' + (v_2141) + '`')
			};
		};
	DataHelper.asStringAttValue = (a_2160, index_2161) => {
			const temp_2162 = a_2160.values[index_2161];
			switch (temp_2162&&temp_2162[0]) {
			case null: case undefined: {
				throw 'Got null, not a string'
			} break;
			
			case 0: {
				const s_2163 = temp_2162[1];
				return s_2163
			} break;
			
			default: 
			throw ('Got `' + (a_2160.values[index_2161]) + '`, not a string')
			};
		};
	DataHelper.getLastOfBlock = (block) => {
			const temp_2164 = block;
			switch (temp_2164&&temp_2164[0]) {
			case null: case undefined: {
				throw 'Got null, not a block'
			} break;
			
			case 12: {
				const el_2165 = temp_2164[1];
				return el_2165[el_2165.length - 1]
			} break;
			
			default: 
			throw ('Got `' + (block) + '`, not a block')
			};
		};
	DataHelper.isVoidValue = (block_2166) => {
			{
				const temp_2167 = block_2166;
				switch (temp_2167&&temp_2167[0]) {
				case null: case undefined: {
					return true
				} break;
				
				case 16: {
					return true
				} break;
				
				case 18: {
					return true
				} break;
				
				case 19: {
					return true
				} break;
				
				case 24: {
					return true
				} break;
				
				case 14: {
					const eelse_2168 = temp_2167[3];
					if (eelse_2168 == null) { return true }
				} break;
				
				case 39: {
					return true
				} break;
				
				case 25: {
					return true
				} break;
				
				case 34: {
					return true
				} break;
				
				case 12: {
					const el_2169 = temp_2167[1];
					{
						if (el_2169.length == 0) { return true };
						return DataHelper.isVoidValue(el_2169[el_2169.length - 1]);
					}
				} break;
				
				default: 
				return false
				};
			};
			return false;
		};
	DataHelper.extractTypeName = (t_2170) => {
			const temp_2171 = t_2170;
			switch (temp_2171&&temp_2171[0]) {
			case 1: {
				const name_2172 = temp_2171[1];
				return name_2172
			} break;
			
			case 2: {
				const name_2173 = temp_2171[1];
				return name_2173
			} break;
			
			case null: case undefined: {
				return null
			} break;
			
			default: 
			throw 'Type has no name: ' + t_2170
			};
		};
	DataHelper.getDecorator = (atts, name_2174) => {
			if (atts != null && atts.length > 0) { for (const att of $toIterator(atts)) {
				if (att.name == name_2174) { return att };
			} };
			return null;
		};
	DataHelper.isTitleCase = (string) => { return string.charAt(0) == string.charAt(0).toUpperCase() };
	var ClassType = class {
		constructor() { 
			this.owner = null
			this.fieldNames = []
			this.fieldRenames = []
			this.fieldStatic = []
			this.fieldInitialized = []
			this.protected = []
			this.immutable = []
			this.constructor = (-1)
			this.indexKeyType = null
			this.indexValueType = null
			this.fields = new Map()
			this.genericParams = []
			this.useless = true
			this.instanceCache = /*ClassInstance*/[4,this,null]
			this.genericCache = []
		{
		} };
		instantiate() { return this.instanceCache };
		instantiateGeneric(params) {
			for (const cached of $toIterator(this.genericCache)) {
				if (cached.length != (params.length + 1)) { continue };
				let found = true;
				{
					let i = 0;
					let it = 0;
					let at = cached.length - 1;
					while (it < at) {
						i = it;
						it++;
						{
							if (params[i] != cached[i + 1]) {
								found = false;
								break;
							};
						};
					};
				};
				if (found) {
					const result_2220 = cached[0];
					return result_2220;
				};
			};
			const result_2221 = /*ClassInstance*/[4,this,params];
			const cache = [result_2221];
			for (const param of $toIterator(params)) {
				cache.push(param);
			};
			this.genericCache.push(cache);
			return result_2221;
		};
	}
	var EnumType = class {
		constructor() { 
			this.fieldNames = []
			this.tagBindVars = []
			this.tagBindVarsNames = []
			this.fieldStatic = []
			this.fieldEnumConstructor = []
			this.fieldType = []
			this.fieldsTypeSimple = null
		{
		} };
	}
	var AliasType = class {
		constructor() {};
	}
	var Module = class {
		constructor() { 
			this.file = '.hexa'
			this.path = 'module'
			this.nodes = []
			this.exported = new Map()
			this.imported = new Map()
		{
		} };
	}
	var Project = class {
		constructor() { 
			this.mapDecorators = new Map()
			this.mapNames = new Map()
			this.mapModules = new Map()
			this.data = new Map()
			this.hints = []
			this.defines = {}
			this.name = 'Hexa Project'
			this.json = 'hexa.json'
			this.roots = []
			this.globals = new Map()
			this.moduleName = []
			this.moduleInfo = []
		{
		} };
	}
	var CompilerError = class {
		constructor(except, details, line, column, filename) { 
		{
			this.exception = except;
			this.details = ((details == null))? ('') : details;
			this.line = ((line == null))? (0) : line;
			this.column = ((column == null))? (0) : column;
			this.fileName = ((filename == null))? ('') : filename;
		} };
		toString() { return '[' + this.fileName + ':' + this.line + ':' + this.column + ']: ' + this.details };
	}
	var CompilerErrors = class {
		constructor(errors) { 
		this.errors = errors };
		toString() {
			{
				let step = 0;
				const error = this.errors[0];
				let temp = null;
				if (step == 0 && error != null) {
					temp = this.errors.length == 1;
					step = 1;
				};
				if (step == 1 && temp != false) { step = 2 };
				if (step == 2) { return error.toString() };
			};
			return (() => {
				const result = [];
				const value = this.errors;
				for (const error of $toIterator(value)) result.push(error.toString());
				return result;
			})().join('\n') + '\nFound ' + this.errors.length + ' errors.';
		};
	}
	var Hint = class {
		constructor(code, details, position) { 
		{
			this.code = code;
			this.details = details;
			this.at = position;
		} };
		toString() { return '[' + this.at.fileName + ':' + this.at.line + ':' + this.at.column + ']: Hint#' + this.code + ': ' + this.details };
	}
	var Main = class {
		processFile(target, project) {
			const content = Fs.readFileSync(target);
			const tokens = Lexer.tokenize(content, target);
			if ((tokens.length > 0)) { this.lines += tokens.line[tokens.length - 1] };
			const parsed = Parser.parseNodes(tokens, project);
			return parsed;
		};
		simplyCompileToJs(buffer, path) {
			process.argv[0] = __dirname + '/repl.json';
			const resolved = Path.resolve(__dirname + '/repl.hexa');
			fileContents.set(resolved, buffer);
			return new Main().perform(true);
		};
		repl() {
			console.log('\x1b[35m' + ('Hexa ' + (version) + ' on node.js ') + process_99.versions.node + '\x1b[0m');
			console.log('\x1b[33mTo print something onto screen use `console.log(value)`\x1b[0m');
			console.log('\x1b[33mTo clear REPL memory use `.clear`\x1b[0m');
			console.log('\x1b[33mTo close REPL use `.exit`\x1b[0m');
			let linesAll = [];
			let linesLatest = [];
			while (true) {
				let line = question('\x1b[32m> \x1b[0m').trim();
				if (line == '.clear') {
					linesAll = [];
					linesLatest = [];
					continue;
				};
				if (line == '.exit') { return };
				if (line.length == 0) { continue };
				linesLatest.push(line);
				try {
					let code = '"use strict"\r\n';
					try {
						const content_2228 = linesAll.join('\n') + '\n' + linesLatest.join('\n');
						const compiled = this.simplyCompileToJs(Buffer.from(content_2228), 'REPL');
						if (compiled == null) {
							linesLatest.pop();
							continue;
						};
						{
							let step = 0;
							const compiled_2229 = compiled;
							if (step == 0 && compiled_2229 != null) { step = 1 };
							if (step == 1) { code = compiled_2229 };
						};
					} catch (temp_2227) {
						if (true) { 
						const e = temp_2227
						{
							const error = '' + e;
							if (error.indexOf('<!--eof-->') == (-1)) {
								linesLatest = [];
								console.error('\x1b[31mCompilation Error: ' + e, '\x1b[0m');
							} else {
								process_99.stdout.write('\x1b[32m>\x1b[0m');
							};
							continue;
						} } else
						
						throw temp_2227;
					};
					for (const line of $toIterator(linesLatest)) {
						linesAll.push(line);
					};
					linesLatest = [];
					const result = eval(code);
				} catch (temp) {
					if (true) { 
					const e = temp
					{
						console.error('Error: ' + e);
					} } else
					
					throw temp;
				};
			};
		};
		processFiles(targets, relativePath, loaded, project_2259) {
			let res = [];
			const imports = [];
			for (const target of $toIterator(targets)) {
				if (((!Fs.existsSync(target)))) {
					console.log(('No such source file on disk `' + (target) + '`'));
					continue;
				};
				try {
					const parsed_2261 = this.processFile(target, project_2259);
					res.push(parsed_2261);
					for (const e of $toIterator(parsed_2261)) {
						const temp_2262 = e;
						switch (temp_2262&&temp_2262[0]) {
						case 37: {
							const el = temp_2262[1];
							const path_2263 = temp_2262[2];
							{
								const resolved_2264 = Path.resolve(relativePath + path_2263 + '.hexa');
								console.log('processFiles! ' + resolved_2264);
								if ((loaded.get(resolved_2264) == true)) { console.log('loaded! ' + resolved_2264) };
								if ((loaded.get(resolved_2264) != true)) {
									loaded.set(resolved_2264, true);
									imports.push(resolved_2264);
								};
							}
						} break;
						};
					};
				} catch (temp_2260) {
					if (true) { 
					const e = temp_2260
					{
						console.log('\x1b[31m' + e.toString() + '\x1b[0m');
					} } else
					
					throw temp_2260;
				};
			};
			if ((targets.length != res.length)) {
				console.log('[Stopped on errors]');
				process_99.exit(1);
			};
			if ((imports.length > 0)) { for (const file of $toIterator(this.processFiles(imports, relativePath, loaded, project_2259))) {
				res.unshift(file);
			} };
			return res;
		};
		incorrect(what, project_2265) {
			const msg_2266 = ('Incorrect package file! Field `' + (what) + '` does not exists\n');
			throw new CompilerErrors([new CompilerError(5, msg_2266, 1, 1, project_2265.json)]);
		};
		readPackage(filename) { try {
			const pack = JSON.parse(Fs.readFileSync(Path.resolve(filename)).toString('utf8').split('\r\n').join('\n'));
			return pack;
		} catch (temp_2267) {
			if (true) { 
			const e = temp_2267
			{
				const msg_2268 = 'Cannot open ' + filename;
				throw new CompilerErrors([new CompilerError(5, msg_2268, 1, 1, 'hexa.json')]);
			} } else
			
			throw temp_2267;
		} };
		loadPackage(filename_2269, target_2270, project_2271) {
			const pack_2272 = this.readPackage(filename_2269);
			project_2271.json = filename_2269;
			{
				let step_2273 = 0;
				const name_2274 = pack_2272.name;
				if (step_2273 == 0 && name_2274 != null) { step_2273 = 1 };
				if (step_2273 == 1) { project_2271.name = name_2274 } else {
					this.incorrect('name', project_2271);
				};
			};
			if ((pack_2272.targets == null)) { this.incorrect('targets', project_2271) };
			{
				let step_2275 = 0;
				const entry = pack_2272.entry;
				if (step_2275 == 0 && entry != null) { step_2275 = 1 };
				if (step_2275 == 1) { if (((!entry.startsWith('/')))) { pack_2272.entry = '/' + entry } } else {
					this.incorrect('entry', project_2271);
				};
			};
			{
				let step_2276 = 0;
				const define = pack_2272.define;
				if (step_2276 == 0 && define != null) { step_2276 = 1 };
				if (step_2276 == 1) { for (const key of $toIterator(Reflect.ownKeys(define))) {
					if (((!Reflect.has(project_2271.defines, key)))) { Reflect.set(project_2271.defines, key, Reflect.get(define, key)) };
				} };
			};
			const t = (() => {
				{
					let t_2277 = 0;
					let it = 0;
					let at = pack_2272.targets.length;
					while (it < at) {
						t_2277 = it;
						it++;
						{
							if ((pack_2272.targets[t_2277].name == target_2270)) {
								this.targetIndex = t_2277;
								return pack_2272.targets[t_2277];
							};
						};
					};
				};
				const msg_2278 = ('Cannot find `' + (target_2270) + '` target in package file\n');
				throw new CompilerErrors([new CompilerError(5, msg_2278, 1, 1, project_2271.json)]);
			})();
			const generator = availableGenerators(t.generator);
			if ((generator == null)) {
				const msg_2279 = ('Generator `' + (t.generator) + '` not available or not supported by this compiler version\n');
				throw new CompilerErrors([new CompilerError(5, msg_2279, 1, 1, project_2271.json)]);
			};
			project_2271.roots.push(Path.resolve(__dirname + '/library/'));
			const dir = Path.dirname(filename_2269);
			{
				let step_2280 = 0;
				const roots_2281 = pack_2272.roots;
				if (step_2280 == 0 && roots_2281 != null) { step_2280 = 1 };
				if (step_2280 == 1) { for (const root of $toIterator(roots_2281)) {
					project_2271.roots.push(Path.resolve(dir + '/' + root));
				} } else {
					project_2271.roots.push(Path.resolve(dir));
				};
			};
			if ((pack_2272.files == null)) { pack_2272.files = [] };
			pack_2272.global = (() => {
				const result_2282 = pack_2272.global;
				if (result_2282 != null) { return result_2282 };
				return [];
			})();
			{
				let i = 0;
				let it_2283 = 0;
				let at_2284 = pack_2272.global.length;
				while (it_2283 < at_2284) {
					i = it_2283;
					it_2283++;
					{
						let step_2285 = 0;
						const file_2286 = pack_2272.global[i];
						let temp_2287 = null;
						if (step_2285 == 0 && file_2286 != null) {
							temp_2287 = (!file_2286.startsWith('/'));
							step_2285 = 1;
						};
						if (step_2285 == 1 && temp_2287 != false) { step_2285 = 2 };
						if (step_2285 == 2) { pack_2272.global[i] = '/' + file_2286 };
					};
				};
			};
			if ((pack_2272.noLib == true)) {} else {
				const libraries = setLibrary(generator, t.options, project_2271.defines);
				for (const file of $toIterator(libraries)) {
					pack_2272.global.unshift(file);
				};
			};
			if ((pack_2272.addLicenseNoticeToOutput == null)) { pack_2272.addLicenseNoticeToOutput = true };
			return pack_2272;
		};
		constructor() { 
			this.lines = 0
			this.targetName = 'default'
			this.targetIndex = 0
			this.typecheckProject = new Project()
		{
		} };
		loadModules(project_2288, input) {
			const moduleErrors = [];
			{
				let step_2289 = 0;
				const global_2290 = input.global;
				if (step_2289 == 0 && global_2290 != null) { step_2289 = 1 };
				if (step_2289 == 1) { for (const path of $toIterator(global_2290)) {
					try { this.lines += Main.processModule(project_2288, path, true) } catch (temp_2291) {
						if (temp_2291 instanceof CompilerErrors) { 
						const e = temp_2291
						{
							const errors = e.errors;
							for (const error of $toIterator(errors)) {
								moduleErrors.push(error);
							};
						} } else
						
						throw temp_2291;
					};
				} };
			};
			try { Main.processModule(project_2288, input.entry, false) } catch (temp_2292) {
				if (temp_2292 instanceof CompilerErrors) { 
				const e = temp_2292
				{
					const errors_2293 = e.errors;
					for (const error of $toIterator(errors_2293)) {
						moduleErrors.push(error);
					};
				} } else
				
				throw temp_2292;
			};
			if ((moduleErrors.length > 0)) { throw new CompilerErrors(moduleErrors) };
		};
		perform(noWrite) {
			const begin = Date.now();
			Lexer.init();
			const defines = {};
			while (process_99.argv[0] == '--define') {
				if ((process_99.argv.length < 2)) {
					console.log('Usage: `--define name=value`');
					process_99.exit(1);
				};
				process_99.argv.shift();
				const kv = ((() => {
					const result_2294 = process_99.argv.shift();
					if (result_2294 != null) { return result_2294 };
					return '';
				})()).split('=');
				if ((kv.length < 2)) {
					console.log('Usage: `--define name=value`');
					process_99.exit(1);
				};
				const k = kv[0];
				const v = JSON.parse(kv[1]);
				defines[k] = v;
			};
			const project_2295 = new Project();
			project_2295.defines = defines;
			if ((process_99.argv[0] == 'syntax-linter')) {
				if ((process_99.argv.length < 2)) { console.log('Usage: `hexa syntax-linter file.hexa`') } else {
					const file_2296 = process_99.argv[1];
					try {
						const content_2298 = Fs.readFileSync(file_2296);
						try {
							const tokens_2300 = Lexer.tokenize(content_2298, file_2296);
							try { const parser = Parser.parseNodes(tokens_2300, project_2295, true) } catch (temp_2301) {
								if (true) { 
								const e = temp_2301
								{
									console.log(('' + (e) + ''));
								} } else
								
								throw temp_2301;
							};
						} catch (temp_2299) {
							if (true) { 
							const e = temp_2299
							{
								console.log(('' + (e) + ''));
							} } else
							
							throw temp_2299;
						};
					} catch (temp_2297) {
						if (true) { 
						const e = temp_2297
						{
							console.log(('ERROR: Unable to open file ' + (file_2296) + ''));
						} } else
						
						throw temp_2297;
					};
				};
				process_99.exit(0);
			};
			const ignoreArguments = (fromIndex) => {
				if ((fromIndex == process_99.argv.length)) { return };
				const args = [];
				const count = process_99.argv.length - fromIndex;
				let i_2302 = 0;
				while (i_2302 < count) {
					args.push(process_99.argv[(i_2302++) + fromIndex]);
				};
				console.log('Argument' + ((args.length > 1)? ('s') : '') + ' `' + args.join('`, `') + '` ignored');
			};
			if ((process_99.argv[0] == null)) {
				this.repl();
				process_99.exit(0);
			} else if ((process_99.argv[0] == 'init')) {
				init();
				ignoreArguments(3);
				process_99.exit(0);
			} else if ((process_99.argv[0] == 'symlink')) {
				symlink();
				process_99.exit(0);
			};
			let currentFile = Path.resolve(process_99.argv[0]);
			let currentParsedFile = Path.parse(currentFile);
			let input_2303 = (null);
			let packageFolder = currentParsedFile.dir;
			if ((currentParsedFile.ext == '.json')) {
				process.argv.shift();
				if ((process.argv[0] == 'targets')) {
					const pack_2304 = this.readPackage(currentFile);
					if ((pack_2304.name == null)) { this.incorrect('name', project_2295) };
					if ((pack_2304.targets == null)) { this.incorrect('targets', project_2295) };
					const targets_2305 = [];
					for (const target of $toIterator(pack_2304.targets)) {
						targets_2305.push(target.name);
					};
					console.log(quote(('The project `' + (pack_2304.name) + '` has following targets: ') + targets_2305.join(', ')));
					return null;
				};
				if ((process.argv[0] == '--target')) {
					process.argv.shift();
					this.targetName = (() => {
						const result_2306 = process.argv[0];
						if (result_2306 != null) { return result_2306 };
						return 'default';
					})();
					process.argv.shift();
				};
				input_2303 = this.loadPackage(currentFile, this.targetName, project_2295);
				ignoreArguments(0);
				if ((!noWrite)) {
					if ((this.targetName != 'default')) { console.log(('[Building ' + (input_2303.name) + ' - ' + (this.targetName) + ']')) } else {
						console.log(('[Building ' + (input_2303.name) + ']'));
					};
					console.log(('[Using 1 of ' + (require('os').cpus().length) + ' CPU cores]'));
				};
			} else if ((Fs.existsSync(currentFile)) && (Fs.lstatSync(currentFile).isDirectory())) {
				ignoreArguments(3);
				input_2303 = this.loadPackage(currentFile + Path.sep + 'hexa.json', this.targetName, project_2295);
				packageFolder = currentFile;
			} else if ((currentParsedFile.ext == '.hexa')) {
				try { eval(this.simplyCompileToJs(Fs.readFileSync(currentFile), currentFile)) } catch (temp_2307) {
					if (true) { 
					const e = temp_2307
					{
						console.error('' + e);
					} } else
					
					throw temp_2307;
				};
				process_99.exit(0);
				return null;
			} else {
				console.error(('Unknown command: ' + (process_99.argv[0]) + ''));
				console.error(quote('Try `hexa help`'));
				printVersion();
				process_99.exit(1);
				return null;
			};
			let files = [];
			if ((false) && (input_2303.files != null)) {
				const relativePath_2308 = packageFolder + Path.sep;
				const loaded_2309 = new Map();
				const fileList = input_2303.files.map((file_2310) => {
					if ((file_2310.startsWith('/') || file_2310.charAt(1) == ':')) { return Path.resolve(file_2310) };
					const resolved_2311 = Path.resolve(relativePath_2308 + file_2310);
					loaded_2309.set(resolved_2311, true);
					return resolved_2311;
				});
				{
					files = this.processFiles(fileList, relativePath_2308 + '/' + input_2303.root + '/', loaded_2309, project_2295);
				};
			};
			try { this.loadModules(project_2295, input_2303) } catch (temp_2312) {
				if (true) { 
				const e = temp_2312
				{
					console.error(e.toString());
					process_99.exit(500);
				} } else
				
				throw temp_2312;
			};
			const typer = new Typer(project_2295);
			try { typer.fillModules() } catch (temp_2313) {
				if (true) { 
				const e = temp_2313
				{
					console.log('\x1b[31m' + e.toString() + '\x1b[0m');
					if (noWrite) { return null };
					process_99.exit(1);
				} } else
				
				throw temp_2313;
			};
			const normalizer = new Normalizer(project_2295);
			const generators = new Map();
			const registerTarget = (name_2314, generator_2315) => {
				{
					let step_2316 = 0;
					const generator_2317 = generators.get(name_2314);
					if (step_2316 == 0 && generator_2317 != null) { step_2316 = 1 };
					if (step_2316 == 1) { console.log(('Note: generator `' + (name_2314) + '` was overridden')) };
				};
				generators.set(name_2314, generator_2315);
			};
			registerTarget('js', GenJs.spawn);
			{
				let step_2318 = 0;
				const generatorName = input_2303.targets[this.targetIndex].generator;
				if (step_2318 == 0 && generatorName != null) { step_2318 = 1 };
				if (step_2318 == 1) {
					let step_2319 = 0;
					const generatorSpawner = generators.get(generatorName);
					if (step_2319 == 0 && generatorSpawner != null) { step_2319 = 1 };
					if (step_2319 == 1) {
						const generator_2320 = generatorSpawner();
						const target_2321 = packageFolder + Path.sep + Path.parse(input_2303.targets[this.targetIndex].output).name + generator_2320.extension;
						const target_2322 = Path.join(packageFolder, input_2303.targets[this.targetIndex].output);
						normalizer.keywords = generator_2320.reserved;
						normalizer.collected = files;
						normalizer.nativeEnums = generator_2320.nativeEnums;
						normalizer.reservedGlobals = (() => {
							const result_2323 = generator_2320.reservedGlobals;
							if (result_2323 != null) { return result_2323 };
							return normalizer.reservedGlobals;
						})();
						normalizer.package = input_2303;
						{
							let step_2324 = 0;
							const randomSeed = input_2303.randomSeed;
							if (step_2324 == 0 && randomSeed != null) { step_2324 = 1 };
							if (step_2324 == 1) { normalizer.id = randomSeed };
						};
						{
							let step_2325 = 0;
							const globalAccessor = generator_2320.globalAccessor;
							if (step_2325 == 0 && globalAccessor != null) { step_2325 = 1 };
							if (step_2325 == 1) { normalizer.globalAccessor = globalAccessor };
						};
						normalizer.typer = typer;
						const normal = normalizer.normalize();
						for (const hint of $toIterator(project_2295.hints)) {
							console.log(hint.toString());
						};
						const outs = generator_2320.perform(normal);
						if (noWrite) { return outs };
						Fs.writeFileSync(target_2322, outs);
					} else {
						console.log(('Generator for `' + (generatorName) + '` is not registered.'));
						process_99.exit(1);
					};
				} else {
					console.log('Generator is not defined or unknown. Is there `target.generator` field in `hexa.json`?');
					process_99.exit(1);
				};
			};
			const delta = Date.now() - begin;
			const lps = Math.round(this.lines / (delta / 1000));
			console.log(('[Finished in ' + (delta) + ' ms, ' + (this.lines) + ' lines, ' + (lps) + ' lines per second]'));
			process_99.stdout.once('drain', () => { process_99.exit(0) });
			process_99.stdout.write('');
			return null;
		};
		typecheck(dir_2326) {
			try {
				const project_2328 = new Project();
				this.typecheckProject = project_2328;
				const defines_2329 = {};
				project_2328.defines = defines_2329;
				const input_2330 = this.loadPackage(dir_2326 + Path.sep + 'hexa.json', this.targetName, project_2328);
				try { this.loadModules(project_2328, input_2330) } catch (temp_2331) {
					if (true) { 
					const e = temp_2331
					{
						return e;
					} } else
					
					throw temp_2331;
				};
				const typer_2332 = new Typer(project_2328);
				try { typer_2332.fillModules() } catch (temp_2333) {
					if (true) { 
					const e = temp_2333
					{
						return e;
					} } else
					
					throw temp_2333;
				};
			} catch (temp_2327) {
				if (true) { 
				const e = temp_2327
				{
					return e;
				} } else
				
				throw temp_2327;
			};
			return new CompilerErrors([]);
		};
	}
	Main.processGlobals = (project_2230, path_2231, fullPath) => {
			const index = project_2230.moduleName.indexOf((() => {
				const result_2232 = fullPath;
				if (result_2232 != null) { return result_2232 };
				return path_2231;
			})());
			{
				let step_2233 = 0;
				const info = project_2230.moduleInfo[index];
				if (step_2233 == 0 && info != null) { step_2233 = 1 };
				if (step_2233 == 1) {
					const nodes = info.nodes;
					for (const e of $toIterator(nodes)) {
						let named = true;
						{
							const temp_2234 = e;
							switch (temp_2234&&temp_2234[0]) {
							case 24: {
								{
								}
							} break;
							
							case 39: {
								{
								}
							} break;
							
							case 22: {
								{
								}
							} break;
							
							case 25: {
								{
								}
							} break;
							
							default: 
							named = false
							};
						};
						if (named) {
							const name = DataHelper.nameOf(e);
							if ((project_2230.globals.has(name))) {
								const data = project_2230.data.get(e);
								const msg = ('Global node `' + (name) + '` declared in `' + (path_2231) + '` already defined somewhere\n');
								throw new CompilerErrors([new CompilerError(5, msg, data.line, data.column, data.fileName)]);
							} else {
								project_2230.globals.set(name, e);
							};
						};
					};
				};
			};
		};
	Main.processModule = (project_2235, path_2236, global, relative, node) => {
			let lines = 0;
			const tryInRoot = (root, fullPath_2237) => {
				const file = Path.join(root, path_2236 + '.hexa');
				if ((Fs.existsSync(file))) { try {
					const resolved_2239 = Path.resolve(file);
					let cachedBuffer = Buffer.from('');
					{
						let step_2240 = 0;
						const cached = fileContents.get(resolved_2239);
						if (step_2240 == 0 && cached != null) { step_2240 = 1 };
						if (step_2240 == 1) { cachedBuffer = cached } else {
							cachedBuffer = Fs.readFileSync(file);
						};
					};
					const content_2241 = cachedBuffer;
					const tokens_2242 = Lexer.tokenize(content_2241, file);
					if ((tokens_2242.length > 0)) { lines += tokens_2242.line[tokens_2242.length - 1] };
					const parsed_2243 = Parser.parseNodes(tokens_2242, project_2235);
					project_2235.moduleName.push(fullPath_2237);
					const info_2244 = new Module();
					info_2244.nodes = parsed_2243;
					info_2244.file = file;
					info_2244.path = fullPath_2237;
					project_2235.moduleInfo.push(info_2244);
					project_2235.mapModules.set(node, info_2244);
					for (const e of $toIterator(parsed_2243)) {
						const temp_2245 = e;
						switch (temp_2245&&temp_2245[0]) {
						case 37: {
							const path_2246 = temp_2245[2];
							{
								console.log('Node.Import', path_2246);
								Main.processModule(project_2235, path_2246, false, info_2244, e);
							}
						} break;
						};
					};
					if ((global == true)) { Main.processGlobals(project_2235, path_2236, fullPath_2237) };
					return lines;
				} catch (temp_2238) {
					if (true) { 
					const e = temp_2238
					{
						throw e;
					} } else
					
					throw temp_2238;
				} };
				return (-1);
			};
			let roots = project_2235.roots;
			{
				let step_2247 = 0;
				const relative_2248 = relative;
				let temp_2249 = null;
				if (step_2247 == 0 && relative_2248 != null) {
					temp_2249 = (!path_2236.startsWith('/'));
					step_2247 = 1;
				};
				if (step_2247 == 1 && temp_2249 != false) { step_2247 = 2 };
				if (step_2247 == 2) {
					const root_2250 = Path.dirname(relative_2248.file);
					roots = [root_2250];
				};
			};
			for (const root of $toIterator(roots)) {
				const file_2251 = Path.join(root, path_2236 + '.hexa');
				let fullPath_2252 = '';
				if (Fs.existsSync(file_2251)) { fullPath_2252 = Path.relative(Path.dirname(project_2235.json), file_2251).slice(0, (-5)).split('\\').join('/') };
				const index_2253 = project_2235.moduleName.indexOf(fullPath_2252);
				if (index_2253 > (-1)) {
					if (global == true) { Main.processGlobals(project_2235, path_2236, fullPath_2252) };
					project_2235.mapModules.set(node, project_2235.moduleInfo[index_2253]);
					return lines;
				};
				const lines_2254 = tryInRoot(root, fullPath_2252);
				if (lines_2254 > (-1)) { return lines_2254 };
			};
			let msg_2255 = ('Cannot find file `' + (path_2236) + '` in any of the roots.\n');
			if ((path_2236.endsWith('.hexa'))) { msg_2255 += ('Do not write `.hexa` extension in imports, just use `import ... in \'' + (path_2236.replace('.hexa', '')) + '\'`.\n') };
			for (const root of $toIterator(roots)) {
				const file_2256 = Path.join(root, path_2236 + '.hexa');
				msg_2255 += ('Checked here: `' + (file_2256) + '`\n');
			};
			{
				let step_2257 = 0;
				const data_2258 = project_2235.data.get(node);
				if (step_2257 == 0 && data_2258 != null) { step_2257 = 1 };
				if (step_2257 == 1) { throw new CompilerErrors([new CompilerError(3, msg_2255, data_2258.line, data_2258.column, data_2258.fileName)]) };
			};
			throw new CompilerErrors([new CompilerError(5, msg_2255, 1, 1, project_2235.json)]);
		};
	var Server = class {
		constructor(port) { 
		{
			this.port = (port == null)? (3978) : parseInt(port);
			const port_2337 = this.port;
			console.log('Requested language server at localhost:' + port_2337);
			Lexer.init();
			const http = require('http');
			const fs = require('fs');
			const path = require('path');
			const url = require('url');
			const project = new Project();
			const empty = '[]';
			const handleRequest = (project_2338, req, res) => {
				const chunks = [];
				req.on('data', (chunk) => (chunks.push(chunk)));
				req.on('end', () => {
					const start = Date.now();
					const data = Buffer.concat(chunks);
					const text = data.toString().trim();
					if (text.length > 0) {
						const json = JSON.parse(data.toString());
						const commands = json;
						if (commands.length == 0) {
							res.writeHead(404, {});
							res.write('[]');
							res.end();
						} else {
							const responseToAll = [];
							for (const command of $toIterator(commands)) {
								const response = [];
								{
									const temp_2339 = command.kind;
									switch (temp_2339) {
									case 'GetWholeFileSyntaxErrors': {
										{
											const file_2340 = 'hexa.hexa';
											const content_2341 = Buffer.from(command.payload);
											const errors_2342 = syntaxCheckOnly('hexa.hexa', content_2341);
											for (const error of $toIterator(errors_2342)) {
												response.push(error);
											};
										}
									} break;
									
									case 'SyncFileContents': {
										{
											const fsPath_2343 = command.payload.fsPath;
											const content_2344 = command.payload.content;
											fileContents.set(Path.resolve(fsPath_2343), Buffer.from(content_2344));
										}
									} break;
									
									case 'DiscardFileContents': {
										{
											const fsPath_2345 = command.payload.fsPath;
											fileContents.delete(Path.resolve(fsPath_2345));
										}
									} break;
									
									case 'AutocheckProject': {
										{
											const fsPath_2346 = command.payload.fsPath;
											const project_2347 = findProjectFile(fsPath_2346);
											if (project_2347.found == true) { try {
												const e = new Main().typecheck(project_2347.dir);
												const errors_2349 = e.errors;
												for (const error of $toIterator(errors_2349)) {
													response.push(error);
												};
											} catch (temp_2348) {
												if (true) { 
												const e = temp_2348
												{
												} } else
												
												throw temp_2348;
											} } else {
												const resolved = Path.resolve(fsPath_2346);
												{
													let step = 0;
													const content_2350 = fileContents.get(resolved);
													if (step == 0 && content_2350 != null) { step = 1 };
													if (step == 1) {
														const errors_2351 = syntaxCheckOnly(resolved, content_2350);
														for (const error of $toIterator(errors_2351)) {
															response.push(error);
														};
													};
												};
											};
										}
									} break;
									
									case 'FindProjectFile': {
										{
											const fsPath_2352 = command.payload;
											response.push(findProjectFile(fsPath_2352));
										}
									} break;
									
									case 'CompletionItemProvider': {
										{
											const fsPath_2353 = Path.resolve(command.payload.fsPath);
											const project_2354 = findProjectFile(fsPath_2353);
											if (project_2354.found == true) { try {
												const main = new Main();
												const e_2356 = main.typecheck(project_2354.dir);
												const completes = [];
												const errors_2357 = e_2356.errors;
												let typecheckProject = main.typecheckProject;
												for (const mod of $toIterator(typecheckProject.moduleInfo)) {
													if (mod.file != fsPath_2353) { continue };
													console.log('mod.file', mod.file, mod.path, Path.relative(project_2354.dir, mod.file));
													const available = [];
													for (const name of $toIterator(mod.imported.keys())) {
														available.push(name);
													};
													for (const name of $toIterator(mod.exported.keys())) {
														available.push(name);
													};
													for (const name of $toIterator(typecheckProject.globals.keys())) {
														if ((!available.includes(name))) { available.push(name) };
													};
													for (const name of $toIterator(available)) {
														let node = mod.exported.get(name);
														let imported = '';
														let file_2358 = '';
														if (node == null) {
															node = mod.imported.get(name);
															{
																let step_2359 = 0;
																const temp_2360 = node != null;
																let mod = null;
																if (step_2359 == 0 && temp_2360 != false) {
																	mod = typecheckProject.mapModules.get(node);
																	step_2359 = 1;
																};
																if (step_2359 == 1 && mod != null) { step_2359 = 2 };
																if (step_2359 == 2) {
																	imported = mod.path;
																	file_2358 = mod.file;
																};
															};
														};
														if (node == null) {
															imported = '*';
															node = typecheckProject.globals.get(name);
														};
														const complete = {imported:imported, file:file_2358, name:name, detail:name, kind:0};
														{
															const temp_2361 = (node);
															switch (temp_2361&&temp_2361[0]) {
															case 25: {
																const t = temp_2361[1];
																{
																	complete.detail = 'class ' + NodeType.stringify(t) + ' {  }';
																	complete.kind = 6;
																}
															} break;
															
															case 39: {
																const t_2362 = temp_2361[1];
																{
																	complete.detail = 'enum ' + NodeType.stringify(t_2362) + ' {  }';
																	complete.kind = 12;
																}
															} break;
															
															case 24: {
																const const_2363 = temp_2361[4];
																{
																	complete.detail = ((const_2363)? ('let ') : 'var ') + name;
																	complete.kind = 5;
																}
															} break;
															
															case 22: {
																{
																	complete.detail = 'fun ' + name + '() {  }';
																	complete.kind = 2;
																}
															} break;
															};
														};
														completes.push(complete);
													};
													break;
												};
												response.push(completes);
											} catch (temp_2355) {
												if (true) { 
												const e = temp_2355
												{
												} } else
												
												throw temp_2355;
											} } else {
												response.push([]);
											};
										}
									} break;
									
									default: 
									console.log('Unknown command kind', command.kind, command)
									};
								};
								responseToAll.push(response);
							};
							res.writeHead(200, {});
							res.write(JSON.stringify(responseToAll));
							const end = Date.now();
							console.log(('[Response finished in ' + (end - start) + ' ms]'));
							res.end();
						};
					} else {
						res.writeHead(400, {});
						res.write('[]');
						res.end();
					};
				});
			};
			const server = http.createServer((req_2364, res_2365) => (handleRequest(project, req_2364, res_2365)));
			server.listen(port_2337, () => ((() => {
				console.log('Compiler version:', version);
				return console.log('Ready to Hexa!');
			})()));
		} };
	}
	function hasOwnProperty(object, name) { return object.hasOwnProperty(name) };
	function btoa(text_112) { return Buffer.from(text_112, 'binary').toString('base64') };
	function atob(base64) { return Buffer.from(base64, 'base64').toString('binary') };
	function availableGenerators(name) {
			const temp = name;
			switch (temp) {
			case 'js': {
				return 'JavaScript'
			} break;
			
			case 'native': {
				return 'Native'
			} break;
			
			default: 
			return null
			};
		};
	function setLibrary(target, options, defines) {
			const files = [];
			{
				const temp_2222 = target;
				switch (temp_2222) {
				case 'JavaScript': {
					{
						defines.js = (() => {
							const result = defines.js;
							if (result != null) { return result };
							return true;
						})();
						files.push('/js/js');
						if (options.includes('nodejs')) { files.unshift('/nodejs/nodejs') };
						if (options.includes('browser')) { files.unshift('/browser/html') };
					}
				} break;
				
				case 'Native': {
					{
						defines.native = (() => {
							const result_2223 = defines.native;
							if (result_2223 != null) { return result_2223 };
							return true;
						})();
						files.push('/c/c');
					}
				} break;
				};
			};
			return files;
		};
	function indigo(text) { return '\x1b[35m' + text + '\x1b[0m' };
	function blue(text_2224) { return '\x1b[34m' + text_2224 + '\x1b[0m' };
	function ocean(text_2225) { return '\x1b[36m' + text_2225 + '\x1b[0m' };
	function ignoreRestArguments() { if (process.argv.length > 0) {
			const args = process.argv;
			console.log('Argument' + ((args.length > 1)? ('s') : '') + ' \x1b[36m`' + args.join('`\x1b[0m, \x1b[36m`') + '`\x1b[0m ignored');
		} };
	function quote(text_2226) {
			const result = [];
			let even = false;
			for (const string of $toIterator(text_2226.split('`'))) {
				if (even == false) { result.push(string) } else {
					result.push('\x1b[33m');
					result.push('`');
					result.push(string);
					result.push('`');
					result.push('\x1b[0m');
				};
				even = (!even);
			};
			return result.join('');
		};
	function printVersion() {
			console.log(indigo(('Hexa ' + (version) + ' on node.js ') + process_99.versions.node));
			process.argv.shift();
			ignoreRestArguments();
			process.exit(0);
		};
	function printHelp() {
			console.log(indigo(('Hexa ' + (version) + ' on node.js ') + process_99.versions.node));
			console.log(ocean('Use `hexa hexa.json` to simply build `default` target'));
			console.log(quote('`hexa init` creates new project by asking some questions'));
			console.log(quote('`hexa hexa.json targets` show available targets for the project'));
			console.log(quote('`hexa help` shows this help'));
			console.log(quote('`hexa version` shows compiler version'));
			console.log(quote('`hexa listen` or `hexa listen 3978` starts language server on the selected port'));
			process.argv.shift();
			ignoreRestArguments();
			process.exit(0);
		};
	function question(query) {
			process_99.stdout.write(query);
			let bufsize = 256;
			let buf = Buffer.alloc(bufsize);
			let bytesRead = 0;
			const stdin = ((process.platform == 'win32'))? (process_99.stdin.fd) : Fs.openSync('/dev/stdin', 'rs');
			try { bytesRead = Fs.readSync(stdin, buf, 0, bufsize) } catch (temp) {
				if (true) { 
				const e = temp
				{
					const e = e;
					if (e.code == 'EAGAIN') { return 'ERROR: interactive stdin input not supported.' };
					if (e.code == 'EOF') { return '' };
					throw e;
				} } else
				
				throw temp;
			};
			if (bytesRead == 0) { return '' };
			const answer = buf.toString('utf8', 0, bytesRead).trim();
			return answer;
		};
	function symlink() {
			const temp = (process.platform);
			switch (temp) {
			case 'linux': case 'mac???TODO': {
				{
					Fs.renameSync('./hexa', '/usr/bin/hexa');
					console.log('Symlinked successfully!');
				}
			} break;
			
			case 'win32???TODO': {
				{
				}
			} break;
			
			default: 
			{
				console.log(('Cannot symlink on ' + (process.platform) + '. You must add hexa to your PATH manually.'));
				process_99.exit(1);
			}
			};
		};
	function init() {
			if (Fs.existsSync('hexa.json')) {
				const create = question('Hexa package \'hexa.json\' already exists here. Create new? (no): ');
				if (create == '' || (!isYes(create))) { process_99.exit(1) };
			};
			let currentDirTmp = process.cwd().split(Path.sep);
			let packageFileName = process.cwd() + Path.sep + 'hexa.json';
			let currentDir = currentDirTmp[currentDirTmp.length - 1];
			let name = question(('Enter package name (' + (currentDir) + '): '));
			if (name == '') { name = currentDir };
			let version_2334 = question('Enter package version (1.0.0): ');
			if (version_2334 == '') { version_2334 = '1.0.0' };
			let description = question('Enter package description: ');
			let main = question('Enter main file (main.hexa): ');
			if (main == '') { main = 'main.hexa' };
			const target = {name:'default', generator:'js', output:name, options:[]};
			const generator = question('Enter target (Node.js/JavaScript):\n1. Node.js/JavaScript\n2. Web/JavaScript\n3. Raw/JavaScript').trim();
			if (generator == '2') {
				target.options.push('browser');
				target.output += '.js';
			} else if (generator == '3') { target.output += '.js' } else {
				target.options.push('nodejs');
				target.output += '.js';
			};
			while ((!main.endsWith('.hexa'))) {
				process_99.stdout.write('Wrong file name. Must end with \'.hexa\'.\n');
				main = question('Enter main file (main.hexa): ');
			};
			const user = (() => {
				const result = require('os').userInfo().username;
				if (result != null) { return result };
				return process.env.USERNAME;
			})();
			let author = question(('Enter package author name (' + (user) + '): '));
			if (author == '') { author = user };
			let license = question('Enter license (LGPL-3.0-only): ');
			if (license == '') { license = 'LGPL-3.0-only' };
			const pack = {name:name, version:version_2334, description:description, author:author, license:license, targets:[target], entry:main.split('.')[0]};
			const extras = [];
			let addGit = false;
			if (Fs.existsSync('.git')) { if ((!Fs.existsSync('.gitignore')) || (!Fs.existsSync('.gitattributes'))) {
				const confirm = question('Create additional git files(.gitignore, .gitattributes)? (yes): ').toLowerCase().trim();
				if (isYes(confirm)) {
					if ((!Fs.existsSync('.gitignore'))) { extras.push('.gitignore') };
					if ((!Fs.existsSync('.gitattributes'))) { extras.push('.gitattributes') };
					addGit = true;
				};
			} };
			const addMain = Fs.existsSync(main) == false;
			if (addMain) { extras.push(main) };
			const packageStr = JSON.stringify(pack, null, '\t').split('\r\n').join('\n').split('\n').join('\r\n');
			const extrasStr = (extras.length > 0)? ('\nAnd \'' + extras.join('\', \'') + '\'') : '';
			const answ = question(('About to write to: ' + (packageFileName) + ':\n' + (packageStr) + '' + (extrasStr) + '\nIs this ok? (yes): '));
			if ((!isYes(answ))) {
				console.log('Exiting without changes');
				process_99.exit(1);
			};
			Fs.writeFileSync('hexa.json', packageStr + '\r\n');
			if ((addMain) && ((!Fs.existsSync(main)))) { Fs.writeFileSync(main, 'console.log("Thank you for choosing Hexa")\r\n') };
			if ((addGit) && ((!Fs.existsSync('.gitattributes')))) { Fs.writeFileSync('.gitattributes', ['# Auto detect text files and perform LF normalization', '* text=auto', ''].join('\r\n')) };
			if ((addGit) && ((!Fs.existsSync('.gitignore')))) { Fs.writeFileSync('.gitignore', ['# Mac & Win', '*~', '._*', '*DS_Store*', '.DS_Store', '.DS_Store?', '.Spotlight-V100', '.Trashes', 'ehthumbs.db', 'Thumbs.db', '*Thumbs.db', '__MACOSX', '', '# Custom', '*.map', target.output, 'node_modules', ''].join('\r\n')) };
			process_99.stdout.write('Hexa package initialized!');
		};
	function isYes(answer) { return ['y', 'yes', ''].includes(answer.toLowerCase().trim()) };
	function findProjectFile(fsPath) {
			let lastPath = '*';
			let dir = Path.dirname(fsPath);
			let found = false;
			while (lastPath != dir) {
				if (Fs.existsSync(Path.join(dir, 'hexa.json'))) {
					found = true;
					break;
				};
				lastPath = dir;
				dir = Path.dirname(dir);
			};
			return {found:found, dir:dir};
		};
	function syntaxCheckOnly(file, content) {
			try {
				const tokens = Lexer.tokenize(content, file);
				try { const parser = Parser.parseNodes(tokens, new Project(), true) } catch (temp_2335) {
					if (temp_2335 instanceof CompilerErrors) { 
					const e = temp_2335
					{
						const errors_2336 = e.errors;
						return errors_2336;
					} } else
					
					throw temp_2335;
				};
			} catch (temp) {
				if (temp instanceof CompilerErrors) { 
				const e = temp
				{
					const errors = e.errors;
					return errors;
				} } else
				
				throw temp;
			};
			return [];
		};
	var colorIndigo = '\x1b[35m'
	var colorBlue = '\x1b[34m'
	var colorYellow = '\x1b[33m'
	var colorOcean = '\x1b[36m'
	var colorDefault = '\x1b[0m'
	var version = selfVersion
	var fileContents = new Map()
	{
		{
			if (process.argv[0].endsWith('node.exe') || process.argv[0].endsWith('node')) {
				process.argv.shift();
				process.argv.shift();
			} else if (process.argv[0].endsWith('.exe')) { process.argv.shift() };
			{
				const temp = process.argv[0];
				switch (temp) {
				case 'listen': {
					const temp_2366 = new Server(process.argv[1])
				} break;
				
				case 'help': {
					printHelp()
				} break;
				
				case 'version': {
					printVersion()
				} break;
				
				case 'symlink': {
					symlink()
				} break;
				
				case 'init': {
					init()
				} break;
				
				default: 
				try { new Main().perform() } catch (temp_2367) {
					if (temp_2367 instanceof CompilerErrors) { 
					const e = temp_2367
					{
						console.log(e.toString());
					} } else
					
					throw temp_2367;
				}
				};
			};
		}
	}
})();
