// The Hexa Compiler
// Copyright (C) 2021  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// Generates C
class GenClang {
	new () {}

	var project: NiceProject
	let extension = '.c'
	let nativeEnums = false
	var toIterator = false

	static fun spawn() {
		return new GenClang()
	}

	fun perform(normalizer): String {
		project = normalizer
		return stringify()
	}

	fun stringify() {
		let out = ['// Generated by Hexa https://hexalang.github.io\n']

		if (project.package.addLicenseNoticeToOutput) {
			out.push('// \(project.package.name)\n')
			out.push('// LICENSE \(project.package.license)\n')
		} else {
			out.push('// The generated code is subject to the original license\n')
		}

		out.push(';(() => {\n\t"use strict"\n\tconst $global = typeof(window) === "undefined"? global : window')
		out.push('\n\tif (typeof($global.require) === "undefined") { $global.require = () => {} };')
		out.push('\n\tconst selfVersion="\(project.package.version)";')

		let constantsIndex = out.length
		let constants = [] // They don't access other variables
		out.push('')

		// Types
		for e in project.enumsSimple {
			// No need to output simple enum values
			if (e.staticVars.length + e.staticMethods.length == 0) {
				continue
			}

			out.push('\n\tvar ' + e.name + ' = {')
			for v in e.staticMethods { switch v {
				case Function(name, expr, args, defaults):
					out.push('\n\t\t' + name + ': ')
					out.push(printFunctionArguments(args, defaults) + ' => { ' + printStatement(expr) + ' }')
					out.push(',')
			}}
			out.push('\n\t}')

			for v in e.staticVars { switch v {
				case Var(name, expr):
					out.push('\n\t' + e.name + '.' + name)
					if (expr != null) {
						out.push(' = ' + printExpression(expr))
					}
				case Const(name, expr):
					out.push('\n\t' + e.name + '.' + name)
					out.push(' = ' + printExpression(expr))
			}}
		}

		for e in project.enumsComplex {
			if e.staticMethods.length == 0, e.names.length == 0 {
				out.push('\n\tvar ' + e.name + ' = {}')
			} else {
				out.push('\n\tvar ' + e.name + ' = {')
				for v in e.staticMethods { switch v {
					case Function(name, expr, args, defaults):
						out.push('\n\t\t' + name + ': ')
						out.push(printFunctionArguments(args, defaults) + ' => { ' + printStatement(expr) + ' }')
						out.push(',')
				}}
				var i = 0
				for name in e.names { // Only values *with* parameters
					if (e.constructors[i] != null) {
						out.push('\n\t\t' + name + ': ')
						out.push('(' + e.constructors[i].join(',') + ')=>[')
						out.push('' + i + ',' + e.constructors[i].join(','))
						out.push('],')
					}
					i++
				}
				out.push('\n\t}')
			}

			var i = 0
			for name in e.names { // Only values *without* parameters
				if (e.constructors[i] != null) {
				} else {
					out.push('\n\tObject.defineProperty(' + e.name + ', "' + name + '", { get: () => { return [' + i + '] }})')
					/*
						Sadly, this optimization breaks object inequality (for Map's):
						out.push('E.name = ["' + name + '",' + i + '];')
					*/
				}
				i++
			}
			for v in e.staticVars { switch v {
				case Var(name, expr):
					out.push('\n\t' + e.name + '.' + name)
					if (expr != null) {
						out.push(' = ' + printExpression(expr))
					}
				case Const(name, expr):
					out.push('\n\t' + e.name + '.' + name)
					out.push(' = ' + printExpression(expr))
			}}
		}

		for i in project.interfaces {
			throw i
		}

		for c in project.classes {
			if (c.useless) {
				continue
			}

			if (c.external) {
				if (c.jsRequire != null) {
					constants.push('\n\t' + 'const ' + c.name + ' = require("' + c.jsRequire + '")')
					continue
				}
				if let jsNative = c.jsNative, jsNative != c.name {
					out.push('\n\t' + 'var ' + c.name + ' = $global.' + jsNative)
				}
				continue
			}

			out.push('\n\t' + 'var ' + c.name + ' = class')
			if let extend = c.extend {
				out.push(' extends ' + extend)
			}
			out.push(' {')
			for v in c.methods { switch v {
				case Function(name, expr, args):
				if name == null or name == 'new' {
					out.push('\n\t\tconstructor')
				} else {
					out.push('\n\t\t' + name)
				}
				out.push('(' + args.join(', ') + ') ')

				if name == null || name == 'new', c.vars.length > 0 {
					// Init fields
					out.push('{ ')
					for v in c.vars { switch v {
						case Var(name, expr):
						if (expr != null) {
							out.push('\n\t\t\tthis.' + name + ' = ' + printExpression(expr) + '')
						}
						case Const(name, expr):
						if (expr != null) {// null if property
							out.push('\n\t\t\tthis.' + name + ' = ' + printExpression(expr) + '')
						}
					}}
					out.push('\n\t\t')
					out.push(printStatement(expr) + ' };')
				} else {
					out.push(printBlock(expr) + ';')
				}
			}}
			for name in c.property {
				// Generate native setters `get name() {}`
				out.push('\n\t\tget ' + name + '() { return this.get_\(name)(); };')
				out.push('\n\t\tset ' + name + '(value) { return this.set_\(name)(value); };')
			}
			out.push('\n\t}')

			for v in c.staticVars { switch v {
				case Var(name, expr):
					out.push('\n\t' + c.name + '.' + name)
					if (expr != null) {
						out.push(' = ' + printExpression(expr))
					}
				case Const(name, expr):
					out.push('\n\t' + c.name + '.' + name)
					out.push(' = ' + printExpression(expr))
			}}
			for v in c.staticMethods { switch v {
				case Function(name, expr, args, defaults):
					out.push('\n\t' + c.name + '.' + name + ' = ')
					out.push(printFunctionArguments(args, defaults) + ' => ' + printBlock(expr) + ';')
			}}
		}

		for g in project.globalFuncs { switch g {
			case Function(name, expr, args, defaults):
				out.push('\n\tfunction ' + name)
				out.push(printFunctionArguments(args, defaults) + ' ' + printBlock(expr) + ';')
		}}

		for g in project.globalVars { switch g {
			case Var(name, expr):
				out.push('\n\tvar ' + name)
				if (expr != null) {
					out.push(' = ' + printExpression(expr))
				} else {
					out.push(' = null')
				}
			case Const(name, expr):
				out.push('\n\tvar ' + name + ' = ' + printExpression(expr))
		}}

		// Init
		for init in project.init {
			out.push('\n\t{\n\t\t')
			out.push(printStatement(init))
			out.push('\n\t}')
		}

		if toIterator {
			constants.unshift('\n\tfunction $toIterator(v) { if (typeof(v) === "number") { v = Math.max(v, 0); const i = new Uint32Array(v); let n = 0; while (n < v) i[n] = n++; return i; } return v; };')
		}
		out[constantsIndex] = constants.join('')
		out.push('\n})();\n')
		return out.join('')
	}

	var tabs = '\t\t'

	@inline fun pushTab() {
		tabs += '\t'
	}

	@inline fun popTab() {
		tabs = tabs.substring(0, tabs.length - 1)
	}

	let globalAccessor = '' // Empty, otherwise __dirname not works
	let reserved = [
		// TODO fix package_TODO in normalizer.project.package -- seems like race condition of renaming
		'with', 'const', 'instanceof', 'typeof', 'delete', 'undefined', 'package_TODO',
		'async', 'await', 'arguments'
	]

	// Surrounds with { brackets } single statement
	fun printBlock(s: Statement): String {
		switch s {
			case Block(el):
				if el.length == 1 { switch el[0] {
					case Block(_):
						return printStatement(el[0])
				}}
				if el.length == 1 {
					return '{ ' + printStatement(el[0]) + ' }'
				}
				if el.length == 0 {
					return '{}'
				}
				return printStatement(s)
			case _:
				return '{ ' + printStatement(s) + ' }'
		}
	}

	fun printStatement(s: Statement) {
		switch s {
			case Statements(els):
				var r = ''
				for s in els {
					if (s != null) {
						r += '\n' + tabs + printStatement(s) + ';'
					}
				}
				return r

			case Break: return 'break'
			case Continue: return 'continue'
			case Block(el):
				if el.length == 1 { switch el[0] {
					case Block(_):
						return printStatement(el[0])
				}}

				pushTab()
				var r = '{'

				for e in el { switch e {
					case null:
					case Statements(els):
						for s in els {
							if (s != null) {
								r += '\n' + tabs + printStatement(s) + ';'
							}
						}
					case _:
						r += '\n' + tabs + printStatement(e) + ';'
				}}

				popTab()
				return r + '\n' + tabs + '}'
			case Const(name, expr):
				return 'const ' + name + (expr == null? ' = null' : ' = ' + printExpression(expr))
			case Var(name, expr): return 'let ' + name + (expr == null? '' : ' = ' + printExpression(expr))
			case Function(name, expr, args, defaults):
				return 'const ' + name + ' = ' + printFunctionArguments(args, defaults) + ' => ' + printBlock(expr)
			case Return(e):
				if (e == null) {
					return 'return'
				}
				return 'return ' + printExpression(e)
			case If(econd, eif, eelse):
				var r = 'if (' + printExpression(econd) + ') ' + printBlock(eif)
				if (eelse != null) {
					r += ' else ' + printStatement(eelse)
				}
				return r
			case Call(e, args): return printExpression(e) + printCallArguments(args)
			case SuperConstructor(args): return 'super' + printCallArguments(args)
			case Try(expr, t, v, catches, temp):
				var r = 'try '
				r += printBlock(expr)
				r += ' catch (\(temp)) {\n' + tabs + '\t'
				pushTab()
				for i in catches.length {
					var typeof = 'T'
					switch t[i] {
						case ClassInstance(type):
							typeof = type.name
						case _:
							throw '' + t[i]
					}
					switch typeof {
						case 'Any':
							r += 'if (true) { '
						case 'String':
							r += 'if (typeof(\(temp)) == "string") { '
						case 'Int':
							r += 'if (typeof(\(temp)) == "number") { '
						case 'Float':
							// TODO special handling !=Int & sort Int check to first
							r += 'if (typeof(\(temp)) == "number") { '
						case 'Bool':
							r += 'if (typeof(\(temp)) == "boolean") { '
						case _:
							r += 'if (\(temp) instanceof \(typeof)) { '
					}
					r += '\n' + tabs
					r += 'const \(v[i]) = \(temp)'
					r += '\n' + tabs
					r += printStatement(catches[i])
					r += ' }'
					r += ' else'
					r += '\n' + tabs
				}
				r += '\n' + tabs + 'throw \(temp);'
				popTab()
				return r + '\n' + tabs + '}'
			case Assign(a, v):
				return printExpression(a) + ' = ' + printExpression(v)
			case Throw(e):
				return 'throw ' + printExpression(e)
			case For(name, over, by):
				toIterator = true
				return 'for (const ' + name + ' of $toIterator(' + printExpression(over) + ')) ' + printStatement(by)
			case Increment(e): return printExpression(e) + '++'
			case Decrement(e): return printExpression(e) + '--'
			case While(econd, e, pre):
				if pre {
					return 'while (' + printExpression(econd) + ') ' + printStatement(e)
				}
				return 'do {' + printStatement(e) + '} while (' + printExpression(econd) + ')'
			case Assignop(a, op, value):
				return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)

			case Switch(expr, cases, statements, guards, binds):
				var r = 'switch (' + printExpression(expr) + ') {'

				// case 1: case 2: case 3:
				for i in cases.length { if (cases[i].length > 0) {
					r += '\n' + tabs
					for cc in cases[i] { switch cc {
						case Null:
							// C is very strict on this
							// in `switch` null != undefined
							// In Hexa we do not have `undefined`
							// and undefined considered to be == null
							r += 'case null: case undefined: '
						case _:
							r += 'case ' + printExpression(cc) + ': '
					}}
					pushTab()
					r += '{\n' + tabs
					if let binders = binds[i] {
						for bind in binders {
							r += printStatement(bind) + ';\n' + tabs
						}
					}

					if let guard = guards[i] {
						pushTab()
						r += 'if (' + printExpression(guard) + ') {\n' + tabs
					}

					r += printStatement(statements[i])
					popTab()
					if let guard = guards[i] {
						popTab()
						r += '\n\t' + tabs + 'break; } }\n' + tabs
					} else {
						r += '\n' + tabs + '} break;\n' + tabs
					}
				}}

				// default:
				for i in cases.length { if (cases[i].length == 0) {
					r += '\n' + tabs + 'default: '
					r += '\n' + tabs
					r += printStatement(statements[i])
					r += '\n' + tabs
				}}

				return r + '}'

			case null: console.error("Got null statement kind in C generator, probably unsupported feature was used, ignoring")
			case _: console.error("Unknown statement kind:", s)
		}

		return '{/* undefined */}'
	}

	fun printCallArguments(args: [Expression]): String {
		return '(' + [for a in args printExpression(a)].join(', ') + ')'
	}

	fun printFunctionArguments(args: [String], defaults: [Expression]) {
		return '(' + [for a in args.length
			args[a] + ((defaults != null && defaults[a] != null)? ' = ' + printExpression(defaults[a]) : '')
		].join(', ') + ')'
	}

	fun printExpression(e: Expression) {
		switch e {
			case Null: return 'null'
			case This: return 'this'
			case Ident(name): return name
			case Int(v): return '' + v
			case MetaInt(v, meta, type): return '' + v + 'n'
			case Float(v): return '' + v
			case String(s):

				let s = s.split('')
				let charsOut = []
				while s.length > 0 {
					switch s[0] {
						case "'":
						charsOut.push("\\")
						charsOut.push("'")
						s.shift()
						case "\n":
						charsOut.push("\\n")
						s.shift()
						case "\r":
						charsOut.push("\\r")
						s.shift()
						case "\\":
						s.shift()
						if (s[0] == "'") {
							charsOut.push("\\'")
							s.shift()
						} else if (s[0] == '"') {
							charsOut.push('\\"')
							s.shift()
						} else if (s[0] == '\\') {
							charsOut.push("\\\\")
							s.shift()
						} else {
							charsOut.push('\\')
						}
						case _:
						charsOut.push(s[0])
						s.shift()
					}
				}

				return "'" + charsOut.join('') + "'"
			case True: return 'true'
			case False: return 'false'
			case Dot(expr, name):
				switch expr {
					case Int(_): return '(' + printExpression(expr) + ').' + name
					case Float(_): return '(' + printExpression(expr) + ').' + name
				}
				return printExpression(expr) + '.' + name
			case Call(e, args): return printExpression(e) + printCallArguments(args)
			case Function(name, expr, args, defaults):
				if (name == null) {
					return printFunctionArguments(args, defaults) + ' => ' + printBlock(expr)
				}
				return '((() => { const ' + name + ' = ' + printFunctionArguments(args, defaults) + ' => '
				+ printBlock(expr) + '; return ' + name + ' })())'
			case Arrow(expr, args, defaults):
				return printFunctionArguments(args, defaults) + ' => (' + printExpression(expr) + ')'
			case New(e, args): return 'new ' + printExpression(e) + printCallArguments(args)
			case Array(el): return '[' + [for a in el printExpression(a)].join(', ') + ']'
			case Unop(op, postfix, e):
				if postfix {
					return '(' + printExpression(e) + Token.stringify(op) + ')'
				}
				return '(' + Token.stringify(op) + printExpression(e) + ')'
			case Elvis(nullable, othewise):
				return '((' + printExpression(nullable) + ') || (' + printExpression(othewise) + '))'
			case Parenthesis(e): return '(' + printExpression(e) + ')'
			case Binop(a, op, b):
				return '' + printExpression(a) + ' ' + Token.stringify(op) + ' ' + printExpression(b) + ''
			case Index(expr, index):
				return printExpression(expr) + '[' + printExpression(index) + ']'
			case If(econd, eif, eelse):
				var r = ''
				try {
					r += '(' + printExpression(econd) + ')?'
					r += ' (' + printExpression(eif) + ')'
					r += ' : ' + printExpression(eelse)
					return r
				} catch error: Any {
					console.log('If =>', e, error)
					return r + '<!-- If => error -->'
				}
			case EnumTag(expr):
				let e = printExpression(expr)
				return e + '&&' + e + '[0]'
			case Object(names, el):
				return '{' + [for i in el.length {
					((names[i]) + ':' + printExpression(el[i]))
				}].join(', ') + '}'
			case Map(keys, values):
				if (keys.length == 0) {
					return 'new Map()'
				}
				return 'new Map([' +
				[for i in keys.length '[' + printExpression(keys[i]) + ', ' + printExpression(values[i]) + ']'].join(', ')
				+ '])'
			case Assignop(a, op, value):
				return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)
			case NativeOperator(kind, args, s): switch kind {
				case Infix: return '((' + printExpression(args[0]) + ') ' + s + ' (' + printExpression(args[1]) + '))'
				case Function: return s + printCallArguments(args)
				case Prefix: return '(' + s + '(' + printExpression(args[0]) + '))'
				case Postfix: return '((' + printExpression(args[1]) + ')' + s + ')'
			}
			case UnsafeBitCast(e, t): return '(' + printExpression(e) + ')'
			case Is(e, t): return '((' + printExpression(e) + ') instanceof ' + Type.stringify(t) + ')'
			case Enum(type, tagName, tag, args):
				if args.length == 0 {
					return '/*\(tagName)*/[' + printExpression(tag) + ']'
				}
				return ('/*\(tagName)*/[' + printExpression(tag) + ',' + [for a in args printExpression(a)].join(',') + ']')
			case EnumParameter(expr, index):
				return printExpression(expr) + '[' + (1 + index) + ']'
			case null:
				console.error("Got null expression kind in C generator, probably unsupported feature was used, ignoring")
			case _:
				console.error("Unknown expression kind:", e)
		}

		return '{/* undefined */}'
	}
}
