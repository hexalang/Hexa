// The Hexa Compiler
// Copyright (C) 2021-2022 Oleh Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// Generates simplified view of syntax tree for easier later generation.
/// Transforms typed abstract syntax tree to a simpler representation called "nice nodes", suitable for code generation.
/// Also does some basic optimizations.
@final
class Normalizer {
	var project: Project
	let niceProject = new NiceProject()
	var keywords: [String] = []
	var reservedGlobals: [String] = []
	var collected: [[Node]] = []
	var nativeEnums = false
	var globalAccessor = '<!--global-->'
	var typer: Typer
	var package: Package
	var thisType: Type? = null

	// Pre-computed value of say `let x = 123` thus `inline[x] == 123`
	let inline: [Node : Expression] = [:]

	/// Never reassigned local variables
	let neverReassignedLocal: [Node : Bool] = [:]
	let neverReassignedLocalParent: [Statement : Node] = [:]

	new (project: Project) {
		this.project = project
	}

	fun normalize() {
			// Reserve globals
			for global in reservedGlobals {
				addToScope(global)
			}

			// Rename upfront to avoid race condition
			for file in project.moduleInfo { for e in file.nodes { switch e {
						case Class(t, ext, impl, fields, external):
							renameClassFields(fields, getRenamingStrategy(project.mapDecorators.get(e)))
						case Enum(t, fields, valuesType):
							renameClassFields(fields, getRenamingStrategy(project.mapDecorators.get(e)))
						case Var(name, t, expr, const, external):
							let atts = project.mapDecorators.get(e)
							if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
								case String(s): uniqueNative(s, e)
								case _: throw '@rename takes string as argument'
							}} else {
								unique(name, e)
							}
						case Function(name, expr, vars, rettype, external):
							if (parentNames.get(e) == null) {
								if let name = getNative(e) {
									uniqueNative(name, e)
								} else if let name = name {
									unique(name, e)
								}
							}
			}}}

			// Fill statements
			let init = []
			for file in project.moduleInfo {
				let initial = []
				pushScope()
				for e in file.nodes {
					let decorators = project.mapDecorators.get(e)
					switch e {
						// TODO indent
								case Function(name, _):
									if let s = nodeToStatement(e) { // Non-declare ones
										let link = new NiceLink()

										if let dec = Decorator.getDecorator(decorators, 'linkName') {
											// TODO ^ rename to `linkAs()`
											switch dec.values[0] {
												case String(s):
													link.linkName = s
											}
										}

										if let dec = Decorator.getDecorator(decorators, 'linkAsIs') {
											link.linkName = name
										}

										if let dec = Decorator.getDecorator(decorators, 'customHeader') {
											switch dec.values[0] {
												case String(s):
													link.customHeader = s
											}
										}

										if let dec = Decorator.getDecorator(decorators, 'dllExport') {
											// Extract linkName from dllExport(nameHere) (a shortcut for `@linkName("abc") @dllExport`)
											switch dec.values[0] {
												case String(s):
													link.linkName = s
											}
											link.dllExport = true
										}

										if let dec = Decorator.getDecorator(decorators, 'dllImport') {
											// TODO disallow linkName + dllExport(nameHere)
											// TODO disallow dllImport + dllExport
											switch dec.values[0] {
												case String(s):
													link.linkName = s
											}
											link.dllImport = true
										}

										if let dec = Decorator.getDecorator(decorators, 'emitHeader') {
											// TODO disallow emitHeader(nameHere)
											// TODO disallow dllImport + dllExport + emitHeader
											link.emitHeader = true
										}

										// TODO better idea + avoid unnecessary nice link allocation
										// TODO linking setting for vars and classes
										niceProject.globalLink.set(s, link)
										niceProject.globalFuncs.push(s)
									}
								case Var(_):
									if let s = nodeToStatement(e) { // Non-declare ones
										niceProject.globalVars.push(s)
									}
								case Enum(_):
									fillStatement(e, 'path')
								case Class(_):
									fillStatement(e, 'path')
						case _:
							let statement = fillStatement(e, null)
							switch statement {
								case null:
								case Block(el):
								if el.length > 0 { // Don't output empty blocks
									initial.push(statement)
								}
								case _:
									initial.push(statement)
							}
					}
				}
				popScope()
				if initial.length > 0 {
					init.push(Statement.Block(initial))
				}
			}

			niceProject.init.push(Statement.Block(init))

			if niceProject.init.length > 1 {
				throw "too many inits"
			}

			niceProject.package = package
			niceProject.typer = typer
			niceProject.mapDecorators = project.mapDecorators

			// Sort non-inherited & external classes upfront
			// TODO backport implementation of dependency tree
			niceProject.classes.sort(fun(a, b) {
				// TODO types of a/b not inferred
				if a.external == true {
					return -1
				}

				if a.extend == null {
					return 0
				}

				return 1
			})

			// Sort forward declarations
			// Let's hope it is a stable sort
			niceProject.classes.sort(fun(a, b) {
				if a.usedByValueDepth > b.usedByValueDepth {
					// TODO test this properly (nested ByValue)
					return -1
				}

				if a.usedByValueDepth == b.usedByValueDepth {
					return 0
				}

				return 1
			})

			return niceProject
		}

		fun nodeToExpression(e: Node): Expression? {
			let result = nodeToExpressionWithoutPosition(e)
			if result != null {
				niceProject.expressionPosition.set(result, project.data.get(e))
				if (niceProject.expressionType.get(result) == null) {
					niceProject.expressionType.set(result, typer.types.get(e))
				}
			}
			return result
		}

		fun nodeToExpressionWithoutPosition(e: Node): Expression? {
			if e == null {
				return null
			}

			switch e {
				// Transformation not required
				case String(v):
					return Expression.String(v)
				case Int(v):
					return Expression.Int(v)
				case MetaInt(v, meta):
					return Expression.MetaInt(v, meta, typer.types.get(e))
				case Float(v):
					return Expression.Float(v)
				case Bool(v):
					if v {
						return Expression.True
					}
					return Expression.False
				case Null:
					return Expression.Null(typer.types.get(e))

				case NodeTypeValue(t): switch t {
					case Type(name):
						return Expression.Ident(parentNames.get(typer.parents.get(e)) ?? name, null)
				}

				// Transform
				case Ident(name):
					var source: Node? = typer.parents.get(e)
					// Constant propagation
					// TODO inline map to TNode.inline, also TNode.neverReassigned
					if let value = inline.get(source) {
						return value
					}

					switch source {
						case null:
							throw 'Unmapped `\(e)` of name `\(name)` ' + JSON.stringify(project.data.get(e))
						case Var(name, _, _):
							let staticSource = typer.parents.get(source)
							if let map = typer.parents.get(source) { switch map as! Node {
								case Module(_):
									let name = parentNames.get(source) ?? name
									let result = Expression.Ident(globalAccessor + name, typer.types.get(source))
									if let name = getNative(source) {
										niceProject.native.set(result, true)
									}
									return result
								case _:
									let type = typer.types.get(typer.parents.get(source))
									// TODO .This(type)
									return Expression.Dot(Expression.This(thisType), getClassDotField(staticSource, name)/*parentNames.get(source) ?? name*/, typer.types.get(e))
							}}
						case Function(name, _):
							if let map = typer.parents.get(source) { switch map as! Node {
								case Module(_):
									let result = Expression.Ident(globalAccessor + (parentNames.get(source) ?? name), null)
									if let name = getNative(source) {
										niceProject.native.set(result, true)
									}
									return result
								case _:
									// TODO .This(type)
									let type = typer.types.get(typer.parents.get(source))
									return Expression.Dot(Expression.This(thisType), parentNames.get(source) ?? name, typer.types.get(e))
							}
							}

						case Static(f):
							let staticSource: Node? = typer.parents.get(source)
							switch staticSource {
								case Class(t, _):
									return Expression.Dot(Expression.Ident(DataHelper.extractTypeName(t), null), getClassDotField(staticSource, name), typer.types.get(e))
								case Enum(t,_):
									return Expression.Dot(Expression.Ident(DataHelper.extractTypeName(t), null), getClassDotField(staticSource, name), typer.types.get(e))
								case _:
									throw 'staticSource is \(staticSource) for \(name)'
							}
					}
					let result = Expression.Ident(parentNames.get(source) ?? name, typer.types.get(e))
					if let name = getNative(source) {
						niceProject.native.set(result, true)
					}
					return result

				// `expr.name`
				// TODO constant propagation
				case Dot(expr, name):
				let parent: Node? = typer.parents.get(expr)
				/*switch expr {
						return NiceExpression.Dot(NiceExpression.This(typer.types.get(expr)), getClassDotField(typer.types.get(expr).parent, name) ?? name, typer.types.get(e))
				}
					case This:
				}*/
				switch parent {
					case Enum(t, fields, valuesType):
						if not nativeEnums, let vt = valuesType, let tag = getTag(parent, name) {
							return tag
						}
						return Expression.Dot(nodeToExpression(expr), getClassDotField(parent, name) ?? name, typer.types.get(e))
					case Class(_):
						return Expression.Dot(nodeToExpression(expr), getClassDotField(parent, name) ?? name, typer.types.get(e))
				}
				if let type = typer.types.get(expr) {
					switch type as! Type {
					case ClassInstance(type):
						let renamed = type.fieldRenames[type.fieldNames.indexOf(name)]
						if let rename = renamed {
							return Expression.Dot(nodeToExpression(expr), rename, typer.types.get(e))
						}
				}}
				let value = nodeToExpression(expr)

				if (name == 'length') { switch value {
					case String(s):
						return Expression.Int(s.length)
				}}

				return Expression.Dot(value, name, typer.types.get(e))

				case DotUpper(expr, name):
				let parent: Node? = typer.parents.get(expr)
				switch parent {
					case Enum(t, fields, valuesType):
						if not nativeEnums, let vt = valuesType, let tag = getTag(parent, name) {
							return tag
						}
						if not nativeEnums, valuesType == null, let tag = getTag(parent, name) {
							return Expression.Enum(DataHelper.extractTypeName(t), name, tag, [])
						}
						return Expression.Dot(nodeToExpression(expr), getClassDotField(parent, name) ?? name, typer.types.get(e))
					case Class(_): return Expression.Dot(nodeToExpression(expr), getClassDotField(parent, name) ?? name, typer.types.get(e))
				}
				return Expression.Dot(nodeToExpression(expr), name, typer.types.get(e))

				case Call(expr, args, argNames):

				// Optimize `'String'.charCodeAt(0)`
				if args.length == 1 { switch expr {
					case Dot(expr, name): if name == 'charCodeAt' { switch expr {
						case String(s): if s.indexOf('\\') == -1 { switch args[0] {
							case Int(v):
								let i = v
								if i < s.length, i > -1 {
									let value = s.charCodeAt(i) // Returns NaN in js
									// TODO how to handle NaN-able integers?
									//if (value > -1) Expression.Int('' + value) // TODO generate enum creation statement to var= or jscrashes
									let result = if not Number.isNaN(value) {
										Expression.Int('' + value)
									} else {
										Expression.Int('' + 0)
									}
									niceProject.expressionType.set(result, typer.typeInt)
									return result
								}
						}}
					}}
				}}

				// Call kind
				var kind = CallKind.Function
				switch expr {
					case Dot(expr, name):
						switch typer.types.get(expr) as! Type {
							case ClassInstance(c, _):
								if c.fields.get(name) == ClassTypeField.Method {
									kind = CallKind.VirtualMethod
								}
							case Class(_): kind = CallKind.Static
						}
				}

				let a = []
				for arg in args {
					a.push(nodeToExpression(arg))
				}

				switch typer.parents.get(expr) as! Node {
					case Function(_, _, vars): {
						if vars.length > a.length {
							// Fill default arg values
							for i in vars.length {
								if i < a.length {
									continue
								}

								switch vars[i] as! Node {
									case Var(_, _, value): if let value = value {
										a.push(nodeToExpression(value))
									} // TODO else `break`? cause not args have values?
								}
							}
						}
					}
				}

				// Enum constructor
				if not nativeEnums { switch expr {
					case DotUpper(expr, name):
						let parent: Node? = typer.parents.get(expr)
						switch parent {
							case Enum(t, fields, valuesType):
								if let tag = getTag(parent, name) {
									return Expression.Enum(DataHelper.extractTypeName(t), name, tag, a)
								}
						}
				}}

				let atts = project.mapDecorators.get(typer.parents.get(expr))

				if let infix = Decorator.getDecorator(atts, 'infix') { switch infix.values[0] {
					case String(s):
						switch expr {
							case Ident(_, params):
								if let parames = params {
									return Expression.NativeOperator(NativeOperatorKind.Infix, a, s, params.map(param => typer.types.get(param)), typer.types.get(e))
								}

								return Expression.NativeOperator(NativeOperatorKind.Infix, a, s, null, typer.types.get(e))
						}
					case _: throw '@infix takes string as argument'
				}}

				// TODO pre-compute `sizeof` for known types, so can eliminate `if sizeof(T) % 8 == 0 { 8-byte step } else`
				if let operator = Decorator.getDecorator(atts, 'operator') { switch operator.values[0] {
					case String(s):
						switch expr {
							case Ident(_, params):
								if let parames = params {
									return Expression.NativeOperator(NativeOperatorKind.Function, a, s, params.map(param => typer.types.get(param)), typer.types.get(e))
								}

								return Expression.NativeOperator(NativeOperatorKind.Function, a, s, null, typer.types.get(e))
						}
					case _: throw '@operator takes string as argument'
				}}

				let v = nodeToExpression(expr)

				switch v {
					case Dot(expr, _): switch expr {
						case This(_): kind = CallKind.VirtualMethod
					}
				}

				return Expression.Call(v, a, typer.types.get(e), kind)

				case Binop(a, op, b):
				// TODO extract bin-op handler to function so than can be called commutatively `infixCommutative()`
				let ea = nodeToExpression(a)
				let eb = nodeToExpression(b)

				// TODO refactor `if op` to `switch op`
				if op == Token.OpAdd { switch ea {
					case String(sa): switch eb {
						// `"abc" + "dce" = "abcdce"`
						case String(sb): return Expression.String(sa + sb)
						// `"abc" + 123 = "abc123"`
						case Int(sb): return Expression.String(sa + sb)
						case Float(sb): return Expression.String(sa + sb)
						case True: return Expression.String(sa + "true")
						case False: return Expression.String(sa + "false")
					}
					case Int(sa): switch eb {
						// `1 + 1 = 2`
						case Int(sb): return Expression.Int(sa + sb)
						case Float(sb): return Expression.Float(sa + sb)
						// `123 + "123" = "123123"`
						case String(sb): return Expression.String(sa + sb)
					}
					case Float(sa): switch eb {
						case Int(sb): return Expression.Float(sa + sb)
						case Float(sb): return Expression.Float(sa + sb)
						case String(sb): return Expression.String(sa + sb)
					}
				}}

				// TODO use nested pattern matching here
				// `case ea, op, eb:`
				if op == Token.OpBoolOr { switch ea {
					case True: switch eb {
						// `true || false = true`
						case False: return Expression.True
						// `true || true = true`
						case True: return Expression.True
					}
					case False: switch eb {
						// `false || false = false`
						case False: return Expression.False
						// `false || true = true`
						case True: return Expression.True
					}
				}}

				if op == Token.OpBoolAnd {
					switch ea {
					case True: switch eb {
						// `true && false = false`
						case False: return Expression.False
						// `true && true = true`
						case True: return Expression.True
					}
					case False: switch eb {
						// `false && false = false`
						case False: return Expression.False
						// `false && true = false`
						case True: return Expression.False
					}
				}}

				// `a == b`
				if op == Token.OpEq {
					switch ea {
					case True: switch eb {
						// `true == false = false`
						case False: return Expression.False
						// `true == true = true`
						case True: return Expression.True
					}
					case False: switch eb {
						// `false == false = true`
						case False: return Expression.True
						// `false == true = false`
						case True: return Expression.False
					}
					case String(sa): switch eb {
						case String(sb):
							if sa == sb {
								return Expression.True
							}
							return Expression.False
					}
					case Int(sa): switch eb {
						case Int(sb):
							if sa == sb {
								return Expression.True
							}
							return Expression.False
					}

					// `null == b`
					// `== null` optimized to `false` for non-nullable types
					// TODO meta-block version, cause expr must be evaluated
					case Null: switch eb {
						case True: return Expression.False
						case False: return Expression.False
						case String(_): return Expression.False
						case Int(_): return Expression.False
						case Ident(_, type): switch type {
							case Nullable(_):
							case UnknownNullable(_):
							case Unknown(_):
							case _: return Expression.False
						}
					}
				}}

				// `a != b`
				if op == Token.OpNotEq {
					switch ea {
					case True: switch eb {
						// `true != false = true`
						case False: return Expression.True
						// `true != true = false`
						case True: return Expression.False
					}
					case False: switch eb {
						// `false != false = false`
						case False: return Expression.False
						// `false != true = true`
						case True: return Expression.True
					}
					case String(sa): switch eb {
						case String(sb):
							if sa != sb {
								return Expression.True
							}
							return Expression.False
					}
					case Int(sa): switch eb {
						case Int(sb):
							if sa != sb {
								return Expression.True
							}
							return Expression.False
					}
				}}

				return Expression.Binop(ea, op, eb, typer.types.get(e))

				case New(path, t, args, fields, el):
				let v = Expression.Ident(parentNames.get(typer.parents.get(e)) ?? DataHelper.extractTypeName(t), null)
				let a = []
				for arg in args {
					a.push(nodeToExpression(arg))
				}
				return Expression.New(v, a, typer.types.get(e))

				case Function(name, expr, vars, rettype, external):
				let a = []
				let defaults = []
				let types = []
				for arg in vars { switch arg {
					case Var(name, t, expr, const):
						a.push(unique(name, arg))
						types.push(t)
						if expr != null {
							defaults.push(nodeToExpression(expr))
						} else {
							defaults.push(null)
						}
				}}
				return Expression.Function(name!=null? unique(name, e) : null as! String, nodeToStatement(expr), a, defaults, typer.types.get(e))

				case Arrow(expr, vars, rettype):
				let a = []
				let defaults = []
				let types = []
				for arg in vars { switch arg {
					case Var(name, t, expr, const):
						a.push(unique(name, arg))
						types.push(t)
						if expr != null {
							defaults.push(nodeToExpression(expr))
						} else {
							defaults.push(null)
						}
				}}
				return Expression.Arrow(nodeToExpression(expr), a, defaults, types, rettype, typer.types.get(e))

				case Block(el):
				if el.length == 0 {
					return Expression.Object([], [], [])
				}
				if el.length == 1 {
					return nodeToExpression(el[0])
				}
				let block = []
				var i = 0
				while i < el.length - 1 {
					if let s = nodeToStatement(el[i]) {
						block.push(s)
					}
					i++
				}
				let result = el[el.length - 1]
				block.push(Statement.Return(nodeToExpression(result)))
				return Expression.Call(Expression.Parenthesis(Expression.Function(null, Statement.Block(block), [], [], null)), [], typer.types.get(result), CallKind.Function)

				case Object(names, el):
				let els = []
				let types = []
				for e in el {
					els.push(nodeToExpression(e))
					types.push(typer.types.get(e))
				}
				return Expression.Object(names, els, types)

				case Parenthesis(inner):
				let value = nodeToExpression(unwrapParens(inner))

				// Don't keep () for single (expr)
				switch value {
					case Int(_): return value
					case String(_): return value
					case Float(_): return value
					case True: return value
					case False: return value
					case Null: return value
				}

				return Expression.Parenthesis(value)

				case Array(el):
				if el.length == 1 { switch el[0] {
					case For(name, over, by, range):
					let block = []
					let result = unique('result')
					let resultType = typer.types.get(e) // TODO refactor to use this var below
					block.push(Statement.Const(result, Expression.Array([], typer.types.get(e)), typer.types.get(e)))
					let value = unique('value')
					let valueType = typer.types.get(el[0])
					block.push(Statement.Const(value, nodeToExpression(over), valueType))

					let push = Statement.Call(Expression.Dot(Expression.Ident(result, typer.types.get(e)), 'push', null), [nodeToExpression(by)], [], CallKind.VirtualMethod)
					fun fillLoop() {
						switch over {
							case Int(s):
							let i = name
							block.push(Statement.Const(i, Expression.Int(-1), typer.typeInt))
							block.push(Statement.While(
								Expression.Binop(
									Expression.Parenthesis(Expression.Binop(Expression.Ident(i, typer.typeInt), Token.OpAdd, Expression.Int(1), typer.typeInt)),
									Token.OpLt,
									Expression.Ident(value, valueType),
									typer.typeBool),
								Statement.Block([
									Statement.Increment(Expression.Ident(i, typer.typeInt)),
									push
								]),
								true))
							return
						}

						block.push(Statement.For(name, Expression.Ident(value, valueType), push))
					}

					fillLoop()
					block.push(Statement.Return(Expression.Ident(result, resultType)))
					return Expression.Call(
						Expression.Parenthesis(
							Expression.Function(null, Statement.Block(block), [], [], Type.Function([], typer.types.get(e)))
						)
						, [],
						typer.types.get(e),
						CallKind.Function
					) // TODO resultType?
				}}

				let els = []
				let types = []
				for e in el {
					els.push(nodeToExpression(e))
					types.push(typer.types.get(e))
				}
				return Expression.Array(els, typer.types.get(e))

				// `nullable ?? otherwise`
				case Elvis(nullable, otherwise):
					let result = unique('result')
					let resultType = typer.types.get(nullable)
					return Expression.Call(Expression.Parenthesis(Expression.Function(null, Statement.Block([
						Statement.Const(result, nodeToExpression(nullable), resultType),
						Statement.If(Expression.Binop(Expression.Ident(result, resultType), Token.OpNotEq, Expression.Null(resultType), typer.typeBool), Statement.Return(Expression.Ident(result, resultType)), null),
						Statement.Return(nodeToExpression(otherwise))
						]), [], [], Type.Function([], typer.types.get(otherwise)))), [], typer.types.get(otherwise),
						CallKind.Function
					)
					return Expression.Elvis(nodeToExpression(nullable), nodeToExpression(otherwise))

				case Unop(op, postfix, e):
					switch op {
						case OpIncrement | OpDecrement:
							var source: Node? = typer.parents.get(e)
							if let source = source {
								switch source {
									case Var(name, _):
										neverReassignedLocal.set(source, false)
								}
							}
					}

					let expression = nodeToExpression(e)
					switch op {
						case OpNot:
							switch expression {
								// `not true = false`
								case True: return Expression.False
								// `not false = true`
								case False: return Expression.True
							}
					}
					return Expression.Unop(op, postfix, expression)

				case This:
					return Expression.This(typer.types.get(e))

				case Map(keys, values):
				let k = []
				let v = []
				for key in keys {
					k.push(nodeToExpression(key))
				}
				for value in values {
					v.push(nodeToExpression(value))
				}

				// TODO transfer `<k, V>`, not `typer.types.get(keys[0])`, also may have zero keys
				return Expression.Map(k, v, typer.types.get(keys[0]), typer.types.get(values[0]), typer.types.get(e))

				case AssignOp(a, op, b):
					var source: Node? = typer.parents.get(a)
					if let source = source {
						switch source {
							case Var(name, _):
								neverReassignedLocal.set(source, false)
						}
					}
					return Expression.Assignop(nodeToExpression(a), op, nodeToExpression(b))

				case If(econd, eif, eelse):
				// Check if it contains if-let bindings
				var binds = false
				for cond in econd { switch cond {
					case Var(_):
					binds = true
				}}

				if not binds, econd.length == 1 {
					return Expression.If(nodeToExpression(econd[0]), nodeToExpression(eif), nodeToExpression(eelse))
				}

				if not binds {
					var parens = Expression.Parenthesis(nodeToExpression(econd[0]))
					var i = 1
					while i < econd.length {
						parens = Expression.Binop(parens, Token.OpBoolAnd, Expression.Parenthesis(nodeToExpression(econd[i])), typer.typeBool)
						i++
					}
					return Expression.If(parens, nodeToExpression(eif), nodeToExpression(eelse))
				}

				return Expression.If(nodeToExpression(econd[0]), nodeToExpression(eif), nodeToExpression(eelse))

				case Index(expr, index):
				return Expression.Index(nodeToExpression(expr), nodeToExpression(index), typer.types.get(e))

				case As(e, kind, t): switch kind {
					case Question:
						console.log('`as?` is not yet supported by normalizer, only `as!`')
					case OpNot:
						return Expression.UnsafeBitCast(nodeToExpression(e), typer.types.get(t))
					case _:
						console.log('`as` is not yet supported by normalizer, only `as!`')
				}

				case Is(e, t):
					return Expression.Is(nodeToExpression(e), typer.types.get(t))

				// Wraps switch into function and adds `return` on every case
				case Switch(exprs, conds, guards, cases):
					let block = []
					let caseRet = []
					var funcType = typer.typeVoid
					var resultType = typer.typeVoid
					for c in cases {
						resultType = typer.types.get(c)
						funcType = Type.Function([], resultType)
						caseRet.push(Node.Return(c))
					}
					block.push(nodeToStatement(Node.Switch(exprs, conds, guards, caseRet)))
					return Expression.Call(
						Expression.Parenthesis(Expression.Function(null, Statement.Block(block), [], [], funcType)),
						[],
						resultType,
						CallKind.Function
					)

				case Module(_):
				case Import(_):
				case _: console.error('(internal warning) Unknown node type for expression:', e, project.data.get(e))
				case TypeAlias(_):
			}

			return null
		}

		fun nodeToStatement(e: Node): Statement? {
			let result = nodeToStatementWithoutPosition(e)
			if result != null {
				niceProject.statementPosition.set(result, project.data.get(e))
			}
			return result
		}

		fun nodeToStatementWithoutPosition(e: Node): Statement? {
			if e == null {
				return null
			}

			switch e {
				case Block(el):
				//var els = [] // TODO
				var els: [Statement] = []
				// Ignore after: break, continue, return, throw...
				var ignore = false
				for e in el {
					var statement = unwrapNestingBlocks(nodeToStatement(e))

					if ignore {
						continue
					}

					switch statement {
						// `null` statement optimized away
						case null:
						// Empty block `{}` optimized away too
						// case If: // TODO error `If` requires `(_)` binds
						case Block(sub):
							switch sub.length {
								// TODO `case []` and `case [one]` patterns
								case 0: // Empty
								//case 1: els.push(els[0]) TODO this typo would be avoided if `els` readonly
								case 1: els.push(sub[0])
								case _: els.push(statement)
							}

						// TODO case other:
						case Break:
							els.push(statement)
							ignore = true

						case Continue:
							els.push(statement)
							ignore = true

						case Return(_):
							els.push(statement)
							ignore = true

						case Throw(_):
							els.push(statement)
							ignore = true

						case _:
							els.push(statement)
					}
				}

				// Promote local to constant
				for i in els.length {
					let element = els[i]
					switch element {
						case Var(name, expr, type):
							if let parent = neverReassignedLocalParent.get(element), neverReassignedLocal.get(parent) == true {
								els[i] = Statement.Const(name, expr, type)
							}
					}
				}

				// Unwrap `{{{{block}}}}`
				if els.length == 1 { switch els[0] {
					case Block(_):
						return els[0]
				}}

				return Statement.Block(els)

				// Types
				case Enum(t, fields, valuesType):
				renameClassFields(fields, getRenamingStrategy(project.mapDecorators.get(e)))
				let isComplexEnum = valuesType == null
				if isComplexEnum {
					// TODO require here new NiceComplexEnum {} fields init
					let type = new NiceComplexEnum()
					type.name = unique(DataHelper.extractTypeName(t), e)
					let atts = project.mapDecorators.get(e)
					type.expose = false
					// TODO move to function `getExposeDecorator(e)`
					if let expose = Decorator.getDecorator(atts, 'expose') {
						if expose.values.length != 0 {
							// TODO move this check to typer
							// TODO normalizer should never throw
							throw '@expose takes zero arguments'
						}

						type.expose = true
					}
					globals.push(type.name)
					let names = []
					let constructors = []
					let constructorsTypes = []
					let types = []
					for f in fields { switch f {
						case NodeTypeValue(t): switch t {
							case Type(name):
							names.push(name)
							constructors.push(null)
							constructorsTypes.push(null)
							types.push(null)
						}
						case Call(e, args, argNames):
							switch e {
								case NodeTypeValue(t): switch t {
									case Type(name): names.push(name)
								}
							}
							constructors.push([for arg in argNames unique(arg as! String)])
							// TODO as! String
							constructorsTypes.push([for arg in args typer.toType(Typer.nodeToNodeType(arg), arg)])
							types.push([for arg in args unique(arg as! String)])
							// TODO as! String
						case Static(field):
							switch field {
							case Var(name, t, expr, const):
								let uname = parentNames.get(field) ?? unique(name, field)
								if const {
									let value = nodeToExpression(expr)
									saveInlineIfViable(f, value)
									type.staticVars.push(Statement.Const(uname, value, typer.types.get(field)))
								} else {
									type.staticVars.push(Statement.Var(uname, nodeToExpression(expr), typer.types.get(field)))
								}
							case Function(name, expr, vars, rettype, external):
								let uname = parentNames.get(field) ?? unique(name, field)
								let a = []
								let defaults = []
								let types = []
								for arg in vars { switch arg {
									case Var(name, t, expr, const):
										a.push(unique(name, arg))
										types.push(t)
										if (expr != null) {
											defaults.push(nodeToExpression(expr))
										} else {
											defaults.push(null)
										}
								}}
								type.staticMethods.push(Statement.Function(uname, unwrapNestingBlocks(nodeToStatement(expr)), a, defaults, typer.types.get(field), VariadicKind.NotVariadic))
							case _: console.error("(internal warning) Unknown complex enum static field kind:", field)
						}
						case _: console.error("(internal warning) Unknown complex enum field kind:", f)
					}}
					type.names = names
					type.constructors = constructors
					type.constructorsTypes = constructorsTypes
					type.types = types
					niceProject.enumsComplex.push(type)
					return null //type
				} else {
					let type = new NiceSimpleEnum()
					type.name = DataHelper.extractTypeName(t)
					let names = []
					// TODO must error cause type of `[]` is unknown
					let values = []
					for f in fields { switch f {
						// `ValueName = b`
						case Binop(a, op, b): // op == OpAssign
							switch a {
								case NodeTypeValue(t): switch t {
									case Type(name):
										names.push(name)
								}
							}
							switch b {
								case String(s): values.push(Expression.String(s))
								case Int(s): values.push(Expression.Int(s))
								case MetaInt(v, meta): values.push(Expression.MetaInt(v, meta, typer.types.get(e)))
								// TODO ^ typer must ensure same precision/meta for all tags' values

								// `Alias = B`
								case NodeTypeValue(type): {
									switch type {
										case Type(name, path): {
											values.push(values[names.indexOf(name)])
										}
										case _: {
											console.error("(internal warning) Unknown node alias value kind:", b)
										}
									}
								}

								case _: console.error("(internal warning) Unknown node field value kind:", b)
							}
						// Just `ValueName`
						case NodeTypeValue(t): switch t {
							case Type(name):
								names.push(name)
						}
						case Static(field):
							switch field {
							case Var(name, t, expr, const):
								let uname = parentNames.get(field) ?? unique(name, field)
								if const {
									let value = nodeToExpression(expr)
									saveInlineIfViable(f, value)
									type.staticVars.push(Statement.Const(uname, value, typer.types.get(field)))
								} else {
									type.staticVars.push(Statement.Var(uname, nodeToExpression(expr), typer.types.get(field)))
								}
							case Function(name, expr, vars, rettype, external):
								let uname = parentNames.get(field) ?? unique(name, field)
								let a = []
								let defaults = []
								let types = []
								for arg in vars { switch arg {
									case Var(name, t, expr, const):
										a.push(unique(name, arg))
										types.push(t)
										if (expr != null) {
											defaults.push(nodeToExpression(expr))
										} else {
											defaults.push(null)
										}
								}}
								type.staticMethods.push(Statement.Function(uname, unwrapNestingBlocks(nodeToStatement(expr)), a, defaults, typer.types.get(field), VariadicKind.NotVariadic))
							case _: console.error("(internal warning) Unknown simple enum static field kind:", field)
						}
						case _: console.error("(internal warning) Unknown simple enum field kind:", f)
					}}
					type.names = names
					type.values = values
					niceProject.enumsSimple.push(type)
					return null //type
				}

				case Class(t, ext, impl, fields, external):
				let atts = project.mapDecorators.get(e)
				renameClassFields(fields, getRenamingStrategy(atts))
				let type = new NiceClass()

				type.external = external
				type.extend = DataHelper.extractTypeName(ext)
				type.type = typer.types.get(e) // TODO better `type` naming
				thisType = type.type
				switch type.type {
					case Class(c):
						if let instanceParams = c.instanceParams {
							type.type = c.instantiateGeneric(instanceParams)
							thisType = type.type
						}

						type.template = c.instances != null and c.instances.length > 0
						type.usedByValueDepth = c.usedByValueDepth
				}

				for implement in impl { switch implement {
					case Type(name):
						type.implement = name
					case ParametricType(name, params):
						type.implement = name
						type.implementParams = [for param in params DataHelper.extractTypeName(param)]
				}}

				switch t {
					case Type(name): // this name
					case ParametricType(name, params):
						type.genericParams = [for param in params DataHelper.extractTypeName(param)]
				}

				// `@require`

				if let require = Decorator.getDecorator(atts, 'require') { switch require.values[0] {
					case String(s): type.jsRequire = s
					case _: throw '@require takes string as argument'
				}}

				// `@struct`

				// type.api = ClassBinaryInterface // TODO why compiles
				type.api = ClassBinaryInterface.Normal

				if let struct = Decorator.getDecorator(atts, 'struct') {
					switch struct.values[0] {
						case null: // Ok
						// TODO `switch struct.values { [] empty array }`
						case _: throw '@struct takes no arguments'
					}
				}

				// `@rename` TODO strategy

				if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
					case String(s):
						type.jsNative = s
						type.name = unique(s, e)
					case _: throw '@rename takes string as argument'
				}} else {
					switch typer.types.get(e) as! Type {
						case Class(the):
							type.name = unique(the.name, e)
						case _:
							type.name = unique(DataHelper.extractTypeName(t), e)
					}
				}

				globals.push(type.name)

				for f in fields { switch f {
					case Var(name, t, expr, const):
						let uname = getClassDotField(e, name) ?? parentNames.get(f) ?? unique(name, f)
						if const {
							let value = nodeToExpression(expr)
							saveInlineIfViable(f, value)
							type.vars.push(Statement.Const(uname, value, typer.types.get(f)))
						} else {
							type.vars.push(Statement.Var(uname, nodeToExpression(expr), typer.types.get(f)))
							let atts = project.mapDecorators.get(f)
							if let native = Decorator.getDecorator(atts, 'bits') {
								switch native.values[0] {
									case Int(v): type.varBits[type.vars.length - 1] = v
								}
							}
						}
					case Property(field, _, _):
						switch field {
							case Var(name, t, expr, const):
								let uname = parentNames.get(f) ?? unique(name, f)
								if const {
									type.vars.push(Statement.Const(uname, nodeToExpression(expr), typer.types.get(field)))
								} else {
									type.vars.push(Statement.Var(uname, nodeToExpression(expr), typer.types.get(field)))
								}
								type.property.push(uname)
						}
					case Function(name, expr, vars, rettype, external):
						let uname = (name == 'new')? 'new' : (parentNames.get(f) ?? unique(name, f))
						let a = []
						let defaults = []
						let types = []
						for arg in vars { switch arg {
							case Var(name, t, expr, const):
								a.push(unique(name, arg))
								types.push(t)
								if (expr != null) {
									defaults.push(nodeToExpression(expr))
								} else {
									defaults.push(null)
								}
						}}
						type.methods.push(Statement.Function(uname, unwrapNestingBlocks(nodeToStatement(expr)), a, defaults, typer.types.get(f), VariadicKind.NotVariadic))
					case Static(field):
						switch field {
							case Var(name, t, expr, const):
								let uname = parentNames.get(field) ?? unique(name, field)
								if const {
									let value = nodeToExpression(expr)
									saveInlineIfViable(f, value)
									type.staticVars.push(Statement.Const(uname, value, typer.types.get(field)))
								} else {
									type.staticVars.push(Statement.Var(uname, nodeToExpression(expr), typer.types.get(field)))
								}
							case Function(name, expr, vars, rettype):
								let uname = parentNames.get(field) ?? unique(name, field)
								let a = []
								let defaults = []
								let types = []
								for arg in vars { switch arg {
									case Var(name, t, expr, const):
										a.push(unique(name, arg))
										types.push(t)
										if (expr != null) {
											defaults.push(nodeToExpression(expr))
										} else {
											defaults.push(null)
										}
								}}
								type.staticMethods.push(Statement.Function(uname, unwrapNestingBlocks(nodeToStatement(expr)), a, defaults, typer.types.get(field), VariadicKind.NotVariadic))
							case _: console.error("(internal warning) Unknown class static field kind:", field)
						}
					case _: console.error("(internal warning) Unknown class field kind:", f)
				}}
				niceProject.classes.push(type)

				switch typer.types.get(e) as! Type {
					case Class(the):
						type.useless = the.useless

						fun fillSignature(signature: [String], type: Type) {
							switch type {
								case ClassInstance(type, generic):
									// TODO safe/renamed name
									// TODO nested names
									if let native = getNative(type.parent) {
										signature.push(native)
									} else {
										signature.push(type.name)
									}

									let generic = generic ?? []
									for param in generic {
										fillSignature(signature, param)
									}

								// TODO are enum instances support generic-ness now?
								case EnumInstance(type):
									signature.push(type.name)
								case Class(type):
									signature.push(type.name)
								case Enum(type):
									signature.push(type.name)
								case Nullable(handle):
									// TODO inconsistent with generator
									signature.push('Null')
									fillSignature(signature, handle)

								case Unknown(handle):
									if let type = handle.value {
										fillSignature(signature, type)
									} else {
										signature.push('Unknown')
									}
								case UnknownNullable(handle):
									signature.push('Null')
									if let type = handle.value {
										fillSignature(signature, type)
									} else {
										signature.push('Unknown')
									}
								case Function(value):
									signature.push('fun')
								case Constant(value):
									signature.push('const')
								case Struct(value):
									signature.push('struct')
								case _:
									throw type
							}
						}

						for instance in the.instances {
							var signature = ['_']
							if let instanceParams = instance.instanceParams {
								for param in instanceParams {
									fillSignature(signature, param)
								}
							}
							// TODO do not save it like this? also `unique(name)`
							instance.useless = the.useless
							nodeToStatement(instance.parent)
						}
				}

				return null //type

				case TypeAlias(_):

				// Expressions
				case New(path, t, args, fields, values, _):
				return Statement.Const(unique('temp'), nodeToExpression(e), typer.types.get(e))

				// TODO just use `Expression.Call`, cause doesn't fills defaults etc
				case Call(e, args, argNames):

				var kind = CallKind.Function
				switch e {
					// `super()` in `new(){}`
					case Super:
						let a = []
						for arg in args {
							a.push(nodeToExpression(arg))
						}
						return Statement.SuperConstructor(a)
					// Call kind
					case Dot(expr, name):
						switch typer.types.get(expr) as! Type {
							case ClassInstance(c, _):
								if c.fields.get(name) == ClassTypeField.Method {
									kind = CallKind.VirtualMethod
								}
							case Class(_): kind = CallKind.Static
						}
				}

				let v = nodeToExpression(e)
				let a = []
				for arg in args {
					a.push(nodeToExpression(arg))
				}

				switch typer.parents.get(e) as! Node {
					case Function(_, _, vars): {
						if vars.length > a.length {
							// Fill default arg values
							for i in vars.length {
								if i < a.length {
									continue
								}

								switch vars[i] as! Node {
									case Var(_, _, value): if let value = value {
										a.push(nodeToExpression(value))
									} // TODO else `break`? cause not args have values?
								}
							}
						}
					}
				}

				var expects = []
				switch typer.types.get(e) as! Type {
					case Function(args, _): expects = args
				}

				switch v {
					case Dot(expr, _): switch expr {
						case This(_): kind = CallKind.VirtualMethod
					}
				}

				return Statement.Call(v, a, expects, kind)

				case Var(name, t, expr, const, external):
				let uname = parentNames.get(e) ?? unique(name, e)
				if external {
					return null
				}

				if const {
					let value = nodeToExpression(expr)

					saveInlineIfViable(e, value)

					return Statement.Const(uname, value, typer.types.get(e))
				}

				let result = Statement.Var(uname, nodeToExpression(expr), typer.types.get(e))
				neverReassignedLocal.set(e, true)
				neverReassignedLocalParent.set(result, e)
				return result

				case Function(name, expr, vars, rettype, external, variadic):
				var uname: String? = null

				// TODO wrap getting `native` into function, also validate it takes only 1 argument
				let atts = project.mapDecorators.get(e)
				if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
						case String(s): if (parentNames.get(e) == null) {
							uniqueNative(s, e)
						}
						uname = parentNames.get(e)
						case _: throw '@rename takes string as argument'
				}} else {
					uname = (name!=null)?(parentNames.get(e) ?? unique(name, e)):null as! String
				}

				var rettype = rettype
				let a = []
				let defaults = []
				var types = []
				for arg in vars { switch arg {
					case Var(name, t, expr, const):
						a.push(unique(name, arg))
						types.push(t)
						if expr != null {
							defaults.push(nodeToExpression(expr))
						} else {
							defaults.push(null)
						}
				}}

				let variadic = variadic? VariadicKind.NativeVariadic : VariadicKind.NotVariadic

				if external {
					return Statement.Function(uname, null, a, defaults, typer.types.get(e), variadic)
				}

				if name == 'new' {
					// TODO just keep `new` as name or whatever
					return Statement.Function(null, unwrapNestingBlocks(nodeToStatement(expr)), a, defaults, typer.types.get(e), variadic)
				}

				return Statement.Function(uname, unwrapNestingBlocks(nodeToStatement(expr)), a, defaults, typer.types.get(e), variadic)

				case For(name, over, by, range):
				if range == null {
					switch over {
					// TODO compare not `Node.Int` but instead propagate whatever constant *Nice* Int/MetaInt
					case Int(s):
					let i = unique(name, e)
					// This allows to call `continue` within loop body,
					// otherwise infinite loop happens
					let it = unique('it')
					return Statement.Block([
						Statement.Var(i, Expression.Int(0), typer.typeInt),
						Statement.Var(it, Expression.Int(0), typer.typeInt),
						Statement.While(
							Expression.Binop(Expression.Ident(it, typer.typeInt), Token.OpLt, Expression.Int(s), typer.typeBool),
							Statement.Block([
								Statement.Assign(Expression.Ident(i, typer.typeInt), Expression.Ident(it, typer.typeInt), null),
								Statement.Increment(Expression.Ident(it, typer.typeInt)),
								nodeToStatement(by)
							]),
							true)
					])
					case _: // Iterate over non-constant Int:

					let overType = typer.types.get(over)
					var iteratorOverInt =
						overType == typer.typeInt
						or
						overType == typer.typeInt32
						or
						overType == typer.typeUInt32
						or
						overType == typer.typeInt8
						or
						overType == typer.typeUInt8
						or
						overType == typer.typeInt16
						or
						overType == typer.typeUInt16
						or
						overType == typer.typeInt64
						or
						overType == typer.typeUInt64
						// TODO more

					if iteratorOverInt {
						let i = unique(name, e)
						let it = unique('it') // TODO why this var is needed? Control flow of `it++`? Then use `do while`?
						let finish = unique('at')

						return Statement.Block([
							Statement.Var(i, Expression.Int(0), overType),
							Statement.Var(it, Expression.Int(0), overType),
							Statement.Var(finish, nodeToExpression(over), overType),
							Statement.While(
								Expression.Binop(
									Expression.Ident(it, overType),
									Token.OpLt,
									Expression.Ident(finish, overType),
									typer.typeBool
								),
								Statement.Block([
									Statement.Assign(Expression.Ident(i, overType), Expression.Ident(it, overType), null),
									Statement.Increment(Expression.Ident(it, overType)),
									nodeToStatement(by)
								]),
								true)
						])
					}
				}}
				if let range = range {
					/*
						let i = 0
						let it = over
						let finish = range

						while it < finish {
							i = it
							it++
							by
						}
					*/

					let i = unique(name, e)
					let it = unique('it')
					let finish = unique('at')

					return Statement.Block([
						Statement.Var(i, Expression.Int(0), typer.typeInt),
						Statement.Var(it, nodeToExpression(over), typer.typeInt),
						Statement.Var(finish, nodeToExpression(range), typer.typeInt),
						Statement.While(
							Expression.Binop(Expression.Ident(it, typer.typeInt), Token.OpLt, Expression.Ident(finish, typer.typeInt), typer.typeBool),
							Statement.Block([
								Statement.Assign(Expression.Ident(i, typer.typeInt), Expression.Ident(it, typer.typeInt), null),
								Statement.Increment(Expression.Ident(it, typer.typeInt)),
								nodeToStatement(by)
							]),
							true)
					])
				}
				return Statement.For(name, nodeToExpression(over), nodeToStatement(by))

				case Return(e):
				if (e == null) {
					return Statement.Return(null)
				}
				return Statement.Return(nodeToExpression(e))

				// TODO this.name
				case Dot(expr, name):
					return Statement.Const(unique('temp'), nodeToExpression(e), typer.types.get(e))
				case DotUpper(expr, name):
					return Statement.Const(unique('temp'), nodeToExpression(e), typer.types.get(e))

				case If(econd, eif, eelse):
				// Check if it contains if-let bindings
				var binds = false
				for cond in econd { switch cond {
					case Var(_):
					binds = true
				}}

				// Just plain `if`
				if not binds, econd.length == 1 {
					let value = nodeToExpression(unwrapParens(econd[0]))
					// Always evaluate all expressions TODO really required?
					let ei = nodeToStatement(eif)
					let ee = nodeToStatement(eelse)
					switch value {
						case True:
							return ei
						case False:
							// `eelse` here is `null` if not present
							return ee
					}
					return Statement.If(value, ei, ee)
				}

				// if cond, cond, cond...
				if not binds {
					var parens = Expression.Parenthesis(nodeToExpression(econd[0]))
					var i = 1
					while i < econd.length {
						parens = Expression.Binop(parens, Token.OpBoolAnd, Expression.Parenthesis(nodeToExpression(econd[i])), typer.typeBool)
						i++
					}
					return Statement.If(parens, nodeToStatement(eif), nodeToStatement(eelse))
				}

				// if let, let, let...
				let block = []
				var current = 0
				// Builds kind of state machine here
				let step = unique('step')
				block.push(Statement.Var(step, Expression.Int(0), typer.typeInt))
				var nullable = false
				var last = ''
				let lastType = typer.types.get(econd[0])
 				switch econd[0] {
					case Var(name, t, expr, const):
					last = unique(name, econd[0])
					nullable = true
					block.push(Statement.Const(last, nodeToExpression(expr), typer.types.get(econd[0])))
					case _:
					last = unique('temp')
					block.push(Statement.Const(last, nodeToExpression(econd[0]), typer.types.get(econd[0])))
				}

				while current < econd.length - 1 { switch econd[current + 1] {
					case Var(vname, t, expr, const):
					let name = unique(vname, econd[current + 1])
					block.push(Statement.Var(name, Expression.Null(typer.types.get(expr)), typer.types.get(expr)))
					block.push(Statement.If(
						Expression.Binop(
							Expression.Binop(Expression.Ident(step, typer.typeInt), Token.OpEq, Expression.Int(current + 0), typer.typeBool),
							Token.OpBoolAnd,
							Expression.Binop(Expression.Ident(last, lastType), Token.OpNotEq, nullable? Expression.Null(lastType) : Expression.False, typer.typeBool),
							typer.typeBool
						),
						Statement.Block([
							Statement.Assign(Expression.Ident(name, typer.types.get(expr)), nodeToExpression(expr), null),
							Statement.Assign(Expression.Ident(step, typer.typeInt), Expression.Int(current + 1), null)
						]), null))
					current++
					last = name
					nullable = true
					case _:
					let next = unique('temp')
					let nextType = typer.types.get(econd[0])
					block.push(Statement.Var(next, Expression.Null(nextType), nextType))
					block.push(Statement.If(
						Expression.Binop(
							Expression.Binop(Expression.Ident(step, typer.typeInt), Token.OpEq, Expression.Int(current + 0), typer.typeBool),
							Token.OpBoolAnd,
							Expression.Binop(Expression.Ident(last, lastType), Token.OpNotEq, nullable? Expression.Null(lastType) : Expression.False, typer.typeBool),
							typer.typeBool
						),
						Statement.Block([
							Statement.Assign(Expression.Ident(next, nextType), nodeToExpression(econd[current + 1]), null),
							Statement.Assign(Expression.Ident(step, typer.typeInt), Expression.Int(current + 1), null)
						]), null))
					current++
					last = next
					nullable = false
				}}

				// Last step
				block.push(Statement.If(
					Expression.Binop(
						Expression.Binop(Expression.Ident(step, typer.typeInt), Token.OpEq, Expression.Int(econd.length - 1), typer.typeBool),
						Token.OpBoolAnd,
						Expression.Binop(Expression.Ident(last, lastType), Token.OpNotEq, nullable? Expression.Null(lastType) : Expression.False, typer.typeBool),
						typer.typeBool
					),
					Statement.Assign(Expression.Ident(step, typer.typeInt), Expression.Int(econd.length), null), null))

				// if (step == steps)
				block.push(Statement.If(
					Expression.Binop(Expression.Ident(step, typer.typeInt), Token.OpEq, Expression.Int(econd.length), typer.typeBool),
					nodeToStatement(eif), nodeToStatement(eelse)))

				return Statement.Block(block)

				case Try(expr, t, v, catches):
				var temp = unique('temp') // Used for `catch (temp)` in JS
				var tt = []
				var vv = []
				for c in v {
					 vv.push(DataHelper.nameOf(c))
				}
				var cc = []
				for c in catches {
					cc.push(nodeToStatement(c))
				}
				for c in t {
					tt.push(typer.types.get(c))
				}
				return Statement.Try(nodeToStatement(expr), tt, vv, cc, temp)

				case Throw(value):
				return Statement.Throw(nodeToExpression(value))

				case AssignOp(a, op, b): {
					var source: Node? = typer.parents.get(a)
						if let source = source {
							switch source {
								case Var(name, _):
									neverReassignedLocal.set(source, false)
							}
						}
					return Statement.Assignop(nodeToExpression(a), op, nodeToExpression(b))
				}

				case Binop(a, op, b):
				switch op {
					case OpAssign:
						var source: Node? = typer.parents.get(a)
						if let source = source {
							switch source {
								case Var(name, _):
									neverReassignedLocal.set(source, false)
							}
						}
					return Statement.Assign(nodeToExpression(a), nodeToExpression(b), null)
					case _:
					let sa = nodeToStatement(a)
					let sb = nodeToStatement(b)
					if sa == null, sb == null {
						return null
					}
					if ((sa == null) || (sb == null)) {
						return sa ?? sb
					}
					return Statement.Statements([sa, sb])
				}

				case Continue: return Statement.Continue
				case Break: return Statement.Break

				case While(econd, e, pre):
				return Statement.While(nodeToExpression(econd), nodeToStatement(e), pre)

				case Unop(op, postfix, e):
					switch op {
						case OpIncrement | OpDecrement:
							var source: Node? = typer.parents.get(e)
							if let source = source {
								switch source {
									case Var(name, _):
										neverReassignedLocal.set(source, false)
								}
							}
					}
					switch op {
						case OpIncrement: return Statement.Increment(nodeToExpression(e))
						case OpDecrement: return Statement.Decrement(nodeToExpression(e))
						case _: // Optimize away
					}
				case Parenthesis(inner):
					return nodeToStatement(unwrapParens(inner))

				case Switch(exprs, conds, guards, cases):
				if (exprs.length > 1) {
					console.error('Multiple switch values not yet supported:', e, project.data.get(e))
				}

				let s = []
				let c = []

				if nativeEnums {
					let index = nodeToExpression(exprs[0])
					for i in cases.length {

						fun toCase(co: Node) { switch co {
							case Null: return Expression.Null(typer.typeAny)
							case Underscore: return Expression.Underscore
							case String(v): return Expression.String(v)
							case Int(v): return Expression.Int(v)
							case Float(v): return Expression.Float(v)
							case Bool(v):
								if v {
									return Expression.True
								}
								return Expression.False
							case Dot(expr, name): return Expression.Dot(nodeToExpression(expr), name, null)
							case DotUpper(expr, name): return Expression.Dot(nodeToExpression(expr), name, null)
							case Binop(a, op, b): switch op {
							case OpOr: return Expression.Binop(toCase(a), Token.OpOr, toCase(b), null)
								case _: console.error('(internal warning) Unknown native case binop kind:', e, typer.parents.get(e))
							}
							case Call(e, args, argNames): switch e {
								case DotUpper(expr, name):
									let a = []
									for arg in args.length { switch args[arg] {
										case Ident(name): a.push(Expression.Ident(unique(name, args[arg]), null))
										case Underscore: a.push(Expression.Underscore)
										case _: console.log('(internal warning) Unknown native case extract value kind:', args[arg])
									}}
									return Expression.Call(nodeToExpression(e), a, null, CallKind.Function)
								case _: console.error('(internal warning) Unknown case extract kind:', e, typer.parents.get(e))
							}
							case _:
							console.error('(internal warning) Unknown native enum case kind:', co, project.data.get(co))
						}}

						c.push([toCase(conds[i])])
						s.push(nodeToStatement(cases[i]))
					}
					return Statement.Switch(index, c, s, [], [])
				}

				let temp = unique('temp')
				let value = nodeToExpression(exprs[0])
				var index = Expression.Ident(temp, typer.types.get(exprs[0]))
				var promoted = false
				var enumType: EnumType? = null

				// TODO solve `Type?` situation with nested pattern matching
				// `case null:`
				// `case Nullable(Enum(type) or EnumInstance(type)) or Enum(type) or EnumInstance(type):`
				// `case Nullable(type) or type: switch type { case Enum(type) or EnumInstance(type):`
				switch Type.unwrapNullable(typer.types.get(exprs[0])) {
					case Enum(type):
						if (type.fieldsTypeSimple == null) { index = Expression.EnumTag(index) promoted = true }
						enumType = type
					case EnumInstance(type):
						if (type.fieldsTypeSimple == null) { index = Expression.EnumTag(index) promoted = true }
						enumType = type
				}

				var i = 0
				let guardians: [Expression] = []
				let binds: [[Statement]] = []

				for ec in cases {
					let block = []
					let co = conds[i]
					let cx = []
					let binders: [Statement] = []
					binds.push(binders)

					fun addTag(co: Node) { switch co {
						case Null: cx.push(Expression.Null)
						case Underscore:
						case String(v): cx.push(Expression.String(v))
						case Int(v): cx.push(Expression.Int(v))
						case Float(v): cx.push(Expression.Float(v))
						case Bool(v):
							if v {
								cx.push(Expression.True)
							} else {
								cx.push(Expression.False)
							}
						case Call(e, args, argNames):
							switch e {
								case DotUpper(expr, name):
								let parent = typer.parents.get(expr)
								let tag = getTag(parent, name)
								cx.push(tag)
								case NodeTypeValue(t):
									switch t {
										case Type(name):
											if let enumType = enumType {
												cx.push(getTag(enumType.parent, name))
											}
									}
								case _:
									console.error('(internal warning) Unknown case extract kind:', e, typer.parents.get(e))
							}
							// Promote to complex enum
							if not promoted {
								index = Expression.EnumTag(index)
							}
							promoted = true
							for arg in args.length { switch args[arg] {
								case Ident(name):
									binders.push(
										Statement.Const(
											unique(name, args[arg]),
											Expression.EnumParameter(
												Expression.Ident(temp, typer.types.get(args[arg])),
												arg
											),
											typer.types.get(args[arg])
										)
									)
								case Underscore: {}
								case Interval: {}
								case _: console.log('(internal warning) Unknown case extract value kind:', arg)
							}}
						case DotUpper(expr, name):
							cx.push(getTag(typer.parents.get(expr), name))
						case Binop(a, op, b):
						switch op {
							case OpOr:
							addTag(a)
							addTag(b)
							case _: console.error('(internal warning) Unknown case binop kind:', e, typer.parents.get(e))
						}
						case NodeTypeValue(t):
							switch t {
								case Type(name):
									if let enumType = enumType {
										cx.push(getTag(enumType.parent, name))
									}
							}
						case _:
						console.error('(internal warning) Unknown case kind:', co, project.data.get(co))
					}}

					addTag(co)

					c.push(cx)
					block.push(unwrapNestingBlocks(nodeToStatement(ec)))
					s.push(unwrapNestingBlocks(Statement.Block(block)))

					if let guard = guards[i] {
						guardians.push(nodeToExpression(guard))
					} else {
						guardians.push(null)
					}

					i++
				}

				return Statement.Block([
					Statement.Const(temp, value, typer.types.get(exprs[0])),
					Statement.Switch(index, c, s, guardians, binds)
				])


				// Optimize away
				case Index(v, index):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused value of index `\(Node.stringify(e))`', project.data.get(e)))
					// No need to compute constant index
					switch index {
						case String(_): return nodeToStatement(v)
						case Int(_): return nodeToStatement(v)
						case Bool(_): return nodeToStatement(v)
						case Float(_): return nodeToStatement(v)
					}
				return Statement.Statements([nodeToStatement(v), nodeToStatement(index)])

				// Optimize away
				case Ident(name):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused value `\(name)`', project.data.get(e)))
				case Arrow(_):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused arrow => function', project.data.get(e)))
				case String(v):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused string `"\(v)"`', project.data.get(e)))
				case Bool(v):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused boolean `\(v)`', project.data.get(e)))
				case Int(v):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused number `\(v)`', project.data.get(e)))
				case Float(v):
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused float `\(v)`', project.data.get(e)))
				case Null:
					project.hints.push(new Hint(Hints.UnusedValue, 'Unused `null`', project.data.get(e)))
				case Module(_):
				case _:
					return Statement.Const(unique('temp'), nodeToExpression(e), typer.types.get(e))
			}

			return null
		}

		fun getTag(enumNode: Node, name: String): Expression? {
			switch enumNode {
				case Enum(t, fields, valuesType):
				var typed: EnumType = null as! EnumType
				switch typer.types.get(enumNode) as! Type {
					case Enum(type): typed = type
				}

				var i = 0
				for f in fields {
					switch f {
						case NodeTypeValue(t): switch t {
							case Type(n):
								if n == name {
									if typed.fieldsTypeSimple == typer.typeString {
										return Expression.String(n)
									}
								}

								if n == name {
									let atts = project.mapDecorators.get(enumNode)
									if let rename = Decorator.getDecorator(atts, 'castTo') {
										return Expression.UnsafeBitCast(Expression.Int(i), typer.types.get(enumNode))
									}
									return Expression.Int(i)
								}
						}
						case Call(e, _): switch e {
							case NodeTypeValue(t): switch t {
								case Type(n):
									if n == name {
										return Expression.Int(i)
									}
							}
						}
						case Binop(a, op, b): switch a {
							case NodeTypeValue(t): switch t {
								case Type(n):
									if n == name {
										return nodeToExpression(b)
									}
							}
						}
						case Static(_): return null // Not a tag
						case _:
							console.error('(internal warning) Unknown enum tag kind:', f)
					}
					i++
				}
				throw 'Enum has no tag or field `\(name)` ' + t
			}
		}

		fun getNative(e: Node): String? {
			let atts = project.mapDecorators.get(e)
			if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
					case String(s):
						return s
					case _: throw '@rename takes string as argument'
			}}
			return null
		}

		let scopes: [[String : Bool]] = [[:]]
		let globals: [String] = [] // Type names are global

		// Randomization for the un-hack-ability
		var id = Math.round(Math.random() * 123.0)

		fun pushScope() {
			scopes.push(([:]))
		}

		fun popScope() {
			scopes.pop()
		}

		fun hasInScope(name: String) {
			for scope in scopes {
				if (scope.get(name) != null) {
					return true
				}
			}
			return false
		}

		fun addToScope(name: String) {
			scopes[scopes.length-1].set(name, true)
		}

		// Allows to find renamed node
		let parentNames: [Node : String] = [:]

		// Returns new name if name occupied or reserved
		// Returns same name and calls addToScope if name is free
		fun unique(name: String, node: Node = null): String {
			var uname = name
			while
				hasInScope(uname) ||
				(keywords.indexOf(uname) != -1) ||
				(globals.indexOf(uname) != -1)
			{
				uname = (name + '_') + (++id)
			}

			addToScope(uname)
			if node != null {
				parentNames.set(node, uname)
			}
			return uname
		}

		// Sets name without renaming for `@rename`
		fun uniqueNative(name: String, node: Node) {
			addToScope(name)
			parentNames.set(node, name)
		}

		fun fillStatement(e: Node): Statement {
			return nodeToStatement(e)
		}

		fun renameClassFields(fields: [Node], renaming: FieldRenaming?) {
			// TODO pre-add `_` suffix to avoid String allocations on every .dot
			pushScope()
			for f in fields { switch f {
				case Var(name, t, expr, const):
					let atts = project.mapDecorators.get(f)
					let renamingStrategy = getRenamingStrategy(atts) ?? renaming

					if let native = Decorator.getDecorator(atts, 'rename') {
						switch native.values[0] {
						case String(s):
						// TODO what that `parentNames` thing even means here? Elaborate in comment!
						// Cause new rename has higher priority
						// oooohhh it just avoids double-renaming, cause `renameClassFields` called twice
						if parentNames.get(f) == null {
							unique(s, f) // TODO `uniqueNative`?
						}
						case _: throw '@rename takes string as argument'
					}} else {

					if parentNames.get(f) == null {
						switch renamingStrategy {
							case AsTitleCase: unique(Hint.toTitleCase(name), f)
							case AsIs: unique(name, f) // TODO what?
							case null: unique(name, f)
						}
					}
					}
				case Function(name, expr, vars, rettype):
					if name == 'new' {
						parentNames.set(f, 'new')
					} else {
						let atts = project.mapDecorators.get(f)

						if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
							case String(s): if parentNames.get(f) == null {
								unique(s, f)
							}
							case _: throw '@rename takes string as argument'
						}} else

						if parentNames.get(f) == null {
							unique(name, f)
						}
					}
				case Static(field): switch field {
					// TODO `RenamingStrategy`
					case Var(name, t, expr, const):
						let atts = project.mapDecorators.get(f)

						if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
							case String(s):
							if parentNames.get(field) == null {
								unique(s, field)
							}
							case _: throw '@rename takes string as argument'
						}} else

						if parentNames.get(field) == null {
							unique(name, field)
						}
					case Function(name, expr, vars, rettype):
						let atts = project.mapDecorators.get(f)

						if let native = Decorator.getDecorator(atts, 'rename') { switch native.values[0] {
							case String(s): if (parentNames.get(field) == null) {
								unique(s, field)
							}
							case _: throw '@rename takes string as argument'
						}} else

						if parentNames.get(field) == null {
							unique(name, field)
						}
				}
			}}
			popScope()
		}

		// Used for `something.name`
		fun getClassDotField(expr: Node, name: String): String? {
			if let type = typer.types.get(expr) {
				switch type as! Type {
					case Class(type):
						let renamed = type.fieldRenames[type.fieldNames.indexOf(name)]
						if let rename = renamed {
							return rename
						}
					case _:
					// TODO Enum
				}
			}

			switch expr {
				case Class(t, ext, impl, fields, external): for f in fields { switch f {
					case Static(sf):
					if (DataHelper.nameOf(sf) == name) {
						return parentNames.get(sf) ?? name
					}
					case Var(n, _):
					if (n == name) {
						return parentNames.get(f) ?? name
					}
				}}
				case Enum(t, fields, valuesType): for f in fields { switch f {
					case Static(sf):
					if (DataHelper.nameOf(sf) == name) {
						return parentNames.get(sf) ?? name
					}
				}}
			}
			return null
		}

		// Converts `{ { { ... } } }` into just `...`
		fun unwrapNestingBlocks(block: Statement): Statement { switch block {
			case Block(el):
				if (el.length == 1) {
					return unwrapNestingBlocks(el[0])
				}
				return block
			case _:
				return block
		}}

		// Saves if value viable for constant propagation
		fun saveInlineIfViable(e: Node, value: Expression) {
			switch value {
				case Int(_): inline.set(e, value)
				case MetaInt(_): inline.set(e, value)
				case String(_): inline.set(e, value)
				case Float(_): inline.set(e, value)
				case True: inline.set(e, value)
				case False: inline.set(e, value)
				case Null: inline.set(e, value)
			}
		}

		// TODO move this to Node as method
		fun unwrapParens(inner: Node) {
			switch inner {
				case Parenthesis(i): return unwrapParens(i)
				case _: return inner
			}
		}
}
