// The Hexa Compiler
// Copyright (C) 2019  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

module
	// See: `/docs/typer.md`
	class Typer {
		// Note that we use new instance for each build to avoid collisions with unit tests
		// and to support parallel compilation in future
		new () {}

		// A starting point of typer
		// Validates that file starts with `module`s and has own namespace
		// Fills module namespaces, module types, than file expressions
		function fillFiles(collected: [[Node]]): Void {
			function fillModuleNamespace(m: Node) {
				var el: [Node] = null as! [Node] // TODO
				var root: String? = null
				switch (m) {
					case Node.TModule(path, els):
					el = els
					root = path.join('.')
					case _: throw 'Unreachable #2'
				}

				if (namespaces.get(root) == null) {
					namespaces.set(root, m)
				} else {
					var els: [Node] = null as! [Node] // TODO
					switch (namespaces.get(root)) {
						case Node.TModule(_, el): els = el
						case _: throw 'Unreachable #1'
					}
					while (el.length > 0) els.push(el.pop())
				}

				{
					var els: [Node] = null as! [Node] // TODO
					switch (namespaces.get(root)) {
						case Node.TModule(_, el): els = el
						case _: throw 'Unreachable #4'
					}

					for (e in els) {
						var name = nameOfModuleItem(e)
						var found = false
						for (el in els) {
							if (nameOfModuleItem(el) == name) {
								if (found) fail(
									'The `\(name)` already exists in module\n' +
									positionOf(el) + '`\(name)` is defined here', e)
								if (!found) found = true
							}
						}
					}
				}
			}

			// Let's fill global namespaces first to avoid delayed expansion
			for (file in collected) {
				var didInit = false
				var lastOne = file[0]
				for (e in file) switch (e) {
					case Node.TModule(path, el):
						if (didInit) fail(
							'Modules should follow before expressions\n'
							+ positionOf(lastOne) + 'Expression is here',
						e)
						fillModuleNamespace(e)
					case _:
						lastOne = e
						didInit = true
				}
			}

			var intermediate: [String] = []

			// Fill intermediate non-existsing modules (module aaa.not_exists.bbb {})
			// Say, we have `module aaa {}` and `module aaa.not_exists.bbb {}`
			// but no `module aaa.not_exists {}`, it creates `aaa.not_exists` namespace
			{
				var intermediateSubs = []
				for (ns in namespaces.keys()) {
					var path = ns.split('.')
					var namespace = path.shift()
					function check(namespace) {
						if (namespaces.get(namespace) == null && intermediate.indexOf(namespace) == -1) {
							intermediate.push(namespace)
						}
					}
					check(namespace)
					while (path.length > 0) {
						namespace += '.' + path.shift()
						check(namespace)
					}
				}

				for (path in intermediate) {
					var m = Node.TModule(path.split('.'), [])
					namespaces.set(path, m)
				}
			}

			function findBasicType(name: String, callback: Any): ClassType {
				let subj = findInNamespaceRoots(name)
				if (subj == null)
					fail('Cannot find basic type `\(name)`. This type should be a part of standard library of the compilation target.')
				return registerClassType(subj, callback)
			}

			// Types cache
			findBasicType('Int', function (type) typeInt = type.instantiate())
			findBasicType('Bool', function (type) typeBool = type.instantiate())
			findBasicType('Float', function (type) typeFloat = type.instantiate())
			findBasicType('String', function (type) typeString = type.instantiate())
			findBasicType('Array', function (type) typeArray = type)
			findBasicType('Map', function (type) typeMap = type)
			findBasicType('Any', function (type) typeAny = type.instantiate())
			findBasicType('Void', function (type) typeVoid = type.instantiate())

			// Fill module scopes of all files at first
			pushScope()
			for (file in collected) for (e in file) switch (e) {
				case Node.TModule(path, el):
					// Fill classes first
					for (node in el) switch (node) {
						case Node.TClass(_):
							parents.set(node, e)
							fill(node)
						case Node.TEnum(_):
							parents.set(node, e)
							fill(node)
						case _:
					}
					for (node in el) switch (node) {
						case Node.TClass(_):
						case Node.TEnum(_):
						case _:
							parents.set(node, e)
							fill(node)
					}
				case _:
			}
			popScope()

			// Fill initialization code at files roots
			for (file in collected) {
				pushScope()
				for (e in file) switch (e) {
					case Node.TModule(path, el):
					case _: fill(e)
				}
				popScope()
			}
		}

		function find(name: String): Node? {
			var subj = null
			for (i in scopes.length) {
				subj = scopes[scopes.length - i - 1].get(name)
				if (subj != null) {
					break
				}
			}
			if (subj == null) subj = findInNamespaceRoots(name)
			return subj
		}

		// Generates `Did you mean xxx?`
		// TODO use this for other errors
		function proposeSimilar(names: [String], subject: String, what: String): String {
			let available = 'Available \(what) are: ' + names.join(', ')
			let subject = subject.toLowerCase()
			let charSubj = subject.split('')
			var bestValue = 0
			var bestName = ''

			// TODO for (name : index in _) _
			for (name in names) {
				let named = name.toLowerCase()
				if (named.startsWith(subject) || subject.startsWith(named))
					return 'Did you mean `\(name)`?\n\n' + available

				var index = 0
				var thisValue = 0
				// TODO for (name : index in _) _
				for (char in named.split('')) {
					if (char == charSubj[index]) thisValue++
					index++
				}

				if (thisValue > bestValue) {
					bestValue = thisValue
					bestName = name
				}
			}

			// Avoid really useless proposals
			if (bestValue > 2) return 'Did you mean `\(bestName)`?\n\n' + available

			return available
		}

		// `class T {}`
		function registerClassType(node: Node, callback: Any): ClassType {
			if (let type = types.get(node)) {
				switch (type) {
					// Avoid typing if already typed
					case Type.Class(t):
						if (let setup = callback) setup(t)
						return t
				}
			} else {
				let type = new ClassType()
				let _thisType = thisType
				thisType = type
				type.parent = node
				type.name = DataHelper.nameOf(node)
				types.set(node, Type.Class(type))

				// Solve race condition
				// TODO do only for std lib
				if (let setup = callback) setup(type)
				switch (type.name) {
					case 'Int': typeInt = type.instantiate()
					case 'Bool': typeBool = type.instantiate()
					case 'Float': typeFloat = type.instantiate()
					case 'String': typeString = type.instantiate()
					case 'Array': typeArray = type
					case 'Map': typeMap = type
					case 'Any': typeAny = type.instantiate()
					case 'Void': typeVoid = type.instantiate()
				}

				function getRename(f: Node): String? {
					let atts = Project.mapAttributes.get(f)
					if (let native = DataHelper.getAttribute(atts, 'native')) {
						if (native.values.length != 1) throw '@native takes one string argument'
						if (native != null) switch (native.values[0]) {
							case Node.TString(s): return s
							case _: throw '@native takes string as argument'
						}
					}
					return null
				}

				switch (node) {
					case Node.TClass(t, extend, implement, f, external):
						switch (t) {
							case NodeType.ParametricType(name, params):
								let names = [DataHelper.extractTypeName(params[0])]
								for (i in 1 ... params.length) {
									let name = DataHelper.extractTypeName(params[i])
									if (names.includes(name))
										fail('Parametric type `\(name)` already exists in `<T, ...>`', node)
									names.push(name)
								}
						}

						if (let ext = extend) toType(ext, node)
						for (impl in implement) toType(impl, node)
						pushScope()

						// Fill scopes
						for (field in f) {
							switch (field) {
								case Node.TFunction(name, _):
									if (type.fieldNames.includes(name))
										fail('Field `\(name)` already exists', field)
									type.fieldNames.push(name)
									if (name == 'new') type.constructor = type.fieldNames.length - 1
									else type.fieldRenames[type.fieldNames.length - 1] = getRename(field)
									addScope(name, field)
								case Node.TVar(name, t, e, _):
									if (type.fieldNames.includes(name))
										fail('Field `\(name)` already exists', field)
									type.fieldNames.push(name)
									type.fieldInitialized[type.fieldNames.length - 1] = false
									type.fieldRenames[type.fieldNames.length - 1] = getRename(field)
									addScope(name, field)
								case Node.TProperty(field, _, _):
									switch (field) {
										case Node.TVar(name, _):
											if (type.fieldNames.includes(name))
												fail('Field `\(name)` already exists', field)
											type.fieldNames.push(name)
											addScope(name, field)
									}
								case Node.TStatic(f): switch (f) {
									case Node.TFunction(name, _):
										if (type.fieldNames.includes(name))
											fail('Field `\(name)` already exists', field)
										type.fieldNames.push(name)
										type.fieldStatic[type.fieldNames.length - 1] = true
										addScope(name, field)
									case Node.TVar(name, _):
										if (type.fieldNames.includes(name))
											fail('Field `\(name)` already exists', field)
										type.fieldNames.push(name)
										type.fieldStatic[type.fieldNames.length - 1] = true
										addScope(name, field)
								}
								case _:
									fail('Wrong class field format', field)
							}
							parents.set(field, node)
						}

						// Fill fields with non-ambiguous types
						for (field in f) switch (field) {
							// `var\let a: known T`
							case Node.TVar(name, t, e, const):
								if (let t = t) types.set(field, toType(t, field))
							// `function a(args with known types or no args): known ret type`
							case Node.TFunction(name, expr, vars, rettype):
								if (let rettype = rettype, vars.length == 0) {
									types.set(field, Type.Function([], toType(rettype, field)))
								}
						}

						// Fill expressions
						for (field in f) switch (field) {
							// Instance method
							case Node.TFunction(name, expr, vars, rettype):
								if (name == 'new') type.constructor = type.fieldNames.length - 1
								if (external, expr != null) {
									if (name == 'new')
										fail('External class constructor `new()` cannot have a body `{}`', field)
									else
										fail('External class method `function \(name)` cannot have a body `{}`', field)
								}
								let _insideClassMethod = insideClassMethod
								let _allowSuper = allowSuper
								insideClassMethod = true
								allowSuper = (extend != null)
								if (!external) fillFunction(field, expr, vars, rettype)
								if (external, types.get(field) == null) types.set(field, Type.Function([], rettype!=null? toType(rettype, field) : typeVoid))
								insideClassMethod = _insideClassMethod
								allowSuper = _allowSuper

							// Field of `var` or `let`
							case Node.TVar(name, t, e, const):
								if (external, e != null)
									fail('External class field `var \(name)` cannot have `= value`', field)
								let _insideClassMethod = insideClassMethod
								insideClassMethod = true
								if (e != null) fillExpression(e)
								insideClassMethod = _insideClassMethod
								mixVarTypes(t, e, field)
								type.fieldInitialized[type.fieldNames.indexOf(name)] = true
								if (types.get(field) == null) {
									fail('Field `var \(name)` initialized, but got no type '+e, field)
								}

							// The thing with getters and setters
							case Node.TProperty(f, _, _):
									switch (f) {
										case Node.TVar(name, t, e, const):
											if (external, e != null)
												fail('External class field `var \(name)` cannot have expression', field)
											let _insideClassMethod = insideClassMethod
											insideClassMethod = true
											if (e != null) fillExpression(e)
											insideClassMethod = _insideClassMethod
											mixVarTypes(t, e, f)
											type.fieldInitialized[type.fieldNames.indexOf(name)] = true
											if (types.get(f) == null) {
												fail('Property `\(name)` initialized, but got no type '+e, field)
											}
											types.set(field, types.get(f))
								}

							// `static f`
							case Node.TStatic(f): switch (f) {
								case Node.TFunction(name, expr, vars, rettype):
									if (external, expr != null)
										fail('External class field `static function \(name)` cannot have a body', field)
									let _insideClassMethod = insideClassMethod
									insideClassMethod = false
									if (!external) fillFunction(f, expr, vars, rettype)
									if (external) types.set(f, Type.Function([], rettype!=null? toType(rettype, f) : typeVoid))
									insideClassMethod = _insideClassMethod
									if (types.get(f) == null) fail('Function get no type: class ' + DataHelper.nameOf(node) + ' static ' + name, f)
									types.set(field, types.get(f))
								case Node.TVar(name, t, e, const):
									if (external, e != null)
										fail('External class field `static var \(name)` cannot have expression', field)
									if (e != null) fillExpression(e)
									mixVarTypes(t, e, f)
									types.set(field, types.get(f))
							}

							case _:
								fail('Wrong class field format', node)
						}

						popScope()
					case _:
						fail('ClassType expects (declare) class node, but got ' + node, node)
				}

				thisType = _thisType
				return type
			}
		}

		// `enum T {}`
		function registerEnumType(node: Node): Type {
			if (let type = types.get(node)) {
				switch (type) {
					// Avoid typing if already typed
					case Type.Enum(t): return t
				}
			} else {
				let type = new EnumType()
				type.parent = node
				type.name = DataHelper.nameOf(node)
				types.set(node, Type.Enum(type))

				var tag = 0

				switch (node) {
					case Node.TEnum(t, f, valuesType):
					pushScope()
					if (let valuesType = valuesType)
						type.fieldsTypeSimple = toType(valuesType, node)
					if (
						type.fieldsTypeSimple != null,
						type.fieldsTypeSimple != typeInt,
						type.fieldsTypeSimple != typeString
					) fail('Simple enums may be only of types `Int` and `String`', node)

					// Check for incompatible tag format and fill scopes
					for (field in f) {
						switch (field) {
							// `enum E { A }`
							case Node.NodeTypeValue(t): switch (t) {
								case NodeType.Type(name):
									if (type.fieldNames.includes(name))
										throw Typer.fail('Field `\(name)` already exists', node)
									type.fieldNames.push(name)
									type.fieldEnumConstructor[type.fieldNames.length - 1] = true
									type.tagBindVars[type.fieldNames.length - 1] = []
									type.tagBindVarsNames[type.fieldNames.length - 1] = []
									type.fieldType[type.fieldNames.length - 1] = Type.EnumInstance(type, tag++)
								case _:
									fail('Wrong enum constructor format, should be `Name`', node)
							}

							// `enum E { A(b: C) }`
							case Node.TCall(e, args, argNames):
								if (valuesType != null)
									throw Typer.fail('Cannot use `Value(args)` format for simple enum', node)
								switch (e) {
									case Node.NodeTypeValue(t): switch (t) {
										case NodeType.Type(name):
											if (type.fieldNames.includes(name))
												throw Typer.fail('Field `\(name)` already exists', node)
											type.fieldNames.push(name)
											type.fieldEnumConstructor[type.fieldNames.length - 1] = true
											type.fieldType[type.fieldNames.length - 1] = Type.EnumConstructor(type, tag++)
											let tagBindVars = []
											let tagBindVarsNames = []
											type.tagBindVars[type.fieldNames.length - 1] = tagBindVars
											type.tagBindVarsNames[type.fieldNames.length - 1] = tagBindVarsNames

											if (args.length == 0) fail('Enum constructor expects more than zero arguments `(value: Type)`', e)

											for (i in args.length) {
												if (argNames[i] == null)
													fail('Enum constructor arguments should have names `E(name1: T, name2: T)', args[i])
													tagBindVars[i] = nodeToNodeType(args[i])
													tagBindVarsNames[i] = argNames[i]
											}
										case _:
											fail('Wrong enum constructor format, should be `Name(value: T)`', e)
									}
								}

							// `enum E { A = b }`
							case Node.TBinop(a, op, b):
								if (op != Token.OpAssign)
									fail('Should use `Value = value` not `Value \(Token.stringify(op)) value` format for enum tag value', node)
								if (valuesType == null)
									fail('Cannot use `Value = value` format for complex enum', node)
								switch (a) {
									case Node.NodeTypeValue(t): switch (t) {
										case NodeType.Type(name):
											if (type.fieldNames.includes(name))
												fail('Field `\(name)` already exists', node)
											type.fieldNames.push(name)
											type.fieldEnumConstructor[type.fieldNames.length - 1] = true
											switch (b) {
												case Node.TInt(_): if (type.fieldsTypeSimple != typeInt)
													fail('`\(name) = value` expects constant value of type `\(Type.stringify(type.fieldsTypeSimple))`', b)
												case Node.TString(_): if (type.fieldsTypeSimple != typeString)
													fail('`\(name) = value` expects constant value of type `\(Type.stringify(type.fieldsTypeSimple))`', b)
												// TODO non-constant values
												// TODO other types
											}
											fillExpression(b)
											type.fieldType[type.fieldNames.length - 1] = types.get(b)
									}
								}

							// `enum E { a }`
							case Node.TIdent(name):
								fail('Cannot use lowercase `\(name)` format for enum values', node)

							// `enum E { static ... }`
							case Node.TStatic(f): switch (f) {
								case Node.TFunction(name, _):
									if (type.fieldNames.includes(name))
										fail('Field `\(name)` already exists', node)
									type.fieldNames.push(name)
									type.fieldStatic[type.fieldNames.length - 1] = true
									addScope(name, field)
								case Node.TVar(name, _):
									if (type.fieldNames.includes(name))
										fail('Field `\(name)` already exists', node)
									type.fieldNames.push(name)
									type.fieldStatic[type.fieldNames.length - 1] = true
									addScope(name, field)
							}

							case _:
								fail('Wrong enum field format', field)
						}

						parents.set(field, node)
					}

					// Fill expressions
					for (field in f) switch (field) {
						case Node.TFunction(name, expr, vars, rettype):
							fillFunction(field, expr, vars, rettype)
						case Node.TVar(name, _):
						case Node.TStatic(f): switch (f) {
							case Node.TFunction(name, expr, vars, rettype):
								let _insideClassMethod = insideClassMethod
								insideClassMethod = false

								// This weird hack, because of race condition
								// if function called within self
								if (rettype != null)
								types.set(f, Type.Function([], toType(rettype, f)))
								else
								types.set(f, Type.Function([], typeVoid))
								types.set(field, types.get(f))

								fillFunction(f, expr, vars, rettype)
								insideClassMethod = _insideClassMethod
								if (types.get(f) == null) fail('Function get no type: enum ' + DataHelper.nameOf(node) + ' static ' + name, f)
								types.set(field, types.get(f))
							case Node.TVar(name, t, e, const):
								if (e != null) fillExpression(e)
								mixVarTypes(t, e, f)
								types.set(field, types.get(f))
						}
						case Node.NodeTypeValue(_): // Ok
						case Node.TCall(_): // Ok
						case Node.TBinop(_): // TODO validate them
						case _:
							fail('Unknown enum field format', field)
					}
					popScope()
					case _:
						fail('EnumType expects (declare) enum node, but got ' + node, node)
				}

				return type
			}
		}

		static let never = '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.'

		static function fail(msg: String, node: Node = null): Void {
			let data = Project.data.get(node)
			if (data == null) {
				throw new CompilerError(Fail.TyperError, msg, 0, 0, "")
			}
			throw new CompilerError(Fail.TyperError, msg, data.line, data.column, data.fileName)
		}

		static function positionOf(node: Node) {
			let data = Project.data.get(node)
			if (data == null) return "[Unknown]: "
			return "[" + data.fileName + ":" + data.line + ":" + data.column + "]: "
		}

		static function nodeToNodeType(node: Node): NodeType switch (node) {
			case Node.TArray(el):
				if (el.length > 1) fail('Array type `[T]` cannot have more than 1 parameter `T`', el[1])
				return NodeType.ParametricType("Array", [nodeToNodeType(el[0])])
			case Node.NodeTypeValue(t):
				return t
			case Node.TObject(names, el):
				let types = [for (e in el) nodeToNodeType(e)]
				return NodeType.Object(names, types)
			case _:
				fail('Cannot nodeToNodeType of ' + Node.stringify(node), node)
		}

		// Takes only nodes valid for `module { node }`
		function nameOfModuleItem(node: Node): String {
			switch (node) {
				case Node.TVar(name, _): return name
				case Node.TFunction(name, _):
					if (let named = name) return named
					else throw 'Module function should have a name'
				case Node.TPrivate(node): switch (node) {
					case Node.TClass(t, _): switch (t) {
						case NodeType.Type(name): return name
						case NodeType.ParametricType(name): return name
					}
				}
				case Node.TClass(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TEnum(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TTypeAlias(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case _: fail('Improper module item format, wrap expressions as `{ expressions }`', node)
			}
		}

		function findInNamespaceRoots(name: String): Node? {
			if (namespaces.get(name) != null) return namespaces.get(name)
			var m = namespaces.get('')
			var el: [Node] = null as! [Node]
			switch (m) {
				case Node.TModule(_, els): el = els
				case _: return null // No root
			}
			for (e in el) if (name == nameOfModuleItem(e)) return e
			return null
		}

		// Scopes
		private let scopes: [[String : Node]] = [[:]]
		let parents: [Node : Node] = [:]
		private function pushScope() scopes.push(([:]))
		private function popScope() scopes.pop()
		private function addScope(name, node) scopes[scopes.length - 1].set(name, node)

		// Types
		private let types: [String : Type] = [:]
		private var typeString: Type? = null
		private var typeInt: Type? = null
		private var typeFloat: Type? = null
		private var typeBool: Type? = null
		private var typeArray: Type? = null // Type instantiators
		private var typeMap: ClassType = null as! ClassType // Type instantiators
		private var typeAny: Type? = null
		private var typeVoid: Type? = null
		private var namespaces: [String : Node] = [:]

		// Stack
		var functionAllowedToThrow = false // `true` if `@noThrow` is *not* set
		var functionThrows = false // `throw` is happened
		var insideTry = false // `try { insideTry } catch (...) { ... }`
		var insideFunction = false // `function () { insideFunction }`
		var allowBreakAndContinue = false // Used in loops
		var functionReturnsAType: Type? = null // `: T` is happened, or infer if `null`
		var functionActuallyReturns: Bool = false // `return something` is actually happened
		var insideClassMethod = false // `class T { function () { insideClassMethod } }` non-static!
		var allowSuper = false // `class T extends C { function () { super() } }` non-static!
		var thisType: Type = null as! Type // Current class

		// var to = from
		function unify(to: Type, fromValue: Type, node: Node): Type {
			// Short path
			if (to == fromValue) return to
			if (to == typeAny) return to
			if (fromValue == typeVoid)
				fail('Incompatible types `\(Type.stringify(to))` and non-value type `Void`', node)

			// `Int` is assignable to `Float`
			if (to == typeFloat, fromValue == typeInt) return typeFloat

			// Nullability
			function isNullable(t: Type): Bool {
				switch (t) {
					case Type.UnknownNullable(_): return true
					case Type.Nullable(_): return true
				}
				return false
			}

			function unwrapNullable(t: Type): Type {
				switch (t) {
					case Type.UnknownNullable(handle): return handle.value
					case Type.Nullable(t): return t
				}
				return t
			}

			function instanceOfClass(t: Type): ClassType? {
				switch (unwrapNullable(t)) {
					case Type.ClassInstance(t): return t
					case Type.Class(t):
						fail('Cannot take classes `class \(t.name)` as values', node)
				}
				return null
			}

			var toNullable = isNullable(to)
			var fromNullable = isNullable(fromValue)

			//if (fromNullable, !toNullable, Type.stringify)
			//	fail('Cannot assign nullable type `\(Type.stringify(fromValue))` to non-nullable `\(Type.stringify(to))`', node)

			var toInstance = instanceOfClass(to)
			var fromInstance = instanceOfClass(fromValue)
			if (toInstance == null || fromInstance == null) {
				return to ?? fromValue
			}

			if (toInstance != fromInstance, to != typeAny, fromValue != typeAny)
				fail('Incompatible types `\(Type.stringify(to))` and value of `\(Type.stringify(fromValue))`', node)

			return to ?? fromValue
		}

		function findType(name: String): Node? {
			for (i in scopes.length) {
				if (let subj = scopes[scopes.length - i - 1].get(name)) {
					return subj
				}
			}
			return findInNamespaceRoots(name)
		}

		function toType(t: NodeType, node: Node): Type {
			switch (t) {
				case NodeType.Type(name):
					let nodeType: Node = findType(name)
					if (types.get(nodeType) == null) switch (nodeType) {
						case Node.TClass(_): registerClassType(nodeType)
						case Node.TEnum(_): registerEnumType(nodeType)
					}
					switch (types.get(nodeType)) {
						case Type.Class(type):
							return type.instantiate()
						case Type.Enum(type):
							return types.get(nodeType)
						case null:
							if (name == 'T') return typeAny
							if (name == 'V') return typeAny
							if (name == 'K') return typeAny
							fail('Cannot find type `\(name)`', node)
						case _:
							fail('Unsupported type `\(name)`', node)
					}
				case NodeType.ParametricType(name, params):
					let nodeType: Node = findType(name)
					if (types.get(nodeType) == null) switch (nodeType) {
						case Node.TClass(_): registerClassType(nodeType)
						case Node.TEnum(_): registerEnumType(nodeType)
					}
					switch (types.get(nodeType)) {
						case Type.Class(type):
							return type.instantiateGeneric([for (p in params) toType(p, node)])
						case null:
							fail('Cannot find type `\(name)`', node)
						case _:
							fail('Unsupported type `\(name)`', node)
					}
				case NodeType.Optional(t):
					return Type.Nullable(toType(t, node))
				case NodeType.Function(args, ret):
					return Type.Function([for (arg in args) toType(arg, node)], toType(ret, node))
				case NodeType.Object(names, el):
					let els = [for (e in el) toType(e, node)]
					return Type.Struct(names, els)
				case _:
					fail('Unsupported node type ' + t + never, node)
			}
		}

		// `var node: NodeType = e`
		function mixVarTypes(t: NodeType?, e: Node?, node: Node) {
			if (t != null, e != null) types.set(node, unify(toType(t, node), types.get(e), e))
			if (t == null, e != null) types.set(node, types.get(e))
			if (t == null, e == null) types.set(node, Type.UnknownNullable({value: null}))
			if (t != null, e == null) types.set(node, toType(t, node))
		}

		// Uses idea of stacks to track nested function behavior
		private function fillFunction(node, expr, vars: [Node], rettype, arrow: Bool = false): Void {
			pushScope()
			// Save stack
			let _insideFunction = insideFunction
			let _functionAllowedToThrow = functionAllowedToThrow
			let _functionThrows = functionThrows
			let _functionReturnsAType = functionReturnsAType
			let _functionActuallyReturns = functionActuallyReturns
			let _insideTry = insideTry

			for (i in vars.length) {
				let v = vars[i]
				switch (v) {
					case Node.TVar(vname, t, e, const):
						if (t != null, toType(t, v) == typeVoid)
							fail('Argument cannot be of type `Void`', v)
						if (e != null) fillExpression(e)
						if (t != null) types.set(v, toType(t, v))
						addScope(vname, v)
				}
			}

			// Reset stack
			var ret: Type? = null // TODO = if (let)
			if (let rt = rettype) ret = toType(rt, node)
			functionReturnsAType = ret
			functionActuallyReturns = false

			let atts = Project.mapAttributes.get(node)

			if (let noThrow = DataHelper.getAttribute(atts, 'noThrow')) {
				if (noThrow.values.length > 0) fail('Attribute `@noThrow` should have no parameters', node)
				functionAllowedToThrow = false
			} else functionAllowedToThrow = true

			if (let throws = DataHelper.getAttribute(atts, 'throws')) {
				if (functionAllowedToThrow == false) fail('Attribute `@noThrow` cannot be used with `@throws`', node)
				functionThrows = true
			} else functionThrows = false

			insideFunction = true
			insideTry = false

			if (arrow, expr != null) fillExpression(expr)
			if (!arrow, expr != null) fill(expr)
			popScope()

			ret = functionReturnsAType // Inferred
			if (ret == null) ret = typeVoid
			if (ret != typeVoid, expr != null, functionActuallyReturns == false)
				fail('Function expects result of `\(Type.stringify(ret))` but never does `return value`', node)

			// Restore stack
			insideFunction = _insideFunction
			functionReturnsAType = _functionReturnsAType
			functionActuallyReturns = _functionActuallyReturns

			// Set function type
			types.set(node, Type.Function(args: [for (v in vars) types.get(v)], returns: ret, lazyTypeCheck: node))
		}

		// Syntax tree traverse
		private function fill(node: Node): Void {
			switch (node) {
				// Types
				// **Note:** supports types *not* placed into `module`s

				// `class T {}`
				case Node.TClass(t, extend, implement, f, external):
					addScope(DataHelper.extractTypeName(t), node)
					registerClassType(node)

				// `enum T {}`
				case Node.TEnum(t, f, valuesType):
					addScope(DataHelper.extractTypeName(t), node)
					registerEnumType(node)

				// `declare A = T`
				case Node.TTypeAlias(alias, value):
					types.set(node, Type.Alias(null))
					addScope(nameOfModuleItem(node), node)

				// Statements do not return value

				// `var a = e, b: T, c`
				case Node.TVars(e):
					for (ee in e) fill(ee)

				// `{...}`
				case Node.TBlock(el):
					pushScope()
					for (e in el) fill(e)
					popScope()

				// `var name: t = e`
				case Node.TVar(name, t, e, const, external):
					if (e == null, const, !external)
						fail('Constant should have a value `let \(name) = value`', node)
					if (e != null, external)
						fail('External variable should not have a value `declare let \(name)`', node)
					if (t == null, external)
						fail('External variable should have a type `declare let \(name): T`', node)
					if (e != null) {
						pushScope()
						fillExpression(e)
						popScope()
					}

					mixVarTypes(t, e, node)

					addScope(name, node)

				// `a op b` like `a + b`
				case Node.TBinop(a, op, b):
					fillExpression(a)
					fillExpression(b)

					var parent: Node = parents.get(a)
					// `a = b`
					if (op == Token.OpAssign) switch (parent) {
						case null:
						case Node.TVar(name, _, _, const):
							if (const)
								fail(
									'Cannot reassign a constant `let \(name)`, redefine it as `var \(name)` to allow reassignment\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							types.set(node, unify(types.get(a), types.get(b), b))
						case Node.TIdent(name):
							fail('Cannot reassign case parameter `\(name)`', node)
						case Node.TFunction(name, _):
							fail('Cannot reassign a function `\(name)`', node)
						case Node.TClass(_):
							fail('Cannot reassign class', node)
						case Node.TEnum(_):
							fail('Cannot reassign enum', node)
						case Node.TFor(name, _):
							fail(
								'Cannot reassign iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for (\(name) in ...)` is defined here',
							node)
						case Node.TStatic(_):
						case Node.TSuper(_):
							fail('Cannot reassign `super`', node)
						case _:
							fail('`=` not implemented for: ' + parent, node)
					}

				// `break`
				case Node.TBreak:
					if (!allowBreakAndContinue)
						fail('Cannot use `break` outside of loop', node)

				// `for (name in over ... range) { by }`
				case Node.TFor(name, over, by, range):
					pushScope()
					fillExpression(over)
					switch (types.get(over)) {
						case Type.ClassInstance(type, generic):
							// Extract Array<T>
							if (generic != null, generic.length == 1) types.set(node, generic[0])
							else if (generic == null) {
								types.set(node, types.get(over))
							}
							else {
								fail('Type of iterable is neither Int nor Array '+Type.stringify(types.get(over)), over)
							}
						case Type.UnknownNullable(_):

						case null:
						case _:
							fail('Type of iterable is neiter Int nor Array', over)
					}
					if (let range = range) {
						fillExpression(range)
						// Ranges always integer for now
						types.set(node, toType(NodeType.Type("Int"), node))
					}
					addScope(name, node)
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					fill(by)
					allowBreakAndContinue = _allowBreakAndContinue
					popScope()

				// `function name(vars): rettype {expr}`
				// `vars` are `TVar(name, t, ...)` where `function(name: t)`
				case Node.TFunction(name, expr, vars, rettype, external):
					if (!external, expr == null)
						fail('Non-external function `\(name)` should have a body', node)
					if (external, rettype == null)
						fail('External function `\(name)` should have a returning type', node)
					addScope(name, node)
					fillFunction(node, expr, vars, rettype)
					if(false){

					// Save stack
					let _insideFunction = insideFunction
					// Reset stack
					insideFunction = true
					pushScope()
					if (expr != null) fill(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction

				}

				// `if (econd) eif else eelse`
				// `if (econd) eif`
				// Also `if (let bind = value, econd..., econd...)`
				case Node.TIf(econd, eif, eelse):
					var depth = 0
					for (e in econd) {
						switch (e) {
							case Node.TVar(name, t, expr, const):
								if (!const)
									fail('Only if-let bindings supported, not if-var', node)
								if (t != null)
									fail('Do not specify a type `: T` in if-let bindings', node)
								if (expr == null)
									fail('if-let binding should have a value `\(name) = value', node)
								depth++
								pushScope()
								pushScope()
								fillExpression(expr)
								popScope()
								switch (types.get(expr)) {
									case Type.Nullable(t): types.set(e, t)
									case _: types.set(e, types.get(expr))
								}
								addScope(name, e)
							case _:
								fillExpression(e)
								// Only Bool allowed
								let type = types.get(e)
								if (type != typeBool, type != typeAny, type != null)
									fail('`if (value)` expects `value` only of type `Bool`, but got `' + Type.stringify(types.get(e)) + '`', e)
						}
					}
					fill(eif)
					while (depth > 0) {
						depth--
						popScope()
					}

					if (eelse != null) fill(eelse)

				// `switch (exprs) { case conds if (guards): { cases } }`
				case Node.TSwitch(exprs, conds, guards, cases):
					fillSwitch(node, false)

				// `try { } catch (e: T) { }`
				case Node.TTry(e, t, v, ca):
					// Save stack
					let _insideTry = insideTry
					// Reset stack
					insideTry = true
					fill(e)
					// Restore stack
					insideTry = _insideTry

					for (i in ca.length) {
						let type = toType(t[i], ca[i])
						switch (type) {
							case Type.Struct(_):
								fail('Catch type must be a specific class, not `{}`', ca[i])
							case Type.Function(_):
								fail('Catch type must be a specific class, not function', ca[i])
						}
						types.set(t[i], type)
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						fill(ca[i])
						popScope()
					}

				// `while (econd) e` if pre == true
				// `do e while (econd)` if pre == false
				case Node.TWhile(econd, e, pre):
					if (pre == true) fillExpression(econd)
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					fill(e)
					allowBreakAndContinue = _allowBreakAndContinue
					if (pre == false) fillExpression(econd)
					types.set(node, typeVoid)

				// `continue`
				case Node.TContinue:
					types.set(node, typeVoid)
					if (!allowBreakAndContinue)
						fail('Cannot use `continue` outside of loop', node)

				// Expressions and errors
				case _:
					fillExpression(node)
			}
		}

		// Expressions return values
		function fillExpression(node) {
			switch (node) {
				// Just `name`
				case Node.TIdent(name):
					var subj = null
					for (i in scopes.length) {
						subj = scopes[scopes.length - i - 1].get(name)
						if (subj != null) {
							break
						}
					}

					if (subj == null) subj = findInNamespaceRoots(name)
					if (subj == null, name == 'const')
						fail('No variable named `const` found. Are you trying to use `const` as a keyword? Use `let varname` syntax instead.', node)
					if (subj == null)
						fail('Cannot find variable with name `\(name)`', node)
					if (parents.get(node) != null, parents.get(node) != subj)
						fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
					parents.set(node, subj)
					if (let type = types.get(subj)) {
						types.set(node, type)
					}


				// `(args)=>{expr}`
				case Node.TArrow(expr, vars, rettype):
					fillFunction(node, expr, vars, rettype, arrow: true)
					if(false){
					pushScope()
					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true
					fillExpression(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				}

				// `function name(vars): rettype {expr}`
				case Node.TFunction(name, expr, vars, rettype, external):
					if (external)
						fail('External function `declare function \(name)` cannot be taken as a value', node)

					fillFunction(node, expr, vars, rettype)

					if(false){
					pushScope()
					addScope(name, node)

					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true

					if (expr != null) fill(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				}

				// `[a,b,c]`
				case Node.TArray(el):
					// `[for(name in over ... range) by]`
					switch (el[0]) {
						case Node.TFor(name, over, by, range):
							if (el.length > 1)
								fail('Cannot use loop `for` within array of more than one element `[for(), ...]`', el[1])
							if (range != null)
								fail('Ranges `...range` are not supported here yet', range)

							pushScope()
							fillExpression(over)
							types.set(el[0], types.get(over))
							addScope(name, el[0])
							let _allowBreakAndContinue = allowBreakAndContinue
							allowBreakAndContinue = false
							fillExpression(by)
							allowBreakAndContinue = _allowBreakAndContinue
							popScope()

							types.set(node, typeArray.instantiateGeneric([types.get(by)]))
						case _:
							for (e in el) fillExpression(e)
							types.set(node, typeArray.instantiateGeneric([types.get(el[0])]))
					}

				// `[k:v, k:v]`
				case Node.TMap(keys, values):
					if (keys.length == 0) {
						types.set(node, typeMap.instantiateGeneric([
							Type.Unknown({value: null}),
							Type.Unknown({value: null})
						]))
						return
					}
					for (i in keys.length) {
						fillExpression(keys[i])
						fillExpression(values[i])
					}
					types.set(node,
						typeMap.instantiateGeneric([types.get(keys[0]), types.get(values[0])])
					)

				// `e as  t`
				// `e as! t`
				// `e as? t`
				case Node.TAs(e, kind, t):
					let type = toType(t, node)
					if (type == typeVoid)
						fail('Conversion `as Void` makes no sense', e)
					fillExpression(e)
					if (types.get(e) == typeVoid)
						fail('Conversion of `value as \(Type.stringify(t))` where `value` is of type `Void` makes no sense', e)
					types.set(t, type)
					types.set(node, type)

				// `e is t`
				case Node.TIs(e, t):
					let type = toType(t, node)
					if (type == typeAny)
						fail('Comparing `is Any` makes no sense, always true', e)
					if (type == typeVoid)
						fail('Comparing `is Void` makes no sense', e)
					fillExpression(e)
					types.set(t, type)
					types.set(node, typeBool)

				// `{...}`
				case Node.TBlock(el):
					if (el.length == 0) {
						types.set(node, Type.Struct([], []))
					} else {
						pushScope()
						for (i in el.length) if (i < el.length - 1) {
							fill(el[i])
						}
						let latest = el[el.length - 1]
						fillExpression(latest)
						types.set(node, types.get(latest))
						popScope()
					}

				// `e.n`
				case Node.TDot(e, n):
					switch (e) {
						case Node.TSuper(_):
							if (!allowSuper)
								fail('Cannot access `super` here', node)
						case _:
							fillExpression(e)
					}
					if (let etype = types.get(e)) switch (etype) {
						case Type.ClassInstance(type): // Non-static fields
							type.useless = false
							if (etype == typeAny) {
								types.set(node, typeAny)
								return
							}
							let index = type.fieldNames.indexOf(n)
							if (index < 0)
								fail('Class `\(nameOfModuleItem(type.parent))` has no field `.\(n)`\nAvailable fields are: ' + type.fieldNames.join(', '), e ?? node)
							if (type.fieldStatic[index] == true)
								fail('Class `\(nameOfModuleItem(type.parent))` field `.\(n)` is static', node)
							switch (type.parent) {
								case Node.TClass(t, extend, implement, fields, external):
									registerClassType(type.parent)
									for (field in fields)
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
											if (types.get(field) == null) {
												console.log(positionOf(node) + 'Note: field fieldInitialized[\(n)] =', type.fieldInitialized[type.fieldNames.indexOf(n)])
												fail('Type for this field is null: ' + n, field)
											}
										}
								case _:
									fail(type.parent, type.parent)
							}
						case Type.Class(type): // Static fields
							type.useless = false
							let index = type.fieldNames.indexOf(n)
							if (index < 0)
								fail('Class `\(nameOfModuleItem(type.parent))` has no static field `.\(n)`\nAvailable fields are: ' + type.fieldNames.join(', '), node)
							if (type.fieldStatic[index] != true)
								fail('Class `\(nameOfModuleItem(type.parent))` field `.\(n)` is not static', node)
							switch (type.parent) {
								case Node.TClass(t, extend, implement, fields, external):
									for (field in fields)
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
										}
								case _:
									fail(type.parent, type.parent)
							}
						case Type.Enum(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0)
								fail('Enum `\(type.name)` has no field `.\(n)`', node)
							if (type.fieldStatic[index] != true)
								fail('Enum field `.\(n)` is not static', node)
							switch (type.parent) {
								case Node.TEnum(t, fields, valuesType):
									for (field in fields) switch (field) {
										case Node.TCall(_):
										case Node.NodeTypeValue(_):
										case Node.TBinop(_):
										case _:
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
										}
									}
								case _:
									fail(type.parent, type.parent)
							}
						case Type.Struct(names, els):
							let index = names.indexOf(n)
							if (index < 0) {
								var object = ''
								switch (e) {
									case Node.TIdent(name): object = ' `\(name)`' // Note a space after '
									case _: {}
								}

								if (names.length == 0)
									fail('Object\(object) is empty `{}` and has no fields. Create object with all fields defined upfront, like this: `obj = { \(n): value }`', node)
								if (names.length != 0)
									fail('Object\(object) has no field `.\(n)`\nAvailable fields are: ' + names.join(', '), node)
							}
							types.set(node, els[index])
						case null:
						case _:
					}// else fail('Got node without type `\(e)`' + never, node)

				// `e.N`
				case Node.TDotUpper(e, n):
					switch (e) {
						case Node.TSuper(_):
							fail('Cannot access `super` here', node)
					}
					fillExpression(e)
					switch (types.get(e)) {
						case Type.Class(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0)
								fail('Class has no field `.\(n)`', node)
							if (type.fieldStatic[index] != true)
								fail('Class field `.\(n)` is not static', node)
						case Type.Enum(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0)
								fail('Enum has no value constructor `.\(n)`\n' + proposeSimilar(type.fieldNames.filter((element, index) => type.fieldEnumConstructor[index]), n, 'constructors'), node)
							if (type.fieldEnumConstructor[index] != true)
								fail('Enum field `.\(n)` is not a value constructor', node)
							if (let fieldType = type.fieldType[index])
								types.set(node, fieldType)
							else fail('Enum field type is null for `\(Node.stringify(node))`', node)
						case null:
							fail('Doing .Upper `\(Node.stringify(node))` over `\(Node.stringify(e))` (\(e)) of type null', node)
						case _:
					}// else fail('Got node without type `\(e)`' + never, node)

				// `T` or `T<G>`
				case Node.NodeTypeValue(t): switch (t) {
					case NodeType.Type(name):
						let subj = find(name)
						if (subj == null)
							fail('Cannot find type with name `\(name)`', node)
						if (parents.get(node) != null, parents.get(node) != subj)
							fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
						parents.set(node, subj)
						if (let type = types.get(subj)) {
							types.set(node, type)
						} else {
							// Try eager on-demand type build
							switch (subj) {
								case Node.TClass(_): registerClassType(subj)
								case Node.TEnum(_): registerEnumType(subj)
							}

							if (let type = types.get(subj)) {
								types.set(node, type)
							} else {
								console.log(positionOf(subj) + '\(name) is here')
								fail('Cannot find type for `\(name)` even after late build' + never, node)
							}
						}
					case NodeType.ParametricType(name, _):
						fail('Cannot use generic type `\(name)` as a value', node)
					case _:
						fail('Cannot use this type as a value', node)
				}

				// `new T {names:values} ()`
				case Node.TNew(path, t, el, names, values):
					let type = toType(t, node)
					let subj = find(DataHelper.extractTypeName(t))
					parents.set(node, subj)
					for (e in el) fillExpression(e)
					switch (type) {
						case Type.ClassInstance(type):
							if (type.constructor == -1)
								fail('Cannot construct class without `new () {}` constructor', node)
							type.useless = false
						case _:
							fail('Constructor `new` may instantiate only classes', node)
					}

					types.set(node, type)

				// `{names:el, ...}`
				case Node.TObject(names, el):
					for (name in names.length)
						if (names.indexOf(names[name]) != name)
							fail('Field `\(names[name])` already exists', node)

					for (e in el) fillExpression(e)
					let els = [for (e in el) types.get(e)]
					types.set(node, Type.Struct(names, els))

				// `try { ... value } catch (e: T) { ... value }`
				case Node.TTry(e, t, v, ca):
					// Save stack
					let _insideTry = insideTry
					// Reset stack
					insideTry = true
					fillExpression(e)
					// Restore stack
					insideTry = _insideTry

					for (i in ca.length) {
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						fill(ca[i])
						popScope()
					}
					types.set(node, types.get(e))

				// `if (econd) eif else eelse`
				case Node.TIf(econd, eif, eelse):
					if (econd.length > 1)
						fail('More than one condition is not yet supported', econd[1])
					switch (econd[0]) {
						case Node.TVar(_):
							fail('Variable bindings in ternary conditions are not yet supported', econd[0])
					}
					if (eelse == null)
						fail('Expression `if` should have an `else` clause', eif)
					fillExpression(econd[0])
					fillExpression(eif)
					fillExpression(eelse)
					types.set(node, unify(types.get(eif), types.get(eelse), eelse))

				// Simple nodes
				case Node.TNull:
					types.set(node, Type.UnknownNullable({value:null}))

				case Node.TString(_):
					types.set(node, typeString)

				case Node.TBool(_):
					types.set(node, typeBool)

				case Node.TInt(_):
					types.set(node, typeInt)

				case Node.TFloat(_):
					types.set(node, typeFloat)

				// `(e)`
				case Node.TParenthesis(e):
					fillExpression(e)
					types.set(node, types.get(e))

				// `a ?? b`
				case Node.TElvis(a, b):
					fillExpression(a)
					fillExpression(b)
					unify(types.get(a), types.get(b), b)
					types.set(node, types.get(b))

				// `e(elNames: el, ...)`
				case Node.TCall(e, el, elNames):
					// JavaScript evaluates arguments first
					switch (e) {
						case Node.TSuper(_):
							if (!allowSuper)
								fail('Cannot access `super` here', node)
						case _:
				 			fillExpression(e)
				 	}
					for (e in el) fillExpression(e)
				 	switch (types.get(e)) {
				 		case Type.Function(args, returns):
				 			for (i in el.length) if (let arg = args[i]) {
				 				unify(arg, types.get(el[i]), el[i])
				 			}
				 			types.set(node, returns)
				 		case Type.EnumConstructor(type, tag):
				 			types.set(node, Type.EnumInstance(type, tag))
				 		case null:
				 			//fail('Calling null ' + Node.stringify(e), e)
				 		case _:
				 			if (types.get(e) == typeAny) {
				 				types.set(node, typeAny)
				 			} else
				 			fail('Calling *not* a function, type is `' + Type.stringify(types.get(e)) + '`', e)
				 	}

				// `a op b` like `a + b`
				case Node.TBinop(a, op, b):
					fill(a)
					fillExpression(b)

					// Anything + String = String
					if (op == Token.OpAdd, types.get(a) == typeString)
						types.set(node, types.get(a))
					else
					// Always provides boolean result
					if (
						op == Token.OpGte ||
						op == Token.OpGt ||
						op == Token.OpLte ||
						op == Token.OpLt ||
						op == Token.OpBoolAnd ||
						op == Token.OpBoolOr ||
						op == Token.OpEq ||
						op == Token.OpNotEq
					) types.set(node, typeBool)
					else
					types.set(node, types.get(b) ?? types.get(a))

				// `op e` or `e op`
				case Node.TUnop(op, postfix, e):
					fillExpression(e)

					// Always provides boolean result
					if (op == Token.OpNot, !postfix) {
						let type = types.get(e)
						if (type != typeBool, type != typeAny, type != null)
							fail('Operator `!value` takes `value` of type `Bool` only, but got `\(Type.stringify(types.get(e)))`', e)
						types.set(node, toType(NodeType.Type("Bool"), node))
						return
					}

					types.set(node, types.get(e))

					let mutates = op == Token.OpIncrement || op == Token.OpDecrement
					if (!mutates) { return }
					var parent: Node = parents.get(e)
					switch (parent) {
						case Node.TVar(name, _, _, const):
							if (const)
								fail(
									'Cannot change a constant `let \(name)`, redefine it as `var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
						case Node.TFunction(name, _):
							fail('Cannot `\(Token.stringify(op))` a function `\(name)`', node)
						case Node.TFor(name, _):
							fail(
								'Cannot change iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for (\(name) in ...)` is defined here',
							node)
						case _: // Ok
					}


				// `e[i]`
				case Node.TIndex(e, i):
					fillExpression(e)
					fillExpression(i)

					// For now, only Int & Any index supported
					var indexableIsAny = false
					switch (types.get(e)) {
						case Type.ClassInstance(type, generic):
							if (type.name == 'Any') indexableIsAny = true
					}

					if (!indexableIsAny)
					switch (types.get(i)) {
						case Type.ClassInstance(type):
							if (type.name != 'Int', type.name != 'Any')
								fail('`value[i]` expects `i` only of type `Int`, but got `' + Type.stringify(types.get(i)) + '`', e)
						case _:
							fail('`value[i]`????? expects `i` only of type `Int`, but got `' + Type.stringify(types.get(i)) + '`', e)
						case null:
					}

					// For now, only Array[i] supported
					switch (types.get(e)) {
						case Type.ClassInstance(type, generic):
							if (generic != null, generic.length == 1) types.set(node, generic[0])
							else if (['Array','Buffer','Uint8Array','Uint32Array'].includes(type.name)) types.set(node, toType(NodeType.Type("Int"), node))
							else if (['Any'].includes(type.name)) types.set(node, toType(NodeType.Type("Any"), node))
							else fail('value[i] generic is null or >1', e)
						case _:
						case null:
					}

				// `a op= b`
				case Node.TAssignop(a, op, b):
					// `===`
					if (op == Token.OpEq)
						fail('`===` not supported, use `strictEqual`', node)
					// `!==`
					if (op == Token.OpEq)
						fail('`!==` not supported, use `strictNotEqual`', node)

					fillExpression(a)
					var parent: Node = parents.get(a)
					switch (parent) {
						case Node.TVar(name, _, _, const):
							if (const)
								fail(
									'Cannot change a constant `let \(name)`, redefine it as `var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
						case Node.TFunction(name, _):
							fail('Cannot reassign a function `\(name)`', node)
						case Node.TFor(name, _):
							fail(
								'Cannot change iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for (\(name) in ...)` is defined here',
							node)
						case _: // Ok
					}
					fillExpression(b)
					types.set(node, unify(types.get(a), types.get(b), b))

				// `throw e`
				case Node.TThrow(e):
					if (!insideFunction && !insideTry)
						fail('Cannot throw outside of `function` or `try`', node)
					if (insideFunction && !functionAllowedToThrow)
						fail('Cannot throw in a @noThrow function', node)
					if (insideFunction)
						functionThrows = true // Infer that function throws
					fillExpression(e)

				// `this`
				case Node.TThis:
					if (!insideClassMethod)
						fail('Cannot access `this` outside of class method', node)
					types.set(node, thisType)

				// `super`
				case Node.TSuper(_):
					fail('Cannot use `super` as value', node)

				// `return e`
				case Node.TReturn(e):
					switch (e) {
						case Node.TVar(name, _, _, const):
							let prefix = const? 'let' : 'var'
							fail('This `return` tries to return a variable `\(prefix) \(name)`. Try to wrap it into braces like this `{ return } \(prefix) \(name)`', node)
						case Node.TReturn(_):
							fail('Cannot return another return. Try to wrap first `{ return } return 2` into braces', node)
					}
					if (!insideFunction)
						fail('Cannot use `return` outside of function', node)
					if (e != null) {
						if (functionReturnsAType == typeVoid)
							fail('Function returns `Void`, cannot return a value here', e)
						fillExpression(e)
						let ret = types.get(e)
						if (ret == typeVoid)
							fail('Cannot `return` a `Void` non-value', node)
						functionReturnsAType = unify(functionReturnsAType, ret, e)
						functionActuallyReturns = true
					} else {
						if (let ret = functionReturnsAType) {
							if (ret != typeVoid)
								fail('Expected `return value` of type `\(Type.stringify(ret))`', node)
						} else functionReturnsAType = typeVoid
					}

				// Errors
				case Node.TUnderscore:
					fail('Cannot use underscore `_` outside of case pattern', node)
				case Node.TExport(_):
					fail('Cannot use `export` here: only applicable to module declarations', node)
				case Node.TStatic(_):
					fail('Cannot use `static` here: only applicable to class fields', node)
				case Node.TPrivate(_):
					fail('Cannot use `private` here: only applicable to class fields and module declarations', node)
				case Node.TModule(_):
					fail('Modules should be at a file\' upper scope', node)

				// Not expressions
				case Node.TBreak:
					fail('Cannot use `break` as a value', node)
				case Node.TContinue:
					fail('Cannot use `continue` as a value', node)
				case Node.TClass(_):
					fail('Cannot use `class` as a value', node)
				case Node.TEnum(_):
					fail('Cannot use `enum` as a value', node)
				case Node.TTypeAlias(_):
					fail('Cannot use `declare` as a value', node)
				case Node.TVar(name, _, _, const):
					let prefix = const? 'let' : 'var'
					fail('Cannot use `\(prefix) \(name)` as a value', node)
				case Node.TSwitch(_):
					fillSwitch(node, true)
				case Node.TWhile(_):
					fail('Cannot use `while` as a value', node)
				case Node.TFor(_):
					fail('Cannot use `for` as a value. To build array from loop, surround with `[for()]` brackets.', node)

				// Fails
				case null:
					fail('Got null node' + never, node)
				case _:
					fail('Unknown node expression kind to type ' + node + never, node)
			}
		}

		function fillSwitch(node, value: Bool) {
			switch (node) {
				case Node.TSwitch(exprs, conds, guards, cases):
					for (e in exprs) { pushScope() fillExpression(e) popScope() }
					if (let expr = exprs[1])
						fail('Multiple switch values are not yet supported', expr)

					// TODO guards
					// let expr = if (let expr = exprs[0]) expr else return
					// @guard let expr = exprs[0]
					// Node.TMacroExpansion <- for simple debug and print of
					// result of evaluated syntax @macro

					// TODO exprs is a positive array like
					// : [T, 1 ...] 1 or more elements, so [0] != don't require null check

					// TODO error on not-all-matched patterns of enum by default,
					// but @hint makes it only a hint and @ok to ignore

					var i = 0
					while (i < cases.length) {
						pushScope()
						var e = conds[i]
						// Fill case condition `case pattern:`
						var currentType = null
						var currentTag = null
						var currentTagBind = 0
						function follow(e: Node) {
							switch (e) {
								case Node.TDotUpper(ex, name):
									fillExpression(e)
									switch (types.get(ex)) {
										case Type.Enum(type):
											currentType = type
											currentTag = name
									}
								case Node.TParenthesis(e): {fill(e)}
								// `case _:` default case
								case Node.TUnderscore: {}

								// TODO error on complex enums
								case Node.TNull: {}
								case Node.TBool(_): {}
								case Node.TInt(_): {}
								case Node.TString(_): {}
								case Node.TCall(ex, args, argNames): {
									// TODO rethink nested pattern mechanics
									// TODO don't follow nested patterns for now
									follow(ex)
									currentTagBind = 0

									for (ee in args) switch (ee) {
										case Node.TIdent(name):
											follow(ee)
											currentTagBind++
										case Node.TUnderscore:
											currentTagBind++
										case _:
											fail('This case pattern is not supported', e)
									}
								}
								case Node.TIdent(name): // Bind (var)
								{
									if (name.charAt(0) == name.charAt(0).toUpperCase()) {fill(e)}
									else {
										addScope(name, e)

										// Find tag bind var and set it's type:
										if (let currentType = currentType) {
											let indexOf = currentType.fieldNames.indexOf(currentTag)
											if (indexOf == -1) fail('currentType.fieldNames.indexOf == -1', e)
											let type = currentType.tagBindVars[indexOf][currentTagBind]
											let name = currentType.tagBindVarsNames[indexOf][currentTagBind]
											if (name == null) {
												let available = currentType.tagBindVarsNames[indexOf].join(', ')
												if (available.length == 0)
													fail('No bindings available for `.' + currentTag + '`', e)
												fail('Too many bindings requested for `.\(currentTag)`, available are: ' + available, e)
											}
											if (type != null) {
												types.set(e, toType(type, e))
											}
											else fail('tagBindVars no type for ' + name, e)
										} else {
											fail('No currentType for '+name, e)
										}
									}
								}
								case Node.TBinop(a, op, b):
								if (op == Token.OpOr) {follow(a) follow(b)}
								else fail('This case pattern is not supported', e)
								case Node.TIf(econd, _, _):
									pushScope()
									fill(econd[0])
									popScope()
								case _:
									fail('This case pattern is not supported', e)
							}
						}
						follow(e)
						// Fill case result expression
						var e = cases[i]
						pushScope()
						if (value == false) fill(e)
						if (value == true) {
							fillExpression(e)
							if (types.get(node) == null) types.set(node, types.get(e))
							else types.set(node, unify(types.get(node), types.get(e), e))
						}
						popScope()

						popScope()
						i++
					}
			}
		}
	}
