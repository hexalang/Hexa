// The Hexa Compiler
// Copyright (C) 2019  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

module
	// Generates C++ with at least C++11 standard
	class GenCxx {
		static function spawn() {
			return new GenCxx()
		}
		new () {}
		function perform(normalizer): String {
			project = normalizer
			return stringify()
		}

		let globalAccessor = ''
		var project: NiceProject
		var declarationsOfFunctions: [String] = []
		var declarationsOfOpaqueTypes: [String] = []
		var declarationsOfFullTypes: [String] = []
		/// Mapping of original strings (optimization)
		var declarationsOfStringsMap: [String : Int] = [:]
		var declarationsOfStrings: [String] = []

		function stringify() {
			// Contains forward declarations
			let header = ['// Generated by Hexa \(version) https://hexalang.github.io']
			if (project.package.addLicenseNoticeToOutput) {
				// rename addLicenseNoticeToOutput
				header.push('// \(project.package.name)')
				header.push('// LICENSE \(project.package.license)')
			} else {
				header.push('// The generated code is subject to the original license')
			}
			header.push(Fs.readFileSync(__dirname + '/library/cxx/hexa.cpp').toString('utf8').split('\r\n').join('\n'))
			header.push('#ifdef __cplusplus')
			header.push('extern "C" {')
			header.push('#endif')


			let out: [String] = []
			let forward: [String] = []
			let forwardFunctions: [String] = []
			let types: [String] = []

			// Strings
			registerString('') // id == 0
			declarationsOfStringsMap.set('', 0)
			registerString('null') // id == 1
			declarationsOfStringsMap.set('null', 1)

			// Types
			for (e in project.enumsSimple) {
				// No need to output simple enum values
				forward.push('struct ' + e.name + '_;')
				if (e.staticVars.length + e.staticMethods.length == 0) continue
				types.push('struct ' + e.name + '_ {\n\t')

				for (v in e.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						out.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
					case NiceStatement.Const(name, expr, type):
						out.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
				}

				types.push('\n};\n')

				for (v in e.staticMethods) switch (v) {
					case NiceStatement.Function(name, expr, args, defaults, funcType):
						forwardFunctions.push(printFunctionReturnType(funcType))
						forwardFunctions.push(' ' + e.name + '_$' + name + '_')
						forwardFunctions.push(printFunctionArguments(args, funcType))
						forwardFunctions.push(';\n')

						out.push(printFunctionReturnType(funcType))
						out.push(' ' + e.name + '_$' + name + '_')
						out.push(printFunctionArguments(args, funcType))
						let _currentReturnType = currentReturnType
						currentReturnType = getFunctionReturnType(funcType)
						out.push(' ' + printBlock(expr) + ';\n')
						currentReturnType = _currentReturnType
				}
			}

			for (e in project.enumsComplex) {
				forward.push('struct ' + e.name + '_;')
				types.push('struct ' + e.name + '_ {\n\t')
				types.push('\n\tAny_** enum_;') // Enum.Name(enum_...)
				types.push('\n\tuint16_t is_;')
				types.push('\n\tuint8_t length_;') // Amount of enum_[] to dealloc

				var i = 0
				for (name in e.names) {
					if (e.constructors[i] != null) {

						out.push(e.name + '_* ' + e.name + '_$' + name + '_(')
						out.push([for (c in e.constructors[i].length)
							stringifyType(e.constructorsTypes[i][c]) + ' ' + e.constructors[i][c] + '_'
						].join(', '))
						out.push(') {\n')
						out.push('\t' + e.name + '_* _ = (' + e.name + '_*)(malloc(sizeof(' + e.name + '_)));\n')
						out.push('\t_->length_ = \(e.constructors[i].length);\n')
						out.push('\t_->enum_ = (Any_**)(malloc(sizeof(Any_*) * \(e.constructors[i].length)));\n')
						out.push('\t_->is_ = \(i);\n')
						for (c in e.constructors[i].length) {
							out.push('\t_->enum_[\(c)] = ')
							out.push(printToAnyConverter(e.constructors[i][c] + '_', e.constructorsTypes[i][c]))
							out.push(';\n')
						}
						out.push('\treturn _;\n')
						out.push('};\n')
					} else {

						out.push(e.name + '_* ' + e.name + '_$' + name + '_() {\n')
						out.push('\t' + e.name + '_* _ = (' + e.name + '_*)(malloc(sizeof(' + e.name + '_)));\n')
						out.push('\t_->length_ = 0;\n')
						out.push('\t_->is_ = \(i);\n')
						out.push('\treturn _;\n')
						out.push('};\n')
					}
					i++
				}

				for (v in e.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						out.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
					case NiceStatement.Const(name, expr, type):
						out.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
				}

				for (v in e.staticMethods) switch (v) {
						case NiceStatement.Function(name, expr, args, defaults, funcType):
							forwardFunctions.push(printFunctionReturnType(funcType))
							forwardFunctions.push(' ' + e.name + '_$' + name + '_')
							forwardFunctions.push(printFunctionArguments(args, funcType))
							forwardFunctions.push(';\n')

							out.push(printFunctionReturnType(funcType))
							out.push(' ' + e.name + '_$' + name + '_')
							out.push(printFunctionArguments(args, funcType))

							let _currentReturnType = currentReturnType
							currentReturnType = getFunctionReturnType(funcType)
							out.push(' ' + printBlock(expr) + ';\n')
							currentReturnType = _currentReturnType
					}
				types.push('\n};\n')
			}

			for (c in project.classes) {
				if (c.name == 'Any') {
					continue
				}
				if (c.name == 'Bool') continue
				forward.push('struct ' + c.name + '_;')
				forward.push('struct ' + c.name + '_$vtable_;')
				types.push('struct ' + c.name + '_ : class_ {\n\t')
				let vtable = ['struct ' + c.name + '_$vtable_ {\n\t']
				types.push('\n\tstruct ' + c.name + '_$vtable_* $vtable_;')
				let vtableValue = ['struct ' + c.name + '_$vtable_ ' + c.name + '_$vtable_$ = {\n\t']
				let vtableBind = []

				for (v in c.vars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						types.push('\n\t\(stringifyType(type)) ' + name + '_;')
					case NiceStatement.Const(name, expr, type):
						types.push('\n\t\(stringifyType(type)) ' + name + '_;')
				}

				for (v in c.methods) switch (v) {
					case NiceStatement.Function(name, expr, args, defaults, funcType):
						if (name == null || name == 'new') {
							types.push('\n\t' + c.name + '_() {};') // For placement new

							forwardFunctions.push(c.name + '_* ' + c.name + '_$new_')
							forwardFunctions.push(printFunctionArguments(args, funcType))
							forwardFunctions.push(';\n')

							// Init
							out.push('void ' + c.name + '_$this_')
							thisArgument = c.name + '_* $this'
							out.push(printFunctionArguments(args, funcType))
							thisArgument = null
							out.push(' {\n')
							out.push('\t$this->$vtable_ = &' + c.name + '_$vtable_$;\n')

							// Init fields
							customThis = '$this'
							for (v in c.vars) switch (v) {
								case NiceStatement.Var(name, expr, type):
									if (expr != null)
									out.push('\t$this->' + name + '_ = ' + printExpression(expr) + ';\n')
								case NiceStatement.Const(name, expr, type):
									out.push('\t$this->' + name + '_ = ' + printExpression(expr) + ';\n')
							}
							pushTab()
							out.push('\t' + printBlock(expr) + ';\n')
							popTab()
							customThis = null
							out.push('};\n')

							// Alloc
							out.push(c.name + '_* ' + c.name + '_$new_')
							out.push(printFunctionArguments(args, funcType))
							out.push(' {\n')
							out.push('\tvoid* buffer_ = (' + c.name + '_*)(malloc(sizeof(' + c.name + '_)));\n')
							out.push('\t' + c.name + '_* _ = new (buffer_) ' + c.name + '_();\n')
							out.push('\t' + c.name + '_$this_(')
							let arg = [for (a in args) a + '_']
							arg.unshift('_')
							out.push(arg.join(', '))
							out.push(');\n')
							out.push('\treturn _;\n')
							out.push('};\n')
						} else {
							types.push('\n\tvirtual ')
							types.push(printFunctionReturnType(funcType))
							types.push(' ' + name + '_')
							types.push(printFunctionArguments(args, funcType))
							types.push(';')

							thisArgument = c.name + '_* $this'
							vtable.push('\n\t')
							vtable.push(printFunctionReturnType(funcType))
							vtable.push(' (*' + name + '_) ')
							vtable.push(printFunctionArguments(args, funcType))
							vtable.push(';')

							forwardFunctions.push(printFunctionReturnType(funcType))
							forwardFunctions.push(' ' + c.name + '_$' + name + '_')
							forwardFunctions.push(printFunctionArguments(args, funcType))
							forwardFunctions.push(';\n')

							let vbind = '&' + c.name + '_$' + name + '_'
							vtableBind.push(vbind)

							out.push(printFunctionReturnType(funcType))
							out.push(' ' + c.name + '_$' + name + '_')
							out.push(printFunctionArguments(args, funcType))
							let _currentReturnType = currentReturnType
							currentReturnType = getFunctionReturnType(funcType)
							customThis = '$this'
							thisArgument = null
							out.push(' ' + printBlock(expr) + ';\n')
							customThis = null
							currentReturnType = _currentReturnType

							out.push(printFunctionReturnType(funcType))
							out.push(' ' + c.name + '_::' + name + '_')
							out.push(printFunctionArguments(args, funcType))
							let _currentReturnType = currentReturnType
							currentReturnType = getFunctionReturnType(funcType)
							let arg = [for (a in args) a + '_']
							arg.unshift('this')
							out.push(' { return this->$vtable_->' + name + '_(' + arg.join(', ') + '); };\n')
							currentReturnType = _currentReturnType
						}
				}

				for (v in c.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						out.push('\(stringifyType(type)) ' + c.name + '_$' + name + '_;\n')
					case NiceStatement.Const(name, expr, type):
						out.push('\(stringifyType(type)) ' + c.name + '_$' + name + '_;\n')
				}


				types.push('\n};\n')
				vtable.push('\n};\n')
				vtableValue.push(vtableBind.join(',\n\t'))
				vtable.push(vtableValue.join('') + '\n};\n')
				types.unshift(vtable.join(''))

				for (v in c.staticMethods) switch (v) {
					case NiceStatement.Function(name, expr, args, defaults, funcType):
						out.push(printFunctionReturnType(funcType))
						out.push(' ' + c.name + '_$' + name + '_')
						out.push(printFunctionArguments(args, funcType))

						let _currentReturnType = currentReturnType
						currentReturnType = getFunctionReturnType(funcType)
						out.push(' ' + printBlock(expr) + ';\n')
						currentReturnType = _currentReturnType
				}
			}

			for (g in project.globalFuncs) switch (g) {
				case NiceStatement.Function(name, expr, args, defaults, funcType):
					types.push(printFunctionReturnType(funcType))
					types.push(' ' + name + '_')
					types.push(printFunctionArguments(args, funcType))
					types.push(';\n')

					out.push(printFunctionReturnType(funcType))
					out.push(' ' + name + '_')
					out.push(printFunctionArguments(args, funcType))

					let _currentReturnType = currentReturnType
					currentReturnType = getFunctionReturnType(funcType)
					out.push(' ' + printBlock(expr) + ';\n')
					currentReturnType = _currentReturnType
			}

			// Init
			out.push('int main(int argc, char **argv) {\n')
			out.push('\t%%%HEXA_STRINGS@@@\n')
			pushTab()

			for (e in project.enumsSimple) {
				for (v in e.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						if (expr != null)
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
					case NiceStatement.Const(name, expr, type):
						if (expr != null)
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
				}
			}

			for (e in project.enumsComplex) {
				for (v in e.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						if (expr != null)
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
					case NiceStatement.Const(name, expr, type):
						if (expr != null)
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
				}
			}

			for (e in project.classes) {
				for (v in e.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						if (expr != null)
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
					case NiceStatement.Const(name, expr, type):
						if (expr != null)
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
				}
			}

			for (g in project.globalVars) switch (g) {
				case NiceStatement.Var(name, expr, type):
					types.push(stringifyType(type))
					types.push(' ' + name + '_;\n')
					if (expr != null)
					out.push('\t' + name + '_ = ' + printExpression(expr) + ';\n')
				case NiceStatement.Const(name, expr, type):
					types.push(stringifyType(type))
					types.push(' ' + name + '_;\n')
					if (expr != null)
					out.push('\t' + name + '_ = ' + printExpression(expr) + ';\n')
			}

			let init = printStatement(project.init[0])
			let strings = ['String_Strings = (String_**)malloc(HEXA_STRINGS * sizeof(String_*));\n']
			for (id in declarationsOfStrings.length) {
				// TODO set ref counting
				strings.push('\tString_Strings[\(id)] = String_fromUTF8z("\(declarationsOfStrings[id])");\n')
			}
			out.push('\t')
			out.push(init)
			popTab()
			out.push('\treturn 0;\n}\n')

			out.push('#ifdef __cplusplus\n')
			out.push('}\n')
			out.push('#endif\n')

			forward.push('#define HEXA_STRINGS \(declarationsOfStrings.length)')

			// TODO all those to [ ].join('\n') instead of `+`
			return (
				header.join('\n')
				+ '\n// Forward\n' +
				forward.join('\n')

				+ '\n// Forward functions\n' +
				forwardFunctions.join('')

				+ '\n// Types\n' +
				types.join('')
				+ '\n// Statements\n' +

				// TODO Boi, dat weird
				out.join('').split('%%%HEXA_STRINGS@@@').join(strings.join(''))
			).split('\n').join('\r\n')

			var out = ''

			// Types
			for (e in project.enumsSimple) {
				// No need to output simple enum values
				//out += '\n' + 'struct _x' + e.name + ' {};'
				//out += '\n' + 'uint32_t _x' + e.name + ';'
				declarationsOfOpaqueTypes.push('typedef uint16_t _x' + e.name)
				// TODO typedef, renamed
				for (v in e.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						out += '\n' + stringifyType(type) + ' _x' + e.name + '_' + name
						if (expr != null) out += ' = ' + printExpression(expr) + ';' //!to constructor
						// += ;
					case NiceStatement.Const(name, expr, type):
						out += '\n' + stringifyType(type) + ' _x' + e.name + '_' + name
						out += ' = ' + printExpression(expr) + ';'
				}
				for (v in e.staticMethods) switch (v) { // TODO forward, auto args
				}
			}

			for (c in project.classes) {
				if (c.external) {
					if (c.jsRequire != null) {
						// todo MAKE IT possible to use plain-c include's!
						// like "declare" vs "deep extern declare" for Haxe
						out += '\n ' + '/*var ' + c.name + ' = require("' + c.jsRequire + '")*/'
						continue
					}
					//declarationsOfOpaqueTypes.push('#define _x' + c.name + ' ' + (c.jsNative ?? c.name))
					// Avoid adding of `;`
					//header.push('#define _x' + c.name + ' ' + (c.jsNative ?? c.name))
					header.push('typedef ' + (c.jsNative ?? c.name) + ' _x' + c.name + ';')
					continue
				}

				let renamed = '_x' + c.name
				let t = ['struct ', renamed, ' {'] // t should be used instead of out???
				//out += '\n ' + 'struct ' + c.name + ' {'
				// maybe use as struct* not just `struct`?
				declarationsOfOpaqueTypes.push('typedef struct \(renamed)* \(renamed)')
				t.push('\n _xclass _xclass;') // Reference counting and metatable
				for (v in c.vars) switch (v) {
					case NiceStatement.Var(name, expr, type):
					t.push('\n ' + stringifyType(type) + ' _x' + name + ';')
					//if (expr != null) out += ' = ' + printExpression(expr)
					//t.push(';')
					case NiceStatement.Const(name, expr, type):
					//t.push('\n ' + printType(type) + ' = ' + printExpression(expr) + ';')
					t.push('\n ' + stringifyType(type) + ' _x' + name + ';')
				}
				for (v in c.methods) switch (v) {
					case NiceStatement.Function(name, expr, args, defaults): // Class method
					let types = null
					let returns = null
					var declaration = printType(returns) + ' '
					let constructor = (name == null || name == 'new')
					if (constructor) declaration = renamed + ' '
					declaration += renamed + '_' + name

					if (constructor) {
						if (args.length > 0) declaration += '(void* _x' + args.join(', void* _x') + ')'
						else declaration += '()'
					} else {
						if (args.length > 0) declaration += '(\(renamed) _xthis, void* _x' + args.join(', void* _x') + ')'
						else declaration += '(\(renamed) _xthis)'
					}

					declarationsOfFunctions.push(declaration)
					//if (name == null || name == 'new') declaration = '\(renamed) \(renamed)_new'
					//if (name == null || name == 'new') out += '\n\(renamed)* constructor_\(renamed)'
					//else out += '\nauto ' + name
					out += '\n' + declaration
					//out += '(' + args.join(', ') + ') { '
					out += ' { '

					if (constructor) {
						out += '\n \(renamed) _xthis = (\(renamed))malloc(sizeof(struct \(renamed)));'
						// Init fields
						for (v in c.vars) switch (v) {
							case NiceStatement.Var(name, expr, type):
							if (expr != null)
							out += '\n _xthis->_x' + name + ' = ' + printExpression(expr) + ';'
							case NiceStatement.Const(name, expr, type):
							out += '\n _xthis->_x' + name + ' = ' + printExpression(expr) + ';'
						}
						out += '\n '
						out += printStatement(expr) + '\n return _xthis;\n};'
					} else

					out += printStatement(expr) + '\n};'
				}
				t.push('\n}')
				declarationsOfFullTypes.push(t.join(''))

				for (v in c.staticVars) switch (v) {
					case NiceStatement.Var(name, expr, type):
						out += '\n ' + stringifyType(type) + ' ' + renamed + '_' + name
						//t.push('\n ' + c.name + '.' + name)
						// TODO to main()
						//if (expr != null) out += ' = ' + printExpression(expr)
						out += ';'
						//if (expr != null) t.push(' = ' + printExpression(expr))
				}
			}
		}

		var tabs = ''
		@inline function pushTab() tabs += '\t'
		@inline function popTab() tabs = tabs.substring(0, tabs.length - 1)

		// All names are prefixed with `_x`, so reserved words are not required
		var reserved = []

		// For `return value` conversions (like Bool to Any)
		var currentReturnType: Type? = null

		// Surrounds with { brackets } single statement
		function printBlock(s: NiceStatement): String {
			switch (s) {
				case NiceStatement.Block(el):
				//if (el.length == 1) return '{ ' + printStatement(el[0]) + '; }'
				if (el.length == 1) switch (el[0]) {
					case NiceStatement.Block(_): return printBlock(el[0])
					case _: return '{ ' + printStatement(el[0]) + '; }'
				}
				if (el.length == 0) return '{}'
				return printStatement(s)
				case _: return '{ ' + printStatement(s) + '; }'
			}
		}

		var last = ''
		function printStatement(s: NiceStatement) {
			switch (s) {
				case NiceStatement.Statements(els):
					var r = ''
					for (s in els) if (s != null) r += '\n' + tabs + printStatement(s) + ';'
					return r

				case NiceStatement.Break: return 'break'
				case NiceStatement.Continue: return 'continue'
				case NiceStatement.Block(el):
					pushTab()
					var r = '{'

					for (e in el) switch (e) {
						case null:
						case NiceStatement.Statements(els):
							for (s in els) if (s != null) r += '\n' + tabs + printStatement(s) + ';'
						case _:
							r += '\n' + tabs + printStatement(e) + ';'
					}

					popTab()
					return r + '\n' + tabs + '}'
				case NiceStatement.New(e, args): return '' + printExpression(e) + '$new_' + printCallArguments(args)
				case NiceStatement.Const(name, expr, type):
					return stringifyType(type) + ' ' + name + '_' + (expr == null? '' : ' = ' + printTypeConverter(printExpression(expr), getType(expr), type))
				case NiceStatement.Var(name, expr, type):
					return stringifyType(type) + ' ' + name + '_' + (expr == null? '' : ' = ' + printTypeConverter(printExpression(expr), getType(expr), type))
				case NiceStatement.Function(name, expr, args, defaults, funcType):
					let _currentReturnType = currentReturnType
					currentReturnType = getFunctionReturnType(funcType)
					let result = 'auto \(name)_ = [&]' + printFunctionArguments(args, defaults)
					+ '->' + printFunctionReturnType(funcType) + ' '
					+ printBlock(expr)
					currentReturnType = _currentReturnType
					return result
				case NiceStatement.Return(e):
					if (e == null) return 'return'
					return 'return ' + printTypeConverter(printExpression(e), getType(e), currentReturnType)
				case NiceStatement.If(econd, eif, eelse):
					var r = 'if (' + printExpression(econd) + ') ' + printBlock(eif)
					if (eelse != null) r += ' else ' + printStatement(eelse)
					return r
				case NiceStatement.Call(e, args, expects):
					return printExpression(e) + printCallArguments(args, expects)
				case NiceStatement.Try(expr, t, v, catches):
					pushTab()
					var r = '_try {\n' + tabs
					r += printStatement(expr)
					popTab()
					r += '\n' + tabs + '} _catch(' + printType(t[0]) + ' _x' + v[0] + ') {\n' + tabs + ' '
					pushTab()
					r += printStatement(catches[0])
					popTab()
					return r + '\n' + tabs + '}'
				case NiceStatement.Assign(a, v):
					switch (a) {
						case NiceExpression.Dot(expr, name):
							// Dynamic
							let type = getType(expr)
							if ((type == project.typer.typeAny) || (type == null))
								return  printExpression(expr) +
									'->var_(String_fromUTF8z("' + name + '"), ' + printToAnyConverter(printExpression(v), getType(v)) + ')'
					}
					return printExpression(a) + ' = ' + printExpression(v)
				case NiceStatement.Throw(e):
					return '_throw(' + printExpression(e) + ')'
				case NiceStatement.For(name, over, by):
					return 'for (Any_* ' + name + '_; ' + printExpression(over) + ';) ' + printStatement(by)
				case NiceStatement.Increment(e): return printExpression(e) + '++'
				case NiceStatement.Decrement(e): return printExpression(e) + '--'
				case NiceStatement.While(econd, e, pre):
					if (pre) return 'while (' + printExpression(econd) + ') ' + printStatement(e)
					return 'do {' + printStatement(e) /*block*/ + '} while (' + printExpression(econd) + ')'
				case NiceStatement.Assignop(a, op, value):
					return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)
				case NiceStatement.Dot(expr, name): switch (expr) {
					case NiceExpression.Ident(id):
						// Static
						if (id.charAt(0) == id.charAt(0).toUpperCase())
							return id + '_::' + name + '_'
					}
					return printExpression(expr) + '->' + name
				case NiceStatement.Switch(expr, cases, statements):
					// Convert to if-else cause C++ is not fun
					var r = '{ auto switch_ = ' + printExpression(expr) + ';'

					// case 1: case 2: case 3:
					var else_ = false
					for (i in cases.length) if (cases[i].length > 0) {
						if (else_) r += ' else'
						r += '\n' + tabs + 'if (('
						let conds = []
						for (cc in cases[i]) switch (cc) {
							case NiceExpression.Null(_):
								conds.push('switch_ == -1')
							case _:
								conds.push('switch_ == ' + printExpression(cc))
						}
						r += conds.join(') || (') +  ')) '
						pushTab()
						r += printBlock(statements[i])
						popTab()
						else_ = true
					}

					// default:
					for (i in cases.length) if (cases[i].length == 0) {
						if (else_) r += ' else'
						r += '\n' + tabs
						r += printBlock(statements[i])
					}

					r += ';\n' + tabs
					return r + '}'

					// TODO: don't use "0" as tag, use 1+; use `switch(a? a->index : 0)` or
					// generate `if(a) switch() else null-case` in normalizer
					/*
						let temp = f()
						if (temp != null) {
							switch (temp.index) {
								// no null case
							}
						} else {
							null case
						}
						^ in normalizer
					*/
					var r = 'switch (' + printExpression(expr) + ') {'

					// case 1: case 2: case 3:
					for (i in cases.length) if (cases[i].length > 0) {
						r += '\n' + tabs
						for (cc in cases[i]) r += 'case ' + printExpression(cc) + ': '
						//pushTab()
						//r += '{\n' + tabs
						//r += printStatement(statements[i])
						//popTab()
						//r += '\n' + tabs + '} break;\n' + tabs

						pushTab()
						r += printBlock(statements[i])
						popTab()
						r += ' break;'
					}

					// default:
					for (i in cases.length) if (cases[i].length == 0) {
						r += '\n' + tabs + 'default:'
						r += '\n' + tabs
						r += printBlock(statements[i])
						//r += '\n' + tabs
					}

					r += '\n' + tabs
					return r + '}'

				case _: console.error("Unknown statement kind:", (s??[])[0])
			}
		}

		function printCallArguments(args: [NiceExpression], expects: [Type]?) {
			if (let exp = expects)
				return '(' + [for (i in args.length)
					printTypeConverter(printExpression(args[i]), getType(args[i]), exp[i])
				].join(', ') + ')'
			return '(' + [for (a in args) printExpression(a)].join(', ') + ')'
		}

		function getFunctionReturnType(funcType: Type): Type? switch (funcType) {
			case Type.Function(args, returns): return returns
			case _: return null
		}

		function printFunctionReturnType(funcType: Type) switch (funcType) {
			case Type.Function(args, returns): return stringifyType(returns)
			case _: return 'void'
		}

		function printToAnyConverter(string: String, type: Type): String {
			if (type == project.typer.typeAny) return string
			if (type == project.typer.typeBool) return 'Any_fromBool(' + string + ')'
			if (type == project.typer.typeInt) return 'Any_fromInt(' + string + ')'
			return string
		}

		function printTypeConverter(string: String, fromValue: Type, to: Type): String {
			if (fromValue == to) return string
			if (fromValue == project.typer.typeBool, to == project.typer.typeAny) return 'Any_fromBool(' + string + ')'
			if (fromValue == project.typer.typeAny, to == project.typer.typeBool) return '(' + string + ')->_toBool()'
			if (fromValue == project.typer.typeAny, to == project.typer.typeInt) return '(' + string + ')->_toInt()'
			if (fromValue == project.typer.typeInt, to == project.typer.typeString) return 'String_fromInt(' + string + ')'
			if (to == project.typer.typeAny) return printToAnyConverter(string, fromValue)
			if (fromValue != to) return '(' + stringifyType(to) + ')(' + string + ')'
			return string
		}

		var thisArgument: String? = null
		function printFunctionArguments(args: [String], funcType: Type, defaults: Bool = false) {
			if (args.length == 0, thisArgument != null) return '(' + thisArgument + ')'
			if (args.length == 0) return '(void)' // Otherwise C function takes infinite number of arguments
			switch (funcType) {
				case Type.Function(types, _):
					let results: [String] = []
					if (let thisArgument = thisArgument) results.push(thisArgument)

					for (a in args.length) {
						var result = stringifyType(types[a]) + ' ' + args[a] + '_'
						if (defaults) switch (types[a]) {
							case Type.Nullable(_): result += ' = $null'
							case Type.UnknownNullable(_): result += ' = $null'
						}
						results.push(result)
					}
					return '(' + results.join(', ') + ')'

					return '(' + [for (a in args.length) {
						var result = stringifyType(types[a]) + ' ' + args[a] + '_'
						if (defaults) switch (types[a]) {
							case Type.Nullable(_): result += ' = $null'
							case Type.UnknownNullable(_): result += ' = $null'
						}
						result
					}].join(', ') + ')'
			}
			return '(' + [for (a in args.length)
				'Any_* ' + args[a] + '_'
			].join(', ') + ')'
			// TODO defaults
			// 'void* ' + args[a] + ((defaults != null && defaults[a] != null)? ' = ' + printExpression(defaults[a]) : '')
		}

		function stringType(t: NodeType, prefix: String) {
			//let prefix = prefix? '' : ''
			if (t == null) return 'void*'
			//if (t == null) return prefix + 'void*'
			switch (t) {
				case NodeType.ParametricType(name, params):
			//		if (name == 'Buffer') return prefix + name
			//		return prefix + name + '<' + [for (param in params) stringType(param, false)].join(', ') + '>'
					return '_x' + name
				case NodeType.Type(name):
			//		if (name == 'Any') return prefix + 'void*'
					return '_x' + name
				case NodeType.Object(_):
			//		return prefix + '{}'
				case NodeType.Optional(t):
			//		return prefix + 'Null<' + stringType(t, false) + '>'
					return stringType(t, '')
			}

			return prefix + 'void*'
		}

		function printType(t: NodeType) {
			let type = stringType(t, '')
			return type
		}

		function stringifyType(t: Type) {
			switch (t) {
				case Type.Nullable(t):
					let name = stringifyType(t)
					if (name == 'int32_t') return 'int32_t*'
					if (name == 'bool') return 'bool*'
					if (name == 'double') return 'double*'
					return name
				case Type.UnknownNullable(handle): return stringifyType(handle.value)
				case Type.ClassInstance(type):
					if (type.name == 'Int') return 'int32_t'
					if (type.name == 'Bool') return 'bool'
					if (type.name == 'Void') return 'void'
					if (type.name == 'Float') return 'double'
					return type.name + '_*'
				case Type.Class(type): return type.name + '_*'
				case Type.Enum(type):
					if (let sub = type.fieldsTypeSimple)
						return stringifyType(sub)
					return type.name + '_*'
				case Type.EnumInstance(type): return type.name + '_*'
				case Type.Struct(_): return 'Any_*'
				case Type.Function(_): return 'Any_*'
				case null: return 'Any_*/*?*/'
				case _: throw 'stringifyType ' + t
			}
		}

		function getType(e: NiceExpression): Type switch (e) {
			case NiceExpression.Int(_): return project.typer.typeInt
			case NiceExpression.Float(_): return project.typer.typeFloat
			case NiceExpression.String(_): return project.typer.typeString
			case NiceExpression.True(_): return project.typer.typeBool
			case NiceExpression.False(_): return project.typer.typeBool
			case NiceExpression.Ident(_, type): return type
			case NiceExpression.Parenthesis(expr): return getType(expr)
			case NiceExpression.Call(_, _, type): return type
			case NiceExpression.Binop(_, _, _, type): return type
			case NiceExpression.Dot(_, _, type): return type
			case NiceExpression.This(type): return type
			case _:
			return project.typer.typeAny
		}

		function registerString(string: String): Int {
			declarationsOfStrings.push(string)
			return declarationsOfStrings.length - 1
		}

		var customThis: String? = null
		function printExpression(e: NiceExpression) {
			switch (e) {
				case NiceExpression.This: return customThis ?? 'this'
				case NiceExpression.Ident(name): return '' + name + '_'
				case NiceExpression.Null:
					// TODO infer actual type of null in typer,
					// to print type conversion `((T*)0)`
					return '$null'
				case NiceExpression.Int(v): return '(int32_t)' + v
				case NiceExpression.Float(v):
					if (v.indexOf('.') == -1) return '(double)' + v + '.0'
					return '(double)' + v
				case NiceExpression.String(string):
					if (let id = declarationsOfStringsMap.get(string))
						return 'String_Strings[\(id)]'

					let s = string.split('')
					let charsOut = []
					while (s.length > 0) {
						switch (s[0]) {
							case "'":
							charsOut.push("\\'")
							s.shift()
							case '"':
							charsOut.push('\\"')
							s.shift()
							case "\n":
							charsOut.push("\\n")
							s.shift()
							case "\r":
							charsOut.push("\\r")
							s.shift()
							case "\\":
							s.shift()
							if (s[0] == "'") {
								charsOut.push("\\'")
								s.shift()
							} else if (s[0] == '"') {
								charsOut.push('\\"')
								s.shift()
							} else if (s[0] == '\\') {
								charsOut.push("\\\\")
								s.shift()
							} else {
								charsOut.push('\\')
							}
							case _:
							charsOut.push(s[0])
							s.shift()
						}
					}

					let id = registerString(charsOut.join(""))
					declarationsOfStringsMap.set(string, id)
					return 'String_Strings[\(id)]'
				case NiceExpression.True: return 'true'
				case NiceExpression.False: return 'false'
				case NiceExpression.Dot(expr, name): switch (expr) {
					case NiceExpression.This: return (customThis ?? 'this') + '->' + name + '_'
					case NiceExpression.Ident(id):
						// Static
						if (id.charAt(0) == id.charAt(0).toUpperCase())
							return id + '_$' + name + '_'
						// Dynamic
						let type = getType(expr)
						if ((type == project.typer.typeAny) || (type == null))
							return printExpression(expr) + '->let_(String_fromUTF8z("' + name + '"))'
						return printExpression(expr) + '->' + name + '_'
					case _:
						return printExpression(expr) + '->' + name + '_'
				}
				case NiceExpression.Call(e, args): return printExpression(e) + printCallArguments(args)
				case NiceExpression.Function(name, expr, args, defaults, funcType):
					let _currentReturnType = currentReturnType
					currentReturnType = getFunctionReturnType(funcType)
					let result = '[&]' + printFunctionArguments(args, defaults)
					+ '->' + printFunctionReturnType(funcType) + ' '
					+ printBlock(expr)
					currentReturnType = _currentReturnType
					return result
				case NiceExpression.New(e, args): return '' + printExpression(e) + '$new_' + printCallArguments(args)
				case NiceExpression.Array(el):
					if (el.length == 0) return 'Array_$new_(0)'
					return 'Array_from(' + [for (a in el) printExpression(a)].join(', ') + ')'
				case NiceExpression.Unop(op, postfix, e):
					if (postfix) return printExpression(e) + Token.stringify(op)
					return Token.stringify(op) + printExpression(e)
				case NiceExpression.Elvis(nullable, othewise):
					return '((' + printExpression(nullable) + ')||(' + printExpression(othewise) + '))'
				case NiceExpression.Parenthesis(e): return '(' + printExpression(e) + ')'
				case NiceExpression.Binop(a, op, b):
					if (op == Token.OpAdd) {
						if (getType(a) == project.typer.typeString)
							return 'String_opAdd(' + printExpression(a) + ', ' + printTypeConverter(printExpression(b), getType(b), project.typer.typeString) + ')'
						if (getType(b) == project.typer.typeString)
							return 'String_opAdd(' + printTypeConverter(printExpression(a), getType(a), project.typer.typeString) + ', ' + printExpression(b) + ')'
					}
					return printExpression(a) + ' ' + Token.stringify(op) + ' ' + printExpression(b)
				case NiceExpression.Index(expr, index):
					return  printExpression(expr) + '->get_(' + printTypeConverter(printExpression(index), getType(index), project.typer.typeInt) + ')'
				case NiceExpression.If(econd, eif, eelse):
					var r = ''
					try {
						r += '(' + printExpression(econd) + ')?'
						r += '(' + printExpression(eif) + ')'
						r += ':' + printExpression(eelse)
						return r
					} catch (error: Any) {
						console.log('If =>', e, error)
						return r + '<!-- If => error -->'
					}
				case NiceExpression.EnumTag(expr):
					let e = printExpression(expr)
					return '(' + e + ' == $null? -1 : ' + e + '->is_)'
				case NiceExpression.Object(names, el):
					return 'Object_from(' + [for (i in el.length) ((names[i]) + ', ' + printExpression(el[i]))].join(', ') + ')'
				case NiceExpression.Map(keys, values):
					if (keys.length == 0) return 'Map_$new_()'
					return 'Map_from(' +
					[for (i in keys.length) '' + printExpression(keys[i]) + ', ' + printExpression(values[i]) + ''].join(', ')
					+ ')'
				case NiceExpression.Assignop(a, op, value):
					return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)
				case NiceExpression.NativeOperator(kind, args, s): switch (kind) {
					case NativeOperatorKind.Infix: return '((' + printExpression(args[0]) + ')' + s + '(' + printExpression(args[1]) + '))'
					case NativeOperatorKind.Function: return s + printCallArguments(args)
					case NativeOperatorKind.Prefix: return '(' + s + '(' + printExpression(args[0]) + '))'
					case NativeOperatorKind.Postfix: return '((' + printExpression(args[1]) + ')' + s + ')'
				}
				case NiceExpression.Enum(typeName, tagName, tag, args):
					return '' + typeName + '_$' + tagName + '_(' + [for (a in args) printExpression(a)].join(', ') + ')'
				case NiceExpression.EnumParameter(expr, index):
					return printExpression(expr) + '->enum_[' + index + ']'
				case _: console.error("Unknown expression kind:", e) return '<!-- ' + (e??[])[0] + ' -->'
			}
		}
	}
