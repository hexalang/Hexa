// Generated by Hexa 1.0.0 https://hexalang.github.io
// Project: The Hexa Compiler
// LICENSE LGPL-3.0-only
;(() => {
	"use strict"
	const $global = typeof(window) === "undefined"? global : window
	if (typeof($global.require) === "undefined") { $global.require = () => {} };
	const selfVersion="1.0.0";
	const $toIterator = (v) => typeof(v) === "number"? Array(Math.max(v, 0)).keys() : v;
	const Fs = require("fs")
	const Path = require("path")
	const ProcessModule = require("process")
	var Token = {
		stringify: (token, param = null) => { {
		const temp = token;
		switch (temp) {
		case 70: {
			return '@'
		} break;
		
		case 83: {
			return '$'
		} break;
		
		case 78: {
			return '#'
		} break;
		
		case 71: {
			return ']'
		} break;
		
		case 72: {
			return '['
		} break;
		
		case 73: {
			return '}'
		} break;
		
		case 74: {
			return '{'
		} break;
		
		case 76: {
			return ':'
		} break;
		
		case 75: {
			return ','
		} break;
		
		case 123: {
			return '<!--empty-->'
		} break;
		
		case 77: {
			return '.'
		} break;
		
		case 0: {
			return '<!--end-->'
		} break;
		
		case 98: {
			return '...'
		} break;
		
		case 58: {
			return 'as'
		} break;
		
		case 3: {
			return 'break'
		} break;
		
		case 4: {
			return 'case'
		} break;
		
		case 6: {
			return 'catch'
		} break;
		
		case 7: {
			return 'class'
		} break;
		
		case 8: {
			return 'continue'
		} break;
		
		case 9: {
			return 'do'
		} break;
		
		case 10: {
			return 'else'
		} break;
		
		case 11: {
			return 'enum'
		} break;
		
		case 12: {
			return 'extends'
		} break;
		
		case 13: {
			return 'declare'
		} break;
		
		case 14: {
			return 'false'
		} break;
		
		case 15: {
			return 'for'
		} break;
		
		case 21: {
			return 'fun'
		} break;
		
		case 17: {
			return 'if'
		} break;
		
		case 18: {
			return 'implements'
		} break;
		
		case 2: {
			return 'import'
		} break;
		
		case 20: {
			return 'in'
		} break;
		
		case 22: {
			return 'interface'
		} break;
		
		case 23: {
			return 'let'
		} break;
		
		case 25: {
			return 'new'
		} break;
		
		case 26: {
			return 'null'
		} break;
		
		case 29: {
			return 'private'
		} break;
		
		case 31: {
			return 'return'
		} break;
		
		case 32: {
			return 'static'
		} break;
		
		case 59: {
			return 'super'
		} break;
		
		case 33: {
			return 'switch'
		} break;
		
		case 34: {
			return 'this'
		} break;
		
		case 35: {
			return 'throw'
		} break;
		
		case 36: {
			return 'true'
		} break;
		
		case 37: {
			return 'try'
		} break;
		
		case 40: {
			return 'var'
		} break;
		
		case 41: {
			return 'while'
		} break;
		
		case 111: {
			return '+'
		} break;
		
		case 112: {
			return '&'
		} break;
		
		case 90: {
			return '=>'
		} break;
		
		case 91: {
			return '='
		} break;
		
		case 92: {
			return '&&'
		} break;
		
		case 93: {
			return '||'
		} break;
		
		case 86: {
			return '--'
		} break;
		
		case 94: {
			return '/'
		} break;
		
		case 95: {
			return '=='
		} break;
		
		case 96: {
			return '>'
		} break;
		
		case 97: {
			return '>='
		} break;
		
		case 87: {
			return '++'
		} break;
		
		case 110: {
			return '\\'
		} break;
		
		case 99: {
			return '<'
		} break;
		
		case 100: {
			return '<='
		} break;
		
		case 101: {
			return '%'
		} break;
		
		case 102: {
			return '*'
		} break;
		
		case 88: {
			return '~'
		} break;
		
		case 89: {
			return '!'
		} break;
		
		case 103: {
			return '!='
		} break;
		
		case 104: {
			return '|'
		} break;
		
		case 105: {
			return '<<'
		} break;
		
		case 106: {
			return '>>'
		} break;
		
		case 107: {
			return '-'
		} break;
		
		case 108: {
			return '>>>'
		} break;
		
		case 109: {
			return '^'
		} break;
		
		case 113: {
			return '?.'
		} break;
		
		case 79: {
			return ')'
		} break;
		
		case 80: {
			return '('
		} break;
		
		case 81: {
			return '?'
		} break;
		
		case 82: {
			return ';'
		} break;
		
		case 1: {
			return '_'
		} break;
		
		case 61: {
			return (((param == null))? ('TitleCase') : param)
		} break;
		
		case 64: {
			return (((param == null))? ('string') : ('\'' + (param) + '\''))
		} break;
		
		case 66: {
			return (((param == null))? ('backtick') : ('`' + (param) + '`'))
		} break;
		
		case 62: {
			return (((param == null))? ('identifier') : param)
		} break;
		
		case 63: {
			return (((param == null))? ('integer') : param)
		} break;
		
		case 60: {
			return (((param == null))? ('float') : param)
		} break;
		
		case 65: {
			return ('///' + (param) + '')
		} break;
		
		case 57: {
			return 'is'
		} break;
		};
	} },
	}
	var Meta = {
		stringify: (kind) => { {
		const temp_6066 = kind;
		switch (temp_6066) {
		case 0: {
			return 'Default'
		} break;
		
		case 1: {
			return 'BigInt'
		} break;
		
		case 2: {
			return 'Int32'
		} break;
		
		case 3: {
			return 'Int64'
		} break;
		
		case 4: {
			return 'Int16'
		} break;
		
		case 5: {
			return 'Int8'
		} break;
		
		case 6: {
			return 'UInt32'
		} break;
		
		case 7: {
			return 'UInt64'
		} break;
		
		case 8: {
			return 'UInt16'
		} break;
		
		case 9: {
			return 'UInt8'
		} break;
		
		case 10: {
			return 'Float32'
		} break;
		};
	} },
	}
	var Statement = {
	}
	var Expression = {
	}
	var ImportNode = {
	}
	var NodeType = {
		stringify: (nodeType) => { {
		{
			const temp = nodeType;
			switch (temp&&temp[0]) {
			case 0: {
				const type_6147 = temp[1];
				return NodeType.stringify(type_6147) + '?'
			} break;
			
			case 5: {
				const names_6148 = temp[1];
				const types_6149 = temp[2];
				{
					if (names_6148.length == 0) { return '{}' };
					return '{ ' + (() => {
						const result = [];
						const value_6150 = names_6148.length;
						for (const i of $toIterator(value_6150)) result.push(names_6148[i] + ': ' + NodeType.stringify(types_6149[i]));
						return result;
					})().join(', ') + ' }';
				}
			} break;
			
			case 3: {
				const args_6151 = temp[1];
				const ret_6152 = temp[2];
				return '(' + args_6151.map((arg) => (NodeType.stringify(arg))).join(', ') + ') => ' + NodeType.stringify(ret_6152)
			} break;
			};
		};
		return DataHelper.extractTypeName(nodeType);
	} },
		clone: (nodeType_6153) => { {
		{
			const temp_6154 = nodeType_6153;
			switch (temp_6154&&temp_6154[0]) {
			case 1: {
				const name_6155 = temp_6154[1];
				const path_6156 = temp_6154[2];
				return /*Type*/[1,name_6155,path_6156,".Type"]
			} break;
			
			case 2: {
				const name_6157 = temp_6154[1];
				const params_6158 = temp_6154[2];
				const path_6159 = temp_6154[3];
				return /*ParametricType*/[2,name_6157,params_6158.map((param) => (NodeType.clone(param))),path_6159,".ParametricType"]
			} break;
			};
		};
		console.error('Cannot clone node type', nodeType_6153);
		return nodeType_6153;
	} },
	}
	var Node = {
		stringify: (node) => { {
		const temp = node;
		switch (temp&&temp[0]) {
		case 0: {
			const s = temp[1];
			return ('\'' + (s) + '\'')
		} break;
		
		case 1: {
			const name_6206 = temp[1];
			return name_6206
		} break;
		
		case 2: {
			const b = temp[1];
			return ((b)? ('true') : 'false')
		} break;
		
		case 5: {
			const s_6207 = temp[1];
			return s_6207.toString()
		} break;
		
		case 7: {
			const s_6208 = temp[1];
			return s_6208.toString()
		} break;
		
		case 8: {
			return 'null'
		} break;
		
		case 3: {
			return 'this'
		} break;
		
		case 15: {
			const expr_6209 = temp[1];
			return '(' + Node.stringify(expr_6209) + ')'
		} break;
		
		case 33: {
			const expr_6210 = temp[1];
			const index_6211 = temp[2];
			return Node.stringify(expr_6210) + '[' + Node.stringify(index_6211) + ']'
		} break;
		
		case 28: {
			const expr_6212 = temp[1];
			const name_6213 = temp[2];
			return Node.stringify(expr_6212) + '.' + name_6213
		} break;
		
		case 29: {
			const expr_6214 = temp[1];
			const name_6215 = temp[2];
			return Node.stringify(expr_6214) + '.' + name_6215
		} break;
		
		case 13: {
			const e_6216 = temp[1];
			const args_6217 = temp[2];
			const argNames_6218 = temp[3];
			{
				const arg = [];
				{
					let i = 0;
					let it = 0;
					let at = args_6217.length;
					while (it < at) {
						i = it;
						it++;
						{
							let step = 0;
							const name_6219 = argNames_6218[i];
							if (step == 0 && name_6219 != null) { step = 1 };
							if (step == 1) { arg.push(name_6219 + ': ' + Node.stringify(args_6217[i])) } else {
								arg.push(Node.stringify(args_6217[i]));
							};
						};
					};
				};
				return Node.stringify(e_6216) + '(' + arg.join(', ') + ')';
			}
		} break;
		
		case 31: {
			const elements_6220 = temp[1];
			return '[' + (() => {
				const result = [];
				const value_6221 = elements_6220;
				for (const el of $toIterator(value_6221)) result.push(Node.stringify(el));
				return result;
			})().join(', ') + ']'
		} break;
		
		case 10: {
			const a = temp[1];
			const op_6222 = temp[2];
			const b_6223 = temp[3];
			return Node.stringify(a) + ' ' + Token.stringify(op_6222) + ' ' + Node.stringify(b_6223)
		} break;
		
		case 38: {
			const names_6224 = temp[1];
			const el_6225 = temp[2];
			return '{' + (() => {
				const result_6226 = [];
				const value_6227 = el_6225.length;
				for (const i of $toIterator(value_6227)) result_6226.push(names_6224[i] + ': ' + Node.stringify(el_6225[i]));
				return result_6226;
			})().join(', ') + '}'
		} break;
		
		case 51: {
			const t_6228 = temp[1];
			return DataHelper.extractTypeName(t_6228)
		} break;
		
		case 47: {
			const f = temp[1];
			return 'static ' + Node.stringify(f)
		} break;
		
		default: 
		{
			console.error(node);
			return '...';
		}
		};
	} },
		clone: (project, node_6229) => { {
		const p = project;
		{
			const temp_6230 = node_6229;
			switch (temp_6230&&temp_6230[0]) {
			case 0: {
				const s_6231 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*String*/[0,s_6231,".String"])
			} break;
			
			case 1: {
				const name_6232 = temp_6230[1];
				const params_6233 = temp_6230[2];
				{
					{
						let step_6234 = 0;
						const params_6235 = params_6233;
						if (step_6234 == 0 && params_6235 != null) { step_6234 = 1 };
						if (step_6234 == 1) { return Node.cloneData(p, node_6229, /*Ident*/[1,name_6232,params_6235.map((param) => (NodeType.clone(param))),".Ident"]) };
					};
					return Node.cloneData(p, node_6229, /*Ident*/[1,name_6232,null,".Ident"]);
				}
			} break;
			
			case 2: {
				const b_6236 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*Bool*/[2,b_6236,".Bool"])
			} break;
			
			case 5: {
				const s_6237 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*Int*/[5,s_6237,".Int"])
			} break;
			
			case 7: {
				const s_6238 = temp_6230[1];
				const meta_6239 = temp_6230[2];
				return Node.cloneData(p, node_6229, /*Float*/[7,s_6238,meta_6239,".Float"])
			} break;
			
			case 8: {
				return Node.cloneData(p, node_6229, /*Null*/[8])
			} break;
			
			case 3: {
				return Node.cloneData(p, node_6229, /*This*/[3])
			} break;
			
			case 15: {
				const expr_6240 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*Parenthesis*/[15,Node.cloneData(p, expr_6240, Node.clone(p, expr_6240)),".Parenthesis"])
			} break;
			
			case 33: {
				const expr_6241 = temp_6230[1];
				const index_6242 = temp_6230[2];
				return Node.cloneData(p, node_6229, /*Index*/[33,Node.cloneData(p, expr_6241, Node.clone(p, expr_6241)),Node.cloneData(p, index_6242, Node.clone(p, index_6242)),".Index"])
			} break;
			
			case 28: {
				const expr_6243 = temp_6230[1];
				const name_6244 = temp_6230[2];
				return Node.cloneData(p, node_6229, /*Dot*/[28,Node.cloneData(p, expr_6243, Node.clone(p, expr_6243)),name_6244,".Dot"])
			} break;
			
			case 29: {
				const expr_6245 = temp_6230[1];
				const name_6246 = temp_6230[2];
				return Node.cloneData(p, node_6229, /*DotUpper*/[29,Node.cloneData(p, expr_6245, Node.clone(p, expr_6245)),name_6246,".DotUpper"])
			} break;
			
			case 13: {
				const e_6247 = temp_6230[1];
				const args_6248 = temp_6230[2];
				const argNames_6249 = temp_6230[3];
				return Node.cloneData(p, node_6229, /*Call*/[13,Node.cloneData(p, e_6247, Node.clone(p, e_6247)),args_6248.map((arg_6250) => (Node.cloneData(p, arg_6250, Node.clone(p, arg_6250)))),argNames_6249,".Call"])
			} break;
			
			case 31: {
				const elements_6251 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*Array*/[31,elements_6251.map((arg_6252) => (Node.cloneData(p, arg_6252, Node.clone(p, arg_6252)))),".Array"])
			} break;
			
			case 10: {
				const a_6253 = temp_6230[1];
				const op_6254 = temp_6230[2];
				const b_6255 = temp_6230[3];
				return Node.cloneData(p, node_6229, /*Binop*/[10,Node.cloneData(p, a_6253, Node.clone(p, a_6253)),op_6254,Node.cloneData(p, b_6255, Node.clone(p, b_6255)),".Binop"])
			} break;
			
			case 49: {
				const name_6256 = temp_6230[1];
				const over_6257 = temp_6230[2];
				const by_6258 = temp_6230[3];
				const range_6259 = temp_6230[4];
				return Node.cloneData(p, node_6229, /*For*/[49,name_6256,Node.cloneData(p, over_6257, Node.clone(p, over_6257)),Node.cloneData(p, by_6258, Node.clone(p, by_6258)),Node.cloneData(p, range_6259, Node.clone(p, range_6259)),".For"])
			} break;
			
			case 38: {
				const names_6260 = temp_6230[1];
				const el_6261 = temp_6230[2];
				return Node.cloneData(p, node_6229, /*Object*/[38,names_6260,el_6261.map((arg_6262) => (Node.cloneData(p, arg_6262, Node.clone(p, arg_6262)))),".Object"])
			} break;
			
			case 51: {
				const t_6263 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*NodeTypeValue*/[51,t_6263,".NodeTypeValue"])
			} break;
			
			case 44: {
				const expr_6264 = temp_6230[1];
				const kind_6265 = temp_6230[2];
				const toType_6266 = temp_6230[3];
				return Node.cloneData(p, node_6229, /*As*/[44,Node.cloneData(p, expr_6264, Node.clone(p, expr_6264)),kind_6265,NodeType.clone(toType_6266),".As"])
			} break;
			
			case 30: {
				const path_6267 = temp_6230[1];
				const t_6268 = temp_6230[2];
				const args_6269 = temp_6230[3];
				const fields_6270 = temp_6230[4];
				const el_6271 = temp_6230[5];
				const argNames_6272 = temp_6230[6];
				return Node.cloneData(p, node_6229, /*New*/[30,path_6267,t_6268,args_6269.map((arg_6273) => (Node.cloneData(p, arg_6273, Node.clone(p, arg_6273)))),fields_6270,el_6271.map((arg_6274) => (Node.cloneData(p, arg_6274, Node.clone(p, arg_6274)))),argNames_6272,".New"])
			} break;
			
			case 20: {
				const op_6275 = temp_6230[1];
				const postfix_6276 = temp_6230[2];
				const e_6277 = temp_6230[3];
				return Node.cloneData(p, node_6229, /*Unop*/[20,op_6275,postfix_6276,Node.cloneData(p, e_6277, Node.clone(p, e_6277)),".Unop"])
			} break;
			
			case 23: {
				const expr_6278 = temp_6230[1];
				const vars_6279 = temp_6230[2];
				const retType_6280 = temp_6230[3];
				return Node.cloneData(p, node_6229, /*Arrow*/[23,Node.cloneData(p, expr_6278, Node.clone(p, expr_6278)),vars_6279.map((arg_6281) => (Node.cloneData(p, arg_6281, Node.clone(p, arg_6281)))),retType_6280,".Arrow"])
			} break;
			
			case 47: {
				const f_6282 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*Static*/[47,Node.cloneData(p, f_6282, Node.clone(p, f_6282)),".Static"])
			} break;
			
			case 16: {
				const e_6283 = temp_6230[1];
				{
					{
						let step_6284 = 0;
						const e_6285 = e_6283;
						if (step_6284 == 0 && e_6285 != null) { step_6284 = 1 };
						if (step_6284 == 1) { return Node.cloneData(p, node_6229, /*Return*/[16,Node.cloneData(p, e_6285, Node.clone(p, e_6285)),".Return"]) };
					};
					return Node.cloneData(p, node_6229, /*Return*/[16,null,".Return"]);
				}
			} break;
			
			case 12: {
				const el_6286 = temp_6230[1];
				return Node.cloneData(p, node_6229, /*Block*/[12,el_6286.map((arg_6287) => (Node.cloneData(p, arg_6287, Node.clone(p, arg_6287)))),".Block"])
			} break;
			
			case 14: {
				const econd_6288 = temp_6230[1];
				const eif_6289 = temp_6230[2];
				const eelse_6290 = temp_6230[3];
				const ternary_6291 = temp_6230[4];
				return Node.cloneData(p, node_6229, /*If*/[14,econd_6288.map((arg_6292) => (Node.cloneData(p, arg_6292, Node.clone(p, arg_6292)))),Node.cloneData(p, eif_6289, Node.clone(p, eif_6289)),((eelse_6290 != null)? (Node.cloneData(p, eelse_6290, Node.clone(p, eelse_6290))) : null),ternary_6291,".If"])
			} break;
			
			case 24: {
				const name_6293 = temp_6230[1];
				const t_6294 = temp_6230[2];
				const expr_6295 = temp_6230[3];
				const const_6296 = temp_6230[4];
				const external_6297 = temp_6230[5];
				return Node.cloneData(p, node_6229, /*Var*/[24,name_6293,t_6294,Node.cloneData(p, expr_6295, Node.clone(p, expr_6295)),const_6296,external_6297,".Var"])
			} break;
			
			case 22: {
				const name_6298 = temp_6230[1];
				const body_6299 = temp_6230[2];
				const vars_6300 = temp_6230[3];
				const retType_6301 = temp_6230[4];
				const external_6302 = temp_6230[5];
				return Node.cloneData(p, node_6229, /*Function*/[22,name_6298,Node.cloneData(p, body_6299, Node.clone(p, body_6299)),vars_6300.map((arg_6303) => (Node.cloneData(p, arg_6303, Node.clone(p, arg_6303)))),retType_6301,external_6302,".Function"])
			} break;
			
			case 25: {
				const t_6304 = temp_6230[1];
				const extend_6305 = temp_6230[2];
				const implement_6306 = temp_6230[3];
				const fields_6307 = temp_6230[4];
				const external_6308 = temp_6230[5];
				const kind_6309 = temp_6230[6];
				return Node.cloneData(p, node_6229, /*Class*/[25,t_6304,extend_6305,implement_6306,fields_6307.map((arg_6310) => (Node.cloneData(p, arg_6310, Node.clone(p, arg_6310)))),external_6308,kind_6309,".Class"])
			} break;
			
			case null: case undefined: {
				return null
			} break;
			
			default: 
			{
			}
			};
		};
		console.log('Cannot clone', node_6229);
		return node_6229;
	} },
		cloneData: (project_6311, from, to) => { {
		const project_6312 = (project_6311);
		project_6312.mapDecorators.set(to, project_6312.mapDecorators.get(from));
		project_6312.data.set(to, project_6312.data.get(from));
		return to;
	} },
	}
	var Type = {
		stringify: (type_6350) => { {
		const temp = type_6350;
		switch (temp&&temp[0]) {
		case 6: {
			const type_6351 = temp[1];
			const generic_6352 = temp[2];
			{
				{
					let step = 0;
					const gen = generic_6352;
					if (step == 0 && gen != null) { step = 1 };
					if (step == 1) { return DataHelper.nameOf(type_6351.parent) + '<' + (() => {
						const result = [];
						const value_6353 = gen;
						for (const g of $toIterator(value_6353)) result.push(Type.stringify(g));
						return result;
					})().join(', ') + '>' };
				};
				return DataHelper.nameOf(type_6351.parent);
			}
		} break;
		
		case 1: {
			const index_6354 = temp[1];
			const name_6355 = temp[2];
			return '<' + name_6355 + ' at ' + index_6354 + '>'
		} break;
		
		case 5: {
			const type_6356 = temp[1];
			return DataHelper.nameOf(type_6356.parent)
		} break;
		
		case 12: {
			const args_6357 = temp[1];
			const returns_6358 = temp[2];
			return '(' + (() => {
				const result_6359 = [];
				const value_6360 = args_6357;
				for (const arg of $toIterator(value_6360)) result_6359.push(Type.stringify(arg));
				return result_6359;
			})().join(', ') + ') => ' + Type.stringify(returns_6358)
		} break;
		
		case 3: {
			const handle_6361 = temp[1];
			{
				{
					let step_6362 = 0;
					const value_6363 = handle_6361.value;
					if (step_6362 == 0 && value_6363 != null) { step_6362 = 1 };
					if (step_6362 == 1) { return Type.stringify(value_6363) + '?' };
				};
				return 'Unknown?';
			}
		} break;
		
		case 4: {
			const type_6364 = temp[1];
			return Type.stringify(type_6364) + '?'
		} break;
		
		case 8: {
			const type_6365 = temp[1];
			return DataHelper.nameOf(type_6365.parent)
		} break;
		
		case 9: {
			const type_6366 = temp[1];
			const tag_6367 = temp[2];
			{
				const tagName = type_6366.fieldNames[tag_6367];
				return DataHelper.nameOf(type_6366.parent) + '.' + tagName;
			}
		} break;
		
		case 2: {
			const handle_6368 = temp[1];
			{
				{
					let step_6369 = 0;
					const value_6370 = handle_6368.value;
					if (step_6369 == 0 && value_6370 != null) { step_6369 = 1 };
					if (step_6369 == 1) { return Type.stringify(value_6370) };
				};
				return 'Unknown';
			}
		} break;
		
		case 11: {
			const alias_6371 = temp[1];
			return NodeType.stringify(alias_6371.value)
		} break;
		
		case 0: {
			const value_6372 = temp[1];
			return value_6372
		} break;
		
		case 13: {
			const names_6373 = temp[1];
			const types_6374 = temp[2];
			return '{ ' + (() => {
				const result_6375 = [];
				const value_6376 = names_6373.length;
				for (const i of $toIterator(value_6376)) result_6375.push(names_6373[i] + Type.stringify(types_6374[i]));
				return result_6375;
			})().join(', ') + ' }'
		} break;
		
		case null: case undefined: {
			return 'could not infer type, try to set type manually'
		} break;
		
		default: 
		{
			console.log(type_6350);
			return '~?' + type_6350 + '?~';
		}
		};
	} },
		primaryName: (type_6377) => { {
		const temp_6378 = type_6377;
		switch (temp_6378&&temp_6378[0]) {
		case 5: {
			const type_6379 = temp_6378[1];
			return type_6379.name
		} break;
		
		case 6: {
			const type_6380 = temp_6378[1];
			return type_6380.name
		} break;
		
		default: 
		return '~?' + type_6377 + '?~'
		};
	} },
		unwrapNullable: (t) => { {
		{
			const temp_6381 = t;
			switch (temp_6381&&temp_6381[0]) {
			case 3: {
				const handle_6382 = temp_6381[1];
				return handle_6382.value
			} break;
			
			case 4: {
				const t_6383 = temp_6381[1];
				return t_6383
			} break;
			};
		};
		return t;
	} },
	}
	var process_3459 = $global.process
	var console_260 = $global.console
	var Map_254 = $global.Map
	var Map_247 = $global.Map
	var Map_240 = $global.Map
	var Map_233 = $global.Map
	var Map_226 = $global.Map
	var Map_219 = $global.Map
	var Map_212 = $global.Map
	var Map_205 = $global.Map
	var Map_198 = $global.Map
	var Map_191 = $global.Map
	var Map_184 = $global.Map
	var Map_177 = $global.Map
	var Map_170 = $global.Map
	var Map_163 = $global.Map
	var Map_156 = $global.Map
	var Map_149 = $global.Map
	var Map_142 = $global.Map
	var Map_135 = $global.Map
	var Map_128 = $global.Map
	var Map_121 = $global.Map
	var Map_114 = $global.Map
	var Map_107 = $global.Map
	var Map_100 = $global.Map
	var Map_93 = $global.Map
	var Map_86 = $global.Map
	var Map_79 = $global.Map
	var Map_72 = $global.Map
	var Map_65 = $global.Map
	var Map_58 = $global.Map
	var Map_51 = $global.Map
	var Normalizer = class {
		constructor(project) { 
			this.niceProject = new NiceProject()
			this.keywords = []
			this.reservedGlobals = []
			this.collected = []
			this.nativeEnums = false
			this.globalAccessor = '<!--global-->'
			this.inline = new Map()
			this.nonInlineRead = new Map()
			this.neverReassignedLocal = new Map()
			this.neverReassignedLocalParent = new Map()
			this.scopes = [new Map()]
			this.globals = []
			this.id = Math.round(Math.random() * 123)
			this.parentNames = new Map()
		this.project = project };
		normalize() {
		for (const global of $toIterator(this.reservedGlobals)) {
			this.addToScope(global);
		};
		for (const file of $toIterator(this.project.moduleInfo)) {
			for (const e of $toIterator(file.nodes)) {
				const temp = e;
				switch (temp&&temp[0]) {
				case 25: {
					const t = temp[1];
					const ext = temp[2];
					const impl = temp[3];
					const fields = temp[4];
					const external = temp[5];
					this.renameClassFields(fields)
				} break;
				
				case 39: {
					const t_3473 = temp[1];
					const fields_3474 = temp[2];
					const valuesType = temp[3];
					this.renameClassFields(fields_3474)
				} break;
				
				case 24: {
					const name = temp[1];
					const t_3475 = temp[2];
					const expr = temp[3];
					const const_3476 = temp[4];
					const external_3477 = temp[5];
					{
						const atts = this.project.mapDecorators.get(e);
						{
							let step = 0;
							const native = Normalizer.getDec(atts, 'rename');
							if (step == 0 && native != null) { step = 1 };
							if (step == 1) {
								const temp_3478 = native.values[0];
								switch (temp_3478&&temp_3478[0]) {
								case 0: {
									const s = temp_3478[1];
									this.uniqueNative(s, e)
								} break;
								
								default: 
								throw '@rename takes string as argument'
								};
							} else {
								this.unique(name, e);
							};
						};
					}
				} break;
				
				case 22: {
					const name_3479 = temp[1];
					const expr_3480 = temp[2];
					const vars = temp[3];
					const rettype = temp[4];
					const external_3481 = temp[5];
					if (this.parentNames.get(e) == null) {
						let step_3482 = 0;
						const name_3483 = this.getNative(e);
						if (step_3482 == 0 && name_3483 != null) { step_3482 = 1 };
						if (step_3482 == 1) { this.uniqueNative(name_3483, e) } else {
							let step_3484 = 0;
							const name_3485 = name_3479;
							if (step_3484 == 0 && name_3485 != null) { step_3484 = 1 };
							if (step_3484 == 1) { this.unique(name_3485, e) };
						};
					}
				} break;
				};
			};
		};
		const init_3486 = [];
		for (const file of $toIterator(this.project.moduleInfo)) {
			const initial = [];
			this.pushScope();
			for (const e of $toIterator(file.nodes)) {
				const temp_3487 = e;
				switch (temp_3487&&temp_3487[0]) {
				case 22: {
					{
						let step_3488 = 0;
						const s_3489 = this.nodeToStatement(e);
						if (step_3488 == 0 && s_3489 != null) { step_3488 = 1 };
						if (step_3488 == 1) { this.niceProject.globalFuncs.push(s_3489) };
					}
				} break;
				
				case 24: {
					{
						let step_3490 = 0;
						const s_3491 = this.nodeToStatement(e);
						if (step_3490 == 0 && s_3491 != null) { step_3490 = 1 };
						if (step_3490 == 1) { this.niceProject.globalVars.push(s_3491) };
					}
				} break;
				
				case 39: {
					this.fillStatement(e, 'path')
				} break;
				
				case 25: {
					this.fillStatement(e, 'path')
				} break;
				
				default: 
				{
					const statement = this.fillStatement(e, null);
					{
						const temp_3492 = statement;
						switch (temp_3492&&temp_3492[0]) {
						case null: case undefined: {
							{
							}
						} break;
						
						case 1: {
							const el = temp_3492[1];
							if (el.length > 0) { initial.push(statement) }
						} break;
						
						default: 
						initial.push(statement)
						};
					};
				}
				};
			};
			this.popScope();
			if (initial.length > 0) { init_3486.push(/*Block*/[1,initial,".Block"]) };
		};
		this.niceProject.init.push(/*Block*/[1,init_3486,".Block"]);
		if (this.niceProject.init.length > 1) { throw 'too many inits' };
		this.niceProject.package = this.package;
		this.niceProject.typer = this.typer;
		this.niceProject.mapDecorators = this.project.mapDecorators;
		this.niceProject.classes.sort((a, b) => {
			if (a.external == true) { return (-1) };
			if (a.extend == null) { return 0 };
			return 1;
		});
		return this.niceProject;
	};
		nodeToExpression(e) {
		const result = this.nodeToExpressionWithoutPosition(e);
		if (result != null) {
			this.niceProject.expressionPosition.set(result, this.project.data.get(e));
			if (this.niceProject.expressionType.get(result) == null) { this.niceProject.expressionType.set(result, this.typer.types.get(e)) };
		};
		return result;
	};
		nodeToExpressionWithoutPosition(e_3493) {
		if (e_3493 == null) { return null };
		{
			const temp_3494 = e_3493;
			switch (temp_3494&&temp_3494[0]) {
			case 0: {
				const v = temp_3494[1];
				{
					if (Normalizer.getDec(this.project.mapDecorators.get(e_3493), 'acpiHeaderSignature') != null) {
						const byteswap = (x) => { return ((x >> 24n) & 255n) | ((x >> 8n) & 65280n) | ((x << 8n) & 16711680n) | ((x << 24n) & 4278190080n) };
						const v_3495 = v.split('');
						v_3495.reverse();
						const v_3496 = v_3495.join('');
						const num32 = BigInt((v_3496.charCodeAt(0))) + BigInt((v_3496.charCodeAt(1))) * 256n + BigInt((v_3496.charCodeAt(2))) * 256n * 256n + BigInt((v_3496.charCodeAt(3))) * 256n * 256n * 256n;
						const result_3497 = '0x' + byteswap(num32).toString(16);
						console.log(v_3496 + ' == ' + num32);
						return /*MetaInt*/[2,result_3497,6,this.typer.typeUInt32,".MetaInt"];
					};
					return /*String*/[0,v,".String"];
				}
			} break;
			
			case 5: {
				const v_3498 = temp_3494[1];
				return /*Int*/[1,v_3498,".Int"]
			} break;
			
			case 6: {
				const v_3499 = temp_3494[1];
				const meta = temp_3494[2];
				return /*MetaInt*/[2,v_3499,meta,this.typer.types.get(e_3493),".MetaInt"]
			} break;
			
			case 7: {
				const v_3500 = temp_3494[1];
				return /*Float*/[3,v_3500,".Float"]
			} break;
			
			case 2: {
				const v_3501 = temp_3494[1];
				{
					if (v_3501) { return /*True*/[4] };
					return /*False*/[5];
				}
			} break;
			
			case 8: {
				return /*Null*/[7,this.typer.types.get(e_3493),".Null"]
			} break;
			
			case 51: {
				const t_3502 = temp_3494[1];
				{
					const temp_3503 = t_3502;
					switch (temp_3503&&temp_3503[0]) {
					case 1: {
						const name_3504 = temp_3503[1];
						return /*Ident*/[6,(() => {
							const result_3505 = this.parentNames.get(this.typer.parents.get(e_3493));
							if (result_3505 != null) { return result_3505 };
							return name_3504;
						})(),null,".Ident"]
					} break;
					};
				}
			} break;
			
			case 1: {
				const name_3506 = temp_3494[1];
				{
					const source = this.typer.parents.get(e_3493);
					{
						let step_3507 = 0;
						const value = this.inline.get(source);
						if (step_3507 == 0 && value != null) { step_3507 = 1 };
						if (step_3507 == 1) { return value };
					};
					this.nonInlineRead.set(source, true);
					{
						const temp_3508 = source;
						switch (temp_3508&&temp_3508[0]) {
						case null: case undefined: {
							throw ('Unmapped `' + (e_3493) + '` of name `' + (name_3506) + '` ') + JSON.stringify(this.project.data.get(e_3493))
						} break;
						
						case 24: {
							const name_3509 = temp_3508[1];
							{
								const staticSource = this.typer.parents.get(source);
								{
									let step_3510 = 0;
									const map = this.typer.parents.get(source);
									if (step_3510 == 0 && map != null) { step_3510 = 1 };
									if (step_3510 == 1) {
										const temp_3511 = (map);
										switch (temp_3511&&temp_3511[0]) {
										case 35: {
											{
												const name_3512 = (() => {
													const result_3513 = this.parentNames.get(source);
													if (result_3513 != null) { return result_3513 };
													return name_3509;
												})();
												const result_3514 = /*Ident*/[6,this.globalAccessor + name_3512,this.typer.types.get(source),".Ident"];
												{
													let step_3515 = 0;
													const name_3516 = this.getNative(source);
													if (step_3515 == 0 && name_3516 != null) { step_3515 = 1 };
													if (step_3515 == 1) { this.niceProject.native.set(result_3514, true) };
												};
												return result_3514;
											}
										} break;
										
										default: 
										{
											const type = this.typer.types.get(this.typer.parents.get(source));
											return /*Dot*/[9,/*This*/[8,type,".This"],this.getClassDotField(staticSource, name_3509),this.typer.types.get(e_3493),".Dot"];
										}
										};
									};
								};
							}
						} break;
						
						case 22: {
							const name_3517 = temp_3508[1];
							{
								let step_3518 = 0;
								const map_3519 = this.typer.parents.get(source);
								if (step_3518 == 0 && map_3519 != null) { step_3518 = 1 };
								if (step_3518 == 1) {
									const temp_3520 = (map_3519);
									switch (temp_3520&&temp_3520[0]) {
									case 35: {
										{
											const result_3521 = /*Ident*/[6,this.globalAccessor + ((() => {
												const result_3522 = this.parentNames.get(source);
												if (result_3522 != null) { return result_3522 };
												return name_3517;
											})()),null,".Ident"];
											{
												let step_3523 = 0;
												const name_3524 = this.getNative(source);
												if (step_3523 == 0 && name_3524 != null) { step_3523 = 1 };
												if (step_3523 == 1) { this.niceProject.native.set(result_3521, true) };
											};
											return result_3521;
										}
									} break;
									
									default: 
									{
										const type_3525 = this.typer.types.get(this.typer.parents.get(source));
										return /*Dot*/[9,/*This*/[8,type_3525,".This"],(() => {
											const result_3526 = this.parentNames.get(source);
											if (result_3526 != null) { return result_3526 };
											return name_3517;
										})(),this.typer.types.get(e_3493),".Dot"];
									}
									};
								};
							}
						} break;
						
						case 47: {
							const f = temp_3508[1];
							{
								const staticSource_3527 = this.typer.parents.get(source);
								{
									const temp_3528 = staticSource_3527;
									switch (temp_3528&&temp_3528[0]) {
									case 25: {
										const t_3529 = temp_3528[1];
										return /*Dot*/[9,/*Ident*/[6,DataHelper.extractTypeName(t_3529),null,".Ident"],this.getClassDotField(staticSource_3527, name_3506),this.typer.types.get(e_3493),".Dot"]
									} break;
									
									case 39: {
										const t_3530 = temp_3528[1];
										return /*Dot*/[9,/*Ident*/[6,DataHelper.extractTypeName(t_3530),null,".Ident"],this.getClassDotField(staticSource_3527, name_3506),this.typer.types.get(e_3493),".Dot"]
									} break;
									
									default: 
									throw ('staticSource is ' + (staticSource_3527) + ' for ' + (name_3506) + '')
									};
								};
							}
						} break;
						};
					};
					const result_3531 = /*Ident*/[6,(() => {
						const result_3532 = this.parentNames.get(source);
						if (result_3532 != null) { return result_3532 };
						return name_3506;
					})(),this.typer.types.get(e_3493),".Ident"];
					{
						let step_3533 = 0;
						const name_3534 = this.getNative(source);
						if (step_3533 == 0 && name_3534 != null) { step_3533 = 1 };
						if (step_3533 == 1) { this.niceProject.native.set(result_3531, true) };
					};
					return result_3531;
				}
			} break;
			
			case 28: {
				const expr_3535 = temp_3494[1];
				const name_3536 = temp_3494[2];
				{
					const parent = this.typer.parents.get(expr_3535);
					{
						const temp_3537 = parent;
						switch (temp_3537&&temp_3537[0]) {
						case 39: {
							const t_3538 = temp_3537[1];
							const fields_3539 = temp_3537[2];
							const valuesType_3540 = temp_3537[3];
							{
								{
									let step_3541 = 0;
									const temp_3542 = (!this.nativeEnums);
									let vt = null;
									if (step_3541 == 0 && temp_3542 != false) {
										vt = valuesType_3540;
										step_3541 = 1;
									};
									let tag = null;
									if (step_3541 == 1 && vt != null) {
										tag = this.getTag(parent, name_3536);
										step_3541 = 2;
									};
									if (step_3541 == 2 && tag != null) { step_3541 = 3 };
									if (step_3541 == 3) { return tag };
								};
								return /*Dot*/[9,this.nodeToExpression(expr_3535),(() => {
									const result_3543 = this.getClassDotField(parent, name_3536);
									if (result_3543 != null) { return result_3543 };
									return name_3536;
								})(),this.typer.types.get(e_3493),".Dot"];
							}
						} break;
						
						case 25: {
							return /*Dot*/[9,this.nodeToExpression(expr_3535),(() => {
								const result_3544 = this.getClassDotField(parent, name_3536);
								if (result_3544 != null) { return result_3544 };
								return name_3536;
							})(),this.typer.types.get(e_3493),".Dot"]
						} break;
						};
					};
					{
						let step_3545 = 0;
						const type_3546 = this.typer.types.get(expr_3535);
						if (step_3545 == 0 && type_3546 != null) { step_3545 = 1 };
						if (step_3545 == 1) {
							const temp_3547 = (type_3546);
							switch (temp_3547&&temp_3547[0]) {
							case 6: {
								const type_3548 = temp_3547[1];
								{
									const renamed = type_3548.fieldRenames[type_3548.fieldNames.indexOf(name_3536)];
									{
										let step_3549 = 0;
										const rename = renamed;
										if (step_3549 == 0 && rename != null) { step_3549 = 1 };
										if (step_3549 == 1) { return /*Dot*/[9,this.nodeToExpression(expr_3535),rename,this.typer.types.get(e_3493),".Dot"] };
									};
								}
							} break;
							};
						};
					};
					const value_3550 = this.nodeToExpression(expr_3535);
					if (name_3536 == 'length') {
						const temp_3551 = value_3550;
						switch (temp_3551&&temp_3551[0]) {
						case 0: {
							const s_3552 = temp_3551[1];
							return /*Int*/[1,s_3552.length,".Int"]
						} break;
						};
					};
					return /*Dot*/[9,value_3550,name_3536,this.typer.types.get(e_3493),".Dot"];
				}
			} break;
			
			case 29: {
				const expr_3553 = temp_3494[1];
				const name_3554 = temp_3494[2];
				{
					const parent_3555 = this.typer.parents.get(expr_3553);
					{
						const temp_3556 = parent_3555;
						switch (temp_3556&&temp_3556[0]) {
						case 39: {
							const t_3557 = temp_3556[1];
							const fields_3558 = temp_3556[2];
							const valuesType_3559 = temp_3556[3];
							{
								{
									let step_3560 = 0;
									const temp_3561 = (!this.nativeEnums);
									let vt_3562 = null;
									if (step_3560 == 0 && temp_3561 != false) {
										vt_3562 = valuesType_3559;
										step_3560 = 1;
									};
									let tag_3563 = null;
									if (step_3560 == 1 && vt_3562 != null) {
										tag_3563 = this.getTag(parent_3555, name_3554);
										step_3560 = 2;
									};
									if (step_3560 == 2 && tag_3563 != null) { step_3560 = 3 };
									if (step_3560 == 3) { return tag_3563 };
								};
								{
									let step_3564 = 0;
									const temp_3565 = (!this.nativeEnums);
									let temp_3566 = null;
									if (step_3564 == 0 && temp_3565 != false) {
										temp_3566 = valuesType_3559 == null;
										step_3564 = 1;
									};
									let tag_3567 = null;
									if (step_3564 == 1 && temp_3566 != false) {
										tag_3567 = this.getTag(parent_3555, name_3554);
										step_3564 = 2;
									};
									if (step_3564 == 2 && tag_3567 != null) { step_3564 = 3 };
									if (step_3564 == 3) { return /*Enum*/[28,DataHelper.extractTypeName(t_3557),name_3554,tag_3567,[],".Enum"] };
								};
								return /*Dot*/[9,this.nodeToExpression(expr_3553),(() => {
									const result_3568 = this.getClassDotField(parent_3555, name_3554);
									if (result_3568 != null) { return result_3568 };
									return name_3554;
								})(),this.typer.types.get(e_3493),".Dot"];
							}
						} break;
						
						case 25: {
							return /*Dot*/[9,this.nodeToExpression(expr_3553),(() => {
								const result_3569 = this.getClassDotField(parent_3555, name_3554);
								if (result_3569 != null) { return result_3569 };
								return name_3554;
							})(),this.typer.types.get(e_3493),".Dot"]
						} break;
						};
					};
					return /*Dot*/[9,this.nodeToExpression(expr_3553),name_3554,this.typer.types.get(e_3493),".Dot"];
				}
			} break;
			
			case 13: {
				const expr_3570 = temp_3494[1];
				const args = temp_3494[2];
				const argNames = temp_3494[3];
				{
					if (args.length == 1) {
						const temp_3571 = expr_3570;
						switch (temp_3571&&temp_3571[0]) {
						case 28: {
							const expr_3572 = temp_3571[1];
							const name_3573 = temp_3571[2];
							if (name_3573 == 'charCodeAt') {
								const temp_3574 = expr_3572;
								switch (temp_3574&&temp_3574[0]) {
								case 0: {
									const s_3575 = temp_3574[1];
									if (s_3575.indexOf('\\') == (-1)) {
										const temp_3576 = args[0];
										switch (temp_3576&&temp_3576[0]) {
										case 5: {
											const v_3577 = temp_3576[1];
											{
												const i = v_3577;
												if ((i < s_3575.length) && (i > (-1))) {
													const value_3578 = s_3575.charCodeAt(i);
													const result_3579 = (((!Number.isNaN(value_3578)))? (/*Int*/[1,'' + value_3578,".Int"]) : /*Int*/[1,'0',".Int"]);
													this.niceProject.expressionType.set(result_3579, this.typer.typeInt);
													return result_3579;
												};
											}
										} break;
										};
									}
								} break;
								};
							}
						} break;
						};
					};
					let kind = 11;
					{
						const temp_3580 = expr_3570;
						switch (temp_3580&&temp_3580[0]) {
						case 28: {
							const expr_3581 = temp_3580[1];
							{
								const temp_3582 = (this.typer.types.get(expr_3581));
								switch (temp_3582&&temp_3582[0]) {
								case 6: {
									kind = 12
								} break;
								
								case 5: {
									kind = 10
								} break;
								};
							}
						} break;
						};
					};
					const a_3583 = [];
					for (const arg of $toIterator(args)) {
						a_3583.push(this.nodeToExpression(arg));
					};
					{
						const temp_3584 = (this.typer.parents.get(expr_3570));
						switch (temp_3584&&temp_3584[0]) {
						case 22: {
							const vars_3585 = temp_3584[3];
							if (vars_3585.length > a_3583.length) {
								let i_3586 = 0;
								let it = 0;
								let at = vars_3585.length;
								while (it < at) {
									i_3586 = it;
									it++;
									{
										if (i_3586 < a_3583.length) { continue };
										{
											const temp_3587 = (vars_3585[i_3586]);
											switch (temp_3587&&temp_3587[0]) {
											case 24: {
												const value_3588 = temp_3587[3];
												{
													let step_3589 = 0;
													const value_3590 = value_3588;
													if (step_3589 == 0 && value_3590 != null) { step_3589 = 1 };
													if (step_3589 == 1) { a_3583.push(this.nodeToExpression(value_3590)) };
												}
											} break;
											};
										};
									};
								};
							}
						} break;
						};
					};
					if ((!this.nativeEnums)) {
						const temp_3591 = expr_3570;
						switch (temp_3591&&temp_3591[0]) {
						case 29: {
							const expr_3592 = temp_3591[1];
							const name_3593 = temp_3591[2];
							{
								const parent_3594 = this.typer.parents.get(expr_3592);
								{
									const temp_3595 = parent_3594;
									switch (temp_3595&&temp_3595[0]) {
									case 39: {
										const t_3596 = temp_3595[1];
										const fields_3597 = temp_3595[2];
										const valuesType_3598 = temp_3595[3];
										{
											let step_3599 = 0;
											const tag_3600 = this.getTag(parent_3594, name_3593);
											if (step_3599 == 0 && tag_3600 != null) { step_3599 = 1 };
											if (step_3599 == 1) { return /*Enum*/[28,DataHelper.extractTypeName(t_3596),name_3593,tag_3600,a_3583,".Enum"] };
										}
									} break;
									};
								};
							}
						} break;
						};
					};
					const atts_3601 = this.project.mapDecorators.get(this.typer.parents.get(expr_3570));
					{
						let step_3602 = 0;
						const infix = Normalizer.getDec(atts_3601, 'infix');
						if (step_3602 == 0 && infix != null) { step_3602 = 1 };
						if (step_3602 == 1) {
							const temp_3603 = infix.values[0];
							switch (temp_3603&&temp_3603[0]) {
							case 0: {
								const s_3604 = temp_3603[1];
								{
									const temp_3605 = expr_3570;
									switch (temp_3605&&temp_3605[0]) {
									case 1: {
										const params = temp_3605[2];
										{
											{
												let step_3606 = 0;
												const parames = params;
												if (step_3606 == 0 && parames != null) { step_3606 = 1 };
												if (step_3606 == 1) { return /*NativeOperator*/[26,0,a_3583,s_3604,params.map((param) => (this.typer.types.get(param))),this.typer.types.get(e_3493),".NativeOperator"] };
											};
											return /*NativeOperator*/[26,0,a_3583,s_3604,null,this.typer.types.get(e_3493),".NativeOperator"];
										}
									} break;
									};
								}
							} break;
							
							default: 
							throw '@infix takes string as argument'
							};
						};
					};
					{
						let step_3607 = 0;
						const operator = Normalizer.getDec(atts_3601, 'operator');
						if (step_3607 == 0 && operator != null) { step_3607 = 1 };
						if (step_3607 == 1) {
							const temp_3608 = operator.values[0];
							switch (temp_3608&&temp_3608[0]) {
							case 0: {
								const s_3609 = temp_3608[1];
								{
									const temp_3610 = expr_3570;
									switch (temp_3610&&temp_3610[0]) {
									case 1: {
										const params_3611 = temp_3610[2];
										{
											{
												let step_3612 = 0;
												const parames_3613 = params_3611;
												if (step_3612 == 0 && parames_3613 != null) { step_3612 = 1 };
												if (step_3612 == 1) { return /*NativeOperator*/[26,1,a_3583,s_3609,params_3611.map((param_3614) => (this.typer.types.get(param_3614))),this.typer.types.get(e_3493),".NativeOperator"] };
											};
											return /*NativeOperator*/[26,1,a_3583,s_3609,null,this.typer.types.get(e_3493),".NativeOperator"];
										}
									} break;
									};
								}
							} break;
							
							default: 
							throw '@operator takes string as argument'
							};
						};
					};
					const v_3615 = this.nodeToExpression(expr_3570);
					{
						const temp_3616 = v_3615;
						switch (temp_3616&&temp_3616[0]) {
						case 9: {
							const expr_3617 = temp_3616[1];
							{
								const temp_3618 = expr_3617;
								switch (temp_3618&&temp_3618[0]) {
								case 8: {
									kind = 12
								} break;
								};
							}
						} break;
						};
					};
					return /*Call*/[10,v_3615,a_3583,this.typer.types.get(e_3493),kind,".Call"];
				}
			} break;
			
			case 10: {
				const a_3619 = temp_3494[1];
				const op = temp_3494[2];
				const b_3620 = temp_3494[3];
				{
					const ea = this.nodeToExpression(a_3619);
					const eb = this.nodeToExpression(b_3620);
					if (op == 111) {
						const temp_3621 = ea;
						switch (temp_3621&&temp_3621[0]) {
						case 0: {
							const sa = temp_3621[1];
							{
								const temp_3622 = eb;
								switch (temp_3622&&temp_3622[0]) {
								case 0: {
									const sb = temp_3622[1];
									return /*String*/[0,sa + sb,".String"]
								} break;
								
								case 1: {
									const sb_3623 = temp_3622[1];
									return /*String*/[0,sa + sb_3623,".String"]
								} break;
								
								case 3: {
									const sb_3624 = temp_3622[1];
									return /*String*/[0,sa + sb_3624,".String"]
								} break;
								
								case 4: {
									return /*String*/[0,sa + 'true',".String"]
								} break;
								
								case 5: {
									return /*String*/[0,sa + 'false',".String"]
								} break;
								};
							}
						} break;
						
						case 1: {
							const sa_3625 = temp_3621[1];
							{
								const temp_3626 = eb;
								switch (temp_3626&&temp_3626[0]) {
								case 1: {
									const sb_3627 = temp_3626[1];
									return /*Int*/[1,sa_3625 + sb_3627,".Int"]
								} break;
								
								case 3: {
									const sb_3628 = temp_3626[1];
									return /*Float*/[3,sa_3625 + sb_3628,".Float"]
								} break;
								
								case 0: {
									const sb_3629 = temp_3626[1];
									return /*String*/[0,sa_3625 + sb_3629,".String"]
								} break;
								};
							}
						} break;
						
						case 3: {
							const sa_3630 = temp_3621[1];
							{
								const temp_3631 = eb;
								switch (temp_3631&&temp_3631[0]) {
								case 1: {
									const sb_3632 = temp_3631[1];
									return /*Float*/[3,sa_3630 + sb_3632,".Float"]
								} break;
								
								case 3: {
									const sb_3633 = temp_3631[1];
									return /*Float*/[3,sa_3630 + sb_3633,".Float"]
								} break;
								
								case 0: {
									const sb_3634 = temp_3631[1];
									return /*String*/[0,sa_3630 + sb_3634,".String"]
								} break;
								};
							}
						} break;
						};
					};
					if (op == 93) {
						const temp_3635 = ea;
						switch (temp_3635&&temp_3635[0]) {
						case 4: {
							{
								const temp_3636 = eb;
								switch (temp_3636&&temp_3636[0]) {
								case 5: {
									return /*True*/[4]
								} break;
								
								case 4: {
									return /*True*/[4]
								} break;
								};
							}
						} break;
						
						case 5: {
							{
								const temp_3637 = eb;
								switch (temp_3637&&temp_3637[0]) {
								case 5: {
									return /*False*/[5]
								} break;
								
								case 4: {
									return /*True*/[4]
								} break;
								};
							}
						} break;
						};
					};
					if (op == 92) {
						const temp_3638 = ea;
						switch (temp_3638&&temp_3638[0]) {
						case 4: {
							{
								const temp_3639 = eb;
								switch (temp_3639&&temp_3639[0]) {
								case 5: {
									return /*False*/[5]
								} break;
								
								case 4: {
									return /*True*/[4]
								} break;
								};
							}
						} break;
						
						case 5: {
							{
								const temp_3640 = eb;
								switch (temp_3640&&temp_3640[0]) {
								case 5: {
									return /*False*/[5]
								} break;
								
								case 4: {
									return /*False*/[5]
								} break;
								};
							}
						} break;
						};
					};
					if (op == 95) {
						const temp_3641 = ea;
						switch (temp_3641&&temp_3641[0]) {
						case 4: {
							{
								const temp_3642 = eb;
								switch (temp_3642&&temp_3642[0]) {
								case 5: {
									return /*False*/[5]
								} break;
								
								case 4: {
									return /*True*/[4]
								} break;
								};
							}
						} break;
						
						case 5: {
							{
								const temp_3643 = eb;
								switch (temp_3643&&temp_3643[0]) {
								case 5: {
									return /*True*/[4]
								} break;
								
								case 4: {
									return /*False*/[5]
								} break;
								};
							}
						} break;
						
						case 0: {
							const sa_3644 = temp_3641[1];
							{
								const temp_3645 = eb;
								switch (temp_3645&&temp_3645[0]) {
								case 0: {
									const sb_3646 = temp_3645[1];
									{
										if (sa_3644 == sb_3646) { return /*True*/[4] };
										return /*False*/[5];
									}
								} break;
								};
							}
						} break;
						
						case 1: {
							const sa_3647 = temp_3641[1];
							{
								const temp_3648 = eb;
								switch (temp_3648&&temp_3648[0]) {
								case 1: {
									const sb_3649 = temp_3648[1];
									{
										if (sa_3647 == sb_3649) { return /*True*/[4] };
										return /*False*/[5];
									}
								} break;
								};
							}
						} break;
						
						case 7: {
							{
								const temp_3650 = eb;
								switch (temp_3650&&temp_3650[0]) {
								case 4: {
									return /*False*/[5]
								} break;
								
								case 5: {
									return /*False*/[5]
								} break;
								
								case 0: {
									return /*False*/[5]
								} break;
								
								case 1: {
									return /*False*/[5]
								} break;
								
								case 6: {
									const type_3651 = temp_3650[2];
									{
										const temp_3652 = type_3651;
										switch (temp_3652&&temp_3652[0]) {
										case 4: {
											{
											}
										} break;
										
										case 3: {
											{
											}
										} break;
										
										case 2: {
											{
											}
										} break;
										
										default: 
										return /*False*/[5]
										};
									}
								} break;
								};
							}
						} break;
						};
					};
					if (op == 103) {
						const temp_3653 = ea;
						switch (temp_3653&&temp_3653[0]) {
						case 4: {
							{
								const temp_3654 = eb;
								switch (temp_3654&&temp_3654[0]) {
								case 5: {
									return /*True*/[4]
								} break;
								
								case 4: {
									return /*False*/[5]
								} break;
								};
							}
						} break;
						
						case 5: {
							{
								const temp_3655 = eb;
								switch (temp_3655&&temp_3655[0]) {
								case 5: {
									return /*False*/[5]
								} break;
								
								case 4: {
									return /*True*/[4]
								} break;
								};
							}
						} break;
						
						case 0: {
							const sa_3656 = temp_3653[1];
							{
								const temp_3657 = eb;
								switch (temp_3657&&temp_3657[0]) {
								case 0: {
									const sb_3658 = temp_3657[1];
									{
										if (sa_3656 != sb_3658) { return /*True*/[4] };
										return /*False*/[5];
									}
								} break;
								};
							}
						} break;
						
						case 1: {
							const sa_3659 = temp_3653[1];
							{
								const temp_3660 = eb;
								switch (temp_3660&&temp_3660[0]) {
								case 1: {
									const sb_3661 = temp_3660[1];
									{
										if (sa_3659 != sb_3661) { return /*True*/[4] };
										return /*False*/[5];
									}
								} break;
								};
							}
						} break;
						};
					};
					return /*Binop*/[12,ea,op,eb,this.typer.types.get(e_3493),".Binop"];
				}
			} break;
			
			case 30: {
				const path = temp_3494[1];
				const t_3662 = temp_3494[2];
				const args_3663 = temp_3494[3];
				const fields_3664 = temp_3494[4];
				const el_3665 = temp_3494[5];
				{
					const v_3666 = /*Ident*/[6,(() => {
						const result_3667 = this.parentNames.get(this.typer.parents.get(e_3493));
						if (result_3667 != null) { return result_3667 };
						return DataHelper.extractTypeName(t_3662);
					})(),null,".Ident"];
					const a_3668 = [];
					for (const arg of $toIterator(args_3663)) {
						a_3668.push(this.nodeToExpression(arg));
					};
					return /*New*/[11,v_3666,a_3668,this.typer.types.get(e_3493),".New"];
				}
			} break;
			
			case 22: {
				const name_3669 = temp_3494[1];
				const expr_3670 = temp_3494[2];
				const vars_3671 = temp_3494[3];
				const rettype_3672 = temp_3494[4];
				const external_3673 = temp_3494[5];
				{
					const a_3674 = [];
					const defaults = [];
					const types = [];
					for (const arg of $toIterator(vars_3671)) {
						const temp_3675 = arg;
						switch (temp_3675&&temp_3675[0]) {
						case 24: {
							const name_3676 = temp_3675[1];
							const t_3677 = temp_3675[2];
							const expr_3678 = temp_3675[3];
							const const_3679 = temp_3675[4];
							{
								a_3674.push(this.unique(name_3676, arg));
								types.push(t_3677);
								if (expr_3678 != null) { defaults.push(this.nodeToExpression(expr_3678)) } else {
									defaults.push(null);
								};
							}
						} break;
						};
					};
					return /*Function*/[13,((name_3669 != null)? (this.unique(name_3669, e_3493)) : (null)),this.nodeToStatement(expr_3670),a_3674,defaults,this.typer.types.get(e_3493),".Function"];
				}
			} break;
			
			case 23: {
				const expr_3680 = temp_3494[1];
				const vars_3681 = temp_3494[2];
				const rettype_3682 = temp_3494[3];
				{
					const a_3683 = [];
					const defaults_3684 = [];
					const types_3685 = [];
					for (const arg of $toIterator(vars_3681)) {
						const temp_3686 = arg;
						switch (temp_3686&&temp_3686[0]) {
						case 24: {
							const name_3687 = temp_3686[1];
							const t_3688 = temp_3686[2];
							const expr_3689 = temp_3686[3];
							const const_3690 = temp_3686[4];
							{
								a_3683.push(this.unique(name_3687, arg));
								types_3685.push(t_3688);
								if (expr_3689 != null) { defaults_3684.push(this.nodeToExpression(expr_3689)) } else {
									defaults_3684.push(null);
								};
							}
						} break;
						};
					};
					return /*Arrow*/[14,this.nodeToExpression(expr_3680),a_3683,defaults_3684,types_3685,rettype_3682,this.typer.types.get(e_3493),".Arrow"];
				}
			} break;
			
			case 12: {
				const el_3691 = temp_3494[1];
				{
					if (el_3691.length == 0) { return /*Object*/[16,[],[],[],".Object"] };
					if (el_3691.length == 1) { return this.nodeToExpression(el_3691[0]) };
					const block = [];
					let i_3692 = 0;
					while (i_3692 < el_3691.length - 1) {
						{
							let step_3693 = 0;
							const s_3694 = this.nodeToStatement(el_3691[i_3692]);
							if (step_3693 == 0 && s_3694 != null) { step_3693 = 1 };
							if (step_3693 == 1) { block.push(s_3694) };
						};
						i_3692++;
					};
					const result_3695 = el_3691[el_3691.length - 1];
					block.push(/*Return*/[6,this.nodeToExpression(result_3695),".Return"]);
					return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,block,".Block"],[],[],null,".Function"],".Parenthesis"],[],this.typer.types.get(result_3695),11,".Call"];
				}
			} break;
			
			case 38: {
				const names = temp_3494[1];
				const el_3696 = temp_3494[2];
				{
					const els = [];
					const types_3697 = [];
					for (const e of $toIterator(el_3696)) {
						els.push(this.nodeToExpression(e));
						types_3697.push(this.typer.types.get(e));
					};
					return /*Object*/[16,names,els,types_3697,".Object"];
				}
			} break;
			
			case 15: {
				const inner = temp_3494[1];
				{
					const value_3698 = this.nodeToExpression(this.unwrapParens(inner));
					{
						const temp_3699 = value_3698;
						switch (temp_3699&&temp_3699[0]) {
						case 1: {
							return value_3698
						} break;
						
						case 0: {
							return value_3698
						} break;
						
						case 3: {
							return value_3698
						} break;
						
						case 4: {
							return value_3698
						} break;
						
						case 5: {
							return value_3698
						} break;
						
						case 7: {
							return value_3698
						} break;
						};
					};
					return /*Parenthesis*/[15,value_3698,".Parenthesis"];
				}
			} break;
			
			case 31: {
				const el_3700 = temp_3494[1];
				{
					if (el_3700.length == 1) {
						const temp_3701 = el_3700[0];
						switch (temp_3701&&temp_3701[0]) {
						case 49: {
							const name_3702 = temp_3701[1];
							const over = temp_3701[2];
							const by = temp_3701[3];
							const range = temp_3701[4];
							{
								const block_3703 = [];
								const result_3704 = this.unique('result', null);
								const resultType = this.typer.types.get(e_3493);
								block_3703.push(/*Const*/[4,result_3704,/*Array*/[17,[],this.typer.types.get(e_3493),".Array"],this.typer.types.get(e_3493),".Const"]);
								const value_3705 = this.unique('value', null);
								const valueType = this.typer.types.get(el_3700[0]);
								block_3703.push(/*Const*/[4,value_3705,this.nodeToExpression(over),valueType,".Const"]);
								const push = /*Call*/[2,/*Dot*/[9,/*Ident*/[6,result_3704,this.typer.types.get(e_3493),".Ident"],'push',null,".Dot"],[this.nodeToExpression(by)],[],12,".Call"];
								const fillLoop = () => {
									{
										const temp_3706 = over;
										switch (temp_3706&&temp_3706[0]) {
										case 5: {
											const s_3707 = temp_3706[1];
											{
												const i_3708 = name_3702;
												block_3703.push(/*Const*/[4,i_3708,/*Int*/[1,(-1),".Int"],this.typer.typeInt,".Const"]);
												block_3703.push(/*While*/[13,/*Binop*/[12,/*Parenthesis*/[15,/*Binop*/[12,/*Ident*/[6,i_3708,this.typer.typeInt,".Ident"],111,/*Int*/[1,1,".Int"],this.typer.typeInt,".Binop"],".Parenthesis"],99,/*Ident*/[6,value_3705,valueType,".Ident"],this.typer.typeBool,".Binop"],/*Block*/[1,[/*Increment*/[14,/*Ident*/[6,i_3708,this.typer.typeInt,".Ident"],".Increment"], push],".Block"],true,".While"]);
												return;
											}
										} break;
										};
									};
									block_3703.push(/*For*/[12,name_3702,/*Ident*/[6,value_3705,valueType,".Ident"],push,".For"]);
								};
								fillLoop();
								block_3703.push(/*Return*/[6,/*Ident*/[6,result_3704,resultType,".Ident"],".Return"]);
								return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,block_3703,".Block"],[],[],/*Function*/[12,[],this.typer.types.get(e_3493),".Function"],".Function"],".Parenthesis"],[],this.typer.types.get(e_3493),11,".Call"];
							}
						} break;
						};
					};
					const els_3709 = [];
					const types_3710 = [];
					for (const e of $toIterator(el_3700)) {
						els_3709.push(this.nodeToExpression(e));
						types_3710.push(this.typer.types.get(e));
					};
					return /*Array*/[17,els_3709,this.typer.types.get(e_3493),".Array"];
				}
			} break;
			
			case 50: {
				const nullable = temp_3494[1];
				const otherwise = temp_3494[2];
				{
					const result_3711 = this.unique('result', null);
					const resultType_3712 = this.typer.types.get(nullable);
					return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,[/*Const*/[4,result_3711,this.nodeToExpression(nullable),resultType_3712,".Const"], /*If*/[7,/*Binop*/[12,/*Ident*/[6,result_3711,resultType_3712,".Ident"],103,/*Null*/[7,resultType_3712,".Null"],this.typer.typeBool,".Binop"],/*Return*/[6,/*Ident*/[6,result_3711,resultType_3712,".Ident"],".Return"],null,".If"], /*Return*/[6,this.nodeToExpression(otherwise),".Return"]],".Block"],[],[],/*Function*/[12,[],this.typer.types.get(otherwise),".Function"],".Function"],".Parenthesis"],[],this.typer.types.get(otherwise),11,".Call"];
				}
			} break;
			
			case 20: {
				const op_3713 = temp_3494[1];
				const postfix = temp_3494[2];
				const e_3714 = temp_3494[3];
				{
					{
						const temp_3715 = op_3713;
						switch (temp_3715) {
						case 87: case 86: {
							{
								const source_3716 = this.typer.parents.get(e_3714);
								{
									let step_3717 = 0;
									const source_3718 = source_3716;
									if (step_3717 == 0 && source_3718 != null) { step_3717 = 1 };
									if (step_3717 == 1) {
										const temp_3719 = source_3718;
										switch (temp_3719&&temp_3719[0]) {
										case 24: {
											const name_3720 = temp_3719[1];
											this.neverReassignedLocal.set(source_3718, false)
										} break;
										};
									};
								};
							}
						} break;
						};
					};
					const expression = this.nodeToExpression(e_3714);
					{
						const temp_3721 = op_3713;
						switch (temp_3721) {
						case 89: {
							{
								const temp_3722 = expression;
								switch (temp_3722&&temp_3722[0]) {
								case 4: {
									return /*False*/[5]
								} break;
								
								case 5: {
									return /*True*/[4]
								} break;
								};
							}
						} break;
						};
					};
					return /*Unop*/[19,op_3713,postfix,expression,".Unop"];
				}
			} break;
			
			case 3: {
				return /*This*/[8,this.typer.types.get(e_3493),".This"]
			} break;
			
			case 32: {
				const keys = temp_3494[1];
				const values = temp_3494[2];
				{
					const k = [];
					const v_3723 = [];
					for (const key of $toIterator(keys)) {
						k.push(this.nodeToExpression(key));
					};
					for (const value of $toIterator(values)) {
						v_3723.push(this.nodeToExpression(value));
					};
					return /*Map*/[18,k,v_3723,this.typer.types.get(keys[0]),this.typer.types.get(values[0]),".Map"];
				}
			} break;
			
			case 11: {
				const a_3724 = temp_3494[1];
				const op_3725 = temp_3494[2];
				const b_3726 = temp_3494[3];
				{
					const source_3727 = this.typer.parents.get(a_3724);
					{
						let step_3728 = 0;
						const source_3729 = source_3727;
						if (step_3728 == 0 && source_3729 != null) { step_3728 = 1 };
						if (step_3728 == 1) {
							const temp_3730 = source_3729;
							switch (temp_3730&&temp_3730[0]) {
							case 24: {
								const name_3731 = temp_3730[1];
								this.neverReassignedLocal.set(source_3729, false)
							} break;
							};
						};
					};
					return /*Assignop*/[25,this.nodeToExpression(a_3724),op_3725,this.nodeToExpression(b_3726),".Assignop"];
				}
			} break;
			
			case 14: {
				const econd = temp_3494[1];
				const eif = temp_3494[2];
				const eelse = temp_3494[3];
				{
					let binds = false;
					for (const cond of $toIterator(econd)) {
						const temp_3732 = cond;
						switch (temp_3732&&temp_3732[0]) {
						case 24: {
							binds = true
						} break;
						};
					};
					if (((!binds)) && (econd.length == 1)) { return /*If*/[21,this.nodeToExpression(econd[0]),this.nodeToExpression(eif),this.nodeToExpression(eelse),".If"] };
					if ((!binds)) {
						let parens = /*Parenthesis*/[15,this.nodeToExpression(econd[0]),".Parenthesis"];
						let i_3733 = 1;
						while (i_3733 < econd.length) {
							parens = /*Binop*/[12,parens,92,/*Parenthesis*/[15,this.nodeToExpression(econd[i_3733]),".Parenthesis"],this.typer.typeBool,".Binop"];
							i_3733++;
						};
						return /*If*/[21,parens,this.nodeToExpression(eif),this.nodeToExpression(eelse),".If"];
					};
					return /*If*/[21,this.nodeToExpression(econd[0]),this.nodeToExpression(eif),this.nodeToExpression(eelse),".If"];
				}
			} break;
			
			case 33: {
				const expr_3734 = temp_3494[1];
				const index = temp_3494[2];
				return /*Index*/[22,this.nodeToExpression(expr_3734),this.nodeToExpression(index),this.typer.types.get(e_3493),".Index"]
			} break;
			
			case 44: {
				const e_3735 = temp_3494[1];
				const kind_3736 = temp_3494[2];
				const t_3737 = temp_3494[3];
				{
					const temp_3738 = kind_3736;
					switch (temp_3738) {
					case 81: {
						console.log('`as?` is not yet supported by normalizer, only `as!`')
					} break;
					
					case 89: {
						return /*UnsafeBitCast*/[23,this.nodeToExpression(e_3735),this.typer.types.get(t_3737),".UnsafeBitCast"]
					} break;
					
					default: 
					console.log('`as` is not yet supported by normalizer, only `as!`')
					};
				}
			} break;
			
			case 43: {
				const e_3739 = temp_3494[1];
				const t_3740 = temp_3494[2];
				return /*Is*/[24,this.nodeToExpression(e_3739),this.typer.types.get(t_3740),".Is"]
			} break;
			
			case 34: {
				const exprs = temp_3494[1];
				const conds = temp_3494[2];
				const guards = temp_3494[3];
				const cases = temp_3494[4];
				{
					const block_3741 = [];
					const caseRet = [];
					let funcType = this.typer.typeVoid;
					let resultType_3742 = this.typer.typeVoid;
					for (const c of $toIterator(cases)) {
						resultType_3742 = this.typer.types.get(c);
						funcType = /*Function*/[12,[],resultType_3742,".Function"];
						caseRet.push(/*Return*/[16,c,".Return"]);
					};
					block_3741.push(this.nodeToStatement(/*Switch*/[34,exprs,conds,guards,caseRet,".Switch"]));
					return /*Call*/[10,/*Parenthesis*/[15,/*Function*/[13,null,/*Block*/[1,block_3741,".Block"],[],[],funcType,".Function"],".Parenthesis"],[],resultType_3742,11,".Call"];
				}
			} break;
			
			case 35: {
				{
				}
			} break;
			
			case 37: {
				{
				}
			} break;
			
			case 9: {
				{
				}
			} break;
			
			default: 
			console.error('(internal warning) Unknown node type for expression:', e_3493, this.project.data.get(e_3493))
			};
		};
		return null;
	};
		nodeToStatement(e_3743) {
		const result_3744 = this.nodeToStatementWithoutPosition(e_3743);
		if (result_3744 != null) { this.niceProject.statementPosition.set(result_3744, this.project.data.get(e_3743)) };
		return result_3744;
	};
		nodeToStatementWithoutPosition(e_3745) {
		if (e_3745 == null) { return null };
		{
			const temp_3746 = e_3745;
			switch (temp_3746&&temp_3746[0]) {
			case 12: {
				const el_3747 = temp_3746[1];
				{
					const els_3748 = [];
					let ignore = false;
					for (const e of $toIterator(el_3747)) {
						const statement_3749 = this.unwrapNestingBlocks(this.nodeToStatement(e));
						if (ignore) { continue };
						{
							const temp_3750 = statement_3749;
							switch (temp_3750&&temp_3750[0]) {
							case null: case undefined: {
								{
								}
							} break;
							
							case 1: {
								const sub = temp_3750[1];
								{
									const temp_3751 = sub.length;
									switch (temp_3751) {
									case 0: {
										{
										}
									} break;
									
									case 1: {
										els_3748.push(sub[0])
									} break;
									
									default: 
									els_3748.push(statement_3749)
									};
								}
							} break;
							
							case 18: {
								{
									els_3748.push(statement_3749);
									ignore = true;
								}
							} break;
							
							case 17: {
								{
									els_3748.push(statement_3749);
									ignore = true;
								}
							} break;
							
							case 6: {
								{
									els_3748.push(statement_3749);
									ignore = true;
								}
							} break;
							
							case 9: {
								{
									els_3748.push(statement_3749);
									ignore = true;
								}
							} break;
							
							default: 
							els_3748.push(statement_3749)
							};
						};
					};
					{
						let i_3752 = 0;
						let it_3753 = 0;
						let at_3754 = els_3748.length;
						while (it_3753 < at_3754) {
							i_3752 = it_3753;
							it_3753++;
							{
								const element = els_3748[i_3752];
								{
									const temp_3755 = element;
									switch (temp_3755&&temp_3755[0]) {
									case 3: {
										const name_3756 = temp_3755[1];
										const expr_3757 = temp_3755[2];
										const type_3758 = temp_3755[3];
										{
											let step_3759 = 0;
											const parent_3760 = this.neverReassignedLocalParent.get(element);
											let temp_3761 = null;
											if (step_3759 == 0 && parent_3760 != null) {
												temp_3761 = this.neverReassignedLocal.get(parent_3760) == true;
												step_3759 = 1;
											};
											if (step_3759 == 1 && temp_3761 != false) { step_3759 = 2 };
											if (step_3759 == 2) { els_3748[i_3752] = /*Const*/[4,name_3756,expr_3757,type_3758,".Const"] };
										}
									} break;
									};
								};
							};
						};
					};
					if (els_3748.length == 1) {
						const temp_3762 = els_3748[0];
						switch (temp_3762&&temp_3762[0]) {
						case 1: {
							return els_3748[0]
						} break;
						};
					};
					return /*Block*/[1,els_3748,".Block"];
				}
			} break;
			
			case 39: {
				const t_3763 = temp_3746[1];
				const fields_3764 = temp_3746[2];
				const valuesType_3765 = temp_3746[3];
				{
					this.renameClassFields(fields_3764);
					const isComplexEnum = valuesType_3765 == null;
					if (isComplexEnum) {
						const type_3766 = new NiceComplexEnum();
						type_3766.name = this.unique(DataHelper.extractTypeName(t_3763), e_3745);
						const atts_3767 = this.project.mapDecorators.get(e_3745);
						type_3766.expose = false;
						{
							let step_3768 = 0;
							const expose = Normalizer.getDec(atts_3767, 'expose');
							if (step_3768 == 0 && expose != null) { step_3768 = 1 };
							if (step_3768 == 1) {
								if (expose.values.length != 0) { throw '@expose takes zero arguments' };
								type_3766.expose = true;
							};
						};
						this.globals.push(type_3766.name);
						const names_3769 = [];
						const constructors = [];
						const constructorsTypes = [];
						const types_3770 = [];
						for (const f of $toIterator(fields_3764)) {
							const temp_3771 = f;
							switch (temp_3771&&temp_3771[0]) {
							case 51: {
								const t_3772 = temp_3771[1];
								{
									const temp_3773 = t_3772;
									switch (temp_3773&&temp_3773[0]) {
									case 1: {
										const name_3774 = temp_3773[1];
										{
											names_3769.push(name_3774);
											constructors.push(null);
											constructorsTypes.push(null);
											types_3770.push(null);
										}
									} break;
									};
								}
							} break;
							
							case 13: {
								const e_3775 = temp_3771[1];
								const args_3776 = temp_3771[2];
								const argNames_3777 = temp_3771[3];
								{
									{
										const temp_3778 = e_3775;
										switch (temp_3778&&temp_3778[0]) {
										case 51: {
											const t_3779 = temp_3778[1];
											{
												const temp_3780 = t_3779;
												switch (temp_3780&&temp_3780[0]) {
												case 1: {
													const name_3781 = temp_3780[1];
													names_3769.push(name_3781)
												} break;
												};
											}
										} break;
										};
									};
									constructors.push((() => {
										const result_3782 = [];
										const value_3783 = argNames_3777;
										for (const arg of $toIterator(value_3783)) result_3782.push(this.unique((arg), null));
										return result_3782;
									})());
									constructorsTypes.push((() => {
										const result_3784 = [];
										const value_3785 = args_3776;
										for (const arg of $toIterator(value_3785)) result_3784.push(this.typer.toType(Typer.nodeToNodeType(arg), arg));
										return result_3784;
									})());
									types_3770.push((() => {
										const result_3786 = [];
										const value_3787 = args_3776;
										for (const arg of $toIterator(value_3787)) result_3786.push(this.unique((arg), null));
										return result_3786;
									})());
								}
							} break;
							
							case 47: {
								const field = temp_3771[1];
								{
									const temp_3788 = field;
									switch (temp_3788&&temp_3788[0]) {
									case 24: {
										const name_3789 = temp_3788[1];
										const t_3790 = temp_3788[2];
										const expr_3791 = temp_3788[3];
										const const_3792 = temp_3788[4];
										{
											const uname = (() => {
												const result_3793 = this.parentNames.get(field);
												if (result_3793 != null) { return result_3793 };
												return this.unique(name_3789, field);
											})();
											if (const_3792) {
												const value_3794 = this.nodeToExpression(expr_3791);
												this.saveInlineIfViable(f, value_3794);
												type_3766.staticVars.push(/*Const*/[4,uname,value_3794,this.typer.types.get(field),".Const"]);
											} else {
												type_3766.staticVars.push(/*Var*/[3,uname,this.nodeToExpression(expr_3791),this.typer.types.get(field),".Var"]);
											};
										}
									} break;
									
									case 22: {
										const name_3795 = temp_3788[1];
										const expr_3796 = temp_3788[2];
										const vars_3797 = temp_3788[3];
										const rettype_3798 = temp_3788[4];
										const external_3799 = temp_3788[5];
										{
											const uname_3800 = (() => {
												const result_3801 = this.parentNames.get(field);
												if (result_3801 != null) { return result_3801 };
												return this.unique(name_3795, field);
											})();
											const a_3802 = [];
											const defaults_3803 = [];
											const types_3804 = [];
											for (const arg of $toIterator(vars_3797)) {
												const temp_3805 = arg;
												switch (temp_3805&&temp_3805[0]) {
												case 24: {
													const name_3806 = temp_3805[1];
													const t_3807 = temp_3805[2];
													const expr_3808 = temp_3805[3];
													const const_3809 = temp_3805[4];
													{
														a_3802.push(this.unique(name_3806, arg));
														types_3804.push(t_3807);
														if (expr_3808 != null) { defaults_3803.push(this.nodeToExpression(expr_3808)) } else {
															defaults_3803.push(null);
														};
													}
												} break;
												};
											};
											type_3766.staticMethods.push(/*Function*/[5,uname_3800,this.unwrapNestingBlocks(this.nodeToStatement(expr_3796)),a_3802,defaults_3803,this.typer.types.get(field),".Function"]);
										}
									} break;
									
									default: 
									console.error('(internal warning) Unknown complex enum static field kind:', field)
									};
								}
							} break;
							
							default: 
							console.error('(internal warning) Unknown complex enum field kind:', f)
							};
						};
						type_3766.names = names_3769;
						type_3766.constructors = constructors;
						type_3766.constructorsTypes = constructorsTypes;
						type_3766.types = types_3770;
						this.niceProject.enumsComplex.push(type_3766);
						return null;
					} else {
						const type_3810 = new NiceSimpleEnum();
						type_3810.name = DataHelper.extractTypeName(t_3763);
						const names_3811 = [];
						const values_3812 = [];
						for (const f of $toIterator(fields_3764)) {
							const temp_3813 = f;
							switch (temp_3813&&temp_3813[0]) {
							case 10: {
								const a_3814 = temp_3813[1];
								const op_3815 = temp_3813[2];
								const b_3816 = temp_3813[3];
								{
									{
										const temp_3817 = a_3814;
										switch (temp_3817&&temp_3817[0]) {
										case 51: {
											const t_3818 = temp_3817[1];
											{
												const temp_3819 = t_3818;
												switch (temp_3819&&temp_3819[0]) {
												case 1: {
													const name_3820 = temp_3819[1];
													names_3811.push(name_3820)
												} break;
												};
											}
										} break;
										};
									};
									{
										const temp_3821 = b_3816;
										switch (temp_3821&&temp_3821[0]) {
										case 0: {
											const s_3822 = temp_3821[1];
											values_3812.push(/*String*/[0,s_3822,".String"])
										} break;
										
										case 5: {
											const s_3823 = temp_3821[1];
											values_3812.push(/*Int*/[1,s_3823,".Int"])
										} break;
										
										default: 
										console.error('(internal warning) Unknown node field value kind:', b_3816)
										};
									};
								}
							} break;
							
							case 51: {
								const t_3824 = temp_3813[1];
								{
									const temp_3825 = t_3824;
									switch (temp_3825&&temp_3825[0]) {
									case 1: {
										const name_3826 = temp_3825[1];
										names_3811.push(name_3826)
									} break;
									};
								}
							} break;
							
							case 47: {
								const field_3827 = temp_3813[1];
								{
									const temp_3828 = field_3827;
									switch (temp_3828&&temp_3828[0]) {
									case 24: {
										const name_3829 = temp_3828[1];
										const t_3830 = temp_3828[2];
										const expr_3831 = temp_3828[3];
										const const_3832 = temp_3828[4];
										{
											const uname_3833 = (() => {
												const result_3834 = this.parentNames.get(field_3827);
												if (result_3834 != null) { return result_3834 };
												return this.unique(name_3829, field_3827);
											})();
											if (const_3832) {
												const value_3835 = this.nodeToExpression(expr_3831);
												this.saveInlineIfViable(f, value_3835);
												type_3810.staticVars.push(/*Const*/[4,uname_3833,value_3835,this.typer.types.get(field_3827),".Const"]);
											} else {
												type_3810.staticVars.push(/*Var*/[3,uname_3833,this.nodeToExpression(expr_3831),this.typer.types.get(field_3827),".Var"]);
											};
										}
									} break;
									
									case 22: {
										const name_3836 = temp_3828[1];
										const expr_3837 = temp_3828[2];
										const vars_3838 = temp_3828[3];
										const rettype_3839 = temp_3828[4];
										const external_3840 = temp_3828[5];
										{
											const uname_3841 = (() => {
												const result_3842 = this.parentNames.get(field_3827);
												if (result_3842 != null) { return result_3842 };
												return this.unique(name_3836, field_3827);
											})();
											const a_3843 = [];
											const defaults_3844 = [];
											const types_3845 = [];
											for (const arg of $toIterator(vars_3838)) {
												const temp_3846 = arg;
												switch (temp_3846&&temp_3846[0]) {
												case 24: {
													const name_3847 = temp_3846[1];
													const t_3848 = temp_3846[2];
													const expr_3849 = temp_3846[3];
													const const_3850 = temp_3846[4];
													{
														a_3843.push(this.unique(name_3847, arg));
														types_3845.push(t_3848);
														if (expr_3849 != null) { defaults_3844.push(this.nodeToExpression(expr_3849)) } else {
															defaults_3844.push(null);
														};
													}
												} break;
												};
											};
											type_3810.staticMethods.push(/*Function*/[5,uname_3841,this.unwrapNestingBlocks(this.nodeToStatement(expr_3837)),a_3843,defaults_3844,this.typer.types.get(field_3827),".Function"]);
										}
									} break;
									
									default: 
									console.error('(internal warning) Unknown simple enum static field kind:', field_3827)
									};
								}
							} break;
							
							default: 
							console.error('(internal warning) Unknown simple enum field kind:', f)
							};
						};
						type_3810.names = names_3811;
						type_3810.values = values_3812;
						this.niceProject.enumsSimple.push(type_3810);
						return null;
					};
				}
			} break;
			
			case 25: {
				const t_3851 = temp_3746[1];
				const ext_3852 = temp_3746[2];
				const impl_3853 = temp_3746[3];
				const fields_3854 = temp_3746[4];
				const external_3855 = temp_3746[5];
				{
					this.renameClassFields(fields_3854);
					const type_3856 = new NiceClass();
					type_3856.external = external_3855;
					type_3856.extend = DataHelper.extractTypeName(ext_3852);
					for (const implement of $toIterator(impl_3853)) {
						const temp_3857 = implement;
						switch (temp_3857&&temp_3857[0]) {
						case 1: {
							const name_3858 = temp_3857[1];
							type_3856.implement = name_3858
						} break;
						
						case 2: {
							const name_3859 = temp_3857[1];
							const params_3860 = temp_3857[2];
							{
								type_3856.implement = name_3859;
								type_3856.implementParams = (() => {
									const result_3861 = [];
									const value_3862 = params_3860;
									for (const param of $toIterator(value_3862)) result_3861.push(DataHelper.extractTypeName(param));
									return result_3861;
								})();
							}
						} break;
						};
					};
					{
						const temp_3863 = t_3851;
						switch (temp_3863&&temp_3863[0]) {
						case 1: {
							const name_3864 = temp_3863[1];
							{
							}
						} break;
						
						case 2: {
							const name_3865 = temp_3863[1];
							const params_3866 = temp_3863[2];
							type_3856.genericParams = (() => {
								const result_3867 = [];
								const value_3868 = params_3866;
								for (const param of $toIterator(value_3868)) result_3867.push(DataHelper.extractTypeName(param));
								return result_3867;
							})()
						} break;
						};
					};
					const atts_3869 = this.project.mapDecorators.get(e_3745);
					{
						let step_3870 = 0;
						const require_3871 = Normalizer.getDec(atts_3869, 'require');
						if (step_3870 == 0 && require_3871 != null) { step_3870 = 1 };
						if (step_3870 == 1) {
							const temp_3872 = require_3871.values[0];
							switch (temp_3872&&temp_3872[0]) {
							case 0: {
								const s_3873 = temp_3872[1];
								type_3856.jsRequire = s_3873
							} break;
							
							default: 
							throw '@require takes string as argument'
							};
						};
					};
					{
						let step_3874 = 0;
						const native_3875 = Normalizer.getDec(atts_3869, 'rename');
						if (step_3874 == 0 && native_3875 != null) { step_3874 = 1 };
						if (step_3874 == 1) {
							const temp_3876 = native_3875.values[0];
							switch (temp_3876&&temp_3876[0]) {
							case 0: {
								const s_3877 = temp_3876[1];
								{
									type_3856.jsNative = s_3877;
									type_3856.name = this.unique(s_3877, e_3745);
								}
							} break;
							
							default: 
							throw '@rename takes string as argument'
							};
						} else {
							const temp_3878 = (this.typer.types.get(e_3745));
							switch (temp_3878&&temp_3878[0]) {
							case 5: {
								const the = temp_3878[1];
								type_3856.name = this.unique(the.name, e_3745)
							} break;
							
							default: 
							type_3856.name = this.unique(DataHelper.extractTypeName(t_3851), e_3745)
							};
						};
					};
					this.globals.push(type_3856.name);
					for (const f of $toIterator(fields_3854)) {
						const temp_3879 = f;
						switch (temp_3879&&temp_3879[0]) {
						case 24: {
							const name_3880 = temp_3879[1];
							const t_3881 = temp_3879[2];
							const expr_3882 = temp_3879[3];
							const const_3883 = temp_3879[4];
							{
								const uname_3884 = (() => {
									const result_3885 = this.parentNames.get(f);
									if (result_3885 != null) { return result_3885 };
									return this.unique(name_3880, f);
								})();
								if (const_3883) {
									const value_3886 = this.nodeToExpression(expr_3882);
									this.saveInlineIfViable(f, value_3886);
									type_3856.vars.push(/*Const*/[4,uname_3884,value_3886,this.typer.types.get(f),".Const"]);
								} else {
									type_3856.vars.push(/*Var*/[3,uname_3884,this.nodeToExpression(expr_3882),this.typer.types.get(f),".Var"]);
								};
							}
						} break;
						
						case 26: {
							const field_3887 = temp_3879[1];
							{
								const temp_3888 = field_3887;
								switch (temp_3888&&temp_3888[0]) {
								case 24: {
									const name_3889 = temp_3888[1];
									const t_3890 = temp_3888[2];
									const expr_3891 = temp_3888[3];
									const const_3892 = temp_3888[4];
									{
										const uname_3893 = (() => {
											const result_3894 = this.parentNames.get(f);
											if (result_3894 != null) { return result_3894 };
											return this.unique(name_3889, f);
										})();
										if (const_3892) { type_3856.vars.push(/*Const*/[4,uname_3893,this.nodeToExpression(expr_3891),this.typer.types.get(field_3887),".Const"]) } else {
											type_3856.vars.push(/*Var*/[3,uname_3893,this.nodeToExpression(expr_3891),this.typer.types.get(field_3887),".Var"]);
										};
										type_3856.property.push(uname_3893);
									}
								} break;
								};
							}
						} break;
						
						case 22: {
							const name_3895 = temp_3879[1];
							const expr_3896 = temp_3879[2];
							const vars_3897 = temp_3879[3];
							const rettype_3898 = temp_3879[4];
							const external_3899 = temp_3879[5];
							{
								const uname_3900 = (((name_3895 == 'new'))? ('new') : ((() => {
									const result_3901 = this.parentNames.get(f);
									if (result_3901 != null) { return result_3901 };
									return this.unique(name_3895, f);
								})()));
								const a_3902 = [];
								const defaults_3903 = [];
								const types_3904 = [];
								for (const arg of $toIterator(vars_3897)) {
									const temp_3905 = arg;
									switch (temp_3905&&temp_3905[0]) {
									case 24: {
										const name_3906 = temp_3905[1];
										const t_3907 = temp_3905[2];
										const expr_3908 = temp_3905[3];
										const const_3909 = temp_3905[4];
										{
											a_3902.push(this.unique(name_3906, arg));
											types_3904.push(t_3907);
											if (expr_3908 != null) { defaults_3903.push(this.nodeToExpression(expr_3908)) } else {
												defaults_3903.push(null);
											};
										}
									} break;
									};
								};
								type_3856.methods.push(/*Function*/[5,uname_3900,this.unwrapNestingBlocks(this.nodeToStatement(expr_3896)),a_3902,defaults_3903,this.typer.types.get(f),".Function"]);
							}
						} break;
						
						case 47: {
							const field_3910 = temp_3879[1];
							{
								const temp_3911 = field_3910;
								switch (temp_3911&&temp_3911[0]) {
								case 24: {
									const name_3912 = temp_3911[1];
									const t_3913 = temp_3911[2];
									const expr_3914 = temp_3911[3];
									const const_3915 = temp_3911[4];
									{
										const uname_3916 = (() => {
											const result_3917 = this.parentNames.get(field_3910);
											if (result_3917 != null) { return result_3917 };
											return this.unique(name_3912, field_3910);
										})();
										if (const_3915) {
											const value_3918 = this.nodeToExpression(expr_3914);
											this.saveInlineIfViable(f, value_3918);
											type_3856.staticVars.push(/*Const*/[4,uname_3916,value_3918,this.typer.types.get(field_3910),".Const"]);
										} else {
											type_3856.staticVars.push(/*Var*/[3,uname_3916,this.nodeToExpression(expr_3914),this.typer.types.get(field_3910),".Var"]);
										};
									}
								} break;
								
								case 22: {
									const name_3919 = temp_3911[1];
									const expr_3920 = temp_3911[2];
									const vars_3921 = temp_3911[3];
									const rettype_3922 = temp_3911[4];
									{
										const uname_3923 = (() => {
											const result_3924 = this.parentNames.get(field_3910);
											if (result_3924 != null) { return result_3924 };
											return this.unique(name_3919, field_3910);
										})();
										const a_3925 = [];
										const defaults_3926 = [];
										const types_3927 = [];
										for (const arg of $toIterator(vars_3921)) {
											const temp_3928 = arg;
											switch (temp_3928&&temp_3928[0]) {
											case 24: {
												const name_3929 = temp_3928[1];
												const t_3930 = temp_3928[2];
												const expr_3931 = temp_3928[3];
												const const_3932 = temp_3928[4];
												{
													a_3925.push(this.unique(name_3929, arg));
													types_3927.push(t_3930);
													if (expr_3931 != null) { defaults_3926.push(this.nodeToExpression(expr_3931)) } else {
														defaults_3926.push(null);
													};
												}
											} break;
											};
										};
										type_3856.staticMethods.push(/*Function*/[5,uname_3923,this.unwrapNestingBlocks(this.nodeToStatement(expr_3920)),a_3925,defaults_3926,this.typer.types.get(field_3910),".Function"]);
									}
								} break;
								
								default: 
								console.error('(internal warning) Unknown class static field kind:', field_3910)
								};
							}
						} break;
						
						default: 
						console.error('(internal warning) Unknown class field kind:', f)
						};
					};
					this.niceProject.classes.push(type_3856);
					{
						const temp_3933 = (this.typer.types.get(e_3745));
						switch (temp_3933&&temp_3933[0]) {
						case 5: {
							const the_3934 = temp_3933[1];
							{
								type_3856.useless = the_3934.useless;
								const fillSignature = (signature, type_3935) => {
									const temp_3936 = type_3935;
									switch (temp_3936&&temp_3936[0]) {
									case 6: {
										const type_3937 = temp_3936[1];
										const generic = temp_3936[2];
										{
											{
												let step_3938 = 0;
												const native_3939 = this.getNative(type_3937.parent);
												if (step_3938 == 0 && native_3939 != null) { step_3938 = 1 };
												if (step_3938 == 1) { signature.push(native_3939) } else {
													signature.push(type_3937.name);
												};
											};
											const generic_3940 = (() => {
												const result_3941 = generic;
												if (result_3941 != null) { return result_3941 };
												return [];
											})();
											for (const param of $toIterator(generic_3940)) {
												fillSignature(signature, param);
											};
										}
									} break;
									
									case 9: {
										const type_3942 = temp_3936[1];
										signature.push(type_3942.name)
									} break;
									
									case 5: {
										const type_3943 = temp_3936[1];
										signature.push(type_3943.name)
									} break;
									
									case 8: {
										const type_3944 = temp_3936[1];
										signature.push(type_3944.name)
									} break;
									
									case 4: {
										const handle = temp_3936[1];
										{
											signature.push('Null');
											fillSignature(signature, handle);
										}
									} break;
									
									case 2: {
										const handle_3945 = temp_3936[1];
										{
											let step_3946 = 0;
											const type_3947 = handle_3945.value;
											if (step_3946 == 0 && type_3947 != null) { step_3946 = 1 };
											if (step_3946 == 1) { fillSignature(signature, type_3947) } else {
												signature.push('Unknown');
											};
										}
									} break;
									
									case 12: {
										const value_3948 = temp_3936[1];
										signature.push('fun')
									} break;
									
									case 0: {
										const value_3949 = temp_3936[1];
										signature.push('const')
									} break;
									
									case 13: {
										const value_3950 = temp_3936[1];
										signature.push('struct')
									} break;
									
									default: 
									throw type_3935
									};
								};
								type_3856.template = the_3934.instances != null && the_3934.instances.length > 0;
								for (const instance of $toIterator(the_3934.instances)) {
									const signature_3951 = ['_'];
									{
										let step_3952 = 0;
										const instanceParams = instance.instanceParams;
										if (step_3952 == 0 && instanceParams != null) { step_3952 = 1 };
										if (step_3952 == 1) { for (const param of $toIterator(instanceParams)) {
											fillSignature(signature_3951, param);
										} };
									};
									instance.name += signature_3951.join('$');
									instance.useless = the_3934.useless;
									this.nodeToStatement(instance.parent);
								};
							}
						} break;
						};
					};
					return null;
				}
			} break;
			
			case 9: {
				{
				}
			} break;
			
			case 30: {
				const path_3953 = temp_3746[1];
				const t_3954 = temp_3746[2];
				const args_3955 = temp_3746[3];
				const fields_3956 = temp_3746[4];
				const values_3957 = temp_3746[5];
				return /*Const*/[4,this.unique('temp', null),this.nodeToExpression(e_3745),this.typer.types.get(e_3745),".Const"]
			} break;
			
			case 13: {
				const e_3958 = temp_3746[1];
				const args_3959 = temp_3746[2];
				const argNames_3960 = temp_3746[3];
				{
					let kind_3961 = 11;
					{
						const temp_3962 = e_3958;
						switch (temp_3962&&temp_3962[0]) {
						case 4: {
							{
								const a_3963 = [];
								for (const arg of $toIterator(args_3959)) {
									a_3963.push(this.nodeToExpression(arg));
								};
								return /*SuperConstructor*/[19,a_3963,".SuperConstructor"];
							}
						} break;
						
						case 28: {
							const expr_3964 = temp_3962[1];
							{
								const temp_3965 = (this.typer.types.get(expr_3964));
								switch (temp_3965&&temp_3965[0]) {
								case 6: {
									kind_3961 = 12
								} break;
								
								case 5: {
									kind_3961 = 10
								} break;
								};
							}
						} break;
						};
					};
					const v_3966 = this.nodeToExpression(e_3958);
					const a_3967 = [];
					for (const arg of $toIterator(args_3959)) {
						a_3967.push(this.nodeToExpression(arg));
					};
					let expects = [];
					{
						const temp_3968 = (this.typer.types.get(e_3958));
						switch (temp_3968&&temp_3968[0]) {
						case 12: {
							const args_3969 = temp_3968[1];
							expects = args_3969
						} break;
						};
					};
					{
						const temp_3970 = v_3966;
						switch (temp_3970&&temp_3970[0]) {
						case 9: {
							const expr_3971 = temp_3970[1];
							{
								const temp_3972 = expr_3971;
								switch (temp_3972&&temp_3972[0]) {
								case 8: {
									kind_3961 = 12
								} break;
								};
							}
						} break;
						};
					};
					return /*Call*/[2,v_3966,a_3967,expects,kind_3961,".Call"];
				}
			} break;
			
			case 24: {
				const name_3973 = temp_3746[1];
				const t_3974 = temp_3746[2];
				const expr_3975 = temp_3746[3];
				const const_3976 = temp_3746[4];
				const external_3977 = temp_3746[5];
				{
					const uname_3978 = (() => {
						const result_3979 = this.parentNames.get(e_3745);
						if (result_3979 != null) { return result_3979 };
						return this.unique(name_3973, e_3745);
					})();
					if (external_3977) { return null };
					if (const_3976) {
						const value_3980 = this.nodeToExpression(expr_3975);
						this.saveInlineIfViable(e_3745, value_3980);
						return /*Const*/[4,uname_3978,value_3980,this.typer.types.get(e_3745),".Const"];
					};
					const result_3981 = /*Var*/[3,uname_3978,this.nodeToExpression(expr_3975),this.typer.types.get(e_3745),".Var"];
					this.neverReassignedLocal.set(e_3745, true);
					this.neverReassignedLocalParent.set(result_3981, e_3745);
					return result_3981;
				}
			} break;
			
			case 22: {
				const name_3982 = temp_3746[1];
				const expr_3983 = temp_3746[2];
				const vars_3984 = temp_3746[3];
				const rettype_3985 = temp_3746[4];
				const external_3986 = temp_3746[5];
				{
					let uname_3987 = null;
					const atts_3988 = this.project.mapDecorators.get(e_3745);
					{
						let step_3989 = 0;
						const native_3990 = Normalizer.getDec(atts_3988, 'rename');
						if (step_3989 == 0 && native_3990 != null) { step_3989 = 1 };
						if (step_3989 == 1) {
							const temp_3991 = native_3990.values[0];
							switch (temp_3991&&temp_3991[0]) {
							case 0: {
								const s_3992 = temp_3991[1];
								{
									if (this.parentNames.get(e_3745) == null) { this.uniqueNative(s_3992, e_3745) };
									uname_3987 = this.parentNames.get(e_3745);
								}
							} break;
							
							default: 
							throw '@rename takes string as argument'
							};
						} else {
							uname_3987 = (((name_3982 != null))? (((() => {
								const result_3993 = this.parentNames.get(e_3745);
								if (result_3993 != null) { return result_3993 };
								return this.unique(name_3982, e_3745);
							})())) : (null));
						};
					};
					if (external_3986) { return null };
					const rettype_3994 = rettype_3985;
					const a_3995 = [];
					const defaults_3996 = [];
					const types_3997 = [];
					for (const arg of $toIterator(vars_3984)) {
						const temp_3998 = arg;
						switch (temp_3998&&temp_3998[0]) {
						case 24: {
							const name_3999 = temp_3998[1];
							const t_4000 = temp_3998[2];
							const expr_4001 = temp_3998[3];
							const const_4002 = temp_3998[4];
							{
								a_3995.push(this.unique(name_3999, arg));
								types_3997.push(t_4000);
								if (expr_4001 != null) { defaults_3996.push(this.nodeToExpression(expr_4001)) } else {
									defaults_3996.push(null);
								};
							}
						} break;
						};
					};
					if (name_3982 == 'new') { return /*Function*/[5,null,this.unwrapNestingBlocks(this.nodeToStatement(expr_3983)),a_3995,defaults_3996,this.typer.types.get(e_3745),".Function"] };
					return /*Function*/[5,uname_3987,this.unwrapNestingBlocks(this.nodeToStatement(expr_3983)),a_3995,defaults_3996,this.typer.types.get(e_3745),".Function"];
				}
			} break;
			
			case 49: {
				const name_4003 = temp_3746[1];
				const over_4004 = temp_3746[2];
				const by_4005 = temp_3746[3];
				const range_4006 = temp_3746[4];
				{
					if (range_4006 == null) {
						const temp_4007 = over_4004;
						switch (temp_4007&&temp_4007[0]) {
						case 5: {
							const s_4008 = temp_4007[1];
							{
								const i_4009 = this.unique(name_4003, e_3745);
								const it_4010 = this.unique('it', null);
								return /*Block*/[1,[/*Var*/[3,i_4009,/*Int*/[1,0,".Int"],this.typer.typeInt,".Var"], /*Var*/[3,it_4010,/*Int*/[1,0,".Int"],this.typer.typeInt,".Var"], /*While*/[13,/*Binop*/[12,/*Ident*/[6,it_4010,this.typer.typeInt,".Ident"],99,/*Int*/[1,s_4008,".Int"],this.typer.typeBool,".Binop"],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,i_4009,this.typer.typeInt,".Ident"],/*Ident*/[6,it_4010,this.typer.typeInt,".Ident"],null,".Assign"], /*Increment*/[14,/*Ident*/[6,it_4010,this.typer.typeInt,".Ident"],".Increment"], this.nodeToStatement(by_4005)],".Block"],true,".While"]],".Block"];
							}
						} break;
						
						default: 
						{
							const overType = this.typer.types.get(over_4004);
							const iteratorOverInt = overType == this.typer.typeInt || overType == this.typer.typeUInt32 || overType == this.typer.typeUInt64;
							if (iteratorOverInt) {
								const i_4011 = this.unique(name_4003, e_3745);
								const it_4012 = this.unique('it', null);
								const finish = this.unique('at', null);
								return /*Block*/[1,[/*Var*/[3,i_4011,/*Int*/[1,0,".Int"],overType,".Var"], /*Var*/[3,it_4012,/*Int*/[1,0,".Int"],overType,".Var"], /*Var*/[3,finish,this.nodeToExpression(over_4004),overType,".Var"], /*While*/[13,/*Binop*/[12,/*Ident*/[6,it_4012,overType,".Ident"],99,/*Ident*/[6,finish,overType,".Ident"],this.typer.typeBool,".Binop"],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,i_4011,overType,".Ident"],/*Ident*/[6,it_4012,overType,".Ident"],null,".Assign"], /*Increment*/[14,/*Ident*/[6,it_4012,overType,".Ident"],".Increment"], this.nodeToStatement(by_4005)],".Block"],true,".While"]],".Block"];
							};
						}
						};
					};
					{
						let step_4013 = 0;
						const range_4014 = range_4006;
						if (step_4013 == 0 && range_4014 != null) { step_4013 = 1 };
						if (step_4013 == 1) {
							const i_4015 = this.unique(name_4003, e_3745);
							const it_4016 = this.unique('it', null);
							const finish_4017 = this.unique('at', null);
							return /*Block*/[1,[/*Var*/[3,i_4015,/*Int*/[1,0,".Int"],this.typer.typeInt,".Var"], /*Var*/[3,it_4016,this.nodeToExpression(over_4004),this.typer.typeInt,".Var"], /*Var*/[3,finish_4017,this.nodeToExpression(range_4014),this.typer.typeInt,".Var"], /*While*/[13,/*Binop*/[12,/*Ident*/[6,it_4016,this.typer.typeInt,".Ident"],99,/*Ident*/[6,finish_4017,this.typer.typeInt,".Ident"],this.typer.typeBool,".Binop"],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,i_4015,this.typer.typeInt,".Ident"],/*Ident*/[6,it_4016,this.typer.typeInt,".Ident"],null,".Assign"], /*Increment*/[14,/*Ident*/[6,it_4016,this.typer.typeInt,".Ident"],".Increment"], this.nodeToStatement(by_4005)],".Block"],true,".While"]],".Block"];
						};
					};
					return /*For*/[12,name_4003,this.nodeToExpression(over_4004),this.nodeToStatement(by_4005),".For"];
				}
			} break;
			
			case 16: {
				const e_4018 = temp_3746[1];
				{
					if (e_4018 == null) { return /*Return*/[6,null,".Return"] };
					return /*Return*/[6,this.nodeToExpression(e_4018),".Return"];
				}
			} break;
			
			case 28: {
				const expr_4019 = temp_3746[1];
				const name_4020 = temp_3746[2];
				return /*Const*/[4,this.unique('temp', null),this.nodeToExpression(e_3745),this.typer.types.get(e_3745),".Const"]
			} break;
			
			case 29: {
				const expr_4021 = temp_3746[1];
				const name_4022 = temp_3746[2];
				return /*Const*/[4,this.unique('temp', null),this.nodeToExpression(e_3745),this.typer.types.get(e_3745),".Const"]
			} break;
			
			case 14: {
				const econd_4023 = temp_3746[1];
				const eif_4024 = temp_3746[2];
				const eelse_4025 = temp_3746[3];
				{
					let binds_4026 = false;
					for (const cond of $toIterator(econd_4023)) {
						const temp_4027 = cond;
						switch (temp_4027&&temp_4027[0]) {
						case 24: {
							binds_4026 = true
						} break;
						};
					};
					if (((!binds_4026)) && (econd_4023.length == 1)) {
						const value_4028 = this.nodeToExpression(this.unwrapParens(econd_4023[0]));
						const ei = this.nodeToStatement(eif_4024);
						const ee = this.nodeToStatement(eelse_4025);
						{
							const temp_4029 = value_4028;
							switch (temp_4029&&temp_4029[0]) {
							case 4: {
								return ei
							} break;
							
							case 5: {
								return ee
							} break;
							};
						};
						return /*If*/[7,value_4028,ei,ee,".If"];
					};
					if ((!binds_4026)) {
						let parens_4030 = /*Parenthesis*/[15,this.nodeToExpression(econd_4023[0]),".Parenthesis"];
						let i_4031 = 1;
						while (i_4031 < econd_4023.length) {
							parens_4030 = /*Binop*/[12,parens_4030,92,/*Parenthesis*/[15,this.nodeToExpression(econd_4023[i_4031]),".Parenthesis"],this.typer.typeBool,".Binop"];
							i_4031++;
						};
						return /*If*/[7,parens_4030,this.nodeToStatement(eif_4024),this.nodeToStatement(eelse_4025),".If"];
					};
					const block_4032 = [];
					let current = 0;
					const step_4033 = this.unique('step', null);
					block_4032.push(/*Var*/[3,step_4033,/*Int*/[1,0,".Int"],this.typer.typeInt,".Var"]);
					let nullable_4034 = false;
					let last = '';
					const lastType = this.typer.types.get(econd_4023[0]);
					{
						const temp_4035 = econd_4023[0];
						switch (temp_4035&&temp_4035[0]) {
						case 24: {
							const name_4036 = temp_4035[1];
							const t_4037 = temp_4035[2];
							const expr_4038 = temp_4035[3];
							const const_4039 = temp_4035[4];
							{
								last = this.unique(name_4036, econd_4023[0]);
								nullable_4034 = true;
								block_4032.push(/*Const*/[4,last,this.nodeToExpression(expr_4038),this.typer.types.get(econd_4023[0]),".Const"]);
							}
						} break;
						
						default: 
						{
							last = this.unique('temp', null);
							block_4032.push(/*Const*/[4,last,this.nodeToExpression(econd_4023[0]),this.typer.types.get(econd_4023[0]),".Const"]);
						}
						};
					};
					while (current < econd_4023.length - 1) {
						const temp_4040 = econd_4023[current + 1];
						switch (temp_4040&&temp_4040[0]) {
						case 24: {
							const vname = temp_4040[1];
							const t_4041 = temp_4040[2];
							const expr_4042 = temp_4040[3];
							const const_4043 = temp_4040[4];
							{
								const name_4044 = this.unique(vname, econd_4023[current + 1]);
								block_4032.push(/*Var*/[3,name_4044,/*Null*/[7,this.typer.types.get(expr_4042),".Null"],this.typer.types.get(expr_4042),".Var"]);
								block_4032.push(/*If*/[7,/*Binop*/[12,/*Binop*/[12,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],95,/*Int*/[1,current + 0,".Int"],this.typer.typeBool,".Binop"],92,/*Binop*/[12,/*Ident*/[6,last,lastType,".Ident"],103,((nullable_4034)? (/*Null*/[7,lastType,".Null"]) : /*False*/[5]),this.typer.typeBool,".Binop"],this.typer.typeBool,".Binop"],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,name_4044,this.typer.types.get(expr_4042),".Ident"],this.nodeToExpression(expr_4042),null,".Assign"], /*Assign*/[10,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],/*Int*/[1,current + 1,".Int"],null,".Assign"]],".Block"],null,".If"]);
								current++;
								last = name_4044;
								nullable_4034 = true;
							}
						} break;
						
						default: 
						{
							const next = this.unique('temp', null);
							const nextType = this.typer.types.get(econd_4023[0]);
							block_4032.push(/*Var*/[3,next,/*Null*/[7,nextType,".Null"],nextType,".Var"]);
							block_4032.push(/*If*/[7,/*Binop*/[12,/*Binop*/[12,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],95,/*Int*/[1,current + 0,".Int"],this.typer.typeBool,".Binop"],92,/*Binop*/[12,/*Ident*/[6,last,lastType,".Ident"],103,((nullable_4034)? (/*Null*/[7,lastType,".Null"]) : /*False*/[5]),this.typer.typeBool,".Binop"],this.typer.typeBool,".Binop"],/*Block*/[1,[/*Assign*/[10,/*Ident*/[6,next,nextType,".Ident"],this.nodeToExpression(econd_4023[current + 1]),null,".Assign"], /*Assign*/[10,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],/*Int*/[1,current + 1,".Int"],null,".Assign"]],".Block"],null,".If"]);
							current++;
							last = next;
							nullable_4034 = false;
						}
						};
					};
					block_4032.push(/*If*/[7,/*Binop*/[12,/*Binop*/[12,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],95,/*Int*/[1,econd_4023.length - 1,".Int"],this.typer.typeBool,".Binop"],92,/*Binop*/[12,/*Ident*/[6,last,lastType,".Ident"],103,((nullable_4034)? (/*Null*/[7,lastType,".Null"]) : /*False*/[5]),this.typer.typeBool,".Binop"],this.typer.typeBool,".Binop"],/*Assign*/[10,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],/*Int*/[1,econd_4023.length,".Int"],null,".Assign"],null,".If"]);
					block_4032.push(/*If*/[7,/*Binop*/[12,/*Ident*/[6,step_4033,this.typer.typeInt,".Ident"],95,/*Int*/[1,econd_4023.length,".Int"],this.typer.typeBool,".Binop"],this.nodeToStatement(eif_4024),this.nodeToStatement(eelse_4025),".If"]);
					return /*Block*/[1,block_4032,".Block"];
				}
			} break;
			
			case 27: {
				const expr_4045 = temp_3746[1];
				const t_4046 = temp_3746[2];
				const v_4047 = temp_3746[3];
				const catches = temp_3746[4];
				{
					const temp_4048 = this.unique('temp', null);
					const tt = [];
					const vv = [];
					for (const c of $toIterator(v_4047)) {
						vv.push(DataHelper.nameOf(c));
					};
					const cc = [];
					for (const c of $toIterator(catches)) {
						cc.push(this.nodeToStatement(c));
					};
					for (const c of $toIterator(t_4046)) {
						tt.push(this.typer.types.get(c));
					};
					return /*Try*/[8,this.nodeToStatement(expr_4045),tt,vv,cc,temp_4048,".Try"];
				}
			} break;
			
			case 17: {
				const value_4049 = temp_3746[1];
				return /*Throw*/[9,this.nodeToExpression(value_4049),".Throw"]
			} break;
			
			case 11: {
				const a_4050 = temp_3746[1];
				const op_4051 = temp_3746[2];
				const b_4052 = temp_3746[3];
				{
					const source_4053 = this.typer.parents.get(a_4050);
					{
						let step_4054 = 0;
						const source_4055 = source_4053;
						if (step_4054 == 0 && source_4055 != null) { step_4054 = 1 };
						if (step_4054 == 1) {
							const temp_4056 = source_4055;
							switch (temp_4056&&temp_4056[0]) {
							case 24: {
								const name_4057 = temp_4056[1];
								this.neverReassignedLocal.set(source_4055, false)
							} break;
							};
						};
					};
					return /*Assignop*/[11,this.nodeToExpression(a_4050),op_4051,this.nodeToExpression(b_4052),".Assignop"];
				}
			} break;
			
			case 10: {
				const a_4058 = temp_3746[1];
				const op_4059 = temp_3746[2];
				const b_4060 = temp_3746[3];
				{
					const temp_4061 = op_4059;
					switch (temp_4061) {
					case 91: {
						{
							const source_4062 = this.typer.parents.get(a_4058);
							{
								let step_4063 = 0;
								const source_4064 = source_4062;
								if (step_4063 == 0 && source_4064 != null) { step_4063 = 1 };
								if (step_4063 == 1) {
									const temp_4065 = source_4064;
									switch (temp_4065&&temp_4065[0]) {
									case 24: {
										const name_4066 = temp_4065[1];
										this.neverReassignedLocal.set(source_4064, false)
									} break;
									};
								};
							};
							return /*Assign*/[10,this.nodeToExpression(a_4058),this.nodeToExpression(b_4060),null,".Assign"];
						}
					} break;
					
					default: 
					{
						const sa_4067 = this.nodeToStatement(a_4058);
						const sb_4068 = this.nodeToStatement(b_4060);
						if ((sa_4067 == null) && (sb_4068 == null)) { return null };
						if ((sa_4067 == null) || (sb_4068 == null)) { return (() => {
							const result_4069 = sa_4067;
							if (result_4069 != null) { return result_4069 };
							return sb_4068;
						})() };
						return /*Statements*/[0,[sa_4067, sb_4068],".Statements"];
					}
					};
				}
			} break;
			
			case 19: {
				return /*Continue*/[17]
			} break;
			
			case 18: {
				return /*Break*/[18]
			} break;
			
			case 21: {
				const econd_4070 = temp_3746[1];
				const e_4071 = temp_3746[2];
				const pre = temp_3746[3];
				return /*While*/[13,this.nodeToExpression(econd_4070),this.nodeToStatement(e_4071),pre,".While"]
			} break;
			
			case 20: {
				const op_4072 = temp_3746[1];
				const postfix_4073 = temp_3746[2];
				const e_4074 = temp_3746[3];
				{
					{
						const temp_4075 = op_4072;
						switch (temp_4075) {
						case 87: case 86: {
							{
								const source_4076 = this.typer.parents.get(e_4074);
								{
									let step_4077 = 0;
									const source_4078 = source_4076;
									if (step_4077 == 0 && source_4078 != null) { step_4077 = 1 };
									if (step_4077 == 1) {
										const temp_4079 = source_4078;
										switch (temp_4079&&temp_4079[0]) {
										case 24: {
											const name_4080 = temp_4079[1];
											this.neverReassignedLocal.set(source_4078, false)
										} break;
										};
									};
								};
							}
						} break;
						};
					};
					{
						const temp_4081 = op_4072;
						switch (temp_4081) {
						case 87: {
							return /*Increment*/[14,this.nodeToExpression(e_4074),".Increment"]
						} break;
						
						case 86: {
							return /*Decrement*/[15,this.nodeToExpression(e_4074),".Decrement"]
						} break;
						
						default: 
						{
						}
						};
					};
				}
			} break;
			
			case 15: {
				const inner_4082 = temp_3746[1];
				return this.nodeToStatement(this.unwrapParens(inner_4082))
			} break;
			
			case 34: {
				const exprs_4083 = temp_3746[1];
				const conds_4084 = temp_3746[2];
				const guards_4085 = temp_3746[3];
				const cases_4086 = temp_3746[4];
				{
					if (exprs_4083.length > 1) { console.error('Multiple switch values not yet supported:', e_3745, this.project.data.get(e_3745)) };
					const s_4087 = [];
					const c = [];
					if (this.nativeEnums) {
						const index_4088 = this.nodeToExpression(exprs_4083[0]);
						{
							let i_4089 = 0;
							let it_4090 = 0;
							let at_4091 = cases_4086.length;
							while (it_4090 < at_4091) {
								i_4089 = it_4090;
								it_4090++;
								{
									const toCase = (co) => {
										const temp_4092 = co;
										switch (temp_4092&&temp_4092[0]) {
										case 8: {
											return /*Null*/[7,this.typer.typeAny,".Null"]
										} break;
										
										case 45: {
											return /*Underscore*/[30]
										} break;
										
										case 0: {
											const v_4093 = temp_4092[1];
											return /*String*/[0,v_4093,".String"]
										} break;
										
										case 5: {
											const v_4094 = temp_4092[1];
											return /*Int*/[1,v_4094,".Int"]
										} break;
										
										case 7: {
											const v_4095 = temp_4092[1];
											return /*Float*/[3,v_4095,".Float"]
										} break;
										
										case 2: {
											const v_4096 = temp_4092[1];
											{
												if (v_4096) { return /*True*/[4] };
												return /*False*/[5];
											}
										} break;
										
										case 28: {
											const expr_4097 = temp_4092[1];
											const name_4098 = temp_4092[2];
											return /*Dot*/[9,this.nodeToExpression(expr_4097),name_4098,null,".Dot"]
										} break;
										
										case 29: {
											const expr_4099 = temp_4092[1];
											const name_4100 = temp_4092[2];
											return /*Dot*/[9,this.nodeToExpression(expr_4099),name_4100,null,".Dot"]
										} break;
										
										case 10: {
											const a_4101 = temp_4092[1];
											const op_4102 = temp_4092[2];
											const b_4103 = temp_4092[3];
											{
												const temp_4104 = op_4102;
												switch (temp_4104) {
												case 104: {
													return /*Binop*/[12,toCase(a_4101),104,toCase(b_4103),null,".Binop"]
												} break;
												
												default: 
												console.error('(internal warning) Unknown native case binop kind:', e_3745, this.typer.parents.get(e_3745))
												};
											}
										} break;
										
										case 13: {
											const e_4105 = temp_4092[1];
											const args_4106 = temp_4092[2];
											const argNames_4107 = temp_4092[3];
											{
												const temp_4108 = e_4105;
												switch (temp_4108&&temp_4108[0]) {
												case 29: {
													const expr_4109 = temp_4108[1];
													const name_4110 = temp_4108[2];
													{
														const a_4111 = [];
														{
															let arg = 0;
															let it_4112 = 0;
															let at_4113 = args_4106.length;
															while (it_4112 < at_4113) {
																arg = it_4112;
																it_4112++;
																{
																	const temp_4114 = args_4106[arg];
																	switch (temp_4114&&temp_4114[0]) {
																	case 1: {
																		const name_4115 = temp_4114[1];
																		a_4111.push(/*Ident*/[6,this.unique(name_4115, args_4106[arg]),null,".Ident"])
																	} break;
																	
																	case 45: {
																		a_4111.push(/*Underscore*/[30])
																	} break;
																	
																	default: 
																	console.log('(internal warning) Unknown native case extract value kind:', args_4106[arg])
																	};
																};
															};
														};
														return /*Call*/[10,this.nodeToExpression(e_4105),a_4111,null,11,".Call"];
													}
												} break;
												
												default: 
												console.error('(internal warning) Unknown case extract kind:', e_4105, this.typer.parents.get(e_4105))
												};
											}
										} break;
										
										default: 
										console.error('(internal warning) Unknown native enum case kind:', co, this.project.data.get(co))
										};
									};
									c.push([toCase(conds_4084[i_4089])]);
									s_4087.push(this.nodeToStatement(cases_4086[i_4089]));
								};
							};
						};
						return /*Switch*/[16,index_4088,c,s_4087,[],[],".Switch"];
					};
					const temp_4116 = this.unique('temp', null);
					const value_4117 = this.nodeToExpression(exprs_4083[0]);
					let index_4118 = /*Ident*/[6,temp_4116,this.typer.types.get(exprs_4083[0]),".Ident"];
					let promoted = false;
					let enumType = null;
					{
						const temp_4119 = Type.unwrapNullable(this.typer.types.get(exprs_4083[0]));
						switch (temp_4119&&temp_4119[0]) {
						case 8: {
							const type_4120 = temp_4119[1];
							{
								if (type_4120.fieldsTypeSimple == null) {
									index_4118 = /*EnumTag*/[27,index_4118,".EnumTag"];
									promoted = true;
								};
								enumType = type_4120;
							}
						} break;
						
						case 9: {
							const type_4121 = temp_4119[1];
							{
								if (type_4121.fieldsTypeSimple == null) {
									index_4118 = /*EnumTag*/[27,index_4118,".EnumTag"];
									promoted = true;
								};
								enumType = type_4121;
							}
						} break;
						};
					};
					let i_4122 = 0;
					const guardians = [];
					const binds_4123 = [];
					for (const ec of $toIterator(cases_4086)) {
						const block_4124 = [];
						const co_4125 = conds_4084[i_4122];
						const cx = [];
						const binders = [];
						binds_4123.push(binders);
						const addTag = (co_4126) => {
							const temp_4127 = co_4126;
							switch (temp_4127&&temp_4127[0]) {
							case 8: {
								cx.push(/*Null*/[7])
							} break;
							
							case 45: {
								{
								}
							} break;
							
							case 0: {
								const v_4128 = temp_4127[1];
								cx.push(/*String*/[0,v_4128,".String"])
							} break;
							
							case 5: {
								const v_4129 = temp_4127[1];
								cx.push(/*Int*/[1,v_4129,".Int"])
							} break;
							
							case 7: {
								const v_4130 = temp_4127[1];
								cx.push(/*Float*/[3,v_4130,".Float"])
							} break;
							
							case 2: {
								const v_4131 = temp_4127[1];
								if (v_4131) { cx.push(/*True*/[4]) } else {
									cx.push(/*False*/[5]);
								}
							} break;
							
							case 13: {
								const e_4132 = temp_4127[1];
								const args_4133 = temp_4127[2];
								const argNames_4134 = temp_4127[3];
								{
									{
										const temp_4135 = e_4132;
										switch (temp_4135&&temp_4135[0]) {
										case 29: {
											const expr_4136 = temp_4135[1];
											const name_4137 = temp_4135[2];
											{
												const parent_4138 = this.typer.parents.get(expr_4136);
												const tag_4139 = this.getTag(parent_4138, name_4137);
												cx.push(tag_4139);
											}
										} break;
										
										case 51: {
											const t_4140 = temp_4135[1];
											{
												const temp_4141 = t_4140;
												switch (temp_4141&&temp_4141[0]) {
												case 1: {
													const name_4142 = temp_4141[1];
													{
														let step_4143 = 0;
														const enumType_4144 = enumType;
														if (step_4143 == 0 && enumType_4144 != null) { step_4143 = 1 };
														if (step_4143 == 1) { cx.push(this.getTag(enumType_4144.parent, name_4142)) };
													}
												} break;
												};
											}
										} break;
										
										default: 
										console.error('(internal warning) Unknown case extract kind:', e_4132, this.typer.parents.get(e_4132))
										};
									};
									if ((!promoted)) { index_4118 = /*EnumTag*/[27,index_4118,".EnumTag"] };
									promoted = true;
									{
										let arg_4145 = 0;
										let it_4146 = 0;
										let at_4147 = args_4133.length;
										while (it_4146 < at_4147) {
											arg_4145 = it_4146;
											it_4146++;
											{
												const temp_4148 = args_4133[arg_4145];
												switch (temp_4148&&temp_4148[0]) {
												case 1: {
													const name_4149 = temp_4148[1];
													binders.push(/*Const*/[4,this.unique(name_4149, args_4133[arg_4145]),/*EnumParameter*/[29,/*Ident*/[6,temp_4116,this.typer.types.get(args_4133[arg_4145]),".Ident"],arg_4145,".EnumParameter"],this.typer.types.get(args_4133[arg_4145]),".Const"])
												} break;
												
												case 45: {
													{
													}
												} break;
												
												case 46: {
													{
													}
												} break;
												
												default: 
												console.log('(internal warning) Unknown case extract value kind:', arg_4145)
												};
											};
										};
									};
								}
							} break;
							
							case 29: {
								const expr_4150 = temp_4127[1];
								const name_4151 = temp_4127[2];
								cx.push(this.getTag(this.typer.parents.get(expr_4150), name_4151))
							} break;
							
							case 10: {
								const a_4152 = temp_4127[1];
								const op_4153 = temp_4127[2];
								const b_4154 = temp_4127[3];
								{
									const temp_4155 = op_4153;
									switch (temp_4155) {
									case 104: {
										{
											addTag(a_4152);
											addTag(b_4154);
										}
									} break;
									
									default: 
									console.error('(internal warning) Unknown case binop kind:', e_3745, this.typer.parents.get(e_3745))
									};
								}
							} break;
							
							case 51: {
								const t_4156 = temp_4127[1];
								{
									const temp_4157 = t_4156;
									switch (temp_4157&&temp_4157[0]) {
									case 1: {
										const name_4158 = temp_4157[1];
										{
											{
												let step_4159 = 0;
												const enumType_4160 = enumType;
												if (step_4159 == 0 && enumType_4160 != null) { step_4159 = 1 };
												if (step_4159 == 1) {
													const tag_4161 = this.getTag(enumType_4160.parent, name_4158);
													cx.push(tag_4161);
												};
											};
											if (enumType == null) { console.log('null enumType for ' + name_4158) };
										}
									} break;
									};
								}
							} break;
							
							default: 
							console.error('(internal warning) Unknown case kind:', co_4126, this.project.data.get(co_4126))
							};
						};
						addTag(co_4125);
						c.push(cx);
						block_4124.push(this.unwrapNestingBlocks(this.nodeToStatement(ec)));
						s_4087.push(this.unwrapNestingBlocks(/*Block*/[1,block_4124,".Block"]));
						{
							let step_4162 = 0;
							const guard = guards_4085[i_4122];
							if (step_4162 == 0 && guard != null) { step_4162 = 1 };
							if (step_4162 == 1) { guardians.push(this.nodeToExpression(guard)) } else {
								guardians.push(null);
							};
						};
						i_4122++;
					};
					if (this.typer.types.get(exprs_4083[0]) == null) { console.error(exprs_4083[0]) };
					return /*Block*/[1,[/*Const*/[4,temp_4116,value_4117,this.typer.types.get(exprs_4083[0]),".Const"], /*Switch*/[16,index_4118,c,s_4087,guardians,binds_4123,".Switch"]],".Block"];
				}
			} break;
			
			case 33: {
				const v_4163 = temp_3746[1];
				const index_4164 = temp_3746[2];
				{
					this.project.hints.push(new Hint(10, ('Unused value of index `' + (Node.stringify(e_3745)) + '`'), this.project.data.get(e_3745)));
					{
						const temp_4165 = index_4164;
						switch (temp_4165&&temp_4165[0]) {
						case 0: {
							return this.nodeToStatement(v_4163)
						} break;
						
						case 5: {
							return this.nodeToStatement(v_4163)
						} break;
						
						case 2: {
							return this.nodeToStatement(v_4163)
						} break;
						
						case 7: {
							return this.nodeToStatement(v_4163)
						} break;
						};
					};
					return /*Statements*/[0,[this.nodeToStatement(v_4163), this.nodeToStatement(index_4164)],".Statements"];
				}
			} break;
			
			case 1: {
				const name_4166 = temp_3746[1];
				this.project.hints.push(new Hint(10, ('Unused value `' + (name_4166) + '`'), this.project.data.get(e_3745)))
			} break;
			
			case 23: {
				this.project.hints.push(new Hint(10, 'Unused arrow => function', this.project.data.get(e_3745)))
			} break;
			
			case 0: {
				const v_4167 = temp_3746[1];
				this.project.hints.push(new Hint(10, ('Unused string `\"' + (v_4167) + '\"`'), this.project.data.get(e_3745)))
			} break;
			
			case 2: {
				const v_4168 = temp_3746[1];
				this.project.hints.push(new Hint(10, ('Unused boolean `' + (v_4168) + '`'), this.project.data.get(e_3745)))
			} break;
			
			case 5: {
				const v_4169 = temp_3746[1];
				this.project.hints.push(new Hint(10, ('Unused number `' + (v_4169) + '`'), this.project.data.get(e_3745)))
			} break;
			
			case 7: {
				const v_4170 = temp_3746[1];
				this.project.hints.push(new Hint(10, ('Unused float `' + (v_4170) + '`'), this.project.data.get(e_3745)))
			} break;
			
			case 8: {
				this.project.hints.push(new Hint(10, 'Unused `null`', this.project.data.get(e_3745)))
			} break;
			
			case 35: {
				{
				}
			} break;
			
			case null: case undefined: {
				console.log('(internal warning) seems like null node passed to normalizer')
			} break;
			
			default: 
			return /*Const*/[4,this.unique('temp', null),this.nodeToExpression(e_3745),this.typer.types.get(e_3745),".Const"]
			};
		};
		return null;
	};
		getTag(enumNode, name_4171) {
		const temp_4172 = enumNode;
		switch (temp_4172&&temp_4172[0]) {
		case 39: {
			const t_4173 = temp_4172[1];
			const fields_4174 = temp_4172[2];
			const valuesType_4175 = temp_4172[3];
			{
				let typed = (null);
				{
					const temp_4176 = (this.typer.types.get(enumNode));
					switch (temp_4176&&temp_4176[0]) {
					case 8: {
						const type_4177 = temp_4176[1];
						typed = type_4177
					} break;
					};
				};
				let i_4178 = 0;
				for (const f of $toIterator(fields_4174)) {
					{
						const temp_4179 = f;
						switch (temp_4179&&temp_4179[0]) {
						case 51: {
							const t_4180 = temp_4179[1];
							{
								const temp_4181 = t_4180;
								switch (temp_4181&&temp_4181[0]) {
								case 1: {
									const n = temp_4181[1];
									{
										if (n == name_4171) { if (typed.fieldsTypeSimple == this.typer.typeString) { return /*String*/[0,n,".String"] } };
										if (n == name_4171) { return /*Int*/[1,i_4178,".Int"] };
									}
								} break;
								};
							}
						} break;
						
						case 13: {
							const e_4182 = temp_4179[1];
							{
								const temp_4183 = e_4182;
								switch (temp_4183&&temp_4183[0]) {
								case 51: {
									const t_4184 = temp_4183[1];
									{
										const temp_4185 = t_4184;
										switch (temp_4185&&temp_4185[0]) {
										case 1: {
											const n_4186 = temp_4185[1];
											if (n_4186 == name_4171) { return /*Int*/[1,i_4178,".Int"] }
										} break;
										};
									}
								} break;
								};
							}
						} break;
						
						case 10: {
							const a_4187 = temp_4179[1];
							const op_4188 = temp_4179[2];
							const b_4189 = temp_4179[3];
							{
								const temp_4190 = a_4187;
								switch (temp_4190&&temp_4190[0]) {
								case 51: {
									const t_4191 = temp_4190[1];
									{
										const temp_4192 = t_4191;
										switch (temp_4192&&temp_4192[0]) {
										case 1: {
											const n_4193 = temp_4192[1];
											if (n_4193 == name_4171) { return this.nodeToExpression(b_4189) }
										} break;
										};
									}
								} break;
								};
							}
						} break;
						
						case 47: {
							return null
						} break;
						
						default: 
						console.error('(internal warning) Unknown enum tag kind:', f)
						};
					};
					i_4178++;
				};
				throw ('Enum has no tag or field `' + (name_4171) + '` ') + t_4173;
			}
		} break;
		};
	};
		getNative(e_4195) {
		const atts_4196 = this.project.mapDecorators.get(e_4195);
		{
			let step_4197 = 0;
			const native_4198 = Normalizer.getDec(atts_4196, 'rename');
			if (step_4197 == 0 && native_4198 != null) { step_4197 = 1 };
			if (step_4197 == 1) {
				const temp_4199 = native_4198.values[0];
				switch (temp_4199&&temp_4199[0]) {
				case 0: {
					const s_4200 = temp_4199[1];
					return s_4200
				} break;
				
				default: 
				throw '@rename takes string as argument'
				};
			};
		};
		return null;
	};
		pushScope() { this.scopes.push((new Map())) };
		popScope() { this.scopes.pop() };
		hasInScope(name_4201) {
		for (const scope of $toIterator(this.scopes)) {
			if (scope.get(name_4201) != null) { return true };
		};
		return false;
	};
		addToScope(name_4202) { this.scopes[this.scopes.length - 1].set(name_4202, true) };
		unique(name_4203, node) {
		let uname_4204 = name_4203;
		while (this.hasInScope(uname_4204) || (this.keywords.indexOf(uname_4204) != (-1)) || (this.globals.indexOf(uname_4204) != (-1))) {
			uname_4204 = (name_4203 + '_') + ((++this.id));
		};
		this.addToScope(uname_4204);
		if (node != null) { this.parentNames.set(node, uname_4204) };
		return uname_4204;
	};
		uniqueNative(name_4205, node_4206) {
		this.addToScope(name_4205);
		this.parentNames.set(node_4206, name_4205);
	};
		fillStatement(e_4207) { return this.nodeToStatement(e_4207) };
		renameClassFields(fields_4208) {
		this.pushScope();
		for (const f of $toIterator(fields_4208)) {
			const temp_4209 = f;
			switch (temp_4209&&temp_4209[0]) {
			case 24: {
				const name_4210 = temp_4209[1];
				const t_4211 = temp_4209[2];
				const expr_4212 = temp_4209[3];
				const const_4213 = temp_4209[4];
				{
					const atts_4214 = this.project.mapDecorators.get(f);
					{
						let step_4215 = 0;
						const native_4216 = Normalizer.getDec(atts_4214, 'rename');
						if (step_4215 == 0 && native_4216 != null) { step_4215 = 1 };
						if (step_4215 == 1) {
							const temp_4217 = native_4216.values[0];
							switch (temp_4217&&temp_4217[0]) {
							case 0: {
								const s_4218 = temp_4217[1];
								if (this.parentNames.get(f) == null) { this.unique(s_4218, f) }
							} break;
							
							default: 
							throw '@rename takes string as argument'
							};
						} else if (this.parentNames.get(f) == null) { this.unique(name_4210, f) };
					};
				}
			} break;
			
			case 22: {
				const name_4219 = temp_4209[1];
				const expr_4220 = temp_4209[2];
				const vars_4221 = temp_4209[3];
				const rettype_4222 = temp_4209[4];
				if (name_4219 == 'new') { this.parentNames.set(f, 'new') } else {
					const atts_4223 = this.project.mapDecorators.get(f);
					{
						let step_4224 = 0;
						const native_4225 = Normalizer.getDec(atts_4223, 'rename');
						if (step_4224 == 0 && native_4225 != null) { step_4224 = 1 };
						if (step_4224 == 1) {
							const temp_4226 = native_4225.values[0];
							switch (temp_4226&&temp_4226[0]) {
							case 0: {
								const s_4227 = temp_4226[1];
								if (this.parentNames.get(f) == null) { this.unique(s_4227, f) }
							} break;
							
							default: 
							throw '@rename takes string as argument'
							};
						} else if (this.parentNames.get(f) == null) { this.unique(name_4219, f) };
					};
				}
			} break;
			
			case 47: {
				const field_4228 = temp_4209[1];
				{
					const temp_4229 = field_4228;
					switch (temp_4229&&temp_4229[0]) {
					case 24: {
						const name_4230 = temp_4229[1];
						const t_4231 = temp_4229[2];
						const expr_4232 = temp_4229[3];
						const const_4233 = temp_4229[4];
						{
							const atts_4234 = this.project.mapDecorators.get(f);
							{
								let step_4235 = 0;
								const native_4236 = Normalizer.getDec(atts_4234, 'rename');
								if (step_4235 == 0 && native_4236 != null) { step_4235 = 1 };
								if (step_4235 == 1) {
									const temp_4237 = native_4236.values[0];
									switch (temp_4237&&temp_4237[0]) {
									case 0: {
										const s_4238 = temp_4237[1];
										if (this.parentNames.get(field_4228) == null) { this.unique(s_4238, field_4228) }
									} break;
									
									default: 
									throw '@rename takes string as argument'
									};
								} else if (this.parentNames.get(field_4228) == null) { this.unique(name_4230, field_4228) };
							};
						}
					} break;
					
					case 22: {
						const name_4239 = temp_4229[1];
						const expr_4240 = temp_4229[2];
						const vars_4241 = temp_4229[3];
						const rettype_4242 = temp_4229[4];
						{
							const atts_4243 = this.project.mapDecorators.get(f);
							{
								let step_4244 = 0;
								const native_4245 = Normalizer.getDec(atts_4243, 'rename');
								if (step_4244 == 0 && native_4245 != null) { step_4244 = 1 };
								if (step_4244 == 1) {
									const temp_4246 = native_4245.values[0];
									switch (temp_4246&&temp_4246[0]) {
									case 0: {
										const s_4247 = temp_4246[1];
										if (this.parentNames.get(field_4228) == null) { this.unique(s_4247, field_4228) }
									} break;
									
									default: 
									throw '@rename takes string as argument'
									};
								} else if (this.parentNames.get(field_4228) == null) { this.unique(name_4239, field_4228) };
							};
						}
					} break;
					};
				}
			} break;
			};
		};
		this.popScope();
	};
		getClassDotField(expr_4248, name_4249) {
		{
			const temp_4250 = expr_4248;
			switch (temp_4250&&temp_4250[0]) {
			case 25: {
				const t_4251 = temp_4250[1];
				const ext_4252 = temp_4250[2];
				const impl_4253 = temp_4250[3];
				const fields_4254 = temp_4250[4];
				const external_4255 = temp_4250[5];
				for (const f of $toIterator(fields_4254)) {
					const temp_4256 = f;
					switch (temp_4256&&temp_4256[0]) {
					case 47: {
						const sf = temp_4256[1];
						if (DataHelper.nameOf(sf) == name_4249) { return (() => {
							const result_4257 = this.parentNames.get(sf);
							if (result_4257 != null) { return result_4257 };
							return name_4249;
						})() }
					} break;
					
					case 24: {
						const n_4258 = temp_4256[1];
						if (n_4258 == name_4249) { return (() => {
							const result_4259 = this.parentNames.get(f);
							if (result_4259 != null) { return result_4259 };
							return name_4249;
						})() }
					} break;
					};
				}
			} break;
			
			case 39: {
				const t_4260 = temp_4250[1];
				const fields_4261 = temp_4250[2];
				const valuesType_4262 = temp_4250[3];
				for (const f of $toIterator(fields_4261)) {
					const temp_4263 = f;
					switch (temp_4263&&temp_4263[0]) {
					case 47: {
						const sf_4264 = temp_4263[1];
						if (DataHelper.nameOf(sf_4264) == name_4249) { return (() => {
							const result_4265 = this.parentNames.get(sf_4264);
							if (result_4265 != null) { return result_4265 };
							return name_4249;
						})() }
					} break;
					};
				}
			} break;
			};
		};
		return null;
	};
		unwrapNestingBlocks(block_4266) {
		const temp_4267 = block_4266;
		switch (temp_4267&&temp_4267[0]) {
		case 1: {
			const el_4268 = temp_4267[1];
			{
				if (el_4268.length == 1) { return this.unwrapNestingBlocks(el_4268[0]) };
				return block_4266;
			}
		} break;
		
		default: 
		return block_4266
		};
	};
		saveInlineIfViable(e_4269, value_4270) {
		const temp_4271 = value_4270;
		switch (temp_4271&&temp_4271[0]) {
		case 1: {
			this.inline.set(e_4269, value_4270)
		} break;
		
		case 2: {
			this.inline.set(e_4269, value_4270)
		} break;
		
		case 0: {
			this.inline.set(e_4269, value_4270)
		} break;
		
		case 3: {
			this.inline.set(e_4269, value_4270)
		} break;
		
		case 4: {
			this.inline.set(e_4269, value_4270)
		} break;
		
		case 5: {
			this.inline.set(e_4269, value_4270)
		} break;
		
		case 7: {
			this.inline.set(e_4269, value_4270)
		} break;
		};
	};
		unwrapParens(inner_4272) {
		const temp_4273 = inner_4272;
		switch (temp_4273&&temp_4273[0]) {
		case 15: {
			const i_4274 = temp_4273[1];
			return this.unwrapParens(i_4274)
		} break;
		
		default: 
		return inner_4272
		};
	};
	}
	Normalizer.getDec = (atts_4194, atname) => {
		if (atts_4194 != null && atts_4194.length > 0) { for (const att of $toIterator(atts_4194)) {
			if (att.name == atname) { return att };
		} };
		return null;
	};
	var Typer = class {
		constructor(project) { 
			this.currentModule = new Module()
			this.scopes = [new Map()]
			this.scopeTypes = [new Map()]
			this.parents = new Map()
			this.types = new Map()
			this.typeString = null
			this.typeIntClass = new ClassType()
			this.typeInt = this.typeIntClass.instantiate()
			this.typeFloat = null
			this.typeBool = null
			this.typeArray = new ClassType()
			this.typeMap = (null)
			this.typeAnyClass = new ClassType()
			this.typeAny = this.typeAnyClass.instantiate()
			this.nodeAny = null
			this.typeVoid = null
			this.namespaces = new Map()
			this.typeBigInt = null
			this.typeInt32 = null
			this.typeInt64 = null
			this.typeInt16 = null
			this.typeInt8 = null
			this.typeUInt32 = null
			this.typeUInt64 = null
			this.typeUInt16 = null
			this.typeUInt8 = null
			this.typeFloat32 = null
			this.functionAllowedToThrow = false
			this.functionThrows = false
			this.insideTry = false
			this.insideFunction = false
			this.allowBreakAndContinue = false
			this.functionReturnsAType = null
			this.functionActuallyReturns = false
			this.insideClassMethod = false
			this.allowSuper = false
			this.thisType = (null)
			this.thisNode = (null)
		this.project = project };
		fillModules() {
		const checkOverrides = (info, name, e) => {
			if (info.exported.has(name)) { this.fail(('Module `' + (info.path) + '` already exports name `' + (name) + '`'), e) };
			if (info.imported.has(name)) { this.fail(('Module `' + (info.path) + '` already imports name `' + (name) + '`'), e) };
		};
		for (const info of $toIterator(this.project.moduleInfo)) {
			const nodes = info.nodes;
			for (const e of $toIterator(nodes)) {
				let named = true;
				{
					const temp = e;
					switch (temp&&temp[0]) {
					case 24: {
						{
						}
					} break;
					
					case 39: {
						{
						}
					} break;
					
					case 22: {
						{
						}
					} break;
					
					case 25: {
						{
						}
					} break;
					
					case 9: {
						{
						}
					} break;
					
					default: 
					named = false
					};
				};
				if (named) {
					const name_4275 = DataHelper.nameOf(e);
					checkOverrides(info, name_4275, e);
					info.exported.set(name_4275, e);
					this.project.mapModules.set(e, info);
				};
			};
		};
		for (const info of $toIterator(this.project.moduleInfo)) {
			const nodes_4276 = info.nodes;
			this.pushScope();
			let doneImports = false;
			for (const e of $toIterator(nodes_4276)) {
				const named_4277 = true;
				let lastOne = nodes_4276[0];
				{
					const temp_4278 = e;
					switch (temp_4278&&temp_4278[0]) {
					case 37: {
						const els = temp_4278[1];
						const path = temp_4278[2];
						{
							if (doneImports) { this.fail('Imports should follow before expressions\n' + this.positionOf(lastOne) + 'Expression is here', e) };
							const index = this.project.mapModules.get(e);
							if (index == null) { this.fail('Cannot import ' + path, e) };
							const importAs = (name_4279, to) => {
								let step = 0;
								const target = index;
								if (step == 0 && target != null) { step = 1 };
								if (step == 1) { if (name_4279 == '*') { info.imported.set(to, /*ModuleExports*/[36,target,".ModuleExports"]) } else {
									let step_4280 = 0;
									const what = target.exported.get(name_4279);
									if (step_4280 == 0 && what != null) { step_4280 = 1 };
									if (step_4280 == 1) {
										checkOverrides(info, to, e);
										info.imported.set(to, what);
									} else {
										let has = (() => {
											const result = [];
											const value = target.exported.keys();
											for (const key of $toIterator(value)) result.push(key);
											return result;
										})().join(', ');
										if (has == '') { has = 'module is empty' };
										this.fail(('Module `' + (path) + '` does not export `' + (name_4279) + '`\nAvailable exports: ' + (has) + ''), e);
									};
								} };
							};
							if (els.length == 0) {
								let step_4281 = 0;
								const target_4282 = index;
								if (step_4281 == 0 && target_4282 != null) { step_4281 = 1 };
								if (step_4281 == 1) { for (const key of $toIterator(target_4282.exported.keys())) {
									info.imported.set(key, target_4282.exported.get(key));
								} };
							};
							for (const el of $toIterator(els)) {
								const temp_4283 = el;
								switch (temp_4283&&temp_4283[0]) {
								case 0: {
									const name_4284 = temp_4283[1];
									importAs(name_4284, name_4284)
								} break;
								
								case 1: {
									const name_4285 = temp_4283[1];
									importAs(name_4285, name_4285)
								} break;
								
								case 3: {
									const left = temp_4283[1];
									const right = temp_4283[2];
									{
										let lhs = '';
										{
											const temp_4286 = left;
											switch (temp_4286&&temp_4286[0]) {
											case 0: {
												const name_4287 = temp_4286[1];
												lhs = name_4287
											} break;
											
											case 1: {
												const name_4288 = temp_4286[1];
												lhs = name_4288
											} break;
											
											case 2: {
												lhs = '*'
											} break;
											
											default: 
											this.fail('This `import ??? as` kind not implemented yet or syntax is incorrect', e)
											};
										};
										{
											const temp_4289 = right;
											switch (temp_4289&&temp_4289[0]) {
											case 0: {
												const name_4290 = temp_4289[1];
												importAs(lhs, name_4290)
											} break;
											
											case 1: {
												const name_4291 = temp_4289[1];
												importAs(lhs, name_4291)
											} break;
											
											default: 
											this.fail(('This `import ' + (lhs) + ' as ???` kind not implemented yet or syntax is incorrect'), e)
											};
										};
									}
								} break;
								
								default: 
								this.fail('This import kind not implemented yet', e)
								};
							};
						}
					} break;
					
					default: 
					{
						lastOne = e;
						doneImports = true;
						const node = e;
						if (this.currentModule != info) {};
						this.currentModule = info;
						{
							const temp_4292 = node;
							switch (temp_4292&&temp_4292[0]) {
							case 25: {
								{
									this.parents.set(node, e);
									this.fillModuleTypes(node);
								}
							} break;
							
							case 39: {
								{
									this.parents.set(node, e);
									this.fillModuleTypes(node);
								}
							} break;
							
							case 9: {
								{
									this.parents.set(node, e);
									this.fillModuleTypes(node);
								}
							} break;
							
							case 22: {
								const name_4293 = temp_4292[1];
								const expr = temp_4292[2];
								const vars = temp_4292[3];
								const rettype = temp_4292[4];
								{
									let step_4294 = 0;
									const rettype_4295 = rettype;
									if (step_4294 == 0 && rettype_4295 != null) { step_4294 = 1 };
									if (step_4294 == 1) {
										this.pushFuncParamsIfRequired(node);
										this.types.set(node, /*Function*/[12,this.varTypes(vars),this.toType(rettype_4295, node),".Function"]);
										this.popFuncParamsIfRequired(node);
									};
								}
							} break;
							
							case 24: {
								const name_4296 = temp_4292[1];
								const t = temp_4292[2];
								const e_4297 = temp_4292[3];
								const const_4298 = temp_4292[4];
								{
									let step_4299 = 0;
									const t_4300 = t;
									if (step_4299 == 0 && t_4300 != null) { step_4299 = 1 };
									if (step_4299 == 1) { this.types.set(node, this.toType(t_4300, node)) };
								}
							} break;
							
							default: 
							{
							}
							};
						};
					}
					};
				};
			};
		};
		const doNotInstantiate = ['ConstArrayPointer', 'ArrayPointer', 'ArrayByValue'];
		for (const info of $toIterator(this.project.moduleInfo)) {
			const nodes_4301 = info.nodes;
			const self = /*Module*/[35,info.path,info.nodes,".Module"];
			this.pushScope();
			this.currentModule = info;
			for (const node of $toIterator(nodes_4301)) {
				const temp_4302 = node;
				switch (temp_4302&&temp_4302[0]) {
				case 37: {
					{
					}
				} break;
				
				case 25: {
					{
					}
				} break;
				
				case 9: {
					{
					}
				} break;
				
				case 39: {
					{
					}
				} break;
				
				default: 
				{
					{
						const temp_4303 = node;
						switch (temp_4303&&temp_4303[0]) {
						case 22: {
							const name_4304 = temp_4303[1];
							{
							}
						} break;
						};
					};
					this.parents.set(node, self);
					this.fill(node);
				}
				};
			};
			this.popScope();
		};
		for (const info of $toIterator(this.project.moduleInfo)) {
			const nodes_4305 = info.nodes;
			const self_4306 = /*Module*/[35,info.path,info.nodes,".Module"];
			this.pushScope();
			this.currentModule = info;
			for (const node of $toIterator(nodes_4305)) {
				const temp_4307 = node;
				switch (temp_4307&&temp_4307[0]) {
				case 37: {
					{
					}
				} break;
				
				case 25: {
					{
						const temp_4308 = (this.types.get(node));
						switch (temp_4308&&temp_4308[0]) {
						case 5: {
							const classType = temp_4308[1];
							if (classType.genericCache.length > 0) { for (const knownParams of $toIterator(classType.genericCache)) {
								const known = knownParams.slice();
								known.shift();
								const cloned = Node.clone(this.project, node);
								let type = (null);
								{
									const temp_4309 = (known[0]);
									switch (temp_4309&&temp_4309[0]) {
									case 2: {
										const handle = temp_4309[1];
										type = handle.value
									} break;
									
									case 1: {
										{
										}
									} break;
									
									default: 
									type = known[0]
									};
								};
								if (type == null) {} else {
									this.parents.set(cloned, cloned);
									this.fillModuleTypes(cloned, known, classType);
								};
							} }
						} break;
						};
					}
				} break;
				
				case 9: {
					{
					}
				} break;
				
				case 39: {
					{
					}
				} break;
				
				default: 
				{
				}
				};
			};
			this.popScope();
		};
		if (Typer.failures.length > 0) {
			const errors = Typer.failures.slice();
			Typer.failures = [];
			throw new CompilerErrors(errors);
		};
	};
		find(name_4310) {
		let subj = null;
		{
			let i = 0;
			let it = 0;
			let at = this.scopes.length;
			while (it < at) {
				i = it;
				it++;
				{
					subj = this.scopes[this.scopes.length - i - 1].get(name_4310);
					if (subj != null) { break };
				};
			};
		};
		if (subj == null) { subj = this.findInNamespaceRoots(name_4310) };
		return subj;
	};
		proposeSimilar(names, subject, what_4311, similarTo) {
		if (names.length == 0) { return ('No ' + (what_4311) + ' available for access') };
		{
			let step_4312 = 0;
			const similarTo_4313 = similarTo;
			if (step_4312 == 0 && similarTo_4313 != null) { step_4312 = 1 };
			if (step_4312 == 1) {
				const firstLetter = similarTo_4313.charAt(0);
				names.sort((left_4314, right_4315) => (((left_4314.startsWith(firstLetter))? ((-1)) : 0)));
			};
		};
		const ten = ((names.length > 11)? (names.slice(0, 10).join(', ') + ' and ' + (names.length - 10) + ' more ' + what_4311) : names.join(', '));
		const available = ('Available ' + (what_4311) + ' are: ') + ten;
		const subject_4316 = subject.toLowerCase();
		const charSubj = subject_4316.split('');
		let bestValue = 0;
		let bestName = '';
		for (const name of $toIterator(names)) {
			const named_4317 = name.toLowerCase();
			if (named_4317.startsWith(subject_4316) || subject_4316.startsWith(named_4317)) { return ('Did you mean `' + (name) + '`?\n\n') + available };
			let index_4318 = 0;
			let thisValue = 0;
			for (const char of $toIterator(named_4317.split(''))) {
				if (char == charSubj[index_4318]) { thisValue++ };
				index_4318++;
			};
			if (thisValue > bestValue) {
				bestValue = thisValue;
				bestName = name;
			};
		};
		if (bestValue > 2) { return ('Did you mean `' + (bestName) + '`?\n\n') + available };
		return available;
	};
		registerClassType(node_4319, callback, params, instanceOf) {
		const mod = this.currentModule;
		this.currentModule = (() => {
			const result_4320 = this.project.mapModules.get(node_4319);
			if (result_4320 != null) { return result_4320 };
			return mod;
		})();
		const registered = this.registerClassTypeWrapped(node_4319, callback, params, instanceOf);
		this.currentModule = mod;
		return registered;
	};
		registerClassTypeWrapped(node_4321, callback_4322, knownParams, instanceOf_4323) {
		let step_4324 = 0;
		const type_4325 = this.types.get(node_4321);
		if (step_4324 == 0 && type_4325 != null) { step_4324 = 1 };
		if (step_4324 == 1) {
			const temp_4326 = (type_4325);
			switch (temp_4326&&temp_4326[0]) {
			case 5: {
				const t_4327 = temp_4326[1];
				{
					{
						let step_4328 = 0;
						const setup = callback_4322;
						if (step_4328 == 0 && setup != null) { step_4328 = 1 };
						if (step_4328 == 1) { setup(t_4327) };
					};
					return t_4327;
				}
			} break;
			};
		} else {
			const typeName = DataHelper.nameOf(node_4321);
			const type_4329 = (() => {
				const temp_4330 = typeName;
				switch (temp_4330) {
				case 'Int': {
					return this.typeIntClass
				} break;
				
				case 'Array': {
					return ((knownParams != null)? (new ClassType()) : this.typeArray)
				} break;
				
				case 'Any': {
					return this.typeAnyClass
				} break;
				
				default: 
				return new ClassType()
				};
			})();
			const _thisType = this.thisType;
			const _thisNode = this.thisNode;
			this.thisType = ((knownParams != null)? (type_4329.instantiateGeneric(knownParams)) : type_4329.instantiate());
			this.thisNode = node_4321;
			type_4329.parent = node_4321;
			type_4329.name = typeName;
			{
				let step_4331 = 0;
				const instanceOf_4332 = instanceOf_4323;
				let temp_4333 = null;
				if (step_4331 == 0 && instanceOf_4332 != null) {
					temp_4333 = knownParams != null;
					step_4331 = 1;
				};
				if (step_4331 == 1 && temp_4333 != false) { step_4331 = 2 };
				if (step_4331 == 2) {
					type_4329.instanceOf = instanceOf_4332;
					type_4329.instanceParams = knownParams;
					instanceOf_4332.instances.push(type_4329);
				};
			};
			this.types.set(node_4321, /*Class*/[5,type_4329,".Class"]);
			{
				let step_4334 = 0;
				const setup_4335 = callback_4322;
				if (step_4334 == 0 && setup_4335 != null) { step_4334 = 1 };
				if (step_4334 == 1) { setup_4335(type_4329) };
			};
			{
				const temp_4336 = type_4329.name;
				switch (temp_4336) {
				case 'Int': {
					{
					}
				} break;
				
				case 'Bool': {
					this.typeBool = type_4329.instantiate()
				} break;
				
				case 'Float': {
					this.typeFloat = type_4329.instantiate()
				} break;
				
				case 'Float32': {
					this.typeFloat32 = type_4329.instantiate()
				} break;
				
				case 'String': {
					this.typeString = type_4329.instantiate()
				} break;
				
				case 'Array': {
					if (knownParams == null) { this.typeArray = type_4329 }
				} break;
				
				case 'Map': {
					if (knownParams == null) { this.typeMap = type_4329 }
				} break;
				
				case 'Any': {
					this.nodeAny = node_4321
				} break;
				
				case 'Void': {
					this.typeVoid = type_4329.instantiate()
				} break;
				
				case 'UInt8': {
					this.typeUInt8 = type_4329.instantiate()
				} break;
				
				case 'UInt16': {
					this.typeUInt16 = type_4329.instantiate()
				} break;
				
				case 'UInt32': {
					this.typeUInt32 = type_4329.instantiate()
				} break;
				
				case 'UInt64': {
					this.typeUInt64 = type_4329.instantiate()
				} break;
				
				case 'Int8': {
					this.typeInt8 = type_4329.instantiate()
				} break;
				
				case 'Int16': {
					this.typeInt16 = type_4329.instantiate()
				} break;
				
				case 'Int32': {
					this.typeInt32 = type_4329.instantiate()
				} break;
				
				case 'Int64': {
					this.typeInt64 = type_4329.instantiate()
				} break;
				
				case 'BigInt': {
					this.typeBigInt = type_4329.instantiate()
				} break;
				};
			};
			const getRename = (f) => {
				const atts = this.project.mapDecorators.get(f);
				{
					let step_4337 = 0;
					const native = DataHelper.getDecorator(atts, 'rename');
					if (step_4337 == 0 && native != null) { step_4337 = 1 };
					if (step_4337 == 1) {
						if (native.values.length != 1) { throw '@rename takes one string argument' };
						if (native != null) {
							const temp_4338 = native.values[0];
							switch (temp_4338&&temp_4338[0]) {
							case 0: {
								const s = temp_4338[1];
								return s
							} break;
							
							default: 
							throw '@rename takes string as argument'
							};
						};
					};
				};
				return null;
			};
			{
				const temp_4339 = node_4321;
				switch (temp_4339&&temp_4339[0]) {
				case 25: {
					const t_4340 = temp_4339[1];
					const extend = temp_4339[2];
					const implement = temp_4339[3];
					const f_4341 = temp_4339[4];
					const external = temp_4339[5];
					{
						{
							const temp_4342 = t_4340;
							switch (temp_4342&&temp_4342[0]) {
							case 2: {
								const name_4343 = temp_4342[1];
								const params_4344 = temp_4342[2];
								{
									type_4329.genericParams.push(DataHelper.extractTypeName(params_4344[0]));
									const names_4345 = type_4329.genericParams;
									{
										let i_4346 = 0;
										let it_4347 = 1;
										let at_4348 = params_4344.length;
										while (it_4347 < at_4348) {
											i_4346 = it_4347;
											it_4347++;
											{
												const name_4349 = DataHelper.extractTypeName(params_4344[i_4346]);
												if (names_4345.includes(name_4349)) { this.fail(('Parameter `' + (name_4349) + '` already exists in `<T, ...>`'), node_4321) };
												names_4345.push(name_4349);
											};
										};
									};
								}
							} break;
							};
						};
						{
							let step_4350 = 0;
							const ext = extend;
							if (step_4350 == 0 && ext != null) { step_4350 = 1 };
							if (step_4350 == 1) { type_4329.extend = this.toType(ext, node_4321) };
						};
						for (const impl of $toIterator(implement)) {
							this.toType(impl, node_4321);
						};
						this.pushScope();
						let genericParamIndex = 0;
						for (const genericParam of $toIterator(type_4329.genericParams)) {
							this.addScopeType(genericParam, this.typeAny);
							{
								let step_4351 = 0;
								const knownParams_4352 = knownParams;
								if (step_4351 == 0 && knownParams_4352 != null) { step_4351 = 1 };
								if (step_4351 == 1) { this.addScopeType(genericParam, knownParams_4352[genericParamIndex]) } else {
									this.addScopeType(genericParam, /*Generic*/[1,genericParamIndex,genericParam,".Generic"]);
								};
							};
							genericParamIndex++;
						};
						for (const field of $toIterator(f_4341)) {
							{
								const temp_4353 = field;
								switch (temp_4353&&temp_4353[0]) {
								case 22: {
									const name_4354 = temp_4353[1];
									{
										if (type_4329.fieldNames.includes(name_4354)) { this.fail(('Field `' + (name_4354) + '` already exists'), field) };
										type_4329.fieldNames.push(name_4354);
										if (name_4354 == 'new') { type_4329.constructor = type_4329.fieldNames.length - 1 } else {
											type_4329.fieldRenames[type_4329.fieldNames.length - 1] = getRename(field);
										};
										this.addScope(name_4354, field);
									}
								} break;
								
								case 24: {
									const name_4355 = temp_4353[1];
									const t_4356 = temp_4353[2];
									const e_4357 = temp_4353[3];
									{
										if (type_4329.fieldNames.includes(name_4355)) { this.fail(('Field `' + (name_4355) + '` already exists'), field) };
										type_4329.fieldNames.push(name_4355);
										type_4329.fieldInitialized[type_4329.fieldNames.length - 1] = false;
										type_4329.fieldRenames[type_4329.fieldNames.length - 1] = getRename(field);
										this.addScope(name_4355, field);
									}
								} break;
								
								case 26: {
									const field = temp_4353[1];
									{
										const temp_4358 = field;
										switch (temp_4358&&temp_4358[0]) {
										case 24: {
											const name_4359 = temp_4358[1];
											{
												if (type_4329.fieldNames.includes(name_4359)) { this.fail(('Field `' + (name_4359) + '` already exists'), field) };
												type_4329.fieldNames.push(name_4359);
												this.addScope(name_4359, field);
											}
										} break;
										};
									}
								} break;
								
								case 47: {
									const f_4360 = temp_4353[1];
									{
										const temp_4361 = f_4360;
										switch (temp_4361&&temp_4361[0]) {
										case 22: {
											const name_4362 = temp_4361[1];
											{
												if (type_4329.fieldNames.includes(name_4362)) { this.fail(('Field `' + (name_4362) + '` already exists'), field) };
												type_4329.fieldNames.push(name_4362);
												type_4329.fieldStatic[type_4329.fieldNames.length - 1] = true;
												this.addScope(name_4362, field);
											}
										} break;
										
										case 24: {
											const name_4363 = temp_4361[1];
											{
												if (type_4329.fieldNames.includes(name_4363)) { this.fail(('Field `' + (name_4363) + '` already exists'), field) };
												type_4329.fieldNames.push(name_4363);
												type_4329.fieldStatic[type_4329.fieldNames.length - 1] = true;
												this.addScope(name_4363, field);
											}
										} break;
										};
									}
								} break;
								
								default: 
								this.fail('Wrong class field format', field)
								};
							};
							this.parents.set(field, node_4321);
						};
						for (const field of $toIterator(f_4341)) {
							const temp_4364 = field;
							switch (temp_4364&&temp_4364[0]) {
							case 24: {
								const name_4365 = temp_4364[1];
								const t_4366 = temp_4364[2];
								const e_4367 = temp_4364[3];
								const const_4368 = temp_4364[4];
								{
									let step_4369 = 0;
									const t_4370 = t_4366;
									if (step_4369 == 0 && t_4370 != null) { step_4369 = 1 };
									if (step_4369 == 1) { this.types.set(field, this.toType(t_4370, field)) };
								}
							} break;
							
							case 22: {
								const name_4371 = temp_4364[1];
								const expr_4372 = temp_4364[2];
								const vars_4373 = temp_4364[3];
								const rettype_4374 = temp_4364[4];
								{
									let step_4375 = 0;
									const rettype_4376 = rettype_4374;
									if (step_4375 == 0 && rettype_4376 != null) { step_4375 = 1 };
									if (step_4375 == 1) { this.types.set(field, /*Function*/[12,this.varTypes(vars_4373),this.toType(rettype_4376, field),".Function"]) };
								}
							} break;
							
							case 47: {
								const f_4377 = temp_4364[1];
								{
									const temp_4378 = f_4377;
									switch (temp_4378&&temp_4378[0]) {
									case 22: {
										const name_4379 = temp_4378[1];
										const expr_4380 = temp_4378[2];
										const vars_4381 = temp_4378[3];
										const rettype_4382 = temp_4378[4];
										{
											let step_4383 = 0;
											const rettype_4384 = rettype_4382;
											if (step_4383 == 0 && rettype_4384 != null) { step_4383 = 1 };
											if (step_4383 == 1) {
												this.types.set(f_4377, /*Function*/[12,this.varTypes(vars_4381),this.toType(rettype_4384, f_4377),".Function"]);
												this.types.set(field, this.types.get(f_4377));
											};
										}
									} break;
									
									case 24: {
										const name_4385 = temp_4378[1];
										const t_4386 = temp_4378[2];
										const e_4387 = temp_4378[3];
										const const_4388 = temp_4378[4];
										{
											let step_4389 = 0;
											const t_4390 = t_4386;
											if (step_4389 == 0 && t_4390 != null) { step_4389 = 1 };
											if (step_4389 == 1) {
												this.types.set(f_4377, this.toType(t_4390, f_4377));
												this.types.set(field, this.types.get(f_4377));
											};
										}
									} break;
									};
								}
							} break;
							};
						};
						for (const field of $toIterator(f_4341)) {
							const temp_4391 = field;
							switch (temp_4391&&temp_4391[0]) {
							case 22: {
								const name_4392 = temp_4391[1];
								const expr_4393 = temp_4391[2];
								const vars_4394 = temp_4391[3];
								const rettype_4395 = temp_4391[4];
								{
									if (name_4392 == 'new') { type_4329.constructor = type_4329.fieldNames.length - 1 };
									if ((external) && (expr_4393 != null)) { if (name_4392 == 'new') { this.fail('External class constructor `new()` cannot have a body `{}`', field) } else {
										this.fail(('External class method `function ' + (name_4392) + '` cannot have a body `{}`'), field);
									} };
									const _insideClassMethod = this.insideClassMethod;
									const _allowSuper = this.allowSuper;
									this.insideClassMethod = true;
									this.allowSuper = (extend != null);
									if ((!external)) { this.fillFunction(field, expr_4393, vars_4394, rettype_4395) };
									if ((external) && (this.types.get(field) == null)) { this.types.set(field, /*Function*/[12,this.varTypes(vars_4394),((rettype_4395 != null)? (this.toType(rettype_4395, field)) : this.typeVoid),".Function"]) };
									this.insideClassMethod = _insideClassMethod;
									this.allowSuper = _allowSuper;
								}
							} break;
							
							case 24: {
								const name_4396 = temp_4391[1];
								const t_4397 = temp_4391[2];
								const e_4398 = temp_4391[3];
								const const_4399 = temp_4391[4];
								{
									if ((external) && (e_4398 != null)) { this.fail(('External class field `var ' + (name_4396) + '` cannot have `= value`'), field) };
									const _insideClassMethod_4400 = this.insideClassMethod;
									this.insideClassMethod = true;
									if (e_4398 != null) { this.fillExpression(e_4398) };
									this.insideClassMethod = _insideClassMethod_4400;
									this.mixVarTypes(t_4397, e_4398, field);
									type_4329.fieldInitialized[type_4329.fieldNames.indexOf(name_4396)] = true;
									if (this.types.get(field) == null) { this.fail(('Field `var ' + (name_4396) + '` initialized, but got no type ') + e_4398, field) };
								}
							} break;
							
							case 26: {
								const f_4401 = temp_4391[1];
								{
									const temp_4402 = f_4401;
									switch (temp_4402&&temp_4402[0]) {
									case 24: {
										const name_4403 = temp_4402[1];
										const t_4404 = temp_4402[2];
										const e_4405 = temp_4402[3];
										const const_4406 = temp_4402[4];
										{
											if ((external) && (e_4405 != null)) { this.fail(('External class field `var ' + (name_4403) + '` cannot have expression'), field) };
											const _insideClassMethod_4407 = this.insideClassMethod;
											this.insideClassMethod = true;
											if (e_4405 != null) { this.fillExpression(e_4405) };
											this.insideClassMethod = _insideClassMethod_4407;
											this.mixVarTypes(t_4404, e_4405, f_4401);
											type_4329.fieldInitialized[type_4329.fieldNames.indexOf(name_4403)] = true;
											if (this.types.get(f_4401) == null) { this.fail(('Property `' + (name_4403) + '` initialized, but got no type ') + e_4405, field) };
											this.types.set(field, this.types.get(f_4401));
										}
									} break;
									};
								}
							} break;
							
							case 47: {
								const f_4408 = temp_4391[1];
								{
									const temp_4409 = f_4408;
									switch (temp_4409&&temp_4409[0]) {
									case 22: {
										const name_4410 = temp_4409[1];
										const expr_4411 = temp_4409[2];
										const vars_4412 = temp_4409[3];
										const rettype_4413 = temp_4409[4];
										{
											if ((external) && (expr_4411 != null)) { this.fail(('External class field `static fun ' + (name_4410) + '` cannot have a body'), field) };
											const _insideClassMethod_4414 = this.insideClassMethod;
											this.insideClassMethod = false;
											if ((!external)) { this.fillFunction(f_4408, expr_4411, vars_4412, rettype_4413) };
											if (external) { this.types.set(f_4408, /*Function*/[12,this.varTypes(vars_4412),((rettype_4413 != null)? (this.toType(rettype_4413, f_4408)) : this.typeVoid),".Function"]) };
											this.insideClassMethod = _insideClassMethod_4414;
											if (this.types.get(f_4408) == null) { this.fail('Function get no type: class ' + DataHelper.nameOf(node_4321) + ' static ' + name_4410, f_4408) };
											this.types.set(field, this.types.get(f_4408));
										}
									} break;
									
									case 24: {
										const name_4415 = temp_4409[1];
										const t_4416 = temp_4409[2];
										const e_4417 = temp_4409[3];
										const const_4418 = temp_4409[4];
										{
											if ((external) && (e_4417 != null)) { this.fail(('External class field `static var ' + (name_4415) + '` cannot have expression'), field) };
											if (e_4417 != null) { this.fillExpression(e_4417) };
											this.mixVarTypes(t_4416, e_4417, f_4408);
											this.types.set(field, this.types.get(f_4408));
										}
									} break;
									};
								}
							} break;
							
							default: 
							this.fail('Wrong class field format', node_4321)
							};
						};
						this.popScope();
					}
				} break;
				
				default: 
				this.fail('ClassType expects (declare) class node, but got ' + node_4321, node_4321)
				};
			};
			this.thisType = _thisType;
			this.thisNode = _thisNode;
			return type_4329;
		};
	};
		registerEnumType(node_4419) {
		let step_4420 = 0;
		const type_4421 = this.types.get(node_4419);
		if (step_4420 == 0 && type_4421 != null) { step_4420 = 1 };
		if (step_4420 == 1) {
			const temp_4422 = (type_4421);
			switch (temp_4422&&temp_4422[0]) {
			case 8: {
				const t_4423 = temp_4422[1];
				return t_4423
			} break;
			};
		} else {
			const type_4424 = new EnumType();
			type_4424.parent = node_4419;
			type_4424.name = DataHelper.nameOf(node_4419);
			this.types.set(node_4419, /*Enum*/[8,type_4424,".Enum"]);
			{
				const temp_4425 = node_4419;
				switch (temp_4425&&temp_4425[0]) {
				case 39: {
					const t_4426 = temp_4425[1];
					const f_4427 = temp_4425[2];
					const valuesType = temp_4425[3];
					const extend_4428 = temp_4425[4];
					{
						this.pushScope();
						{
							let step_4429 = 0;
							const valuesType_4430 = valuesType;
							if (step_4429 == 0 && valuesType_4430 != null) { step_4429 = 1 };
							if (step_4429 == 1) { type_4424.fieldsTypeSimple = this.toType(valuesType_4430, node_4419) };
						};
						if ((type_4424.fieldsTypeSimple != null) && (type_4424.fieldsTypeSimple != this.typeString) && (type_4424.fieldsTypeSimple != this.typeInt) && (type_4424.fieldsTypeSimple != this.typeInt8) && (type_4424.fieldsTypeSimple != this.typeInt16) && (type_4424.fieldsTypeSimple != this.typeInt32) && (type_4424.fieldsTypeSimple != this.typeInt64) && (type_4424.fieldsTypeSimple != this.typeUInt8) && (type_4424.fieldsTypeSimple != this.typeUInt16) && (type_4424.fieldsTypeSimple != this.typeUInt32) && (type_4424.fieldsTypeSimple != this.typeUInt64)) { this.fail('Simple enums may be only of integer and string types', node_4419) };
						if ((f_4427.length == 0) && (extend_4428 == null)) { this.fail(('Enum `' + (type_4424.name) + '` must have at least one value `enum ' + (type_4424.name) + ' { Value }`'), node_4419) };
						for (const field of $toIterator(f_4427)) {
							{
								const temp_4431 = field;
								switch (temp_4431&&temp_4431[0]) {
								case 51: {
									const t_4432 = temp_4431[1];
									{
										const temp_4433 = t_4432;
										switch (temp_4433&&temp_4433[0]) {
										case 1: {
											const name_4434 = temp_4433[1];
											{
												if (type_4424.fieldNames.includes(name_4434)) { throw this.fail(('Field `' + (name_4434) + '` already exists'), node_4419) };
												type_4424.fieldNames.push(name_4434);
												type_4424.fieldEnumConstructor[type_4424.fieldNames.length - 1] = true;
												type_4424.tagBindVars[type_4424.fieldNames.length - 1] = [];
												type_4424.tagBindVarsNames[type_4424.fieldNames.length - 1] = [];
												type_4424.fieldType[type_4424.fieldNames.length - 1] = /*EnumInstance*/[9,type_4424,type_4424.fieldNames.length - 1,".EnumInstance"];
											}
										} break;
										
										default: 
										this.fail('Wrong enum constructor format, should be `Name`', node_4419)
										};
									}
								} break;
								
								case 13: {
									const e_4435 = temp_4431[1];
									const args = temp_4431[2];
									const argNames = temp_4431[3];
									{
										if (valuesType != null) { throw this.fail('Cannot use `Value(args)` format for simple enum', node_4419) };
										{
											const temp_4436 = e_4435;
											switch (temp_4436&&temp_4436[0]) {
											case 51: {
												const t_4437 = temp_4436[1];
												{
													const temp_4438 = t_4437;
													switch (temp_4438&&temp_4438[0]) {
													case 1: {
														const name_4439 = temp_4438[1];
														{
															if (type_4424.fieldNames.includes(name_4439)) { throw this.fail(('Field `' + (name_4439) + '` already exists'), node_4419) };
															type_4424.fieldNames.push(name_4439);
															type_4424.fieldEnumConstructor[type_4424.fieldNames.length - 1] = true;
															type_4424.fieldType[type_4424.fieldNames.length - 1] = /*EnumConstructor*/[10,type_4424,type_4424.fieldNames.length - 1,".EnumConstructor"];
															const tagBindVars = [];
															const tagBindVarsNames = [];
															type_4424.tagBindVars[type_4424.fieldNames.length - 1] = tagBindVars;
															type_4424.tagBindVarsNames[type_4424.fieldNames.length - 1] = tagBindVarsNames;
															if (args.length == 0) { this.fail('Enum constructor expects more than zero arguments `(value: Type)`', e_4435) };
															{
																let i_4440 = 0;
																let it_4441 = 0;
																let at_4442 = args.length;
																while (it_4441 < at_4442) {
																	i_4440 = it_4441;
																	it_4441++;
																	{
																		if (argNames[i_4440] == null) { this.fail('Enum constructor arguments should have names `E(name1: T, name2: T)', args[i_4440]) };
																		tagBindVars[i_4440] = Typer.nodeToNodeType(args[i_4440]);
																		if (tagBindVarsNames.includes(argNames[i_4440])) { this.fail(('Enum constructor argument `' + (argNames[i_4440]) + '` already exists'), args[i_4440]) };
																		tagBindVarsNames[i_4440] = argNames[i_4440];
																	};
																};
															};
														}
													} break;
													
													default: 
													this.fail('Wrong enum constructor format, should be `Name(value: T)`', e_4435)
													};
												}
											} break;
											};
										};
									}
								} break;
								
								case 10: {
									const a = temp_4431[1];
									const op = temp_4431[2];
									const b = temp_4431[3];
									{
										if (op != 91) { this.fail(('Should use `Value = value` not `Value ' + (Token.stringify(op)) + ' value` format for enum tag value'), node_4419) };
										if (valuesType == null) { this.fail('Cannot use `Value = value` format for complex enum', node_4419) };
										{
											const temp_4443 = a;
											switch (temp_4443&&temp_4443[0]) {
											case 51: {
												const t_4444 = temp_4443[1];
												{
													const temp_4445 = t_4444;
													switch (temp_4445&&temp_4445[0]) {
													case 1: {
														const name_4446 = temp_4445[1];
														{
															if (type_4424.fieldNames.includes(name_4446)) { this.fail(('Field `' + (name_4446) + '` already exists'), node_4419) };
															type_4424.fieldNames.push(name_4446);
															type_4424.fieldEnumConstructor[type_4424.fieldNames.length - 1] = true;
															{
																const temp_4447 = b;
																switch (temp_4447&&temp_4447[0]) {
																case 5: {
																	if ((type_4424.fieldsTypeSimple != this.typeInt) && (type_4424.fieldsTypeSimple != this.typeInt32) && (type_4424.fieldsTypeSimple != this.typeInt16) && (type_4424.fieldsTypeSimple != this.typeInt8) && (type_4424.fieldsTypeSimple != this.typeInt64) && (type_4424.fieldsTypeSimple != this.typeUInt32) && (type_4424.fieldsTypeSimple != this.typeUInt16) && (type_4424.fieldsTypeSimple != this.typeUInt8) && (type_4424.fieldsTypeSimple != this.typeUInt64)) { this.fail(('`' + (name_4446) + ' = value` expects constant value of type `' + (Type.stringify(type_4424.fieldsTypeSimple)) + '`'), b) }
																} break;
																
																case 0: {
																	if (type_4424.fieldsTypeSimple != this.typeString) { this.fail(('`' + (name_4446) + ' = value` expects constant value of type `' + (Type.stringify(type_4424.fieldsTypeSimple)) + '`'), b) }
																} break;
																};
															};
															this.fillExpression(b);
															type_4424.fieldType[type_4424.fieldNames.length - 1] = /*EnumInstance*/[9,type_4424,type_4424.fieldNames.length - 1,".EnumInstance"];
														}
													} break;
													};
												}
											} break;
											};
										};
									}
								} break;
								
								case 1: {
									const name_4448 = temp_4431[1];
									this.fail(('Cannot use lowercase `' + (name_4448) + '` format for enum values'), node_4419)
								} break;
								
								case 47: {
									const f_4449 = temp_4431[1];
									{
										const temp_4450 = f_4449;
										switch (temp_4450&&temp_4450[0]) {
										case 22: {
											const name_4451 = temp_4450[1];
											{
												if (type_4424.fieldNames.includes(name_4451)) { this.fail(('Field `' + (name_4451) + '` already exists'), node_4419) };
												type_4424.fieldNames.push(name_4451);
												type_4424.fieldStatic[type_4424.fieldNames.length - 1] = true;
												this.addScope(name_4451, field);
											}
										} break;
										
										case 24: {
											const name_4452 = temp_4450[1];
											{
												if (type_4424.fieldNames.includes(name_4452)) { this.fail(('Field `' + (name_4452) + '` already exists'), node_4419) };
												type_4424.fieldNames.push(name_4452);
												type_4424.fieldStatic[type_4424.fieldNames.length - 1] = true;
												this.addScope(name_4452, field);
											}
										} break;
										};
									}
								} break;
								
								case 22: {
									const name_4453 = temp_4431[1];
									const expr_4454 = temp_4431[2];
									const vars_4455 = temp_4431[3];
									const rettype_4456 = temp_4431[4];
									this.fail('Enum fields cannot be functions', field)
								} break;
								
								default: 
								this.fail('Wrong enum field format', field)
								};
							};
							this.parents.set(field, node_4419);
						};
						for (const field of $toIterator(f_4427)) {
							const temp_4457 = field;
							switch (temp_4457&&temp_4457[0]) {
							case 22: {
								const name_4458 = temp_4457[1];
								const expr_4459 = temp_4457[2];
								const vars_4460 = temp_4457[3];
								const rettype_4461 = temp_4457[4];
								this.fillFunction(field, expr_4459, vars_4460, rettype_4461)
							} break;
							
							case 24: {
								const name_4462 = temp_4457[1];
								{
								}
							} break;
							
							case 47: {
								const f_4463 = temp_4457[1];
								{
									const temp_4464 = f_4463;
									switch (temp_4464&&temp_4464[0]) {
									case 22: {
										const name_4465 = temp_4464[1];
										const expr_4466 = temp_4464[2];
										const vars_4467 = temp_4464[3];
										const rettype_4468 = temp_4464[4];
										{
											const _insideClassMethod_4469 = this.insideClassMethod;
											this.insideClassMethod = false;
											if (rettype_4468 != null) { this.types.set(f_4463, /*Function*/[12,[],this.toType(rettype_4468, f_4463),".Function"]) } else {
												this.types.set(f_4463, /*Function*/[12,[],this.typeVoid,".Function"]);
											};
											this.types.set(field, this.types.get(f_4463));
											this.fillFunction(f_4463, expr_4466, vars_4467, rettype_4468);
											this.insideClassMethod = _insideClassMethod_4469;
											if (this.types.get(f_4463) == null) { this.fail('Function get no type: enum ' + DataHelper.nameOf(node_4419) + ' static ' + name_4465, f_4463) };
											this.types.set(field, this.types.get(f_4463));
										}
									} break;
									
									case 24: {
										const name_4470 = temp_4464[1];
										const t_4471 = temp_4464[2];
										const e_4472 = temp_4464[3];
										const const_4473 = temp_4464[4];
										{
											if (e_4472 != null) { this.fillExpression(e_4472) };
											this.mixVarTypes(t_4471, e_4472, f_4463);
											this.types.set(field, this.types.get(f_4463));
										}
									} break;
									};
								}
							} break;
							
							case 51: {
								{
								}
							} break;
							
							case 13: {
								{
								}
							} break;
							
							case 10: {
								{
								}
							} break;
							
							default: 
							this.fail('Unknown enum field format', field)
							};
						};
						this.popScope();
					}
				} break;
				
				default: 
				this.fail('EnumType expects (declare) enum node, but got ' + node_4419, node_4419)
				};
			};
			return type_4424;
		};
	};
		fail(msg, node_4474) {
		this.failNonFatal(msg, node_4474);
		const errors_4475 = Typer.failures.slice();
		Typer.failures = [];
		throw new CompilerErrors(errors_4475);
	};
		failNonFatal(msg_4476, node_4477) {
		const t_4478 = this.project.data.get;
		const data = this.project.data.get(node_4477);
		{
			let step_4479 = 0;
			const data_4480 = data;
			if (step_4479 == 0 && data_4480 != null) { step_4479 = 1 };
			if (step_4479 == 1) { Typer.failures.push(new CompilerError(3, msg_4476, data_4480.line, data_4480.column, data_4480.fileName)) } else {
				Typer.failures.push(new CompilerError(3, msg_4476, 0, 0, ''));
			};
		};
	};
		positionOf(node_4481) {
		const data_4482 = this.project.data.get(node_4481);
		if (data_4482 == null) { return '[Unknown]: ' };
		return '[' + data_4482.fileName + ':' + data_4482.line + ':' + data_4482.column + ']: ';
	};
		nameOfModuleItem(node_4490) {
		const temp_4491 = node_4490;
		switch (temp_4491&&temp_4491[0]) {
		case 24: {
			const name_4492 = temp_4491[1];
			return name_4492
		} break;
		
		case 22: {
			const name_4493 = temp_4491[1];
			{
				let step_4494 = 0;
				const named_4495 = name_4493;
				if (step_4494 == 0 && named_4495 != null) { step_4494 = 1 };
				if (step_4494 == 1) { return named_4495 } else {
					throw 'Module function should have a name';
				};
			}
		} break;
		
		case 48: {
			const node_4496 = temp_4491[1];
			{
				const temp_4497 = node_4496;
				switch (temp_4497&&temp_4497[0]) {
				case 25: {
					const t_4498 = temp_4497[1];
					{
						const temp_4499 = t_4498;
						switch (temp_4499&&temp_4499[0]) {
						case 1: {
							const name_4500 = temp_4499[1];
							return name_4500
						} break;
						
						case 2: {
							const name_4501 = temp_4499[1];
							return name_4501
						} break;
						};
					}
				} break;
				};
			}
		} break;
		
		case 25: {
			const t_4502 = temp_4491[1];
			{
				const temp_4503 = t_4502;
				switch (temp_4503&&temp_4503[0]) {
				case 1: {
					const name_4504 = temp_4503[1];
					return name_4504
				} break;
				
				case 2: {
					const name_4505 = temp_4503[1];
					return name_4505
				} break;
				};
			}
		} break;
		
		case 39: {
			const t_4506 = temp_4491[1];
			{
				const temp_4507 = t_4506;
				switch (temp_4507&&temp_4507[0]) {
				case 1: {
					const name_4508 = temp_4507[1];
					return name_4508
				} break;
				
				case 2: {
					const name_4509 = temp_4507[1];
					return name_4509
				} break;
				};
			}
		} break;
		
		case 9: {
			const t_4510 = temp_4491[1];
			{
				const temp_4511 = t_4510;
				switch (temp_4511&&temp_4511[0]) {
				case 1: {
					const name_4512 = temp_4511[1];
					return name_4512
				} break;
				
				case 2: {
					const name_4513 = temp_4511[1];
					return name_4513
				} break;
				};
			}
		} break;
		
		default: 
		this.fail('Improper module item format, wrap expressions as `{ expressions }`', node_4490)
		};
	};
		findInNamespaceRoots(name_4514) {
		{
			let step_4515 = 0;
			const node_4516 = this.currentModule.imported.get(name_4514);
			if (step_4515 == 0 && node_4516 != null) { step_4515 = 1 };
			if (step_4515 == 1) { return node_4516 };
		};
		{
			let step_4517 = 0;
			const node_4518 = this.currentModule.exported.get(name_4514);
			if (step_4517 == 0 && node_4518 != null) { step_4517 = 1 };
			if (step_4517 == 1) { return node_4518 };
		};
		{
			let step_4519 = 0;
			const node_4520 = this.project.globals.get(name_4514);
			if (step_4519 == 0 && node_4520 != null) { step_4519 = 1 };
			if (step_4519 == 1) { return node_4520 };
		};
		return null;
	};
		pushScope() {
		this.scopes.push(new Map());
		this.scopeTypes.push(new Map());
	};
		popScope() {
		this.scopes.pop();
		this.scopeTypes.pop();
	};
		addScope(name_4524, node_4525) { this.scopes[this.scopes.length - 1].set(name_4524, node_4525) };
		addScopeType(name_4526, type_4527) { this.scopeTypes[this.scopeTypes.length - 1].set(name_4526, type_4527) };
		unify(to_4528, fromValue, node_4529) {
		if (to_4528 == fromValue) { return to_4528 };
		if (to_4528 == this.typeAny) { return to_4528 };
		if (fromValue == this.typeVoid) { this.fail(('Incompatible types `' + (Type.stringify(to_4528)) + '` and non-value type `Void`'), node_4529) };
		if ((to_4528 == this.typeFloat) && (fromValue == this.typeInt)) { return this.typeFloat };
		const isNullable = (t_4530) => {
			{
				const temp_4531 = t_4530;
				switch (temp_4531&&temp_4531[0]) {
				case 3: {
					return true
				} break;
				
				case 4: {
					return true
				} break;
				};
			};
			return false;
		};
		const instanceOfClass = (t_4532) => {
			{
				const temp_4533 = Type.unwrapNullable(t_4532);
				switch (temp_4533&&temp_4533[0]) {
				case 6: {
					const t_4534 = temp_4533[1];
					return t_4534
				} break;
				
				case 5: {
					const t_4535 = temp_4533[1];
					this.fail(('Cannot take classes `class ' + (t_4535.name) + '` as values'), node_4529)
				} break;
				};
			};
			return null;
		};
		const instanceOfEnum = (t_4536) => {
			{
				const temp_4537 = Type.unwrapNullable(t_4536);
				switch (temp_4537&&temp_4537[0]) {
				case 9: {
					const t_4538 = temp_4537[1];
					return t_4538
				} break;
				
				case 8: {
					const t_4539 = temp_4537[1];
					return t_4539
				} break;
				};
			};
			return null;
		};
		{
			const temp_4540 = to_4528;
			switch (temp_4540&&temp_4540[0]) {
			case 3: {
				const handle_4541 = temp_4540[1];
				if (handle_4541.value == null) { handle_4541.value = (() => {
					const temp_4542 = fromValue;
					switch (temp_4542&&temp_4542[0]) {
					case 3: {
						const handle_4543 = temp_4542[1];
						return handle_4543.value
					} break;
					
					case 4: {
						const t_4544 = temp_4542[1];
						return t_4544
					} break;
					
					default: 
					return fromValue
					};
				})() }
			} break;
			};
		};
		const toNullable = isNullable(to_4528);
		const fromNullable = isNullable(fromValue);
		const toInstance = instanceOfClass(to_4528);
		const fromInstance = instanceOfClass(fromValue);
		const toEnumInstance = instanceOfEnum(to_4528);
		const fromEnumInstance = instanceOfEnum(fromValue);
		if ((toInstance == null && toEnumInstance == null) || (fromInstance == null && fromEnumInstance == null)) { return (() => {
			const result_4545 = to_4528;
			if (result_4545 != null) { return result_4545 };
			return fromValue;
		})() };
		if ((toInstance != fromInstance) && (Type.unwrapNullable(to_4528) != this.typeAny) && (Type.unwrapNullable(fromValue) != this.typeAny)) {
			if ((to_4528 == this.typeFloat) && ([this.typeUInt32, this.typeUInt16, this.typeUInt8, this.typeInt32, this.typeInt16, this.typeInt8, this.typeFloat32, this.typeInt].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeFloat32) && ([this.typeUInt16, this.typeUInt8, this.typeInt16, this.typeInt8].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeUInt16) && ([this.typeUInt8].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeInt16) && ([this.typeUInt8, this.typeInt8].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeUInt64) && ([this.typeUInt8, this.typeUInt16, this.typeUInt32].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeInt64) && (fromValue == this.typeInt)) { return to_4528 };
			if ((to_4528 == this.typeInt64) && (fromValue == this.typeInt32)) { return to_4528 };
			if ((to_4528 == this.typeInt64) && (fromValue == this.typeUInt32)) { return to_4528 };
			if ((to_4528 == this.typeInt64) && ([this.typeInt8, this.typeInt16, this.typeInt32, this.typeUInt8, this.typeUInt16, this.typeUInt32].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeUInt64) && (fromValue == this.typeUInt32)) { return to_4528 };
			if ((to_4528 == this.typeUInt32) && (fromValue == this.typeUInt8)) { return to_4528 };
			if ((to_4528 == this.typeUInt32) && (fromValue == this.typeUInt16)) { return to_4528 };
			if ((to_4528 == this.typeInt32 || to_4528 == this.typeInt) && ([this.typeUInt8, this.typeInt8, this.typeUInt16, this.typeInt16, this.typeInt].includes(fromValue))) { return to_4528 };
			if ((to_4528 == this.typeInt32) && (fromValue == this.typeUInt16)) { return to_4528 };
			if ((to_4528 == this.typeInt32 && fromValue == this.typeInt) || (to_4528 == this.typeInt && fromValue == this.typeInt32)) { return this.typeInt32 };
			{
				const temp_4546 = node_4529;
				switch (temp_4546&&temp_4546[0]) {
				case 5: {
					const value_4547 = temp_4546[1];
					{
						if (value_4547 == 0 && [this.typeInt64, this.typeInt32, this.typeInt16, this.typeInt8, this.typeUInt64, this.typeUInt32, this.typeUInt16, this.typeUInt8, this.typeInt].includes(fromValue)) { return to_4528 };
						if ((to_4528 == this.typeUInt8) && (value_4547 >= 0) && (value_4547 < 256)) { return to_4528 };
						if ((to_4528 == this.typeUInt16) && (value_4547 >= 0) && (value_4547 < 65536)) { return to_4528 };
						if ((to_4528 == this.typeUInt32) && (value_4547 >= 0) && (value_4547 < 4294967296n)) { return to_4528 };
						if ((to_4528 == this.typeUInt64) && (value_4547 >= 0) && (value_4547 < 18446744073709551616n)) { return to_4528 };
					}
				} break;
				};
			};
			const toName = Type.primaryName(to_4528);
			const fromName = Type.primaryName(fromValue);
			if ((toName == 'ArrayByValue') && ((fromName == 'Array' || fromName == 'String'))) { return to_4528 };
			if ((toName == 'ConstPointer') && (fromName == 'Pointer')) { return to_4528 };
			{
				const temp_4548 = node_4529;
				switch (temp_4548&&temp_4548[0]) {
				case 5: {
					const value_4549 = temp_4548[1];
					{
						if (to_4528 == this.typeUInt64) {};
						if ((value_4549 >= 0) && (value_4549 < 18446744073709551616n)) {};
					}
				} break;
				};
			};
			{
				const temp_4550 = fromValue;
				switch (temp_4550&&temp_4550[0]) {
				case 6: {
					const type_4551 = temp_4550[1];
					const generic = temp_4550[2];
					{
						{
							const temp_4552 = to_4528;
							switch (temp_4552&&temp_4552[0]) {
							case 6: {
								const typeTo = temp_4552[1];
								const genericTo = temp_4552[2];
								if (type_4551.name == typeTo.name) {
									const temp_4553 = generic[0];
									switch (temp_4553&&temp_4553[0]) {
									case 2: {
										const handle_4554 = temp_4553[1];
										return to_4528
									} break;
									
									default: 
									{
										{
											let step_4555 = 0;
											const instanceOf_4556 = type_4551.instanceOf;
											if (step_4555 == 0 && instanceOf_4556 != null) { step_4555 = 1 };
											if (step_4555 == 1) { return instanceOf_4556.instantiateGeneric(genericTo) };
										};
										{
											let step_4557 = 0;
											const instanceOf_4558 = typeTo.instanceOf;
											if (step_4557 == 0 && instanceOf_4558 != null) { step_4557 = 1 };
											if (step_4557 == 1) { return instanceOf_4558.instantiateGeneric(genericTo) };
										};
									}
									};
								}
							} break;
							};
						};
						let extended = type_4551.extend;
						while (true) {
							let step_4559 = 0;
							const extend_4560 = extended;
							if (step_4559 == 0 && extend_4560 != null) { step_4559 = 1 };
							if (step_4559 == 1) {
								if (extend_4560 == to_4528) { return to_4528 };
								{
									const temp_4561 = extend_4560;
									switch (temp_4561&&temp_4561[0]) {
									case 6: {
										const type_4562 = temp_4561[1];
										const generic_4563 = temp_4561[2];
										extended = type_4562.extend
									} break;
									
									case 5: {
										const type_4564 = temp_4561[1];
										extended = type_4564.extend
									} break;
									
									default: 
									extended = null
									};
								};
							} else {
								break;
							};
						};
					}
				} break;
				};
			};
			this.fail(('Incompatible types `' + (Type.stringify(to_4528)) + '` and value of `' + (Type.stringify(fromValue)) + '`'), node_4529);
		};
		if ((toEnumInstance != fromEnumInstance) && (Type.unwrapNullable(to_4528) != this.typeAny) && (Type.unwrapNullable(fromValue) != this.typeAny)) {};
		return (() => {
			const result_4565 = to_4528;
			if (result_4565 != null) { return result_4565 };
			return fromValue;
		})();
	};
		findType(name_4566) {
		{
			let i_4567 = 0;
			let it_4568 = 0;
			let at_4569 = this.scopes.length;
			while (it_4568 < at_4569) {
				i_4567 = it_4568;
				it_4568++;
				{
					let step_4570 = 0;
					const subj_4571 = this.scopes[this.scopes.length - i_4567 - 1].get(name_4566);
					if (step_4570 == 0 && subj_4571 != null) { step_4570 = 1 };
					if (step_4570 == 1) { return subj_4571 };
				};
			};
		};
		const rooted = this.findInNamespaceRoots(name_4566);
		if (rooted == null) {};
		return rooted;
	};
		findActualType(name_4572) {
		{
			let i_4573 = 0;
			let it_4574 = 0;
			let at_4575 = this.scopeTypes.length;
			while (it_4574 < at_4575) {
				i_4573 = it_4574;
				it_4574++;
				{
					let step_4576 = 0;
					const subj_4577 = this.scopeTypes[this.scopeTypes.length - i_4573 - 1].get(name_4572);
					if (step_4576 == 0 && subj_4577 != null) { step_4576 = 1 };
					if (step_4576 == 1) { return subj_4577 };
				};
			};
		};
		return null;
	};
		toType(t_4578, node_4579) {
		const temp_4580 = t_4578;
		switch (temp_4580&&temp_4580[0]) {
		case 1: {
			const name_4581 = temp_4580[1];
			const path_4582 = temp_4580[2];
			{
				let nodeType = null;
				{
					let step_4583 = 0;
					const path_4584 = path_4582;
					if (step_4583 == 0 && path_4584 != null) { step_4583 = 1 };
					if (step_4583 == 1) {
						const temp_4585 = (this.currentModule.imported.get(path_4584));
						switch (temp_4585&&temp_4585[0]) {
						case 36: {
							const handle_4586 = temp_4585[1];
							{
								nodeType = handle_4586.exported.get(name_4581);
								if (nodeType == null) {
									const file = handle_4586.file;
									this.fail(('Namespace `' + (path_4584) + '` does not export type `' + (name_4581) + '` (aliased module is `' + (file) + '`)'), node_4579);
								};
							}
						} break;
						
						default: 
						this.fail(('Cannot find supposedly imported namespace `' + (path_4584) + '` of type `' + (name_4581) + '`'), node_4579)
						};
					} else {
						nodeType = (() => {
							const result_4587 = this.findType(name_4581);
							if (result_4587 != null) { return result_4587 };
							return (() => {
								const result_4588 = this.currentModule.exported.get(name_4581);
								if (result_4588 != null) { return result_4588 };
								return this.currentModule.imported.get(name_4581);
							})();
						})();
					};
				};
				if (this.types.get(nodeType) == null) {
					const temp_4589 = nodeType;
					switch (temp_4589&&temp_4589[0]) {
					case 25: {
						{
							const mod_4590 = this.currentModule;
							this.registerClassType(nodeType);
							this.currentModule = mod_4590;
						}
					} break;
					
					case 39: {
						this.registerEnumType(nodeType)
					} break;
					
					case null: case undefined: {
						{
						}
					} break;
					
					default: 
					{
					}
					};
				};
				const type_4591 = (() => {
					const result_4592 = this.findActualType(name_4581);
					if (result_4592 != null) { return result_4592 };
					return this.types.get(nodeType);
				})();
				{
					const temp_4593 = type_4591;
					switch (temp_4593&&temp_4593[0]) {
					case 5: {
						const type_4594 = temp_4593[1];
						{
							if (type_4594.genericParams.length > 0) { this.fail(('The type `' + (type_4594.name) + '` requires `<' + (type_4594.genericParams) + '>` generic parameters'), node_4579) };
							return type_4594.instantiate();
						}
					} break;
					
					case 8: {
						const type_4595 = temp_4593[1];
						return this.types.get(nodeType)
					} break;
					
					case 6: {
						return type_4591
					} break;
					
					case 9: {
						return type_4591
					} break;
					
					case 4: {
						return type_4591
					} break;
					
					case null: case undefined: {
						{
							const available_4596 = [];
							for (const name of $toIterator(this.currentModule.imported.keys())) {
								available_4596.push(name);
							};
							for (const name of $toIterator(this.currentModule.exported.keys())) {
								available_4596.push(name);
							};
							this.fail(('Cannot find type `' + (name_4581) + '`\n') + this.proposeSimilar(available_4596.filter((named_4597) => (DataHelper.isTitleCase(named_4597))), name_4581, 'types', name_4581), node_4579);
						}
					} break;
					
					case 11: {
						const alias = temp_4593[1];
						return this.toType(alias.value, node_4579)
					} break;
					
					default: 
					{
						if (type_4591 == this.typeAny) { return this.typeAny };
						{
							const temp_4598 = type_4591;
							switch (temp_4598&&temp_4598[0]) {
							case 1: {
								return type_4591
							} break;
							};
						};
						return type_4591;
					}
					};
				};
			}
		} break;
		
		case 2: {
			const name_4599 = temp_4580[1];
			const params_4600 = temp_4580[2];
			const path_4601 = temp_4580[3];
			{
				const nodeType_4602 = (() => {
					const result_4603 = this.findType(name_4599);
					if (result_4603 != null) { return result_4603 };
					return (() => {
						const result_4604 = this.currentModule.exported.get(name_4599);
						if (result_4604 != null) { return result_4604 };
						return this.currentModule.imported.get(name_4599);
					})();
				})();
				if (this.types.get(nodeType_4602) == null) {
					const temp_4605 = nodeType_4602;
					switch (temp_4605&&temp_4605[0]) {
					case 25: {
						{
							const mod_4606 = this.currentModule;
							this.registerClassType(nodeType_4602);
							this.currentModule = mod_4606;
						}
					} break;
					
					case 39: {
						this.registerEnumType(nodeType_4602)
					} break;
					};
				};
				const type_4607 = (() => {
					const result_4608 = this.findActualType(name_4599);
					if (result_4608 != null) { return result_4608 };
					return this.types.get(nodeType_4602);
				})();
				{
					const temp_4609 = type_4607;
					switch (temp_4609&&temp_4609[0]) {
					case 5: {
						const type_4610 = temp_4609[1];
						{
							if (type_4610.genericParams.length == 0) { this.fail(('The type `' + (type_4610.name) + '` requires zero generic parameters'), node_4579) };
							if (type_4610.genericParams.length != params_4600.length) { this.fail(('The type `' + (type_4610.name) + '` requires `<' + (type_4610.genericParams) + '>` generic parameters'), node_4579) };
							return type_4610.instantiateGeneric((() => {
								const result_4611 = [];
								const value_4612 = params_4600;
								for (const p of $toIterator(value_4612)) result_4611.push(this.toType(p, node_4579));
								return result_4611;
							})());
						}
					} break;
					
					case null: case undefined: {
						this.fail(('Cannot find type `' + (name_4599) + '`'), node_4579)
					} break;
					
					default: 
					{
						if (type_4607 == this.typeAny) { return this.typeAny };
						{
							const temp_4613 = type_4607;
							switch (temp_4613&&temp_4613[0]) {
							case 1: {
								return this.typeAny
							} break;
							};
						};
						this.fail(('Unsupported type `' + (name_4599) + '`'), node_4579);
					}
					};
				};
			}
		} break;
		
		case 0: {
			const t_4614 = temp_4580[1];
			return /*Nullable*/[4,this.toType(t_4614, node_4579),".Nullable"]
		} break;
		
		case 3: {
			const args_4615 = temp_4580[1];
			const ret = temp_4580[2];
			return /*Function*/[12,(() => {
				const result_4616 = [];
				const value_4617 = args_4615;
				for (const arg of $toIterator(value_4617)) result_4616.push(this.toType(arg, node_4579));
				return result_4616;
			})(),this.toType(ret, node_4579),".Function"]
		} break;
		
		case 5: {
			const names_4618 = temp_4580[1];
			const el_4619 = temp_4580[2];
			{
				const els_4620 = (() => {
					const result_4621 = [];
					const value_4622 = el_4619;
					for (const e of $toIterator(value_4622)) result_4621.push(this.toType(e, node_4579));
					return result_4621;
				})();
				return /*Struct*/[13,names_4618,els_4620,".Struct"];
			}
		} break;
		
		case 7: {
			const value_4623 = temp_4580[1];
			return /*Constant*/[0,'' + value_4623,".Constant"]
		} break;
		
		case 6: {
			const value_4624 = temp_4580[1];
			return /*Constant*/[0,'' + value_4624,".Constant"]
		} break;
		
		default: 
		this.fail('Unsupported node type ' + t_4578 + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_4579)
		};
	};
		mixVarTypes(t_4625, e_4626, node_4627) {
		if ((t_4625 != null) && (e_4626 != null)) { this.types.set(node_4627, this.unify(this.toType(t_4625, node_4627), this.types.get(e_4626), e_4626)) };
		if ((t_4625 == null) && (e_4626 != null)) { this.types.set(node_4627, this.types.get(e_4626)) };
		if ((t_4625 == null) && (e_4626 == null)) { this.types.set(node_4627, /*UnknownNullable*/[3,{value:null},".UnknownNullable"]) };
		if ((t_4625 != null) && (e_4626 == null)) { this.types.set(node_4627, this.toType(t_4625, node_4627)) };
	};
		areCovariant(left_4628, right_4629, strictNull) {
		if (left_4628 == right_4629) { return true };
		let left_4630 = left_4628;
		let right_4631 = right_4629;
		let leftNullable = false;
		let rightNullable = false;
		{
			const temp_4632 = left_4630;
			switch (temp_4632&&temp_4632[0]) {
			case null: case undefined: {
				return true
			} break;
			
			case 4: {
				const t_4633 = temp_4632[1];
				{
					left_4630 = t_4633;
					leftNullable = true;
				}
			} break;
			};
		};
		{
			const temp_4634 = right_4631;
			switch (temp_4634&&temp_4634[0]) {
			case null: case undefined: {
				return true
			} break;
			
			case 4: {
				const t_4635 = temp_4634[1];
				{
					right_4631 = t_4635;
					rightNullable = true;
				}
			} break;
			};
		};
		if ((rightNullable) && ((!leftNullable)) && (strictNull)) { return false };
		if (left_4630 == this.typeAny || right_4631 == this.typeAny) { return true };
		if (left_4630 == right_4631) { return true };
		{
			const temp_4636 = left_4630;
			switch (temp_4636&&temp_4636[0]) {
			case 8: {
				const lt = temp_4636[1];
				{
					const temp_4637 = right_4631;
					switch (temp_4637&&temp_4637[0]) {
					case 9: {
						const rt = temp_4637[1];
						if (lt == rt) { return true }
					} break;
					
					case 8: {
						const rt_4638 = temp_4637[1];
						if (lt == rt_4638) { return true }
					} break;
					};
				}
			} break;
			
			case 9: {
				const lt_4639 = temp_4636[1];
				{
					const temp_4640 = right_4631;
					switch (temp_4640&&temp_4640[0]) {
					case 9: {
						const rt_4641 = temp_4640[1];
						if (lt_4639 == rt_4641) { return true }
					} break;
					
					case 8: {
						const rt_4642 = temp_4640[1];
						if (lt_4639 == rt_4642) { return true }
					} break;
					};
				}
			} break;
			};
		};
		return false;
	};
		areComparable(left_4643, right_4644) {
		if (left_4643 == this.typeAny || right_4644 == this.typeAny) { return true };
		const numerical = [this.typeInt, this.typeFloat, this.typeFloat32, this.typeBigInt, this.typeUInt64, this.typeUInt32, this.typeUInt16, this.typeUInt8, this.typeInt64, this.typeInt32, this.typeInt16, this.typeInt8];
		return numerical.includes(left_4643) && numerical.includes(right_4644);
	};
		pushFuncParamsIfRequired(func) {
		let step_4645 = 0;
		const params_4646 = (this.project.mapFuncParams.get(func));
		let temp_4647 = null;
		if (step_4645 == 0 && params_4646 != null) {
			temp_4647 = params_4646.length > 0;
			step_4645 = 1;
		};
		if (step_4645 == 1 && temp_4647 != false) { step_4645 = 2 };
		if (step_4645 == 2) {
			this.pushScope();
			for (const genericParam of $toIterator(params_4646)) {
				const name_4648 = DataHelper.extractTypeName(genericParam);
				this.addScopeType(name_4648, this.typeAny);
			};
		};
	};
		popFuncParamsIfRequired(func_4649) {
		let step_4650 = 0;
		const params_4651 = (this.project.mapFuncParams.get(func_4649));
		let temp_4652 = null;
		if (step_4650 == 0 && params_4651 != null) {
			temp_4652 = params_4651.length > 0;
			step_4650 = 1;
		};
		if (step_4650 == 1 && temp_4652 != false) { step_4650 = 2 };
		if (step_4650 == 2) { this.popScope() };
	};
		varTypes(vars_4653) {
		const varTypes = [];
		for (const v of $toIterator(vars_4653)) {
			const temp_4654 = v;
			switch (temp_4654&&temp_4654[0]) {
			case 24: {
				const t_4655 = temp_4654[2];
				{
					let step_4656 = 0;
					const t_4657 = t_4655;
					if (step_4656 == 0 && t_4657 != null) { step_4656 = 1 };
					if (step_4656 == 1) { varTypes.push(this.toType(t_4657, v)) } else {
						varTypes.push(/*Unknown*/[2,{value:null},".Unknown"]);
					};
				}
			} break;
			};
		};
		return varTypes;
	};
		booleanable(type_4658) { return (type_4658 == this.typeBool) || (type_4658 == this.typeAny) };
		fillFunction(node_4659, expr_4660, vars_4661, rettype_4662, arrow) {
		const argNames_4663 = [];
		this.pushScope();
		const _insideFunction = this.insideFunction;
		const _functionAllowedToThrow = this.functionAllowedToThrow;
		const _functionThrows = this.functionThrows;
		const _functionReturnsAType = this.functionReturnsAType;
		const _functionActuallyReturns = this.functionActuallyReturns;
		const _insideTry = this.insideTry;
		{
			let i_4664 = 0;
			let it_4665 = 0;
			let at_4666 = vars_4661.length;
			while (it_4665 < at_4666) {
				i_4664 = it_4665;
				it_4665++;
				{
					const v = vars_4661[i_4664];
					{
						const temp_4667 = v;
						switch (temp_4667&&temp_4667[0]) {
						case 24: {
							const vname = temp_4667[1];
							const t_4668 = temp_4667[2];
							const e_4669 = temp_4667[3];
							const const_4670 = temp_4667[4];
							{
								if (argNames_4663.includes(vname)) { this.fail(('Argument `' + (vname) + '` defined multiple times'), v) };
								argNames_4663.push(vname);
								if ((t_4668 != null) && (this.toType(t_4668, v) == this.typeVoid)) { this.fail('Argument cannot be of type `Void`', v) };
								if (t_4668 != null) { this.types.set(v, this.toType(t_4668, v)) };
								if (e_4669 != null) {
									this.fillExpression(e_4669);
									{
										let step_4671 = 0;
										const t_4672 = this.types.get(v);
										if (step_4671 == 0 && t_4672 != null) { step_4671 = 1 };
										if (step_4671 == 1) { this.unify(t_4672, this.types.get(e_4669), e_4669) };
									};
								};
								this.addScope(vname, v);
							}
						} break;
						};
					};
				};
			};
		};
		{
			const temp_4673 = node_4659;
			switch (temp_4673&&temp_4673[0]) {
			case 22: {
				{
					let step_4674 = 0;
					const params_4675 = (this.project.mapFuncParams.get(node_4659));
					if (step_4674 == 0 && params_4675 != null) { step_4674 = 1 };
					if (step_4674 == 1) { for (const genericParam of $toIterator(params_4675)) {
						const name_4676 = DataHelper.extractTypeName(genericParam);
						this.addScopeType(name_4676, this.typeAny);
					} };
				}
			} break;
			};
		};
		let ret_4677 = null;
		{
			let step_4678 = 0;
			const rt_4679 = rettype_4662;
			if (step_4678 == 0 && rt_4679 != null) { step_4678 = 1 };
			if (step_4678 == 1) { ret_4677 = this.toType(rt_4679, node_4659) };
		};
		this.functionReturnsAType = ret_4677;
		this.functionActuallyReturns = false;
		const atts_4680 = this.project.mapDecorators.get(node_4659);
		{
			let step_4681 = 0;
			const noThrow = DataHelper.getDecorator(atts_4680, 'noThrow');
			if (step_4681 == 0 && noThrow != null) { step_4681 = 1 };
			if (step_4681 == 1) {
				if (noThrow.values.length > 0) { this.fail('Decorator `@noThrow` should have no parameters', node_4659) };
				this.functionAllowedToThrow = false;
			} else {
				this.functionAllowedToThrow = true;
			};
		};
		{
			let step_4682 = 0;
			const throws = DataHelper.getDecorator(atts_4680, 'throws');
			if (step_4682 == 0 && throws != null) { step_4682 = 1 };
			if (step_4682 == 1) {
				if (this.functionAllowedToThrow == false) { this.fail('Decorator `@noThrow` cannot be used with `@throws`', node_4659) };
				this.functionThrows = true;
			} else {
				this.functionThrows = false;
			};
		};
		this.insideFunction = true;
		this.insideTry = false;
		if ((arrow) && (expr_4660 != null)) { this.fillExpression(expr_4660) };
		if (((!arrow)) && (expr_4660 != null)) { this.fill(expr_4660) };
		this.popScope();
		ret_4677 = this.functionReturnsAType;
		if (arrow) { if ((arrow) && (ret_4677 == null) && (expr_4660 != null)) { ret_4677 = this.types.get(expr_4660) } else {
			this.unify(this.types.get(expr_4660), ret_4677, expr_4660);
		} } else {
			if (ret_4677 == null) { ret_4677 = this.typeVoid };
			if ((ret_4677 != this.typeVoid) && (expr_4660 != null) && (this.functionActuallyReturns == false)) { this.fail(('Function expects result of `' + (Type.stringify(ret_4677)) + '` but never does `return value`'), node_4659) };
		};
		this.insideFunction = _insideFunction;
		this.functionReturnsAType = _functionReturnsAType;
		this.functionActuallyReturns = _functionActuallyReturns;
		this.types.set(node_4659, /*Function*/[12,(() => {
			const result_4683 = [];
			const value_4684 = vars_4661;
			for (const v of $toIterator(value_4684)) result_4683.push(this.types.get(v));
			return result_4683;
		})(),ret_4677,".Function"]);
	};
		fillModuleTypes(node_4685, params_4686, instanceOf_4687) {
		const temp_4688 = node_4685;
		switch (temp_4688&&temp_4688[0]) {
		case 25: {
			const t_4689 = temp_4688[1];
			const extend_4690 = temp_4688[2];
			const implement_4691 = temp_4688[3];
			const f_4692 = temp_4688[4];
			const external_4693 = temp_4688[5];
			{
				this.addScope(DataHelper.extractTypeName(t_4689), node_4685);
				const mod_4694 = this.currentModule;
				if (params_4686 != null) {};
				this.registerClassType(node_4685, null, params_4686, instanceOf_4687);
				this.currentModule = mod_4694;
			}
		} break;
		
		case 39: {
			const t_4695 = temp_4688[1];
			const f_4696 = temp_4688[2];
			const valuesType_4697 = temp_4688[3];
			{
				this.addScope(DataHelper.extractTypeName(t_4695), node_4685);
				const mod_4698 = this.currentModule;
				this.registerEnumType(node_4685);
				this.currentModule = mod_4698;
			}
		} break;
		
		case 9: {
			const alias_4699 = temp_4688[1];
			const value_4700 = temp_4688[2];
			{
				const type_4701 = new AliasType(value_4700);
				this.types.set(node_4685, /*Alias*/[11,type_4701,".Alias"]);
				this.addScope(this.nameOfModuleItem(node_4685), node_4685);
			}
		} break;
		
		default: 
		console.log('fillModuleTypes', node_4685)
		};
	};
		fill(node_4702) {
		const temp_4703 = node_4702;
		switch (temp_4703&&temp_4703[0]) {
		case 25: {
			this.fail('Defining classes within blocks not allowed', node_4702)
		} break;
		
		case 39: {
			this.fail('Defining enums within blocks not allowed', node_4702)
		} break;
		
		case 9: {
			const t_4704 = temp_4703[2];
			{
				this.fail('Defining alias within blocks not allowed', node_4702);
				const name_4705 = (() => {
					const temp_4706 = t_4704;
					switch (temp_4706&&temp_4706[0]) {
					case 1: {
						const name_4707 = temp_4706[1];
						return name_4707
					} break;
					
					case 2: {
						const name_4708 = temp_4706[1];
						return name_4708
					} break;
					
					case null: case undefined: {
						return (() => {
							this.fail('Type has no name: ' + NodeType.stringify(t_4704), node_4702);
							return '';
						})()
					} break;
					
					default: 
					return (() => {
						this.fail('Wrong alias format: ' + NodeType.stringify(t_4704), node_4702);
						return '';
					})()
					};
				})();
				const type_4709 = this.findActualType(name_4705);
				this.types.set(node_4702, /*Alias*/[11,type_4709,".Alias"]);
				this.addScope(this.nameOfModuleItem(node_4702), node_4702);
			}
		} break;
		
		case 12: {
			const el_4710 = temp_4703[1];
			{
				this.pushScope();
				for (const e of $toIterator(el_4710)) {
					{
						const temp_4711 = e;
						switch (temp_4711&&temp_4711[0]) {
						case 1: {
							const name_4712 = temp_4711[1];
							{
							}
						} break;
						};
					};
					this.fill(e);
				};
				this.popScope();
			}
		} break;
		
		case 24: {
			const name_4713 = temp_4703[1];
			const t_4714 = temp_4703[2];
			const e_4715 = temp_4703[3];
			const const_4716 = temp_4703[4];
			const external_4717 = temp_4703[5];
			{
				if ((e_4715 == null) && (const_4716) && ((!external_4717))) { this.fail(('Constant should have a value `let ' + (name_4713) + ' = value`'), node_4702) };
				if ((e_4715 != null) && (external_4717)) { this.fail(('External variable should not have a value `declare let ' + (name_4713) + '`'), node_4702) };
				if ((t_4714 == null) && (external_4717)) { this.fail(('External variable should have a type `declare let ' + (name_4713) + ': T`'), node_4702) };
				if (e_4715 != null) {
					this.pushScope();
					this.fillExpression(e_4715);
					this.popScope();
				};
				if (name_4713 == 'aazz') { console.log('before', t_4714 != null, e_4715 != null, node_4702 != null) };
				this.mixVarTypes(t_4714, e_4715, node_4702);
				if (name_4713 == 'aazz') { console.log('after') };
				this.addScope(name_4713, node_4702);
			}
		} break;
		
		case 10: {
			const a_4718 = temp_4703[1];
			const op_4719 = temp_4703[2];
			const b_4720 = temp_4703[3];
			{
				this.fillExpression(node_4702);
				const parent = this.parents.get(a_4718);
				if (op_4719 == 91) {
					const temp_4721 = parent;
					switch (temp_4721&&temp_4721[0]) {
					case null: case undefined: {
						{
							const temp_4722 = a_4718;
							switch (temp_4722&&temp_4722[0]) {
							case 1: {
								{
								}
							} break;
							
							case 28: {
								{
								}
							} break;
							
							case 33: {
								{
								}
							} break;
							
							default: 
							this.fail(('Cannot reassign `' + (Node.stringify(a_4718)) + '`'), a_4718)
							};
						}
					} break;
					
					case 24: {
						const name_4723 = temp_4721[1];
						const const_4724 = temp_4721[4];
						{
							if (const_4724) { this.fail(('Cannot reassign a constant `let ' + (name_4723) + '`, redefine it as `var ' + (name_4723) + '` to allow reassignment\n') + this.positionOf(parent) + ('`let ' + (name_4723) + '` is defined here'), node_4702) };
							const newType = this.unify(this.types.get(a_4718), this.types.get(b_4720), b_4720);
							this.types.set(node_4702, newType);
							const parentType = this.types.get(parent);
							{
								const temp_4725 = parentType;
								switch (temp_4725&&temp_4725[0]) {
								case null: case undefined: {
									this.types.set(parent, newType)
								} break;
								
								case 3: {
									const handle_4726 = temp_4725[1];
									if (handle_4726.value == null) { handle_4726.value = newType }
								} break;
								};
							};
						}
					} break;
					
					case 1: {
						const name_4727 = temp_4721[1];
						this.fail(('Cannot reassign case parameter `' + (name_4727) + '`'), node_4702)
					} break;
					
					case 22: {
						const name_4728 = temp_4721[1];
						this.fail(('Cannot reassign a function `' + (name_4728) + '`'), node_4702)
					} break;
					
					case 25: {
						this.fail('Cannot reassign class', node_4702)
					} break;
					
					case 39: {
						this.fail('Cannot reassign enum', node_4702)
					} break;
					
					case 49: {
						const name_4729 = temp_4721[1];
						this.fail(('Cannot reassign iterator value `' + (name_4729) + '` of for loop\n') + this.positionOf(parent) + ('`for ' + (name_4729) + ' in ...` is defined here'), node_4702)
					} break;
					
					case 47: {
						{
						}
					} break;
					
					case 4: {
						this.fail('Cannot reassign `super`', node_4702)
					} break;
					
					default: 
					this.fail('`=` not implemented for: ' + parent, node_4702)
					};
				};
			}
		} break;
		
		case 18: {
			if ((!this.allowBreakAndContinue)) { this.fail('Cannot use `break` outside of loop', node_4702) }
		} break;
		
		case 49: {
			const name_4730 = temp_4703[1];
			const over = temp_4703[2];
			const by = temp_4703[3];
			const range = temp_4703[4];
			{
				const iterableIntegers = [this.typeInt, this.typeUInt64, this.typeUInt32, this.typeUInt16, this.typeUInt8, this.typeInt64, this.typeInt32, this.typeInt16, this.typeInt8];
				this.pushScope();
				this.fillExpression(over);
				const overType = this.types.get(over);
				{
					const temp_4731 = overType;
					switch (temp_4731&&temp_4731[0]) {
					case 6: {
						const type_4732 = temp_4731[1];
						const generic_4733 = temp_4731[2];
						if ((generic_4733 != null) && (generic_4733.length == 1)) { this.types.set(node_4702, generic_4733[0]) } else if (iterableIntegers.includes(overType)) { this.types.set(node_4702, overType) } else {
							this.fail('Type of iterable is neither integer nor `Array`, but ' + Type.stringify(overType), over);
						}
					} break;
					
					case 4: {
						this.fail('Type of iterable should not be nullable', over)
					} break;
					
					case 3: {
						this.fail('Type of iterable should not be nullable', over)
					} break;
					
					case null: case undefined: {
						{
						}
					} break;
					
					default: 
					this.fail('Type of iterable is neither integer nor `Array`', over)
					};
				};
				{
					let step_4734 = 0;
					const range_4735 = range;
					if (step_4734 == 0 && range_4735 != null) { step_4734 = 1 };
					if (step_4734 == 1) {
						this.fillExpression(range_4735);
						const endType = this.types.get(range_4735);
						if ((!iterableIntegers.includes(endType))) { this.fail('Range end must be of integer type', range_4735) };
						if ((!iterableIntegers.includes(overType))) { this.fail('Range start must be of integer type', over) };
						if (endType != overType) { this.fail('Range start and end must be of the same type, but got `' + Type.stringify(overType) + '...' + Type.stringify(endType) + '`', over) };
						this.types.set(node_4702, overType);
					};
				};
				this.addScope(name_4730, node_4702);
				const _allowBreakAndContinue = this.allowBreakAndContinue;
				this.allowBreakAndContinue = true;
				{
					const temp_4736 = by;
					switch (temp_4736&&temp_4736[0]) {
					case 12: {
						{
						}
					} break;
					
					default: 
					this.fail('Loop body must be a `{` block `}`', by)
					};
				};
				this.fill(by);
				this.allowBreakAndContinue = _allowBreakAndContinue;
				this.popScope();
			}
		} break;
		
		case 22: {
			const name_4737 = temp_4703[1];
			const expr_4738 = temp_4703[2];
			const vars_4739 = temp_4703[3];
			const rettype_4740 = temp_4703[4];
			const external_4741 = temp_4703[5];
			{
				if (((!external_4741)) && (expr_4738 == null)) { this.fail(('Non-external function `' + (name_4737) + '` should have a body'), node_4702) };
				if ((external_4741) && (rettype_4740 == null)) { this.fail(('External function `' + (name_4737) + '` should have a returning type'), node_4702) };
				this.addScope(name_4737, node_4702);
				this.pushFuncParamsIfRequired(node_4702);
				this.fillFunction(node_4702, expr_4738, vars_4739, rettype_4740);
			}
		} break;
		
		case 14: {
			const econd = temp_4703[1];
			const eif = temp_4703[2];
			const eelse = temp_4703[3];
			{
				let depth = 0;
				for (const e of $toIterator(econd)) {
					const temp_4743 = e;
					switch (temp_4743&&temp_4743[0]) {
					case 24: {
						const name_4744 = temp_4743[1];
						const t_4745 = temp_4743[2];
						const expr_4746 = temp_4743[3];
						const const_4747 = temp_4743[4];
						{
							if ((!const_4747)) { this.fail('Only `if let` bindings supported, not `if var`', node_4702) };
							if (t_4745 != null) { this.fail('Do not specify a type `: T` in `if let` bindings', node_4702) };
							if (expr_4746 == null) { this.fail(('`if let` binding should have a value `' + (name_4744) + ' = value'), node_4702) };
							depth++;
							this.pushScope();
							this.pushScope();
							this.fillExpression(expr_4746);
							this.popScope();
							{
								const temp_4748 = (this.types.get(expr_4746));
								switch (temp_4748&&temp_4748[0]) {
								case 4: {
									const t_4749 = temp_4748[1];
									this.types.set(e, t_4749)
								} break;
								
								case 3: {
									const handle_4750 = temp_4748[1];
									{
										let step_4751 = 0;
										const t_4752 = handle_4750.value;
										if (step_4751 == 0 && t_4752 != null) { step_4751 = 1 };
										if (step_4751 == 1) { this.types.set(e, t_4752) } else {
											this.fail('`if let` cannot bind not fully known nullable type', node_4702);
										};
									}
								} break;
								
								default: 
								this.types.set(e, this.types.get(expr_4746))
								};
							};
							this.addScope(name_4744, e);
						}
					} break;
					
					default: 
					{
						this.fillExpression(e);
						const type_4753 = this.types.get(e);
						if ((type_4753 != this.typeBool) && (type_4753 != this.typeAny) && (type_4753 != null)) {
							if (type_4753 == this.typeInt) { this.fail('Use `if ' + Node.stringify(e) + ' != 0` syntax to compare `Int` values with zero', e) };
							this.fail('`if value` expects `value` only of type `Bool`, but got `' + Type.stringify(type_4753) + '`', e);
						};
					}
					};
				};
				this.fill(eif);
				while (depth > 0) {
					depth--;
					this.popScope();
				};
				if (eelse != null) { this.fill(eelse) };
			}
		} break;
		
		case 34: {
			const exprs = temp_4703[1];
			const conds = temp_4703[2];
			const guards = temp_4703[3];
			const cases = temp_4703[4];
			this.fillSwitch(node_4702, false)
		} break;
		
		case 27: {
			const e_4754 = temp_4703[1];
			const t_4755 = temp_4703[2];
			const v_4756 = temp_4703[3];
			const ca = temp_4703[4];
			{
				const _insideTry_4757 = this.insideTry;
				this.insideTry = true;
				{
					const temp_4758 = e_4754;
					switch (temp_4758&&temp_4758[0]) {
					case 12: {
						{
						}
					} break;
					
					default: 
					this.fail('Try body must be a `{ block }`', e_4754)
					};
				};
				this.fill(e_4754);
				this.insideTry = _insideTry_4757;
				{
					let i_4759 = 0;
					let it_4760 = 0;
					let at_4761 = ca.length;
					while (it_4760 < at_4761) {
						i_4759 = it_4760;
						it_4760++;
						{
							const type_4762 = this.toType(t_4755[i_4759], ca[i_4759]);
							{
								const temp_4763 = type_4762;
								switch (temp_4763&&temp_4763[0]) {
								case 13: {
									this.fail('Catch type must be a specific class, not `{}`', ca[i_4759])
								} break;
								
								case 12: {
									this.fail('Catch type must be a specific class, not function', ca[i_4759])
								} break;
								};
							};
							this.types.set(t_4755[i_4759], type_4762);
							this.pushScope();
							this.scopes[this.scopes.length - 1].set(DataHelper.varName(v_4756[i_4759]), v_4756[i_4759]);
							{
								const temp_4764 = ca[i_4759];
								switch (temp_4764&&temp_4764[0]) {
								case 12: {
									{
									}
								} break;
								
								default: 
								this.fail('Catch body must be a `{ block }`', ca[i_4759])
								};
							};
							this.fill(ca[i_4759]);
							this.popScope();
						};
					};
				};
			}
		} break;
		
		case 21: {
			const econd_4765 = temp_4703[1];
			const e_4766 = temp_4703[2];
			const pre = temp_4703[3];
			{
				if (pre == true) { this.fillExpression(econd_4765) };
				const _allowBreakAndContinue_4767 = this.allowBreakAndContinue;
				this.allowBreakAndContinue = true;
				{
					const temp_4768 = e_4766;
					switch (temp_4768&&temp_4768[0]) {
					case 12: {
						{
						}
					} break;
					
					default: 
					this.fail('`while` statements must be wrapped with a `{` block `}`', e_4766)
					};
				};
				this.fill(e_4766);
				this.allowBreakAndContinue = _allowBreakAndContinue_4767;
				if (pre == false) { this.fillExpression(econd_4765) };
				this.types.set(node_4702, this.typeVoid);
			}
		} break;
		
		case 19: {
			{
				this.types.set(node_4702, this.typeVoid);
				if ((!this.allowBreakAndContinue)) { this.fail('Cannot use `continue` outside of loop', node_4702) };
			}
		} break;
		
		default: 
		this.fillExpression(node_4702)
		};
	};
		fillExpression(node_4769) {
		const temp_4770 = node_4769;
		switch (temp_4770&&temp_4770[0]) {
		case 1: {
			const name_4771 = temp_4770[1];
			const params_4772 = temp_4770[2];
			{
				let subj_4773 = null;
				{
					let i_4774 = 0;
					let it_4775 = 0;
					let at_4776 = this.scopes.length;
					while (it_4775 < at_4776) {
						i_4774 = it_4775;
						it_4775++;
						{
							subj_4773 = this.scopes[this.scopes.length - i_4774 - 1].get(name_4771);
							if (subj_4773 != null) { break };
						};
					};
				};
				if (subj_4773 == null) { subj_4773 = this.findInNamespaceRoots(name_4771) };
				if ((subj_4773 == null) && (name_4771 == 'const')) { this.fail('No variable named `const` found. Are you trying to use `const` as a keyword? Use `let varname` syntax instead.', node_4769) };
				if (subj_4773 == null) { this.fail(('Cannot find variable with name `' + (name_4771) + '`'), node_4769) };
				if ((this.parents.get(node_4769) != null) && (this.parents.get(node_4769) != subj_4773)) { this.fail(('Parent overwitten from ' + (this.parents.get(node_4769)) + ' to ' + (subj_4773) + ' for node ' + (node_4769) + '') + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_4769) };
				this.parents.set(node_4769, subj_4773);
				{
					let step_4777 = 0;
					const type_4778 = this.types.get(subj_4773);
					if (step_4777 == 0 && type_4778 != null) { step_4777 = 1 };
					if (step_4777 == 1) { this.types.set(node_4769, type_4778) };
				};
				{
					let step_4779 = 0;
					const params_4780 = params_4772;
					if (step_4779 == 0 && params_4780 != null) { step_4779 = 1 };
					if (step_4779 == 1) { for (const param of $toIterator(params_4780)) {
						this.types.set(param, this.toType(param, node_4769));
					} };
				};
			}
		} break;
		
		case 23: {
			const expr_4781 = temp_4770[1];
			const vars_4782 = temp_4770[2];
			const rettype_4783 = temp_4770[3];
			this.fillFunction(node_4769, expr_4781, vars_4782, rettype_4783, true)
		} break;
		
		case 22: {
			const name_4785 = temp_4770[1];
			const expr_4786 = temp_4770[2];
			const vars_4787 = temp_4770[3];
			const rettype_4788 = temp_4770[4];
			const external_4789 = temp_4770[5];
			{
				if (external_4789) { this.fail(('External function `declare fun ' + (name_4785) + '` cannot be taken as a value'), node_4769) };
				this.fillFunction(node_4769, expr_4786, vars_4787, rettype_4788);
			}
		} break;
		
		case 31: {
			const el_4791 = temp_4770[1];
			{
				const temp_4792 = el_4791[0];
				switch (temp_4792&&temp_4792[0]) {
				case 49: {
					const name_4793 = temp_4792[1];
					const over_4794 = temp_4792[2];
					const by_4795 = temp_4792[3];
					const range_4796 = temp_4792[4];
					{
						if (el_4791.length > 1) { this.fail('Cannot use loop `for` within array of more than one element `[for, ...]`', el_4791[1]) };
						if (range_4796 != null) { this.fail('Ranges `...range` are not supported here yet', range_4796) };
						this.pushScope();
						this.fillExpression(over_4794);
						const overType_4797 = this.types.get(over_4794);
						{
							const temp_4798 = overType_4797;
							switch (temp_4798&&temp_4798[0]) {
							case 6: {
								const type_4799 = temp_4798[1];
								const generic_4800 = temp_4798[2];
								if ((generic_4800 != null) && (generic_4800.length == 1)) { this.types.set(el_4791[0], generic_4800[0]) } else if (overType_4797 == this.typeInt) { this.types.set(el_4791[0], this.typeInt) } else if ((overType_4797 == this.typeUInt32) || (overType_4797 == this.typeUInt64)) { this.types.set(el_4791[0], overType_4797) } else {
									this.fail('Type of iterable is neither `Int` nor `Array`, but ' + Type.stringify(overType_4797), over_4794);
								}
							} break;
							
							case 4: {
								this.fail('Type of iterable should not be nullable', over_4794)
							} break;
							
							case 3: {
								this.fail('Type of iterable should not be nullable', over_4794)
							} break;
							
							case null: case undefined: {
								{
								}
							} break;
							
							default: 
							this.fail('Type of iterable is neiter Int nor Array', over_4794)
							};
						};
						this.addScope(name_4793, el_4791[0]);
						const _allowBreakAndContinue_4801 = this.allowBreakAndContinue;
						this.allowBreakAndContinue = false;
						this.fillExpression(by_4795);
						this.allowBreakAndContinue = _allowBreakAndContinue_4801;
						this.popScope();
						this.types.set(node_4769, this.typeArray.instantiateGeneric([this.types.get(by_4795)]));
					}
				} break;
				
				default: 
				{
					for (const e of $toIterator(el_4791)) {
						this.fillExpression(e);
					};
					this.types.set(node_4769, this.typeArray.instantiateGeneric([(((el_4791.length > 0))? (this.types.get(el_4791[0])) : /*Unknown*/[2,{value:null},".Unknown"])]));
				}
				};
			}
		} break;
		
		case 32: {
			const keys = temp_4770[1];
			const values = temp_4770[2];
			{
				if (keys.length == 0) {
					this.types.set(node_4769, this.typeMap.instantiateGeneric([/*Unknown*/[2,{value:null},".Unknown"], /*Unknown*/[2,{value:null},".Unknown"]]));
					return;
				};
				{
					let i_4802 = 0;
					let it_4803 = 0;
					let at_4804 = keys.length;
					while (it_4803 < at_4804) {
						i_4802 = it_4803;
						it_4803++;
						{
							this.fillExpression(keys[i_4802]);
							this.fillExpression(values[i_4802]);
						};
					};
				};
				this.types.set(node_4769, this.typeMap.instantiateGeneric([this.types.get(keys[0]), this.types.get(values[0])]));
			}
		} break;
		
		case 44: {
			const e_4805 = temp_4770[1];
			const kind = temp_4770[2];
			const t_4806 = temp_4770[3];
			{
				const type_4807 = this.toType(t_4806, node_4769);
				if (type_4807 == this.typeVoid) { this.fail('Conversion `as Void` makes no sense', e_4805) };
				this.fillExpression(e_4805);
				if (this.types.get(e_4805) == this.typeVoid) { this.fail(('Conversion of `value as ' + (Type.stringify(t_4806)) + '` where `value` is of type `Void` makes no sense'), e_4805) };
				this.types.set(t_4806, type_4807);
				this.types.set(node_4769, type_4807);
			}
		} break;
		
		case 43: {
			const e_4808 = temp_4770[1];
			const t_4809 = temp_4770[2];
			{
				const type_4810 = this.toType(t_4809, node_4769);
				if (type_4810 == this.typeAny) { this.fail('Comparing `is Any` makes no sense, always true', e_4808) };
				if (type_4810 == this.typeVoid) { this.fail('Comparing `is Void` makes no sense', e_4808) };
				this.fillExpression(e_4808);
				this.types.set(t_4809, type_4810);
				this.types.set(node_4769, this.typeBool);
			}
		} break;
		
		case 12: {
			const el_4811 = temp_4770[1];
			if (el_4811.length == 0) { this.types.set(node_4769, /*Struct*/[13,[],[],".Struct"]) } else {
				this.pushScope();
				{
					let i_4812 = 0;
					let it_4813 = 0;
					let at_4814 = el_4811.length;
					while (it_4813 < at_4814) {
						i_4812 = it_4813;
						it_4813++;
						{
							if (i_4812 < el_4811.length - 1) { this.fill(el_4811[i_4812]) };
						};
					};
				};
				const latest = el_4811[el_4811.length - 1];
				this.fillExpression(latest);
				this.types.set(node_4769, this.types.get(latest));
				this.popScope();
			}
		} break;
		
		case 28: {
			const e_4815 = temp_4770[1];
			const n = temp_4770[2];
			{
				{
					const temp_4816 = e_4815;
					switch (temp_4816&&temp_4816[0]) {
					case 4: {
						if ((!this.allowSuper)) { this.fail('Cannot access `super` here', node_4769) }
					} break;
					
					default: 
					this.fillExpression(e_4815)
					};
				};
				{
					let step_4817 = 0;
					const etype = (this.types.get(e_4815));
					if (step_4817 == 0 && etype != null) { step_4817 = 1 };
					if (step_4817 == 1) {
						const temp_4818 = etype;
						switch (temp_4818&&temp_4818[0]) {
						case 6: {
							const type_4819 = temp_4818[1];
							const generic_4820 = temp_4818[2];
							{
								type_4819.useless = false;
								if (etype == this.typeAny) {
									this.types.set(node_4769, this.typeAny);
									return;
								};
								const index_4821 = type_4819.fieldNames.indexOf(n);
								const named_4822 = this.nameOfModuleItem(type_4819.parent);
								if (index_4821 < 0) { this.fail(('Class `' + (named_4822) + '` has no field `.' + (n) + '`\n') + this.positionOf(type_4819.parent) + ('`' + (named_4822) + '` is defined here\n') + this.proposeSimilar(type_4819.fieldNames, n, 'fields'), (() => {
									const result_4823 = e_4815;
									if (result_4823 != null) { return result_4823 };
									return node_4769;
								})()) };
								if (type_4819.fieldStatic[index_4821] == true) { this.fail(('Class `' + (named_4822) + '` field `.' + (n) + '` is static'), node_4769) };
								{
									const temp_4824 = type_4819.parent;
									switch (temp_4824&&temp_4824[0]) {
									case 25: {
										const t_4825 = temp_4824[1];
										const extend_4826 = temp_4824[2];
										const implement_4827 = temp_4824[3];
										const fields = temp_4824[4];
										const external_4828 = temp_4824[5];
										{
											const mod_4829 = this.currentModule;
											this.registerClassType(type_4819.parent);
											this.currentModule = mod_4829;
											for (const field of $toIterator(fields)) {
												if (DataHelper.nameOf(field) == n) {
													const genericFixup = (ofType, generic_4830) => {
														{
															const temp_4831 = ofType;
															switch (temp_4831&&temp_4831[0]) {
															case 1: {
																const genericParamIndex_4832 = temp_4831[1];
																const genericParam = temp_4831[2];
																{
																	if (generic_4830 == null) { return this.typeAny };
																	return generic_4830[genericParamIndex_4832];
																}
															} break;
															
															case 6: {
																const type_4833 = temp_4831[1];
																const generics = temp_4831[2];
																{
																	let step_4834 = 0;
																	const general = generics;
																	if (step_4834 == 0 && general != null) { step_4834 = 1 };
																	if (step_4834 == 1) { return type_4833.instantiateGeneric((() => {
																		const result_4835 = [];
																		const value_4836 = general;
																		for (const item of $toIterator(value_4836)) result_4835.push(genericFixup(item, generic_4830));
																		return result_4835;
																	})()) } else {
																		return ofType;
																	};
																}
															} break;
															
															case 4: {
																const type_4837 = temp_4831[1];
																return /*Nullable*/[4,genericFixup(type_4837, generic_4830),".Nullable"]
															} break;
															
															case 12: {
																const args_4838 = temp_4831[1];
																const returns = temp_4831[2];
																{
																	let returns_4839 = returns;
																	let changed = false;
																	const fixedReturns = genericFixup(returns_4839, generic_4830);
																	changed = fixedReturns != returns_4839;
																	returns_4839 = fixedReturns;
																	const reArgs = [];
																	for (const arg of $toIterator(args_4838)) {
																		const fixedArg = genericFixup(arg, generic_4830);
																		changed = changed || (fixedArg != arg);
																		reArgs.push(fixedArg);
																	};
																	if (changed) { return /*Function*/[12,reArgs,returns_4839,".Function"] };
																}
															} break;
															
															default: 
															{
															}
															};
														};
														return ofType;
													};
													const extractedType = (this.types.get(field));
													this.types.set(node_4769, genericFixup(extractedType, generic_4820));
													this.parents.set(node_4769, field);
													if (this.types.get(field) == null) {
														console.log(this.positionOf(node_4769) + ('Note: field fieldInitialized[' + (n) + '] ='), type_4819.fieldInitialized[type_4819.fieldNames.indexOf(n)]);
														this.fail('Type for this field cannot be inferred, try to specify types manually: ' + n, field);
													};
												};
											};
										}
									} break;
									
									default: 
									this.fail('type.parent not a class, internal error', type_4819.parent)
									};
								};
							}
						} break;
						
						case 5: {
							const type_4840 = temp_4818[1];
							{
								type_4840.useless = false;
								const index_4841 = type_4840.fieldNames.indexOf(n);
								if (index_4841 < 0) { this.fail(('Class `' + (this.nameOfModuleItem(type_4840.parent)) + '` has no static field `.' + (n) + '`\nAvailable fields are: ') + type_4840.fieldNames.join(', '), node_4769) };
								if (type_4840.fieldStatic[index_4841] != true) { this.fail(('Class `' + (this.nameOfModuleItem(type_4840.parent)) + '` field `.' + (n) + '` is not static'), node_4769) };
								{
									const temp_4842 = type_4840.parent;
									switch (temp_4842&&temp_4842[0]) {
									case 25: {
										const t_4843 = temp_4842[1];
										const extend_4844 = temp_4842[2];
										const implement_4845 = temp_4842[3];
										const fields_4846 = temp_4842[4];
										const external_4847 = temp_4842[5];
										for (const field of $toIterator(fields_4846)) {
											if (DataHelper.nameOf(field) == n) {
												this.types.set(node_4769, this.types.get(field));
												this.parents.set(node_4769, field);
											};
										}
									} break;
									
									default: 
									this.fail('type.parent not a class, internal error', type_4840.parent)
									};
								};
							}
						} break;
						
						case 8: {
							const type_4848 = temp_4818[1];
							{
								const index_4849 = type_4848.fieldNames.indexOf(n);
								if (index_4849 < 0) { this.fail(('Enum `' + (type_4848.name) + '` has no field `.' + (n) + '`'), node_4769) };
								if (type_4848.fieldStatic[index_4849] != true) { this.fail(('Enum field `.' + (n) + '` is not static'), node_4769) };
								{
									const temp_4850 = type_4848.parent;
									switch (temp_4850&&temp_4850[0]) {
									case 39: {
										const t_4851 = temp_4850[1];
										const fields_4852 = temp_4850[2];
										const valuesType_4853 = temp_4850[3];
										for (const field of $toIterator(fields_4852)) {
											const temp_4854 = field;
											switch (temp_4854&&temp_4854[0]) {
											case 13: {
												{
												}
											} break;
											
											case 51: {
												{
												}
											} break;
											
											case 10: {
												{
												}
											} break;
											
											default: 
											if (DataHelper.nameOf(field) == n) {
												this.types.set(node_4769, this.types.get(field));
												this.parents.set(node_4769, field);
											}
											};
										}
									} break;
									
									default: 
									this.fail('type.parent not an enum, internal error', type_4848.parent)
									};
								};
							}
						} break;
						
						case 13: {
							const names_4855 = temp_4818[1];
							const els_4856 = temp_4818[2];
							{
								const index_4857 = names_4855.indexOf(n);
								if (index_4857 < 0) {
									let object = '';
									{
										const temp_4858 = e_4815;
										switch (temp_4858&&temp_4858[0]) {
										case 1: {
											const name_4859 = temp_4858[1];
											object = (' `' + (name_4859) + '`')
										} break;
										
										default: 
										{
										}
										};
									};
									if (names_4855.length == 0) { this.fail(('Object' + (object) + ' is empty `{}` and has no fields. Create object with all fields defined upfront, like this: `obj = { ' + (n) + ': value }`'), node_4769) };
									if (names_4855.length != 0) { this.fail(('Object' + (object) + ' has no field `.' + (n) + '`\nAvailable fields are: ') + names_4855.join(', '), node_4769) };
								};
								this.types.set(node_4769, els_4856[index_4857]);
							}
						} break;
						
						case 3: {
							const handle_4860 = temp_4818[1];
							{
								this.failNonFatal(('Cannot access `.' + (n) + '` of nullable type `' + (Type.stringify(etype)) + '`, try to unwrap it with `if let`'), node_4769);
								this.types.set(node_4769, this.typeAny);
							}
						} break;
						
						case 4: {
							const type_4861 = temp_4818[1];
							{
								this.failNonFatal(('Cannot access `.' + (n) + '` of nullable type `' + (Type.stringify(etype)) + '`, try to unwrap it with `if let`'), node_4769);
								this.types.set(node_4769, this.typeAny);
							}
						} break;
						
						case 2: {
							const handle_4862 = temp_4818[1];
							{
								let step_4863 = 0;
								const type_4864 = handle_4862.value;
								if (step_4863 == 0 && type_4864 != null) { step_4863 = 1 };
								if (step_4863 == 1) {} else {
									this.failNonFatal(('Cannot access `.' + (n) + '` due to type of value being unknown, try to specify a proper type (set full type `[T]` if this value coming from array)'), node_4769);
									this.types.set(node_4769, this.typeAny);
								};
							}
						} break;
						
						case null: case undefined: {
							this.fail(('Cannot access `.' + (n) + '` due to type being `null`, seems to be internal compiler error'), node_4769)
						} break;
						
						case 12: {
							this.fail(('Cannot access `.' + (n) + '` of function type `' + (Type.stringify(etype)) + '`'), node_4769)
						} break;
						
						default: 
						this.fail(('Cannot access `.' + (n) + '` due to type being unhandled `' + (Type.stringify(etype)) + '`, seems to be internal compiler error'), node_4769)
						};
					} else {
						this.types.set(node_4769, this.typeAny);
					};
				};
			}
		} break;
		
		case 29: {
			const e_4865 = temp_4770[1];
			const n_4866 = temp_4770[2];
			{
				{
					const temp_4867 = e_4865;
					switch (temp_4867&&temp_4867[0]) {
					case 4: {
						this.fail('Cannot access `super` here', node_4769)
					} break;
					};
				};
				this.fillExpression(e_4865);
				{
					const temp_4868 = (this.types.get(e_4865));
					switch (temp_4868&&temp_4868[0]) {
					case 9: {
						const type_4869 = temp_4868[1];
						this.fail(('Enum instance has no field `.' + (n_4866) + '`'), node_4769)
					} break;
					
					case 6: {
						const type_4870 = temp_4868[1];
						this.fail(('Class has no field `.' + (n_4866) + '`'), node_4769)
					} break;
					
					case 5: {
						const type_4871 = temp_4868[1];
						this.fail(('Class has no field `.' + (n_4866) + '`'), node_4769)
					} break;
					
					case 8: {
						const type_4872 = temp_4868[1];
						{
							const index_4873 = type_4872.fieldNames.indexOf(n_4866);
							if (index_4873 < 0) { this.fail(('Enum has no value constructor `.' + (n_4866) + '`\n') + this.proposeSimilar(type_4872.fieldNames.filter((element, index_4874) => (type_4872.fieldEnumConstructor[index_4874])), n_4866, 'constructors'), node_4769) };
							if (type_4872.fieldEnumConstructor[index_4873] != true) { this.fail(('Enum field `.' + (n_4866) + '` is not a value constructor'), node_4769) };
							{
								let step_4875 = 0;
								const fieldType = type_4872.fieldType[index_4873];
								if (step_4875 == 0 && fieldType != null) { step_4875 = 1 };
								if (step_4875 == 1) { this.types.set(node_4769, fieldType) } else {
									this.fail(('Enum field type is null for `' + (Node.stringify(node_4769)) + '`'), node_4769);
								};
							};
						}
					} break;
					
					case null: case undefined: {
						this.fail(('Accessing non-existing field `.' + (n_4866) + '` of `' + (Node.stringify(e_4865)) + '`'), node_4769)
					} break;
					
					default: 
					{
					}
					};
				};
			}
		} break;
		
		case 51: {
			const t_4876 = temp_4770[1];
			{
				const temp_4877 = t_4876;
				switch (temp_4877&&temp_4877[0]) {
				case 1: {
					const name_4878 = temp_4877[1];
					{
						const subj_4879 = this.find(name_4878);
						if (subj_4879 == null) { this.fail(('Cannot find type with name `' + (name_4878) + '`'), node_4769) };
						if ((this.parents.get(node_4769) != null) && (this.parents.get(node_4769) != subj_4879)) { this.fail(('Parent overwitten from ' + (this.parents.get(node_4769)) + ' to ' + (subj_4879) + ' for node ' + (node_4769) + '') + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_4769) };
						this.parents.set(node_4769, subj_4879);
						{
							let step_4880 = 0;
							const type_4881 = this.types.get(subj_4879);
							if (step_4880 == 0 && type_4881 != null) { step_4880 = 1 };
							if (step_4880 == 1) { this.types.set(node_4769, type_4881) } else {
								{
									const temp_4882 = subj_4879;
									switch (temp_4882&&temp_4882[0]) {
									case 25: {
										{
											const mod_4883 = this.currentModule;
											this.registerClassType(subj_4879);
											this.currentModule = mod_4883;
										}
									} break;
									
									case 39: {
										this.registerEnumType(subj_4879)
									} break;
									};
								};
								{
									let step_4884 = 0;
									const type_4885 = this.types.get(subj_4879);
									if (step_4884 == 0 && type_4885 != null) { step_4884 = 1 };
									if (step_4884 == 1) { this.types.set(node_4769, type_4885) } else {
										console.log(this.positionOf(subj_4879) + ('' + (name_4878) + ' is here'));
										this.fail(('Cannot find type for `' + (name_4878) + '` even after late build') + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_4769);
									};
								};
							};
						};
					}
				} break;
				
				case 2: {
					const name_4886 = temp_4877[1];
					this.fail(('Cannot use generic type `' + (name_4886) + '` as a value'), node_4769)
				} break;
				
				default: 
				this.fail('Cannot use this type as a value', node_4769)
				};
			}
		} break;
		
		case 30: {
			const path_4887 = temp_4770[1];
			const t_4888 = temp_4770[2];
			const el_4889 = temp_4770[3];
			const names_4890 = temp_4770[4];
			const values_4891 = temp_4770[5];
			{
				const type_4892 = this.toType(t_4888, node_4769);
				const subj_4893 = this.find(DataHelper.extractTypeName(t_4888));
				this.parents.set(node_4769, subj_4893);
				for (const e of $toIterator(el_4889)) {
					this.fillExpression(e);
				};
				{
					const temp_4894 = type_4892;
					switch (temp_4894&&temp_4894[0]) {
					case 6: {
						const type_4895 = temp_4894[1];
						{
							if (type_4895.constructor == (-1)) { this.fail('Cannot construct class without `new () {}` constructor', node_4769) };
							type_4895.useless = false;
						}
					} break;
					
					default: 
					this.fail('Constructor `new` may instantiate only classes', node_4769)
					};
				};
				this.types.set(node_4769, type_4892);
			}
		} break;
		
		case 38: {
			const names_4896 = temp_4770[1];
			const el_4897 = temp_4770[2];
			{
				{
					let name_4898 = 0;
					let it_4899 = 0;
					let at_4900 = names_4896.length;
					while (it_4899 < at_4900) {
						name_4898 = it_4899;
						it_4899++;
						{
							if (names_4896.indexOf(names_4896[name_4898]) != name_4898) { this.fail(('Field `' + (names_4896[name_4898]) + '` already exists'), node_4769) };
						};
					};
				};
				for (const e of $toIterator(el_4897)) {
					this.fillExpression(e);
				};
				const els_4901 = (() => {
					const result_4902 = [];
					const value_4903 = el_4897;
					for (const e of $toIterator(value_4903)) result_4902.push(this.types.get(e));
					return result_4902;
				})();
				this.types.set(node_4769, /*Struct*/[13,names_4896,els_4901,".Struct"]);
			}
		} break;
		
		case 27: {
			const e_4904 = temp_4770[1];
			const t_4905 = temp_4770[2];
			const v_4906 = temp_4770[3];
			const ca_4907 = temp_4770[4];
			{
				const _insideTry_4908 = this.insideTry;
				this.insideTry = true;
				this.fillExpression(e_4904);
				this.insideTry = _insideTry_4908;
				{
					let i_4909 = 0;
					let it_4910 = 0;
					let at_4911 = ca_4907.length;
					while (it_4910 < at_4911) {
						i_4909 = it_4910;
						it_4910++;
						{
							this.pushScope();
							this.scopes[this.scopes.length - 1].set(DataHelper.varName(v_4906[i_4909]), v_4906[i_4909]);
							this.fill(ca_4907[i_4909]);
							this.popScope();
						};
					};
				};
				this.types.set(node_4769, this.types.get(e_4904));
			}
		} break;
		
		case 14: {
			const econd_4912 = temp_4770[1];
			const eif_4913 = temp_4770[2];
			const eelse_4914 = temp_4770[3];
			const ternary = temp_4770[4];
			{
				if (econd_4912.length > 1) { this.fail('More than one condition is not yet supported', econd_4912[1]) };
				{
					const temp_4915 = econd_4912[0];
					switch (temp_4915&&temp_4915[0]) {
					case 24: {
						this.fail('Variable bindings in ternary conditions are not yet supported', econd_4912[0])
					} break;
					};
				};
				if (eelse_4914 == null) { this.fail('Expression `if` should have an `else` clause', eif_4913) };
				this.fillExpression(econd_4912[0]);
				if (ternary == false) {
					{
						const temp_4916 = eif_4913;
						switch (temp_4916&&temp_4916[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						this.fail('Ternary `if` should have a `{ block }` as a body', eif_4913)
						};
					};
					{
						const temp_4917 = eelse_4914;
						switch (temp_4917&&temp_4917[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						this.fail('Ternary `else` should have a `{ block }` as a body', eelse_4914)
						};
					};
				};
				this.fillExpression(eif_4913);
				this.fillExpression(eelse_4914);
				this.types.set(node_4769, this.unify(this.types.get(eif_4913), this.types.get(eelse_4914), eelse_4914));
			}
		} break;
		
		case 8: {
			{
				this.types.set(node_4769, /*UnknownNullable*/[3,{value:null},".UnknownNullable"]);
				this.types.set(node_4769, /*Nullable*/[4,this.typeAny,".Nullable"]);
			}
		} break;
		
		case 0: {
			this.types.set(node_4769, this.typeString)
		} break;
		
		case 2: {
			this.types.set(node_4769, this.typeBool)
		} break;
		
		case 5: {
			this.types.set(node_4769, this.typeInt)
		} break;
		
		case 6: {
			const meta = temp_4770[2];
			{
				{
					const temp_4918 = meta;
					switch (temp_4918) {
					case 1: {
						this.types.set(node_4769, this.typeBigInt)
					} break;
					
					case 2: {
						this.types.set(node_4769, this.typeInt32)
					} break;
					
					case 3: {
						this.types.set(node_4769, this.typeInt64)
					} break;
					
					case 4: {
						this.types.set(node_4769, this.typeInt16)
					} break;
					
					case 5: {
						this.types.set(node_4769, this.typeInt8)
					} break;
					
					case 6: {
						this.types.set(node_4769, this.typeUInt32)
					} break;
					
					case 7: {
						this.types.set(node_4769, this.typeUInt64)
					} break;
					
					case 8: {
						this.types.set(node_4769, this.typeUInt16)
					} break;
					
					case 9: {
						this.types.set(node_4769, this.typeUInt8)
					} break;
					
					case 10: {
						this.types.set(node_4769, this.typeFloat32)
					} break;
					
					default: 
					this.fail('Unhandled meta type of number', node_4769)
					};
				};
				if (this.types.get(node_4769) == null) {
					const name_4919 = Meta.stringify(meta);
					this.fail(('Number literal of type `' + (name_4919) + '` fail, probably standard library of the current target does not define `class ' + (name_4919) + '` type'), node_4769);
				};
			}
		} break;
		
		case 7: {
			const v_4920 = temp_4770[1];
			const meta_4921 = temp_4770[2];
			if (meta_4921 == 10) { this.types.set(node_4769, this.typeFloat32) } else {
				this.types.set(node_4769, this.typeFloat);
			}
		} break;
		
		case 15: {
			const e_4922 = temp_4770[1];
			{
				this.fillExpression(e_4922);
				this.types.set(node_4769, this.types.get(e_4922));
			}
		} break;
		
		case 50: {
			const a_4923 = temp_4770[1];
			const b_4924 = temp_4770[2];
			{
				this.fillExpression(a_4923);
				this.fillExpression(b_4924);
				this.unify(this.types.get(a_4923), this.types.get(b_4924), b_4924);
				this.types.set(node_4769, this.types.get(b_4924));
			}
		} break;
		
		case 13: {
			const e_4925 = temp_4770[1];
			const el_4926 = temp_4770[2];
			const elNames = temp_4770[3];
			{
				{
					const temp_4927 = e_4925;
					switch (temp_4927&&temp_4927[0]) {
					case 4: {
						if ((!this.allowSuper)) { this.fail('Cannot access `super` here', node_4769) }
					} break;
					
					default: 
					this.fillExpression(e_4925)
					};
				};
				for (const e of $toIterator(el_4926)) {
					this.fillExpression(e);
				};
				{
					const temp_4928 = (this.types.get(e_4925));
					switch (temp_4928&&temp_4928[0]) {
					case 12: {
						const args_4929 = temp_4928[1];
						const returns_4930 = temp_4928[2];
						{
							{
								let i_4931 = 0;
								let it_4932 = 0;
								let at_4933 = el_4926.length;
								while (it_4932 < at_4933) {
									i_4931 = it_4932;
									it_4932++;
									{
										let step_4934 = 0;
										const arg = args_4929[i_4931];
										if (step_4934 == 0 && arg != null) { step_4934 = 1 };
										if (step_4934 == 1) { this.unify(arg, this.types.get(el_4926[i_4931]), el_4926[i_4931]) };
									};
								};
							};
							this.types.set(node_4769, returns_4930);
						}
					} break;
					
					case 10: {
						const type_4935 = temp_4928[1];
						const tag = temp_4928[2];
						{
							const name_4936 = type_4935.fieldNames[tag];
							if (el_4926.length < type_4935.tagBindVars[tag].length) { this.fail(('Not enough enum parameters, required `' + (name_4936) + '` parameters are: ') + type_4935.tagBindVarsNames[tag].join(', '), node_4769) };
							if (el_4926.length > type_4935.tagBindVars[tag].length) { this.fail(('Too many enum parameters, required `' + (name_4936) + '` parameters are: ') + type_4935.tagBindVarsNames[tag].join(', '), node_4769) };
							if (el_4926.length == 0) { this.fail('Use syntax without empty `()`', node_4769) };
							this.types.set(node_4769, /*EnumInstance*/[9,type_4935,tag,".EnumInstance"]);
						}
					} break;
					
					case null: case undefined: {
						{
						}
					} break;
					
					default: 
					if (this.types.get(e_4925) == this.typeAny) { this.types.set(node_4769, this.typeAny) } else {
						this.fail('Calling *not* a function, type is `' + Type.stringify(this.types.get(e_4925)) + '`', e_4925);
					}
					};
				};
			}
		} break;
		
		case 10: {
			const a_4937 = temp_4770[1];
			const op_4938 = temp_4770[2];
			const b_4939 = temp_4770[3];
			{
				this.fillExpression(a_4937);
				this.fillExpression(b_4939);
				const typeA = this.types.get(a_4937);
				const typeB = this.types.get(b_4939);
				if ((op_4938 == 111) && (typeA == this.typeString)) { this.types.set(node_4769, this.typeString) } else if (op_4938 == 92 || op_4938 == 93) {
					const token = ((op_4938 == 92)? ('and') : 'or');
					if ((!this.booleanable(typeA))) { this.fail(('Operator `a ' + (token) + ' b` takes `a` of type `Bool` only, but got `' + (Type.stringify(typeA)) + '`'), a_4937) };
					if ((!this.booleanable(typeB))) { this.fail(('Operator `a ' + (token) + ' b` takes `b` of type `Bool` only, but got `' + (Type.stringify(typeB)) + '`'), b_4939) };
					this.types.set(node_4769, this.typeBool);
				} else if ((typeA == typeB) && (typeA == this.typeString) && ((op_4938 == 97) || (op_4938 == 96) || (op_4938 == 100) || (op_4938 == 99))) { this.types.set(node_4769, this.typeBool) } else if (op_4938 == 95 || op_4938 == 103) {
					const booleans = (typeA == typeB) && (typeA == this.typeBool);
					const comparable = this.areComparable(typeA, typeB);
					const covariant = this.areCovariant(typeA, typeB);
					if (((!comparable)) && ((!booleans)) && ((!covariant))) {
						const tokenString = Token.stringify(op_4938);
						const leftString = (() => {
							const temp_4940 = a_4937;
							switch (temp_4940&&temp_4940[0]) {
							case 8: {
								return 'null'
							} break;
							
							default: 
							return Type.stringify(typeA)
							};
						})();
						const rightString = (() => {
							const temp_4941 = b_4939;
							switch (temp_4941&&temp_4941[0]) {
							case 8: {
								return 'null'
							} break;
							
							default: 
							return Type.stringify(typeB)
							};
						})();
						if ((leftString != 'null') && (rightString != 'null')) { this.fail(('Operator `a ' + (tokenString) + ' b` requires `a` and `b` of comparable types, but got `' + (leftString) + '` and `' + (rightString) + '`'), b_4939) };
					};
					this.types.set(node_4769, this.typeBool);
				} else if ((op_4938 == 97) || (op_4938 == 96) || (op_4938 == 100) || (op_4938 == 99) || (op_4938 == 95) || (op_4938 == 103)) {
					const comparable_4942 = this.areComparable(typeA, typeB);
					if ((!comparable_4942)) {
						const tokenString_4943 = Token.stringify(op_4938);
						const leftString_4944 = (() => {
							const temp_4945 = a_4937;
							switch (temp_4945&&temp_4945[0]) {
							case 8: {
								return 'null'
							} break;
							
							default: 
							return Type.stringify(typeA)
							};
						})();
						const rightString_4946 = (() => {
							const temp_4947 = b_4939;
							switch (temp_4947&&temp_4947[0]) {
							case 8: {
								return 'null'
							} break;
							
							default: 
							return Type.stringify(typeB)
							};
						})();
						this.fail(('Operator `a ' + (tokenString_4943) + ' b` requires `a` and `b` of comparable non-nullable types, but got `' + (leftString_4944) + '` and `' + (rightString_4946) + '`'), b_4939);
					};
					this.types.set(node_4769, this.typeBool);
				} else {
					const typeLeft = (() => {
						const result_4948 = this.types.get(a_4937);
						if (result_4948 != null) { return result_4948 };
						return this.types.get(b_4939);
					})();
					let typeRight = (() => {
						const result_4949 = this.types.get(b_4939);
						if (result_4949 != null) { return result_4949 };
						return this.types.get(a_4937);
					})();
					if ((typeLeft == this.typeUInt32) && (typeRight == this.typeInt)) { typeRight = this.typeUInt32 };
					if ((typeLeft == this.typeUInt64) && (typeRight == this.typeInt)) { typeRight = this.typeUInt64 };
					if ((typeLeft == this.typeUInt16) && (typeRight == this.typeInt)) { typeRight = this.typeUInt16 };
					this.types.set(node_4769, typeRight);
				};
			}
		} break;
		
		case 20: {
			const op_4950 = temp_4770[1];
			const postfix = temp_4770[2];
			const e_4951 = temp_4770[3];
			{
				this.fillExpression(e_4951);
				if ((op_4950 == 89) && ((!postfix))) {
					const type_4952 = this.types.get(e_4951);
					if ((!this.booleanable(type_4952))) { this.fail(('Operator `!value` takes `value` of type `Bool` only, but got `' + (Type.stringify(this.types.get(e_4951))) + '`'), e_4951) };
					this.types.set(node_4769, this.typeBool);
					return;
				};
				this.types.set(node_4769, this.types.get(e_4951));
				const mutates = op_4950 == 87 || op_4950 == 86;
				if ((!mutates)) { return };
				const parent_4953 = this.parents.get(e_4951);
				{
					const temp_4954 = parent_4953;
					switch (temp_4954&&temp_4954[0]) {
					case 24: {
						const name_4955 = temp_4954[1];
						const const_4956 = temp_4954[4];
						if (const_4956) { this.fail(('Cannot change a constant `let ' + (name_4955) + '`, redefine it as `var ' + (name_4955) + '` to allow value changes\n') + this.positionOf(parent_4953) + ('`let ' + (name_4955) + '` is defined here'), node_4769) }
					} break;
					
					case 22: {
						const name_4957 = temp_4954[1];
						this.fail(('Cannot `' + (Token.stringify(op_4950)) + '` a function `' + (name_4957) + '`'), node_4769)
					} break;
					
					case 49: {
						const name_4958 = temp_4954[1];
						this.fail(('Cannot change iterator value `' + (name_4958) + '` of for loop\n') + this.positionOf(parent_4953) + ('`for ' + (name_4958) + ' in ...` is defined here'), node_4769)
					} break;
					
					case 47: {
						const f_4959 = temp_4954[1];
						{
							const temp_4960 = f_4959;
							switch (temp_4960&&temp_4960[0]) {
							case 22: {
								const name_4961 = temp_4960[1];
								this.fail(('Cannot `' + (Token.stringify(op_4950)) + '` a `static fun ' + (name_4961) + '`'), node_4769)
							} break;
							
							case 24: {
								const name_4962 = temp_4960[1];
								const const_4963 = temp_4960[4];
								if (const_4963) { this.fail(('Cannot change a constant `static let ' + (name_4962) + '`, redefine it as `static var ' + (name_4962) + '` to allow value changes\n') + this.positionOf(parent_4953) + ('`static let ' + (name_4962) + '` is defined here'), node_4769) }
							} break;
							};
						}
					} break;
					
					default: 
					{
						const temp_4964 = e_4951;
						switch (temp_4964&&temp_4964[0]) {
						case 33: {
							{
							}
						} break;
						
						default: 
						{
							const ops = ((87)? ('increment `++`') : 'decrement `--`');
							this.fail(('You can ' + (ops) + ' only a variable, .field or array element'), node_4769);
						}
						};
					}
					};
				};
				const hha = 1;
			}
		} break;
		
		case 33: {
			const e_4965 = temp_4770[1];
			const i_4966 = temp_4770[2];
			{
				this.fillExpression(e_4965);
				this.fillExpression(i_4966);
				const eType = (this.types.get(e_4965));
				const iType = (this.types.get(i_4966));
				let indexableIsAny = false;
				let indexableIsMap = false;
				let mapKey = null;
				{
					const temp_4967 = eType;
					switch (temp_4967&&temp_4967[0]) {
					case 6: {
						const type_4968 = temp_4967[1];
						const generic_4969 = temp_4967[2];
						{
							if (type_4968.name == 'Any') { indexableIsAny = true };
							if (type_4968.name == 'Map') {
								indexableIsMap = true;
								mapKey = generic_4969[0];
							};
						}
					} break;
					
					case 4: {
						this.fail(('Cannot index `' + (Node.stringify(e_4965)) + '` because `' + (Type.stringify(eType)) + '` can be null, try to extract its value with `if let value = ' + (Node.stringify(e_4965)) + '`'), e_4965)
					} break;
					
					case 3: {
						const handle_4970 = temp_4967[1];
						this.fail(('Cannot index `' + (Node.stringify(e_4965)) + '` because `' + (Type.stringify(eType)) + '` can be null, try to extract its value with `if let value = ' + (Node.stringify(e_4965)) + '`'), e_4965)
					} break;
					};
				};
				if ((!indexableIsAny)) {
					const temp_4971 = iType;
					switch (temp_4971&&temp_4971[0]) {
					case 6: {
						const type_4972 = temp_4971[1];
						{
							if (((!indexableIsMap)) && (type_4972.name != 'Int') && (type_4972.name != 'UInt64') && (type_4972.name != 'UInt32') && (type_4972.name != 'UInt16') && (type_4972.name != 'UInt8') && (type_4972.name != 'Int64') && (type_4972.name != 'Int32') && (type_4972.name != 'Int16') && (type_4972.name != 'Int8') && (type_4972.name != 'Any') && (type_4972.name != 'UInt64')) { this.fail('`value[index]` expects `index` only of type `Int` or similar, but got `' + Type.stringify(iType) + '`', e_4965) };
							if ((indexableIsMap) && (iType != mapKey)) { this.fail(('`map[key]` expects `key` only of type `' + (Type.stringify(mapKey)) + '`, but got `') + Type.stringify(iType) + '`', e_4965) };
						}
					} break;
					
					case null: case undefined: {
						{
						}
					} break;
					
					default: 
					this.fail('`value[i]` expects `i` only of type `Int` or similar, but got `' + Type.stringify(iType) + '`', e_4965)
					};
				};
				{
					const temp_4973 = eType;
					switch (temp_4973&&temp_4973[0]) {
					case 6: {
						const type_4974 = temp_4973[1];
						const generic_4975 = temp_4973[2];
						if ((generic_4975 != null) && (generic_4975.length >= 1)) { if (type_4974.name == 'Map') { this.types.set(node_4769, generic_4975[1]) } else {
							this.types.set(node_4769, generic_4975[0]);
						} } else if (['Buffer', 'Uint8Array', 'Uint32Array'].includes(type_4974.name)) { this.types.set(node_4769, this.toType(/*Type*/[1,'Int',null,".Type"], node_4769)) } else if (['Any'].includes(type_4974.name)) { this.types.set(node_4769, this.toType(/*Type*/[1,'Any',null,".Type"], node_4769)) } else {
							this.fail(('Cannot index `' + (Node.stringify(e_4965)) + '` because `' + (Type.stringify(eType)) + '` is not indexable'), e_4965);
						}
					} break;
					
					case null: case undefined: {
						{
						}
					} break;
					
					default: 
					{
					}
					};
				};
			}
		} break;
		
		case 11: {
			const a_4976 = temp_4770[1];
			const op_4977 = temp_4770[2];
			const b_4978 = temp_4770[3];
			{
				if (op_4977 == 95) { this.fail('`===` not supported, use `strictEqual`', node_4769) };
				if (op_4977 == 95) { this.fail('`!==` not supported, use `strictNotEqual`', node_4769) };
				this.fillExpression(a_4976);
				const parent_4979 = this.parents.get(a_4976);
				{
					const temp_4980 = parent_4979;
					switch (temp_4980&&temp_4980[0]) {
					case 24: {
						const name_4981 = temp_4980[1];
						const const_4982 = temp_4980[4];
						if (const_4982) { this.fail(('Cannot change a constant `let ' + (name_4981) + '`, redefine it as `var ' + (name_4981) + '` to allow value changes\n') + this.positionOf(parent_4979) + ('`let ' + (name_4981) + '` is defined here'), node_4769) }
					} break;
					
					case 22: {
						const name_4983 = temp_4980[1];
						this.fail(('Cannot reassign a function `' + (name_4983) + '`'), node_4769)
					} break;
					
					case 49: {
						const name_4984 = temp_4980[1];
						this.fail(('Cannot change iterator value `' + (name_4984) + '` of for loop\n') + this.positionOf(parent_4979) + ('`for ' + (name_4984) + ' in ...` is defined here'), node_4769)
					} break;
					
					default: 
					{
					}
					};
				};
				this.fillExpression(b_4978);
				this.types.set(node_4769, this.unify(this.types.get(a_4976), this.types.get(b_4978), b_4978));
			}
		} break;
		
		case 17: {
			const e_4985 = temp_4770[1];
			{
				if (((!this.insideFunction)) && ((!this.insideTry))) { this.fail('Cannot throw outside of `function` or `try`', node_4769) };
				if ((this.insideFunction) && ((!this.functionAllowedToThrow))) { this.fail('Cannot throw in a @noThrow function', node_4769) };
				if (this.insideFunction) { this.functionThrows = true };
				this.fillExpression(e_4985);
			}
		} break;
		
		case 3: {
			{
				if ((!this.insideClassMethod)) { this.fail('Cannot access `this` outside of class method', node_4769) };
				if (this.thisType == null) { this.fail('Cannot access `this` in class method', node_4769) };
				this.types.set(node_4769, this.thisType);
				this.parents.set(node_4769, this.thisNode);
			}
		} break;
		
		case 4: {
			this.fail('Cannot use `super` as value', node_4769)
		} break;
		
		case 16: {
			const e_4986 = temp_4770[1];
			{
				{
					const temp_4987 = e_4986;
					switch (temp_4987&&temp_4987[0]) {
					case 24: {
						const name_4988 = temp_4987[1];
						const const_4989 = temp_4987[4];
						{
							const prefix = ((const_4989)? ('let') : 'var');
							this.fail(('This `return` tries to return a variable `' + (prefix) + ' ' + (name_4988) + '`. Try to wrap it into braces like this `{ return } ' + (prefix) + ' ' + (name_4988) + '`'), node_4769);
						}
					} break;
					
					case 16: {
						this.fail('Cannot return another return. Try to wrap first `{ return } return 2` into braces', node_4769)
					} break;
					};
				};
				if ((!this.insideFunction)) { this.fail('Cannot use `return` outside of function', node_4769) };
				if (e_4986 != null) {
					if (this.functionReturnsAType == this.typeVoid) { this.fail('Function returns `Void`, cannot return a value here', e_4986) };
					this.fillExpression(e_4986);
					const ret_4990 = this.types.get(e_4986);
					if (ret_4990 == this.typeVoid) { this.fail('Cannot `return` a `Void` non-value', node_4769) };
					this.functionReturnsAType = this.unify(this.functionReturnsAType, ret_4990, e_4986);
					this.functionActuallyReturns = true;
				} else {
					let step_4991 = 0;
					const ret_4992 = this.functionReturnsAType;
					if (step_4991 == 0 && ret_4992 != null) { step_4991 = 1 };
					if (step_4991 == 1) { if (ret_4992 != this.typeVoid) { this.fail(('Expected `return value` of type `' + (Type.stringify(ret_4992)) + '`'), node_4769) } } else {
						this.functionReturnsAType = this.typeVoid;
					};
				};
			}
		} break;
		
		case 45: {
			this.fail('Cannot use underscore `_` outside of case pattern', node_4769)
		} break;
		
		case 47: {
			this.fail('Cannot use `static` here: only applicable to class fields', node_4769)
		} break;
		
		case 48: {
			this.fail('Cannot use `private` here: only applicable to class fields and module declarations', node_4769)
		} break;
		
		case 35: {
			{
			}
		} break;
		
		case 18: {
			this.fail('Cannot use `break` as a value', node_4769)
		} break;
		
		case 19: {
			this.fail('Cannot use `continue` as a value', node_4769)
		} break;
		
		case 25: {
			this.fail('Cannot use `class` as a value', node_4769)
		} break;
		
		case 39: {
			this.fail('Cannot use `enum` as a value', node_4769)
		} break;
		
		case 9: {
			this.fail('Cannot use `declare` as a value', node_4769)
		} break;
		
		case 37: {
			this.fail('Cannot use `import` as a value', node_4769)
		} break;
		
		case 24: {
			const name_4993 = temp_4770[1];
			const const_4994 = temp_4770[4];
			{
				const prefix_4995 = ((const_4994)? ('let') : 'var');
				this.fail(('Cannot use `' + (prefix_4995) + ' ' + (name_4993) + '` as a value'), node_4769);
			}
		} break;
		
		case 34: {
			this.fillSwitch(node_4769, true)
		} break;
		
		case 21: {
			this.fail('Cannot use `while` as a value', node_4769)
		} break;
		
		case 49: {
			this.fail('Cannot use `for` as a value. To build array from loop, surround with `[for]` brackets.', node_4769)
		} break;
		
		case null: case undefined: {
			this.fail('Got null node. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_4769)
		} break;
		
		default: 
		this.fail('Unknown node expression kind to type ' + node_4769 + '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.', node_4769)
		};
	};
		fillSwitch(node_4996, value_4997) {
		const temp_4998 = node_4996;
		switch (temp_4998&&temp_4998[0]) {
		case 34: {
			const exprs_4999 = temp_4998[1];
			const conds_5000 = temp_4998[2];
			const guards_5001 = temp_4998[3];
			const cases_5002 = temp_4998[4];
			{
				for (const e of $toIterator(exprs_4999)) {
					this.pushScope();
					this.fillExpression(e);
					this.popScope();
				};
				{
					let step_5003 = 0;
					const expr_5004 = exprs_4999[1];
					if (step_5003 == 0 && expr_5004 != null) { step_5003 = 1 };
					if (step_5003 == 1) { this.fail('Multiple switch values are not yet supported', expr_5004) };
				};
				const unwrapUnknownAndNullable = (type_5005) => {
					{
						const temp_5006 = type_5005;
						switch (temp_5006&&temp_5006[0]) {
						case null: case undefined: {
							return null
						} break;
						
						case 4: {
							const type_5007 = temp_5006[1];
							return unwrapUnknownAndNullable(type_5007)
						} break;
						
						case 2: {
							const type_5008 = temp_5006[1];
							return unwrapUnknownAndNullable(type_5008.value)
						} break;
						
						case 3: {
							const type_5009 = temp_5006[1];
							return unwrapUnknownAndNullable(type_5009.value)
						} break;
						};
					};
					return type_5005;
				};
				const etype_5010 = unwrapUnknownAndNullable(this.types.get(exprs_4999[0]));
				if (etype_5010 == null) { this.fail(('Value of switch `' + (Node.stringify(exprs_4999[0])) + '` must have a known type at this postition'), exprs_4999[0]) };
				let enumType = null;
				let shortHandSyntax = false;
				const switchable = [this.typeBool, this.typeInt, this.typeUInt64, this.typeUInt32, this.typeUInt16, this.typeUInt8, this.typeInt64, this.typeInt32, this.typeInt16, this.typeInt8, this.typeString];
				if (switchable.includes(etype_5010)) {} else if (etype_5010 == this.typeFloat) { this.fail('Due to imprecise nature of `Float` type, switching over it is not allowed', exprs_4999[0]) } else {
					const temp_5011 = etype_5010;
					switch (temp_5011&&temp_5011[0]) {
					case 8: {
						const type_5012 = temp_5011[1];
						enumType = type_5012
					} break;
					
					case 9: {
						const type_5013 = temp_5011[1];
						enumType = type_5013
					} break;
					
					default: 
					this.fail(('Cannot switch over `' + (Type.stringify(etype_5010)) + '` type'), exprs_4999[0])
					};
				};
				const tags = [];
				let i_5014 = 0;
				const tagCheck = (currentTag, e_5015) => { if (tags.includes(currentTag)) { this.fail(('Tag `' + (currentTag) + '` already matched'), e_5015) } else {
					tags.push(currentTag);
				} };
				while (i_5014 < cases_5002.length) {
					this.pushScope();
					const e_5016 = conds_5000[i_5014];
					let currentType = null;
					let currentTag_5017 = null;
					let currentTagBind = 0;
					let interval = false;
					const follow = (e_5018) => {
						const temp_5019 = e_5018;
						switch (temp_5019&&temp_5019[0]) {
						case 29: {
							const ex = temp_5019[1];
							const name_5020 = temp_5019[2];
							{
								this.fillExpression(e_5018);
								{
									const temp_5021 = (this.types.get(ex));
									switch (temp_5021&&temp_5021[0]) {
									case 8: {
										const type_5022 = temp_5021[1];
										{
											currentType = type_5022;
											currentTag_5017 = name_5020;
											this.fail(('Use `case ' + (currentTag_5017) + '` instead of `case ' + (type_5022.name) + '.' + (currentTag_5017) + '`'), e_5018);
											if (tags.includes(currentTag_5017)) { this.fail(('Tag `' + (currentTag_5017) + '` already matched'), e_5018) } else {
												tags.push(currentTag_5017);
											};
										}
									} break;
									};
								};
							}
						} break;
						
						case 15: {
							const e_5023 = temp_5019[1];
							this.fill(e_5023)
						} break;
						
						case 45: {
							{
							}
						} break;
						
						case 8: {
							{
							}
						} break;
						
						case 2: {
							const val = temp_5019[1];
							{
								tagCheck('' + val, e_5018);
								if (etype_5010 != this.typeBool) { this.fail('Cannot switch over boolean here', e_5018) };
							}
						} break;
						
						case 5: {
							const val_5024 = temp_5019[1];
							{
								tagCheck('' + val_5024, e_5018);
								const validNumberTypes = [this.typeInt32, this.typeInt64, this.typeInt16, this.typeInt8, this.typeUInt32, this.typeUInt64, this.typeUInt16, this.typeUInt8, this.typeInt];
								if ((!validNumberTypes.includes(etype_5010))) { this.fail('Cannot switch over number here', e_5018) };
							}
						} break;
						
						case 0: {
							const val_5025 = temp_5019[1];
							{
								tagCheck(val_5025, e_5018);
								if (etype_5010 != this.typeString) { this.fail('Cannot switch over string here', e_5018) };
							}
						} break;
						
						case 13: {
							const ex_5026 = temp_5019[1];
							const args_5027 = temp_5019[2];
							const argNames_5028 = temp_5019[3];
							{
								follow(ex_5026);
								currentTagBind = 0;
								if (args_5027.length == 0) { this.fail(('Do not use `()` empty pattern, use `' + (currentTag_5017) + '(...)` syntax to ignore all bindings'), e_5018) };
								{
									let step_5029 = 0;
									const enumType_5030 = enumType;
									let temp_5031 = null;
									if (step_5029 == 0 && enumType_5030 != null) {
										temp_5031 = enumType_5030.fieldsTypeSimple != null;
										step_5029 = 1;
									};
									if (step_5029 == 1 && temp_5031 != false) { step_5029 = 2 };
									if (step_5029 == 2) { this.fail(('The `' + (enumType_5030.name) + '` is simple enum and has no `()` bindings'), e_5018) };
								};
								{
									let step_5032 = 0;
									const enumType_5033 = enumType;
									let temp_5034 = null;
									if (step_5032 == 0 && enumType_5033 != null) {
										temp_5034 = shortHandSyntax == true;
										step_5032 = 1;
									};
									let i_5035 = null;
									if (step_5032 == 1 && temp_5034 != false) {
										i_5035 = enumType_5033.fieldNames.indexOf(currentTag_5017);
										step_5032 = 2;
									};
									let binds = null;
									if (step_5032 == 2 && i_5035 != null) {
										binds = enumType_5033.tagBindVarsNames[i_5035];
										step_5032 = 3;
									};
									let temp_5036 = null;
									if (step_5032 == 3 && binds != null) {
										temp_5036 = binds.length == 0;
										step_5032 = 4;
									};
									if (step_5032 == 4 && temp_5036 != false) { step_5032 = 5 };
									if (step_5032 == 5) {
										const temp_5037 = args_5027[0];
										switch (temp_5037&&temp_5037[0]) {
										case 46: {
											{
											}
										} break;
										
										default: 
										this.fail(('The `' + (currentTag_5017) + '` has no `()` bindings, use `' + (currentTag_5017) + '(...)` syntax to ignore all future bindings added'), e_5018)
										};
									};
								};
								for (const ee of $toIterator(args_5027)) {
									if (interval) { this.fail('Do not match any patterns after `...` interval', ee) };
									{
										const temp_5038 = ee;
										switch (temp_5038&&temp_5038[0]) {
										case 46: {
											interval = true
										} break;
										
										case 1: {
											const name_5039 = temp_5038[1];
											{
												follow(ee);
												currentTagBind++;
											}
										} break;
										
										case 45: {
											{
												{
													let step_5040 = 0;
													const enumType_5041 = enumType;
													let temp_5042 = null;
													if (step_5040 == 0 && enumType_5041 != null) {
														temp_5042 = shortHandSyntax == true;
														step_5040 = 1;
													};
													let i_5043 = null;
													if (step_5040 == 1 && temp_5042 != false) {
														i_5043 = enumType_5041.fieldNames.indexOf(currentTag_5017);
														step_5040 = 2;
													};
													let binds_5044 = null;
													if (step_5040 == 2 && i_5043 != null) {
														binds_5044 = enumType_5041.tagBindVarsNames[i_5043];
														step_5040 = 3;
													};
													let temp_5045 = null;
													if (step_5040 == 3 && binds_5044 != null) {
														temp_5045 = binds_5044.length <= currentTagBind;
														step_5040 = 4;
													};
													if (step_5040 == 4 && temp_5045 != false) { step_5040 = 5 };
													if (step_5040 == 5) { this.fail('Too many bindings ignored with `_` for `F` tag, use `...` syntax to ignore all future bindings', e_5018) };
												};
												currentTagBind++;
											}
										} break;
										
										default: 
										this.fail('This case pattern is not supported', e_5018)
										};
									};
								};
							}
						} break;
						
						case 51: {
							const t_5046 = temp_5019[1];
							{
								shortHandSyntax = true;
								{
									const temp_5047 = t_5046;
									switch (temp_5047&&temp_5047[0]) {
									case 1: {
										const name_5048 = temp_5047[1];
										{
											let step_5049 = 0;
											const enumType_5050 = enumType;
											if (step_5049 == 0 && enumType_5050 != null) { step_5049 = 1 };
											if (step_5049 == 1) {
												let step_5051 = 0;
												const i_5052 = enumType_5050.fieldNames.indexOf(name_5048);
												let temp_5053 = null;
												if (step_5051 == 0 && i_5052 != null) {
													temp_5053 = enumType_5050.fieldEnumConstructor[i_5052] == true;
													step_5051 = 1;
												};
												if (step_5051 == 1 && temp_5053 != false) { step_5051 = 2 };
												if (step_5051 == 2) {
													currentType = enumType_5050;
													currentTag_5017 = name_5048;
													if (tags.includes(currentTag_5017)) { this.fail(('Tag `' + (currentTag_5017) + '` already matched'), e_5018) } else {
														tags.push(currentTag_5017);
													};
												} else {
													this.fail(('The `' + (name_5048) + '` is not an enum constructor of `' + (enumType_5050.name) + '`'), e_5018);
												};
											} else {
												this.fail('This case pattern is not supported over non-enum types', e_5018);
											};
										}
									} break;
									
									default: 
									this.fail('This case pattern is not supported', e_5018)
									};
								};
							}
						} break;
						
						case 1: {
							const name_5054 = temp_5019[1];
							if (name_5054.charAt(0) == name_5054.charAt(0).toUpperCase()) { this.fill(e_5018) } else {
								this.addScope(name_5054, e_5018);
								{
									let step_5055 = 0;
									const currentType_5056 = currentType;
									if (step_5055 == 0 && currentType_5056 != null) { step_5055 = 1 };
									if (step_5055 == 1) {
										const indexOf = currentType_5056.fieldNames.indexOf(currentTag_5017);
										if (indexOf == (-1)) { this.fail('currentType.fieldNames.indexOf == -1', e_5018) };
										const type_5057 = currentType_5056.tagBindVars[indexOf][currentTagBind];
										const name_5058 = currentType_5056.tagBindVarsNames[indexOf][currentTagBind];
										if (name_5058 == null) {
											const available_5059 = currentType_5056.tagBindVarsNames[indexOf].join(', ');
											if (available_5059.length == 0) { this.fail('No bindings available for `.' + currentTag_5017 + '`', e_5018) };
											this.fail(('Too many bindings requested for `' + (currentTag_5017) + '`, available are: ') + available_5059, e_5018);
										};
										if (type_5057 != null) { this.types.set(e_5018, this.toType(type_5057, e_5018)) } else {
											this.fail('tagBindVars no type for ' + name_5058, e_5018);
										};
									} else {
										this.fail('No currentType for ' + name_5054, e_5018);
									};
								};
							}
						} break;
						
						case 10: {
							const a_5060 = temp_5019[1];
							const op_5061 = temp_5019[2];
							const b_5062 = temp_5019[3];
							if (op_5061 == 104) {
								follow(a_5060);
								follow(b_5062);
							} else {
								this.fail('This case pattern is not supported', e_5018);
							}
						} break;
						
						case 14: {
							const econd_5063 = temp_5019[1];
							{
								this.pushScope();
								this.fill(econd_5063[0]);
								this.popScope();
							}
						} break;
						
						default: 
						this.fail('This case pattern is not supported', e_5018)
						};
					};
					follow(e_5016);
					const e_5064 = cases_5002[i_5014];
					this.pushScope();
					{
						let step_5065 = 0;
						const guard = guards_5001[i_5014];
						if (step_5065 == 0 && guard != null) { step_5065 = 1 };
						if (step_5065 == 1) {
							this.fillExpression(guard);
							if (this.types.get(guard) != this.typeBool) { this.fail('Case guard must be a simple boolean expression', guard) };
						};
					};
					if (value_4997 == false) { this.fill(e_5064) };
					if (value_4997 == true) {
						this.fillExpression(e_5064);
						if (this.types.get(node_4996) == null) { this.types.set(node_4996, this.types.get(e_5064)) } else {
							this.types.set(node_4996, this.unify(this.types.get(node_4996), this.types.get(e_5064), e_5064));
						};
					};
					this.popScope();
					this.popScope();
					i_5014++;
				};
			}
		} break;
		};
	};
	}
	Typer.never = '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.'
	Typer.failures = []
	Typer.nodeToNodeType = (node_4483) => {
		const temp_4484 = node_4483;
		switch (temp_4484&&temp_4484[0]) {
		case 31: {
			const el = temp_4484[1];
			{
				if (el.length > 1) { this.fail('Array type `[T]` cannot have more than 1 parameter `T`', el[1]) };
				return /*ParametricType*/[2,'Array',[Typer.nodeToNodeType(el[0])],null,".ParametricType"];
			}
		} break;
		
		case 51: {
			const t_4485 = temp_4484[1];
			return t_4485
		} break;
		
		case 38: {
			const names_4486 = temp_4484[1];
			const el_4487 = temp_4484[2];
			{
				const types = (() => {
					const result_4488 = [];
					const value_4489 = el_4487;
					for (const e of $toIterator(value_4489)) result_4488.push(Typer.nodeToNodeType(e));
					return result_4488;
				})();
				return /*Object*/[5,names_4486,types,".Object"];
			}
		} break;
		
		default: 
		this.fail('Cannot nodeToNodeType of ' + Node.stringify(node_4483), node_4483)
		};
	};
	var Tokens = class {
		constructor(tokens, length, values, lines, columns, fileName, meta) { 
		{
		this.token = tokens;
		this.length = length;
		this.value = values;
		this.line = lines;
		this.column = columns;
		this.fileName = fileName;
		this.meta = meta;
	} };
	}
	var Lexer = class {
	}
	Lexer.isident = Buffer.alloc(256)
	Lexer.isUpper = Buffer.alloc(256)
	Lexer.ops8a = Buffer.alloc(256)
	Lexer.op16token = Buffer.alloc(768)
	Lexer.kwd
	Lexer.tokenize = (bytes, fileName_5066) => {
		let position = 0;
		const len = bytes.length;
		let to = 0;
		let s = '';
		let p = 0;
		let line = 1;
		let columnBase = 0;
		const params = [];
		const meta_5067 = [];
		const tokens_5068 = Buffer.alloc(len + 1);
		const lines_5069 = [];
		const columns_5070 = [];
		const add = (t) => {
			tokens_5068[(to++)] = t;
			lines_5069.push(line);
			columns_5070.push(position - columnBase - 1);
		};
		const addn = (t_5071, p_5072) => {
			params[to] = p_5072;
			add(t_5071);
		};
		const addm = (t_5073, p_5074, m) => {
			params[to] = p_5074;
			meta_5067[to] = m;
			add(t_5073);
		};
		const curPos = () => { return position - columnBase - 1 };
		const get_8 = (pos) => { return bytes[pos] };
		const not_eof = () => { return (position < len) };
		const new_line = () => {
			line++;
			columnBase = position;
		};
		const fail = (message, erline = null, column = null, filename = null) => {
			const erline_5075 = ((erline != null)? (erline) : line);
			const column_5076 = ((column != null)? (column) : curPos());
			const filename_5077 = ((filename != null)? (filename) : fileName_5066);
			return new CompilerErrors([new CompilerError(2, message, erline_5075, column_5076, filename_5077)]);
		};
		if ((len > 2) && (get_8(0) == 239) && (get_8(1) == 187) && (get_8(2) == 191)) { position += 3 };
		if ((len > 2) && (get_8(0) == 35) && (get_8(1) == 33)) { while (position < len && get_8(position) != 10) {
			position++;
		} };
		while (position < len) {
			let _8 = 0;
			do {{
				_8 = get_8(position);
				if (_8 == 10) { new_line() };
			}} while (_8 <= 32 && ((++position) < len));
			if ((!not_eof())) { break };
			let _16 = (((len - position) > 1)? (_8 | (get_8(position + 1) << 8)) : _8);
			if (_8 == 47) {
				if (_16 == 12079) {
					const pos_5078 = position + 2;
					while (get_8(position) != 10 && not_eof()) {
						position++;
					};
					continue;
				};
				if (_16 == 10799 && get_8(position + 2) == 42) {
					position += 3;
					p = position;
					while (not_eof()) {
						const _32 = (((len - position) > 3)? (bytes.readUInt32LE(position)) : get_8(position));
						if ((_32 & 255) == 10) { new_line() } else if ((_32 & 16777215) == 3090986) { break };
						position++;
					};
					if ((!not_eof())) { throw fail('Unclosed doc-comment', null, null, null) };
					addn(65, bytes.toString('utf8', p, position));
					position += 3;
					continue;
				};
				if (_16 == 10799) {
					const pos_5079 = position + 2;
					p = 0;
					position += 2;
					while (not_eof()) {
						_16 = (((len - position) > 1)? (bytes.readUInt16LE(position)) : get_8(position));
						if ((_16 & 255) == 10) { new_line() } else if (_16 == 12074 && p > 0) { p-- } else if (_16 == 10799) { p++ } else if (_16 == 12074 && p == 0) { break };
						position++;
					};
					position += 2;
					continue;
				};
			};
			if (((_8 & 95) >= 65 && (_8 & 95) <= 90) || (_8 == 95)) {
				const titlechar = _8;
				p = position + 1;
				_8 = get_8(p);
				while (p < len && Lexer.isident[_8] != 0) {
					_8 = get_8((++p));
				};
				s = bytes.toString('ascii', position, p);
				const t_5080 = ((((_16 & 255) <= 90))? (null) : Lexer.kwd.get(s));
				{
					let step = 0;
					const t_5081 = t_5080;
					if (step == 0 && t_5081 != null) { step = 1 };
					if (step == 1) { add(t_5081) } else {
						if (titlechar >= 65 && titlechar <= 90) { addn(61, s) } else {
							addn(62, s);
						};
					};
				};
				position = p;
				continue;
			};
			if (_8 == 96) {
				position++;
				const pos_5082 = position;
				while (not_eof()) {
					if ((get_8(position) == 96) && (get_8(position + 1) == 96)) {
						position++;
						position++;
						continue;
					};
					if (get_8(position) == 96) { break };
					if (get_8(position) == 10) { new_line() };
					position++;
				};
				let result = bytes.toString('utf8', pos_5082, position);
				if (result.indexOf('``') != (-1)) { result = result.split('``').join('') };
				addn(66, result.replaceAll('\r\n', '\n'));
				position++;
				continue;
			};
			if (_16 == 11822 && (get_8(position + 2) == 46)) {
				add(98);
				position += 3;
				continue;
			};
			if (_16 == 15934 && (get_8(position + 2) == 62)) {
				add(108);
				position += 3;
				continue;
			};
			const hash = Lexer.simplehash(_16);
			if (_16 == Lexer.op16token.readUInt16LE(hash * 2)) {
				add((Lexer.op16token[hash + 512]));
				position += 2;
				continue;
			};
			const found = (Lexer.ops8a[_8]);
			if (found != 0) {
				add(found);
				position++;
				continue;
			};
			if (_8 < 40) {
				p = _8;
				position++;
				const pos_5083 = position;
				while (get_8(position) != p && not_eof()) {
					if (get_8(position) == 10) { new_line() };
					if (get_8(position) == '\\'.charCodeAt(0)) {
						position += 2;
						continue;
					};
					_16 = (((len - position) > 1)? (bytes.readUInt16LE(position)) : get_8(position));
					position++;
				};
				let result_5084 = bytes.toString('utf8', pos_5083, position);
				if (result_5084.indexOf('\r\n') != (-1)) { result_5084 = result_5084.replaceAll('\r\n', '\n') };
				addn(64, result_5084);
				position++;
				continue;
			};
			if (_16 == 25136) {
				p = position;
				p += 2;
				_8 = get_8(position);
				while (_8 == 48 || _8 == 49) {
					_8 = get_8((++p));
				};
				if (p - position == 2) { throw fail('Integer `0b` not allowed!', null, null, null) };
				let m_5085 = 0;
				let offset = 0;
				if (get_8(p) == 110) {
					m_5085 = 1;
					offset = 1;
				} else if (get_8(p) == 105) {
					const header = bytes.readUInt16LE(p + 1);
					if (get_8(p + 1) == 56) {
						m_5085 = 5;
						offset = 2;
					} else if (header == 51 + 50 * 256) {
						m_5085 = 2;
						offset = 3;
					} else if (header == 54 + 52 * 256) {
						m_5085 = 3;
						offset = 3;
					} else if (header == 49 + 54 * 256) {
						m_5085 = 4;
						offset = 3;
					};
				} else if (get_8(p) == 117) {
					const header_5086 = bytes.readUInt16LE(p + 1);
					if (get_8(p + 1) == 56) {
						m_5085 = 9;
						offset = 2;
					} else if (header_5086 == 51 + 50 * 256) {
						m_5085 = 6;
						offset = 3;
					} else if (header_5086 == 54 + 52 * 256) {
						m_5085 = 7;
						offset = 3;
					} else if (header_5086 == 49 + 54 * 256) {
						m_5085 = 8;
						offset = 3;
					};
				};
				const string = parseInt(bytes.toString('ascii', position + 2, p), 2).toString();
				addm(63, string, m_5085);
				position = p + offset;
				continue;
			};
			if (_16 == 30768) {
				p = position;
				p += 2;
				_8 = get_8(position);
				while ((_8 >= 65 && _8 <= 70) || (_8 >= 48 && _8 <= 57) || (_8 >= 97 && _8 <= 102)) {
					_8 = get_8((++p));
				};
				if (p - position == 2) { throw fail('Integer `0x` not allowed!', null, null, null) };
				let m_5087 = 0;
				let offset_5088 = 0;
				if (get_8(p) == 110) {
					m_5087 = 1;
					offset_5088 = 1;
				} else if (get_8(p) == 105) {
					const header_5089 = bytes.readUInt16LE(p + 1);
					if (get_8(p + 1) == 56) {
						m_5087 = 5;
						offset_5088 = 2;
					} else if (header_5089 == 51 + 50 * 256) {
						m_5087 = 2;
						offset_5088 = 3;
					} else if (header_5089 == 54 + 52 * 256) {
						m_5087 = 3;
						offset_5088 = 3;
					} else if (header_5089 == 49 + 54 * 256) {
						m_5087 = 4;
						offset_5088 = 3;
					};
				} else if (get_8(p) == 117) {
					const header_5090 = bytes.readUInt16LE(p + 1);
					if (get_8(p + 1) == 56) {
						m_5087 = 9;
						offset_5088 = 2;
					} else if (header_5090 == 51 + 50 * 256) {
						m_5087 = 6;
						offset_5088 = 3;
					} else if (header_5090 == 54 + 52 * 256) {
						m_5087 = 7;
						offset_5088 = 3;
					} else if (header_5090 == 49 + 54 * 256) {
						m_5087 = 8;
						offset_5088 = 3;
					};
				};
				addm(63, bytes.toString('ascii', position, p), m_5087);
				position = p + offset_5088;
				continue;
			};
			if (_8 < 58) {
				p = position;
				_8 = get_8(p);
				let found_5091 = 63;
				while (_8 >= 48 && _8 <= 57) {
					_8 = get_8((++p));
				};
				if (_8 == 46 && get_8(p + 1) != 46) {
					_8 = get_8((++p));
					while (_8 >= 48 && _8 <= 57) {
						_8 = get_8((++p));
					};
					found_5091 = 60;
				};
				if (_8 == 101 || _8 == 69) {
					_8 = get_8((++p));
					if (_8 == 43 || _8 == 45) { _8 = get_8((++p)) };
					while (_8 >= 48 && _8 <= 57) {
						_8 = get_8((++p));
					};
					found_5091 = 60;
				};
				let m_5092 = 0;
				let offset_5093 = 0;
				if (get_8(p) == 110) {
					m_5092 = 1;
					offset_5093 = 1;
				} else if (get_8(p) == 105) {
					const header_5094 = bytes.readUInt16LE(p + 1);
					if (get_8(p + 1) == 56) {
						m_5092 = 5;
						offset_5093 = 2;
					} else if (header_5094 == 51 + 50 * 256) {
						m_5092 = 2;
						offset_5093 = 3;
					} else if (header_5094 == 54 + 52 * 256) {
						m_5092 = 3;
						offset_5093 = 3;
					} else if (header_5094 == 49 + 54 * 256) {
						m_5092 = 4;
						offset_5093 = 3;
					};
				} else if (get_8(p) == 117) {
					const header_5095 = bytes.readUInt16LE(p + 1);
					if (get_8(p + 1) == 56) {
						m_5092 = 9;
						offset_5093 = 2;
					} else if (header_5095 == 51 + 50 * 256) {
						m_5092 = 6;
						offset_5093 = 3;
					} else if (header_5095 == 54 + 52 * 256) {
						m_5092 = 7;
						offset_5093 = 3;
					} else if (header_5095 == 49 + 54 * 256) {
						m_5092 = 8;
						offset_5093 = 3;
					};
				} else if (get_8(p) == 102) {
					const header_5096 = bytes.readUInt16LE(p + 1);
					if (header_5096 == 51 + 50 * 256) {
						m_5092 = 10;
						offset_5093 = 3;
					};
				};
				addm(found_5091, bytes.toString('ascii', position, p), m_5092);
				position = p + offset_5093;
				continue;
			};
			if (position >= len) { break };
			throw fail('Unexpected character ' + String.fromCharCode(_8), null, null, null);
		};
		add(0);
		return new Tokens(tokens_5068, to, params, lines_5069, columns_5070, fileName_5066, meta_5067);
	};
	Lexer.init = () => {
		{
			let _8_5097 = 0;
			let it = 0;
			while (it < 256) {
				_8_5097 = it;
				it++;
				{
					Lexer.isident[_8_5097] = ((((_8_5097 >= 65 && _8_5097 <= 90) || (_8_5097 >= 48 && _8_5097 <= 57) || (_8_5097 >= 97 && _8_5097 <= 122) || _8_5097 == 95))? (128) : 0);
				};
			};
		};
		{
			let _8_5098 = 0;
			let it_5099 = 0;
			while (it_5099 < 256) {
				_8_5098 = it_5099;
				it_5099++;
				{
					Lexer.isident[_8_5098] = ((((_8_5098 >= 65 && _8_5098 <= 90) || (_8_5098 >= 48 && _8_5098 <= 57) || (_8_5098 >= 97 && _8_5098 <= 122) || _8_5098 == 95))? (128) : 0);
				};
			};
		};
		Lexer.kwd = new Map([['_', 1], ['as', 58], ['break', 3], ['case', 4], ['catch', 6], ['class', 7], ['continue', 8], ['do', 9], ['else', 10], ['enum', 11], ['extends', 12], ['declare', 13], ['false', 14], ['for', 15], ['fun', 21], ['if', 17], ['implements', 18], ['import', 2], ['in', 20], ['interface', 22], ['let', 23], ['new', 25], ['null', 26], ['private', 29], ['return', 31], ['static', 32], ['super', 59], ['switch', 33], ['this', 34], ['throw', 35], ['true', 36], ['try', 37], ['var', 40], ['while', 41], ['and', 92], ['or', 93], ['not', 89], ['is', 57]]);
		const ops8 = new Map([[64, 70], [36, 83], [35, 78], [33, 89], [37, 101], [38, 112], [40, 80], [41, 79], [42, 102], [43, 111], [44, 75], [45, 107], [46, 77], [47, 94], [58, 76], [59, 82], [60, 99], [61, 91], [62, 96], [63, 81], [91, 72], ['\\'.charCodeAt(0), 110], [93, 71], [94, 109], [123, 74], [124, 104], [125, 73], [126, 88]]);
		for (const key of $toIterator(ops8.keys())) {
			Lexer.ops8a[key] = ops8.get(key);
		};
		const ops16 = new Map([[11051, 87], [11565, 86], [15420, 105], [15649, 103], [15676, 100], [15677, 95], [15678, 97], [15934, 106], [31868, 93], [9766, 92], [15933, 90], [11839, 113]]);
		for (const key1 of $toIterator(ops16.keys())) {
			for (const key2 of $toIterator(ops16.keys())) {
				if (key1 != key2 && Lexer.simplehash(key1) == Lexer.simplehash(key2)) { throw new CompilerError(2, '2-byte op hash collision: ' + key1 + ' ' + key2, 0, 0, 'INTERNAL') };
			};
		};
		for (const key of $toIterator(ops16.keys())) {
			const hash_5100 = Lexer.simplehash(key);
			Lexer.op16token.writeUInt16LE(key, hash_5100 * 2);
			Lexer.op16token[hash_5100 + 512] = ops16.get(key);
		};
		return;
	};
	Lexer.simplehash = (val) => { return ((val & 255) + (((val >> (8 * 1)) & 255) << 3)) & 239 };
	var Preprocessor = class {
	}
	Preprocessor.process_6 = (tokens, project) => {
		let i = 0;
		let token = (tokens.token[0]);
		while (i < tokens.length && token != 0) {
			if (token == 78) { return Preprocessor.processTokens(tokens, 0, project) };
			i++;
			token = (tokens.token[i]);
		};
		return tokens;
	};
	Preprocessor.fail = (lex, i_5101, message) => {
		const line = lex.line[i_5101];
		const column = lex.column[i_5101];
		const filename = lex.fileName;
		throw new CompilerErrors([new CompilerError(0, message, line, column, filename)]);
	};
	Preprocessor.processTokens = (tokens_5102, i_5103, project_5104) => {
		let i_5105 = i_5103;
		let token_5106 = (tokens_5102.token[0]);
		const bytes = tokens_5102.token.slice();
		const params = tokens_5102.value.slice();
		const lines = tokens_5102.line.slice();
		const columns = tokens_5102.column.slice();
		const meta = tokens_5102.meta.slice();
		let to = i_5105;
		const states = [0];
		let state = 0;
		const evaluateCondition = () => {
			project_5104.defines['false'] = false;
			project_5104.defines['true'] = true;
			let defName = tokens_5102.value[i_5105];
			const token_5107 = (tokens_5102.token[i_5105]);
			{
				const temp = token_5107;
				switch (temp) {
				case 62: {
					{
					}
				} break;
				
				case 14: {
					defName = 'false'
				} break;
				
				case 36: {
					defName = 'true'
				} break;
				
				default: 
				Preprocessor.fail(tokens_5102, i_5105, 'Incorrect `#if` syntax')
				};
			};
			const def = project_5104.defines[defName];
			if (def == null) { Preprocessor.fail(tokens_5102, i_5105, '`#if` looks for the `' + defName + '` parameter which is *not* defined in project file.' + (' Add `\"define\": { \"' + (defName) + '\": false }` to `hexa.json` or `--define ' + (defName) + '=false` to suppress this message.')) };
			i_5105++;
			if (def == true) { return true };
			return false;
		};
		while (i_5105 < tokens_5102.length && token_5106 != 0) {
			if (token_5106 == 78) {
				i_5105++;
				token_5106 = (tokens_5102.token[i_5105]);
				if (token_5106 == 17) {
					i_5105++;
					if (evaluateCondition()) { states.push(1) } else {
						states.push(4);
					};
					state = states[states.length - 1];
				} else if ((token_5106 == 62) && (tokens_5102.value[i_5105] == 'end')) {
					i_5105++;
					{
						const temp_5108 = state;
						switch (temp_5108) {
						case 1: {
							{
							}
						} break;
						
						case 2: {
							{
							}
						} break;
						
						case 3: {
							{
							}
						} break;
						
						case 4: {
							{
							}
						} break;
						
						default: 
						Preprocessor.fail(tokens_5102, i_5105 - 1, 'Unexpected `#end`')
						};
					};
					states.pop();
					state = states[states.length - 1];
				} else if (token_5106 == 10) {
					i_5105++;
					{
						const temp_5109 = state;
						switch (temp_5109) {
						case 1: {
							state = 3
						} break;
						
						case 4: {
							state = 2
						} break;
						
						default: 
						Preprocessor.fail(tokens_5102, i_5105 - 1, 'Unexpected `#else`')
						};
					};
					states[states.length - 1] = state;
				} else if ((token_5106 == 62) && (tokens_5102.value[i_5105] == 'error')) {
					i_5105++;
					const message_5110 = tokens_5102.value[i_5105];
					i_5105++;
					{
						const temp_5111 = state;
						switch (temp_5111) {
						case 4: case 3: {
							{
							}
						} break;
						
						default: 
						Preprocessor.fail(tokens_5102, i_5105, '#error ' + message_5110)
						};
					};
				} else {
					Preprocessor.fail(tokens_5102, i_5105, 'Incorrect `#` syntax');
				};
			} else {
				{
					const temp_5112 = state;
					switch (temp_5112) {
					case 0: case 1: case 2: {
						{
							bytes[to] = tokens_5102.token[i_5105];
							params[to] = tokens_5102.value[i_5105];
							lines[to] = tokens_5102.line[i_5105];
							columns[to] = tokens_5102.column[i_5105];
							meta[to] = tokens_5102.meta[i_5105];
							i_5105++;
							to++;
						}
					} break;
					
					default: 
					i_5105++
					};
				};
				{
					const temp_5113 = state;
					switch (temp_5113) {
					case 4: case 3: case 1: case 2: {
						{
							const token_5114 = (tokens_5102.token[i_5105]);
							if (token_5114 == 0) { Preprocessor.fail(tokens_5102, i_5105, 'Unexpected end, you have unclosed `#if` or `#else`. Place `#end` to close condition.') };
						}
					} break;
					};
				};
			};
			token_5106 = (tokens_5102.token[i_5105]);
		};
		return new Tokens(bytes, to, params, lines, columns, tokens_5102.fileName, meta);
	};
	var Parser = class {
		constructor(lexe_5115, project_5116, lint_5117) { 
			this.i = 0
			this.endif = 0
			this.lasttok = (-1)
			this.lasttokchecks = 10
			this.lint = false
			this.hints = []
			this.classExternal = false
			this.parametricTypeNesting = 0
			this.parametricTypeNestingToken = 0
		{
		this.lex = Preprocessor.process_6(lexe_5115, project_5116);
		this.lint = lint_5117;
		this.project = project_5116;
		this.nodes = [];
		while (this.i < this.lex.length && this.tok() != 0) {
			this.nodes.push(this.parseExpr());
		};
	} };
		parseFields() {
		const fields = [];
		while (this.tok() != 73) {
			const atts = [];
			while (this.tok() == 70) {
				atts.push(this.parseDecorator());
			};
			const pos = {line:this.lex.line[this.i], column:this.lex.column[this.i]};
			const pos_5118 = new NodeData(pos.line, pos.column, this.lex.fileName);
			let _static = false;
			if (this.tok() == 32) {
				_static = true;
				this.i++;
			};
			{
				const temp = this.tok();
				switch (temp) {
				case 29: {
					this.i++
				} break;
				
				case 40: {
					{
						let f = this.parseExpr();
						this.project.data.set(f, pos_5118);
						if (_static) {
							f = /*Static*/[47,f,".Static"];
							this.project.data.set(f, pos_5118);
						};
						this.project.mapDecorators.set(f, atts);
						fields.push(f);
					}
				} break;
				
				case 21: {
					{
						let f_5119 = this.parseExpr();
						this.project.data.set(f_5119, pos_5118);
						if (_static) {
							f_5119 = /*Static*/[47,f_5119,".Static"];
							this.project.data.set(f_5119, pos_5118);
						};
						this.project.mapDecorators.set(f_5119, atts);
						fields.push(f_5119);
					}
				} break;
				
				case 23: {
					{
						let f_5120 = this.parseExpr();
						this.project.data.set(f_5120, pos_5118);
						if (_static) {
							f_5120 = /*Static*/[47,f_5120,".Static"];
							this.project.data.set(f_5120, pos_5118);
						};
						this.project.mapDecorators.set(f_5120, atts);
						fields.push(f_5120);
					}
				} break;
				
				case 25: {
					{
						this.i++;
						let expr = null;
						const vars = [];
						const types = [];
						const values = [];
						this.step(80);
						if (this.tok() != 79) { while (true) {
							vars.push(this.getgo(62));
							let expr_5121 = null;
							let t = null;
							if (this.tok() == 76) {
								this.i++;
								t = this.parseType();
							};
							if (this.tok() == 91) {
								this.i++;
								expr_5121 = this.parseExpr();
							};
							types.push(t);
							values.push(expr_5121);
							if (this.tok() == 75) { this.i++ } else {
								break;
							};
						} };
						this.step(79);
						const tmp = this.i;
						while (this.tok() == 70) {
							this.parseDecorator();
						};
						if ((this.tok() != 73) && (this.tok() != 21)) {
							this.i = tmp;
							expr = this.parseExpr();
						} else {
							this.i = tmp;
						};
						const v = [];
						{
							let i = 0;
							let it = 0;
							let at = vars.length;
							while (it < at) {
								i = it;
								it++;
								{
									v.push(/*Var*/[24,vars[i],types[i],values[i],true,false,".Var"]);
								};
							};
						};
						{
							const temp_5122 = expr;
							switch (temp_5122&&temp_5122[0]) {
							case null: case undefined: {
								{
								}
							} break;
							
							case 12: {
								{
								}
							} break;
							
							default: 
							{
								this.i--;
								this.fail('Constructor `new` should have a `{ block }` as a body');
							}
							};
						};
						const field = /*Function*/[22,'new',expr,v,null,false,".Function"];
						this.project.data.set(field, pos_5118);
						fields.push(field);
					}
				} break;
				
				case 62: {
					{
						const name = this.getgo(62);
						if ((name == 'get') && (this.tok() == 62)) {
							const field_5123 = this.getgo(62);
							this.fail(('Use property `var ' + (field_5123) + ' { get { return value } }` instead of `get ' + (field_5123) + '()`'));
						};
						if ((name == 'set') && (this.tok() == 62)) {
							const field_5124 = this.getgo(62);
							this.step(80);
							const value = this.getgo(62);
							this.fail(('Use property `var ' + (field_5124) + ' { set(' + (value) + ') { ... } }` instead of `set ' + (field_5124) + '(' + (value) + ')`'));
						};
						if (this.tok() == 80) {
							if (name == 'constructor') { this.fail('Use `new()` syntax instead of `constructor()`') };
							if (_static) { this.fail('Use `static fun ' + name + '()` syntax for static methods') } else {
								this.fail('Use `function ' + name + '()` syntax for methods');
							};
						};
						this.fail('Fields should start with `var ' + name + '` or `let ' + name + '`');
					}
				} break;
				
				case 61: {
					this.fail('Fields cannot start with uppercase character `' + this.print() + '` -> `' + this.print().toLowerCase() + '`')
				} break;
				
				case 74: {
					{
						const pos_5125 = {line:this.lex.line[this.i], column:this.lex.column[this.i]};
						const field_5126 = fields.pop();
						let v_5127 = null;
						let t_5128 = null;
						let n = null;
						let onlyGet = false;
						{
							const temp_5129 = field_5126;
							switch (temp_5129&&temp_5129[0]) {
							case 24: {
								const name_5130 = temp_5129[1];
								const type = temp_5129[2];
								const expr_5131 = temp_5129[3];
								const const_5132 = temp_5129[4];
								{
									if (expr_5131 != null) { this.fail('Property should not have a `= value`') };
									v_5127 = field_5126;
									t_5128 = type;
									n = name_5130;
									onlyGet = const_5132;
								}
							} break;
							
							default: 
							this.fail('Only `var` and `let` fields may have a getter `let v: T { get() ... }`')
							};
						};
						this.i++;
						if (this.print() == 'set') { this.fail('Expected `get` before `set`') };
						if (this.print() != 'get') { this.fail('Expected `get`') };
						const kind = this.print();
						let getterExpr = null;
						if (kind == 'get') {
							this.i++;
							getterExpr = this.parseExpr();
						};
						const kind_5133 = this.print();
						let setterExpr = null;
						let setterVar = null;
						if ((kind_5133 == 'set') && (onlyGet)) { this.fail('Constants `let` may have only getter `get`') };
						if (kind_5133 == 'set') {
							this.i++;
							this.step(80);
							setterVar = this.getgo(62);
							this.step(79);
							setterExpr = this.parseExpr();
						};
						if ((setterExpr == null) && ((!onlyGet))) { this.fail('Variables `var` should have both getter `get` and setter `set`') };
						this.step(73);
						const getter = (((getterExpr == null))? (null) : /*Function*/[22,'get_' + n,getterExpr,[],t_5128,false,".Function"]);
						const setter = (((setterExpr == null))? (null) : /*Function*/[22,'set_' + n,setterExpr,[/*Var*/[24,setterVar,t_5128,null,true,false,".Var"]],null,false,".Function"]);
						const property = /*Property*/[26,field_5126,getter,setter,".Property"];
						this.project.data.set(property, new NodeData(pos_5125.line, pos_5125.column, this.lex.fileName));
						this.project.data.set(getter, new NodeData(pos_5125.line, pos_5125.column, this.lex.fileName));
						this.project.data.set(setter, new NodeData(pos_5125.line, pos_5125.column, this.lex.fileName));
						fields.push(property);
						{
							let step = 0;
							const getter_5134 = getter;
							if (step == 0 && getter_5134 != null) { step = 1 };
							if (step == 1) { fields.push(getter_5134) };
						};
						{
							let step_5135 = 0;
							const setter_5136 = setter;
							if (step_5135 == 0 && setter_5136 != null) { step_5135 = 1 };
							if (step_5135 == 1) { fields.push(setter_5136) };
						};
					}
				} break;
				
				default: 
				this.fail('Fields cannot start with `' + this.print() + '`')
				};
			};
		};
		return fields;
	};
		tok() { return (this.lex.token[this.i]) };
		print() { return Token.stringify((this.lex.token[this.i]), this.lex.value[this.i]) };
		expect(t_5137) { if (t_5137 != this.tok()) { this.expected(Token.stringify(t_5137)) } };
		fail(message, line, column, filename) {
		const line_5138 = ((line != null)? (line) : this.lex.line[this.i]);
		const column_5139 = ((column != null)? (column) : this.lex.column[this.i]);
		const filename_5140 = ((filename != null)? (filename) : this.lex.fileName);
		this.hints.push(new CompilerError(0, message, line_5138, column_5139, filename_5140));
		throw new CompilerErrors(this.hints);
	};
		failHint(message_5141, line_5142, column_5143, filename_5144) {
		const line_5145 = ((line_5142 != null)? (line_5142) : this.lex.line[this.i]);
		const column_5146 = ((column_5143 != null)? (column_5143) : this.lex.column[this.i]);
		const filename_5147 = ((filename_5144 != null)? (filename_5144) : this.lex.fileName);
		this.hints.push(new CompilerError(0, message_5141, line_5145, column_5146, filename_5147));
	};
		getgo(t_5148) {
		this.expect(t_5148);
		return this.lex.value[(this.i++)];
	};
		step(t_5149) {
		this.expect(t_5149);
		this.i++;
	};
		next() { this.i++ };
		offset(v_5150) { return (this.lex.token[this.i + v_5150]) };
		unexpected() {
		const token = Token.stringify((this.lex.token[this.i]), this.lex.value[this.i]);
		let error = ('Unexpected `' + (token) + '`');
		if (this.tok() == 82) { error += ' semicolon. Note: Hexa has no semicolons!' };
		if (this.print() == 'public') { error += '. Note: Hexa has no `public` keyword!' };
		this.fail(error);
	};
		expected(str) {
		const token_5151 = Token.stringify((this.lex.token[this.i]), this.lex.value[this.i]);
		this.fail(('Expected `' + (str) + '` before `' + (token_5151) + '`'));
	};
		parseExpr() {
		let atts_5152 = [];
		while (this.tok() == 70) {
			atts_5152.push(this.parseDecorator());
		};
		const node = this.tok();
		const nodePosition = {line:this.lex.line[this.i], column:this.lex.column[this.i]};
		let result = null;
		{
			const temp_5153 = node;
			switch (temp_5153) {
			case 13: {
				{
					this.i++;
					{
						const temp_5154 = this.tok();
						switch (temp_5154) {
						case 21: {
							result = this.parseFunction(false, true)
						} break;
						
						case 40: case 23: {
							{
								const parsed = this.parseVar(true);
								if (parsed.length > 1) {} else {
									result = parsed[0];
								};
							}
						} break;
						
						case 7: case 22: {
							result = this.parseClass(true)
						} break;
						
						case 61: {
							{
								const alias = this.parseType();
								this.step(91);
								const value_5155 = this.parseType();
								result = /*TypeAlias*/[9,alias,value_5155,".TypeAlias"];
							}
						} break;
						
						default: 
						this.fail(('Wrong `declare` format, got `' + (Token.stringify(this.tok())) + '`'))
						};
					};
				}
			} break;
			
			case 74: {
				{
					const startsAt = this.i;
					this.i++;
					if (this.tok() == 73) {
						this.i++;
						result = /*Block*/[12,[],".Block"];
					} else if (this.tok() == 62 && this.offset(1) == 76) {
						const names = [];
						const el = [];
						while (true) {
							names.push(this.getgo(62));
							this.step(76);
							el.push(this.parseExpr());
							if (this.tok() == 75) {
								this.i++;
								if (this.tok() == 73) { this.fail('Unexpected `}`, remove trailing `,` comma') };
								continue;
							} else {
								break;
							};
						};
						if (this.tok() != 73) { this.fail(('Expected `}` or `,` before `' + (this.print()) + '`')) };
						this.step(73);
						result = /*Object*/[38,names,el,".Object"];
					} else {
						const el_5156 = [];
						while (this.tok() != 73) {
							if (this.tok() == 0) {
								this.i = startsAt;
								this.fail('The block `{` has got unclosed to the end of the file');
							};
							el_5156.push(this.parseExpr());
						};
						this.step(73);
						result = /*Block*/[12,el_5156,".Block"];
					};
				}
			} break;
			
			case 17: {
				{
					this.i++;
					const econd = [this.parseExpr()];
					while (this.tok() == 75) {
						this.next();
						econd.push(this.parseExpr());
					};
					let eif = null;
					const eifAt = this.i;
					if (this.tok() != 76) { eif = this.parseExpr() };
					let eelse = null;
					const eelseAt = this.i;
					if (this.tok() == 10) {
						this.i++;
						{
							const temp_5157 = this.tok();
							switch (temp_5157) {
							case 17: {
								eelse = this.parseExpr()
							} break;
							
							default: 
							eelse = this.parseBlock()
							};
						};
					};
					if (eif != null) {
						const temp_5158 = eif;
						switch (temp_5158&&temp_5158[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						{
							const temp_5159 = this.i;
							this.i = eifAt;
							this.failHint('`if` body must be a `{` block `}`');
							this.i = temp_5159;
						}
						};
					};
					if (eelse != null) {
						const temp_5160 = eelse;
						switch (temp_5160&&temp_5160[0]) {
						case 12: {
							{
							}
						} break;
						
						case 14: {
							{
							}
						} break;
						
						default: 
						{
							const temp_5161 = this.i;
							this.i = eelseAt;
							this.failHint('`else` body must be a `{` block `}`');
							this.i = temp_5161;
						}
						};
					};
					result = /*If*/[14,econd,eif,eelse,false,".If"];
				}
			} break;
			
			case 41: {
				{
					this.i++;
					const econd_5162 = this.parseExpr();
					const eAt = this.i;
					const e = this.parseExpr();
					{
						const temp_5163 = e;
						switch (temp_5163&&temp_5163[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						{
							const temp_5164 = this.i;
							this.i = eAt;
							this.failHint('`while` body must be a `{` block `}`');
							this.i = temp_5164;
						}
						};
					};
					result = /*While*/[21,econd_5162,e,true,".While"];
				}
			} break;
			
			case 9: {
				{
					this.i++;
					const eAt_5165 = this.i;
					const e_5166 = this.parseExpr();
					{
						const temp_5167 = e_5166;
						switch (temp_5167&&temp_5167[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						{
							const temp_5168 = this.i;
							this.i = eAt_5165;
							this.failHint('`do` body must be a `{` block `}`');
							this.i = temp_5168;
						}
						};
					};
					this.step(41);
					const econd_5169 = this.parseExpr();
					result = /*While*/[21,econd_5169,e_5166,false,".While"];
				}
			} break;
			
			case 80: {
				{
					const startsAt_5170 = this.i;
					this.next();
					if ((this.tok() == 79 && this.offset(1) == 90) || (this.tok() == 62 && this.offset(1) == 75) || (this.tok() == 62 && this.offset(1) == 76) || (this.tok() == 62 && this.offset(1) == 79 && this.offset(2) == 90)) {
						const vars_5171 = [];
						const types_5172 = [];
						const values_5173 = [];
						while (this.tok() != 79) {
							vars_5171.push(this.getgo(62));
							if (this.tok() == 76) {
								this.i++;
								types_5172.push(this.parseType());
							};
							if (this.tok() == 91) {
								this.i++;
								values_5173.push(this.parseExpr());
							};
							if (this.tok() == 75) { this.i++ };
						};
						this.step(79);
						this.step(90);
						const v_5174 = [];
						{
							let i_5175 = 0;
							let it_5176 = 0;
							let at_5177 = vars_5171.length;
							while (it_5176 < at_5177) {
								i_5175 = it_5176;
								it_5176++;
								{
									v_5174.push(/*Var*/[24,vars_5171[i_5175],types_5172[i_5175],values_5173[i_5175],true,false,".Var"]);
								};
							};
						};
						result = /*Arrow*/[23,this.parseExpr(),v_5174,null,".Arrow"];
					} else {
						if (this.tok() == 0) {
							this.i = startsAt_5170;
							this.fail('The parenthesis `(` has got unclosed to the end of the file');
						};
						const expr_5178 = this.parseExpr();
						if (this.tok() == 0) {
							this.i = startsAt_5170;
							this.fail('The parenthesis `(` has got unclosed to the end of the file');
						};
						this.step(79);
						result = /*Parenthesis*/[15,expr_5178,".Parenthesis"];
					};
				}
			} break;
			
			case 31: {
				{
					this.i++;
					{
						const temp_5179 = this.tok();
						switch (temp_5179) {
						case 73: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						case 40: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						case 23: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						case 4: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						case 3: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						case 8: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						case 31: {
							result = /*Return*/[16,null,".Return"]
						} break;
						
						default: 
						result = /*Return*/[16,this.parseExpr(),".Return"]
						};
					};
				}
			} break;
			
			case 35: {
				{
					this.i++;
					result = /*Throw*/[17,this.parseExpr(),".Throw"];
				}
			} break;
			
			case 8: {
				{
					this.i++;
					result = /*Continue*/[19];
				}
			} break;
			
			case 3: {
				{
					this.i++;
					result = /*Break*/[18];
				}
			} break;
			
			case 1: {
				{
					this.i++;
					result = /*Underscore*/[45];
				}
			} break;
			
			case 98: {
				{
					this.i++;
					result = /*Interval*/[46];
				}
			} break;
			
			case 87: case 86: case 89: case 88: case 107: {
				{
					const id = this.lex.token[this.i];
					this.i++;
					const value_5180 = this.parseExpr();
					const fix = (value_5181) => {
						const temp_5182 = value_5181;
						switch (temp_5182&&temp_5182[0]) {
						case 10: {
							const aa = temp_5182[1];
							const op = temp_5182[2];
							const bb = temp_5182[3];
							{
								const out = /*Binop*/[10,fix(aa),op,bb,".Binop"];
								this.project.data.set(out, this.project.data.get(value_5181));
								return out;
							}
						} break;
						
						default: 
						return /*Unop*/[20,id,false,value_5181,".Unop"]
						};
					};
					result = fix(value_5180);
				}
			} break;
			
			case 60: {
				{
					const meta = this.lex.meta[this.i];
					result = /*Float*/[7,parseFloat(this.getgo(60)),meta,".Float"];
				}
			} break;
			
			case 63: {
				{
					const meta_5183 = this.lex.meta[this.i];
					const value_5184 = this.getgo(63);
					{
						const temp_5185 = meta_5183;
						switch (temp_5185) {
						case 0: {
							{
								const at_5186 = this.i;
								const v_5187 = parseInt(value_5184);
								if (v_5187 > 2147483647 || v_5187 < (-2147483647)) {
									this.i = at_5186 - 1;
									this.fail(('Integer `' + (value_5184) + '` is too large for *signed* 32 bit, use `' + (value_5184) + 'u32` or `' + (value_5184) + 'n`'));
								};
								result = /*Int*/[5,v_5187,".Int"];
							}
						} break;
						
						case 9: {
							{
								const at_5188 = this.i;
								const v_5189 = BigInt(value_5184);
								if (v_5189 >= 256n || v_5189 < 0n) {
									this.i = at_5188 - 1;
									this.fail(('Integer `' + (value_5184) + '` is negative or too large for *unsigned* 8 bit, use `' + (value_5184) + 'u16` or `' + (value_5184) + 'n`'));
								};
								result = /*MetaInt*/[6,v_5189,meta_5183,".MetaInt"];
							}
						} break;
						
						case 8: {
							{
								const at_5190 = this.i;
								const v_5191 = BigInt(value_5184);
								if (v_5191 >= 65536n || v_5191 < 0n) {
									this.i = at_5190 - 1;
									this.fail(('Integer `' + (value_5184) + '` is negative or too large for *unsigned* 16 bit, use `' + (value_5184) + 'u32` or `' + (value_5184) + 'n`'));
								};
								result = /*MetaInt*/[6,v_5191,meta_5183,".MetaInt"];
							}
						} break;
						
						case 6: {
							{
								const at_5192 = this.i;
								const v_5193 = BigInt(value_5184);
								if (v_5193 >= 4294967296n || v_5193 < 0n) {
									this.i = at_5192 - 1;
									this.fail(('Integer `' + (value_5184) + '` is negative or too large for *unsigned* 32 bit, use `' + (value_5184) + 'u64` or `' + (value_5184) + 'n`'));
								};
								result = /*MetaInt*/[6,v_5193,meta_5183,".MetaInt"];
							}
						} break;
						
						default: 
						result = /*MetaInt*/[6,BigInt(value_5184),meta_5183,".MetaInt"]
						};
					};
				}
			} break;
			
			case 61: {
				if (this.offset(1) == 99) {
					const res = this.parseType();
					result = /*NodeTypeValue*/[51,res,".NodeTypeValue"];
				} else if (this.offset(1) == 81) {
					const name_5194 = this.getgo(61);
					this.i++;
					result = /*NodeTypeValue*/[51,/*Optional*/[0,/*Type*/[1,name_5194,null,".Type"],".Optional"],".NodeTypeValue"];
				} else {
					const name_5195 = this.getgo(61);
					result = /*NodeTypeValue*/[51,/*Type*/[1,name_5195,null,".Type"],".NodeTypeValue"];
				}
			} break;
			
			case 62: {
				{
					const pos_5196 = this.lex.column[this.i];
					const name_5197 = this.getgo(62);
					if (this.tok() == 90) {
						this.next();
						result = /*Arrow*/[23,this.parseExpr(),[/*Var*/[24,name_5197,null,null,true,false,".Var"]],null,".Arrow"];
					} else if ((this.tok() == 99) && (this.lex.column[this.i] == pos_5196 + name_5197.length)) {
						this.i++;
						const params = [this.parseType()];
						while (this.tok() == 75) {
							this.i++;
							params.push(this.parseType());
						};
						this.step(96);
						result = /*Ident*/[1,name_5197,params,".Ident"];
					} else {
						result = /*Ident*/[1,name_5197,null,".Ident"];
					};
				}
			} break;
			
			case 66: {
				result = /*String*/[0,this.getgo(66),".String"]
			} break;
			
			case 64: {
				{
					const str_5198 = this.getgo(64);
					if (this.hasInterpolation(str_5198)) { result = /*Parenthesis*/[15,this.parseInterpolations(str_5198),".Parenthesis"] } else {
						result = /*String*/[0,str_5198,".String"];
					};
				}
			} break;
			
			case 36: {
				{
					this.i++;
					result = /*Bool*/[2,true,".Bool"];
				}
			} break;
			
			case 14: {
				{
					this.i++;
					result = /*Bool*/[2,false,".Bool"];
				}
			} break;
			
			case 34: {
				{
					this.i++;
					result = /*This*/[3];
				}
			} break;
			
			case 26: {
				{
					this.i++;
					result = /*Null*/[8];
				}
			} break;
			
			case 59: {
				{
					this.i++;
					result = /*Super*/[4];
				}
			} break;
			
			case 40: {
				{
					const parsed_5199 = this.parseVar(false);
					if (parsed_5199.length > 1) {} else {
						result = parsed_5199[0];
					};
				}
			} break;
			
			case 23: {
				{
					const parsed_5200 = this.parseVar(false);
					if (parsed_5200.length > 1) {} else {
						result = parsed_5200[0];
					};
				}
			} break;
			
			case 37: {
				{
					this.i++;
					const exprAt = this.i;
					const expr_5201 = this.parseExpr();
					{
						const temp_5202 = expr_5201;
						switch (temp_5202&&temp_5202[0]) {
						case 12: {
							{
							}
						} break;
						
						default: 
						{
							const temp_5203 = this.i;
							this.i = exprAt;
							this.failHint('`try` body must be a `{` block `}`');
							this.i = temp_5203;
						}
						};
					};
					const vars_5204 = [];
					const t_5205 = [];
					const v_5206 = [];
					const catches = [];
					while (this.tok() == 6) {
						this.step(6);
						const name_5207 = this.getgo(62);
						vars_5204.push(name_5207);
						this.step(76);
						const type_5208 = this.parseType();
						t_5205.push(type_5208);
						v_5206.push(/*Var*/[24,name_5207,type_5208,null,true,false,".Var"]);
						const exprAt_5209 = this.i;
						const expr_5210 = this.parseExpr();
						{
							const temp_5211 = expr_5210;
							switch (temp_5211&&temp_5211[0]) {
							case 12: {
								{
								}
							} break;
							
							default: 
							{
								const temp_5212 = this.i;
								this.i = exprAt_5209;
								this.failHint('`catch` body must be a `{` block `}`');
								this.i = temp_5212;
							}
							};
						};
						catches.push(expr_5210);
					};
					if (catches.length == 0) { this.failHint('`try` must have at least one `catch` block') };
					result = /*Try*/[27,expr_5201,t_5205,v_5206,catches,".Try"];
				}
			} break;
			
			case 2: {
				{
					this.i++;
					if (this.tok() == 64) {
						result = /*Import*/[37,[],this.getgo(64),".Import"];
						this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
						return result;
					};
					const el_5213 = [];
					while (true) {
						if (this.tok() == 62) { el_5213.push(/*Lower*/[0,this.getgo(62),".Lower"]) } else if (this.tok() == 61) { el_5213.push(/*Upper*/[1,this.getgo(61),".Upper"]) } else if (this.tok() == 102) {
							this.i++;
							this.step(58);
							el_5213.push(/*As*/[3,/*AllTheThings*/[2],/*Lower*/[0,this.getgo(62),".Lower"],".As"]);
						} else {
							this.fail('Incorrect `import` syntax');
						};
						if (this.tok() == 58) {
							this.i++;
							if (this.tok() == 62) { el_5213.push(/*As*/[3,el_5213.pop(),/*Lower*/[0,this.getgo(62),".Lower"],".As"]) } else if (this.tok() == 61) { el_5213.push(/*As*/[3,el_5213.pop(),/*Upper*/[1,this.getgo(61),".Upper"],".As"]) } else {
								this.fail('Incorrect `import x as y` syntax');
							};
						};
						if (this.tok() == 75) { this.i++ } else {
							break;
						};
					};
					this.step(20);
					result = /*Import*/[37,el_5213,this.getgo(64),".Import"];
					this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
					return result;
				}
			} break;
			
			case 11: {
				{
					const att = atts_5152;
					atts_5152 = [];
					this.i++;
					const t_5214 = this.parseType();
					let valuesType = null;
					if (this.tok() == 76) {
						this.i++;
						valuesType = this.parseType();
					};
					let extend = null;
					if (this.tok() == 12) {
						this.i++;
						extend = this.parseType();
					};
					this.step(74);
					const names_5215 = [];
					while (this.tok() != 73) {
						while (this.tok() == 70) {
							atts_5152.push(this.parseDecorator());
						};
						atts_5152 = [];
						names_5215.push(this.parseExpr());
					};
					this.step(73);
					result = /*Enum*/[39,t_5214,names_5215,valuesType,extend,".Enum"];
					this.project.mapDecorators.set(result, att);
				}
			} break;
			
			case 7: case 22: {
				{
					const att_5216 = atts_5152;
					atts_5152 = [];
					const me = this.parseClass(false);
					this.project.mapDecorators.set(me, att_5216);
					result = me;
				}
			} break;
			
			case 21: {
				result = this.parseFunction(true, false)
			} break;
			
			case 72: {
				{
					this.i++;
					const el_5217 = [];
					const values_5218 = [];
					let isMap = false;
					if (this.tok() != 71) { while (true) {
						if (this.tok() == 76) {
							isMap = true;
							this.next();
							break;
						};
						el_5217.push(this.parseExpr());
						if (this.tok() == 76) {
							this.i++;
							values_5218.push(this.parseExpr());
							isMap = true;
						};
						if (this.tok() == 75) {
							this.i++;
							if (this.tok() == 71) { this.fail('Unexpected `]`, remove trailing comma `,` before `]` or add a value after `,` if required') };
						} else {
							break;
						};
					} };
					this.step(71);
					if (isMap) { result = /*Map*/[32,el_5217,values_5218,".Map"] } else {
						result = /*Array*/[31,el_5217,".Array"];
					};
				}
			} break;
			
			case 25: {
				{
					this.i++;
					const t_5219 = this.parseType();
					const names_5220 = [];
					const values_5221 = [];
					if (this.tok() == 74) {
						this.i++;
						if (this.tok() == 73) { this.step(73) } else if (this.tok() == 62 && this.offset(1) == 76) {
							while (this.tok() != 73) {
								names_5220.push(this.getgo(62));
								this.step(76);
								values_5221.push(this.parseExpr());
								if (this.tok() == 75) { this.i++ };
							};
							this.step(73);
						};
					};
					this.step(80);
					const args = [];
					const argNames = [];
					if (this.tok() != 79) { while (true) {
						{
							const temp_5222 = this.tok();
							switch (temp_5222) {
							case 79: {
								this.fail('Unexpected `)`, remove trailing `,` comma')
							} break;
							
							case 61: {
								{
									argNames.push(null);
									args.push(this.parseExpr());
									if (this.tok() == 76) {
										this.step(76);
										this.parseType();
									};
								}
							} break;
							
							default: 
							{
								if (this.offset(1) == 76) {
									argNames.push(this.getgo(62));
									this.step(76);
								} else {
									argNames.push(null);
								};
								args.push(this.parseExpr());
							}
							};
						};
						if (this.tok() == 75) { this.i++ } else {
							break;
						};
					} };
					this.step(79);
					result = /*New*/[30,[],t_5219,args,names_5220,values_5221,argNames,".New"];
				}
			} break;
			
			case 33: {
				{
					this.i++;
					const exprs = [this.parseExpr()];
					while (this.tok() == 75) {
						this.i++;
						exprs.push(this.parseExpr());
					};
					this.step(74);
					const cases = [];
					const conds = [];
					const guards = [];
					while (this.tok() != 73) {
						this.step(4);
						if (this.tok() == 1) {
							conds.push(/*Underscore*/[45]);
							this.i++;
						} else {
							conds.push(this.parseExpr());
						};
						if (this.tok() == 17) {
							this.i++;
							guards.push(this.parseExpr());
						} else {
							guards.push(null);
						};
						this.step(76);
						const exs = [];
						while (this.tok() != 4 && this.tok() != 73) {
							exs.push(this.parseExpr());
						};
						cases.push(/*Block*/[12,exs,".Block"]);
					};
					this.step(73);
					result = /*Switch*/[34,exprs,conds,guards,cases,".Switch"];
				}
			} break;
			
			case 15: {
				{
					this.i++;
					if (this.tok() == 23 || this.tok() == 40) {
						this.i++;
						const name_5223 = this.getgo(62);
						if (this.print() == 'of' || this.print() == 'in') {
							this.i++;
							let values_5224 = this.print();
							this.i++;
							while (this.tok() != 79 && this.tok() != 0) {
								if (this.tok() == 107 || this.tok() == 111) { values_5224 += ' ' + this.print() + ' ' } else {
									values_5224 += this.print();
								};
								this.i++;
							};
							this.fail(('This loop should be replaced to `for ' + (name_5223) + ' in ' + (values_5224) + '`'));
						};
						let classic = true;
						if (this.tok() == 91) { this.i++ } else {
							classic = false;
						};
						let specialCase = '';
						if ((this.tok() == 63) && (this.lex.value[this.i] == '0')) { this.i++ } else {
							while (this.tok() == 62 || this.tok() == 61 || this.tok() == 80 || this.tok() == 79 || this.tok() == 111 || this.tok() == 107 || this.tok() == 63 || this.tok() == 102 || this.tok() == 77) {
								if (this.tok() == 107 || this.tok() == 111) { specialCase += ' ' + this.print() + ' ' } else {
									specialCase += this.print();
								};
								this.i++;
							};
						};
						if (this.tok() == 82) { this.i++ } else {
							classic = false;
						};
						if ((this.tok() == 62) && (this.lex.value[this.i] == name_5223)) { this.i++ } else {
							classic = false;
						};
						let lesserOrEqual = false;
						if (this.tok() == 99) { this.i++ } else if (this.tok() == 100) {
							this.i++;
							lesserOrEqual = true;
						} else {
							classic = false;
						};
						let values_5225 = this.print();
						this.i++;
						while (this.tok() == 62 || this.tok() == 61 || this.tok() == 80 || this.tok() == 79 || this.tok() == 111 || this.tok() == 107 || this.tok() == 63 || this.tok() == 102 || this.tok() == 77) {
							if (this.tok() == 107 || this.tok() == 111) { values_5225 += ' ' + this.print() + ' ' } else {
								values_5225 += this.print();
							};
							this.i++;
						};
						if (lesserOrEqual) { values_5225 += ' + 1' };
						if (this.tok() == 82) { this.i++ } else {
							classic = false;
						};
						if ((this.tok() == 62) && (this.lex.value[this.i] == name_5223)) {
							this.i++;
							if (this.tok() == 87) { this.i++ } else {
								classic = false;
							};
						} else if (this.tok() == 87) {
							this.i++;
							if ((this.tok() == 62) && (this.lex.value[this.i] == name_5223)) { this.i++ } else {
								classic = false;
							};
						} else {
							classic = false;
						};
						if (this.tok() == 79) {} else {
							classic = false;
						};
						if ((classic) && (specialCase == '')) { this.fail(('This loop should be replaced to `for ' + (name_5223) + ' in ' + (values_5225) + '`')) };
						if (classic) { this.fail(('This loop should be replaced to `for ' + (name_5223) + ' in ' + (specialCase) + ' ... ' + (values_5225) + '`')) };
						this.fail(('Hexa has only `for ' + (name_5223) + ' in values` syntax'));
					};
					const name_5226 = this.getgo(62);
					this.step(20);
					const values_5227 = this.parseExpr();
					let range = null;
					if (this.tok() == 98) {
						this.i++;
						range = this.parseExpr();
					};
					const expression = this.parseExpr();
					result = /*For*/[49,name_5226,values_5227,expression,range,".For"];
				}
			} break;
			
			case 32: {
				{
					this.next();
					result = /*Static*/[47,this.parseExpr(),".Static"];
				}
			} break;
			
			case 29: {
				{
					this.next();
					result = /*Private*/[48,this.parseExpr(),".Private"];
				}
			} break;
			
			default: 
			this.unexpected()
			};
		};
		if (result == null) {
			process_3459.stdout.write('\n');
			this.fail('Expression is incomplete, current token is: ' + Token.stringify(this.tok()));
		};
		this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
		if (atts_5152.length > 0) {
			this.project.mapDecorators.set(result, atts_5152);
			atts_5152 = [];
		};
		let done = this.i >= this.lex.length;
		while ((!done)) {
			this.project.data.set(result, new NodeData(this.lex.line[this.i], this.lex.column[this.i], this.lex.fileName));
			{
				const temp_5228 = this.tok();
				switch (temp_5228) {
				case 0: {
					done = true
				} break;
				
				case 72: {
					{
						this.i++;
						const index = this.parseExpr();
						if (this.tok() == 75) { this.fail('Expected `]` instead of `,` comma. Hexa supports only one `[index]` value.\n' + ('Note, you are indexing this expression: `' + (Node.stringify(result)) + '[' + (Node.stringify(index)) + ']`\n') + ('To create array here, wrap it with `{` as `{[' + (Node.stringify(index)) + ', ...]}` so it doesn\'t index previous expression.')) };
						this.step(71);
						result = /*Index*/[33,result,index,".Index"];
					}
				} break;
				
				case 57: {
					{
						this.i++;
						{
							const temp_5229 = this.tok();
							switch (temp_5229) {
							case 61: {
								result = /*Is*/[43,result,this.parseType(),".Is"]
							} break;
							
							default: 
							this.fail('Cannot parse type `' + Token.stringify(this.tok()) + '`')
							};
						};
					}
				} break;
				
				case 58: {
					{
						this.i++;
						let kind_5230 = this.tok();
						if (this.tok() == 89) { this.i++ } else if (this.tok() == 81) { this.i++ } else {
							kind_5230 = 123;
						};
						result = /*As*/[44,result,kind_5230,this.parseType(),".As"];
					}
				} break;
				
				case 80: {
					{
						const args_5231 = [];
						const argNames_5232 = [];
						this.i++;
						if (this.tok() != 79) { while (true) {
							{
								const temp_5233 = this.tok();
								switch (temp_5233) {
								case 79: {
									this.fail('Unexpected `)`, remove trailing `,` comma')
								} break;
								
								case 61: {
									{
										argNames_5232.push(null);
										args_5231.push(this.parseExpr());
										if (this.tok() == 76) {
											this.step(76);
											this.parseType();
										};
									}
								} break;
								
								default: 
								{
									if ((this.tok() == 62) && (this.offset(1) == 76)) {
										argNames_5232.push(this.getgo(62));
										this.step(76);
									} else {
										argNames_5232.push(null);
									};
									args_5231.push(this.parseExpr());
								}
								};
							};
							if (this.tok() == 75) { this.i++ } else {
								break;
							};
						} };
						this.step(79);
						result = /*Call*/[13,result,args_5231,argNames_5232,".Call"];
					}
				} break;
				
				case 90: {
					{
						this.next();
						result = /*Arrow*/[23,this.parseExpr(),[result],null,".Arrow"];
					}
				} break;
				
				case 87: {
					{
						{
							const temp_5234 = result;
							switch (temp_5234&&temp_5234[0]) {
							case 20: {
								return result
							} break;
							};
						};
						this.i++;
						result = /*Unop*/[20,87,true,result,".Unop"];
					}
				} break;
				
				case 86: {
					{
						{
							const temp_5235 = result;
							switch (temp_5235&&temp_5235[0]) {
							case 20: {
								return result
							} break;
							};
						};
						this.i++;
						result = /*Unop*/[20,86,true,result,".Unop"];
					}
				} break;
				
				case 77: {
					{
						this.i++;
						{
							const temp_5236 = this.tok();
							switch (temp_5236) {
							case 61: {
								result = /*DotUpper*/[29,result,this.getgo(61),".DotUpper"]
							} break;
							
							default: 
							result = /*Dot*/[28,result,this.getgo(62),".Dot"]
							};
						};
					}
				} break;
				
				case 81: {
					{
						this.i++;
						if (this.tok() == 77) {
							const name_5237 = this.getgo(62);
							result = /*Dot*/[28,result,name_5237,".Dot"];
						} else if (this.tok() == 81) {
							this.i++;
							result = /*Elvis*/[50,result,this.parseExpr(),".Elvis"];
						} else {
							const eif_5238 = this.parseExpr();
							this.step(76);
							const eelse_5239 = this.parseExpr();
							result = /*If*/[14,[result],eif_5238,eelse_5239,true,".If"];
						};
					}
				} break;
				
				case 113: {
					{
						this.i++;
						result = this.parseExpr();
					}
				} break;
				
				default: 
				{
					const failAt = this.i;
					const t_5240 = this.tok();
					if (Parser.isBinop(t_5240) && this.offset(1) == 91) {
						const op_5241 = this.tok();
						this.i++;
						this.i++;
						const b = this.parseExpr();
						{
							const temp_5242 = result;
							switch (temp_5242&&temp_5242[0]) {
							case 1: {
								{
								}
							} break;
							
							case 28: {
								{
								}
							} break;
							
							case 33: {
								{
								}
							} break;
							
							default: 
							{
								const temp_5243 = this.i;
								this.i = failAt;
								this.failHint(('Cannot reassign `=` expression `' + (Node.stringify(result)) + '`'));
								this.i = temp_5243;
							}
							};
						};
						result = /*AssignOp*/[11,result,op_5241,b,".AssignOp"];
					} else if (Parser.isBinop(t_5240)) {
						this.i++;
						const b_5244 = this.parseExpr();
						const a = result;
						{
							const temp_5245 = b_5244;
							switch (temp_5245&&temp_5245[0]) {
							case 10: {
								const aa_5246 = temp_5245[1];
								const op_5247 = temp_5245[2];
								const bb_5248 = temp_5245[3];
								{
									let tp = Parser.precedence(t_5240);
									const tLeft = tp > 99;
									tp = tp % 100;
									let bp = Parser.precedence(op_5247);
									const bLeft = bp > 99;
									bp = bp % 100;
									if (bp > tp) {
										const eb = /*Binop*/[10,result,t_5240,aa_5246,".Binop"];
										this.project.data.set(eb, (() => {
											const result_5249 = this.project.data.get(result);
											if (result_5249 != null) { return result_5249 };
											return (() => {
												const result_5250 = this.project.data.get(b_5244);
												if (result_5250 != null) { return result_5250 };
												return this.project.data.get(aa_5246);
											})();
										})());
										result = /*Binop*/[10,eb,op_5247,bb_5248,".Binop"];
									} else {
										result = /*Binop*/[10,result,t_5240,b_5244,".Binop"];
									};
								}
							} break;
							
							case 14: {
								const econd_5251 = temp_5245[1];
								const eif_5252 = temp_5245[2];
								const eelse_5253 = temp_5245[3];
								const ternary = temp_5245[4];
								if (ternary == true && t_5240 != 91) { result = /*If*/[14,[/*Binop*/[10,result,t_5240,econd_5251[0],".Binop"]],eif_5252,eelse_5253,true,".If"] } else {
									result = /*Binop*/[10,result,t_5240,b_5244,".Binop"];
								}
							} break;
							
							default: 
							result = /*Binop*/[10,result,t_5240,b_5244,".Binop"]
							};
						};
					} else {
						done = true;
					};
				}
				};
			};
		};
		if (result == null) {
			process_3459.stdout.write('\n');
			this.fail('Expression postfix is incomplete');
		};
		if (atts_5152.length > 0) {
			this.project.mapDecorators.set(result, atts_5152);
			atts_5152 = [];
		};
		this.project.data.set(result, new NodeData(nodePosition.line, nodePosition.column, this.lex.fileName));
		return result;
	};
		parseBlock() {
		this.step(74);
		if (this.tok() == 73) {
			this.i++;
			return /*Block*/[12,[],".Block"];
		} else if (this.tok() == 62 && this.offset(1) == 76) {
			const names_5254 = [];
			const el_5255 = [];
			while (true) {
				names_5254.push(this.getgo(62));
				this.step(76);
				el_5255.push(this.parseExpr());
				if (this.tok() == 75) {
					this.i++;
					if (this.tok() == 73) { this.fail('Unexpected `}`, remove trailing `,` comma') };
					continue;
				} else {
					break;
				};
			};
			if (this.tok() != 73) { this.fail(('Expected `}` or `,` before `' + (this.print()) + '`')) };
			this.step(73);
			return /*Object*/[38,names_5254,el_5255,".Object"];
		} else {
			const el_5256 = [];
			while (this.tok() != 73) {
				el_5256.push(this.parseExpr());
			};
			this.step(73);
			return /*Block*/[12,el_5256,".Block"];
		};
		return /*Block*/[12,[],".Block"];
	};
		parseVar(external) {
		const const_5257 = this.tok() == 23;
		this.i++;
		const vars_5258 = [];
		if (this.tok() == 83) {
			this.i++;
			const name_5259 = (((this.tok() == 62))? (this.print()) : 'name');
			const prefix = ((const_5257)? ('let') : 'var');
			this.fail(('Hexa doesn\'t support PHP-style variables, replace it to `' + (prefix) + ' ' + (name_5259) + '`'));
		};
		const parseSingleVar = () => {
			const varname = this.getgo(62);
			if (varname.endsWith('___')) { this.fail('Variables can\'t end with `___`, it is reserved.') };
			let type_5260 = null;
			if (this.tok() == 76) {
				this.i++;
				type_5260 = this.parseType();
			};
			let expr_5261 = null;
			if (this.tok() == 91) {
				this.i++;
				expr_5261 = this.parseExpr();
			};
			return /*Var*/[24,varname,type_5260,expr_5261,const_5257,(() => {
				const result_5262 = external;
				if (result_5262 != null) { return result_5262 };
				return false;
			})(),".Var"];
		};
		const parseSingleBinding = () => {
			const path = [];
			while (this.tok() == 62 && this.offset(1) == 77) {
				path.push(this.getgo(62));
				this.i++;
			};
			path.push(this.getgo(61));
			this.step(77);
			path.push(this.getgo(61));
			if (this.tok() == 80 && this.offset(1) == 79) { this.fail('Don\'t use empty parenthesis for `let ' + path.join('.') + '()` bindings') };
			const bind = [];
			if (this.tok() == 80) {
				do {{
					this.i++;
					if (this.tok() == 1) {
						this.i++;
						bind.push(null);
					} else {
						bind.push(/*Var*/[24,this.getgo(62),null,null,const_5257,false,".Var"]);
					};
				}} while (this.tok() == 75);
				this.step(79);
			};
			this.step(91);
			const expr_5263 = this.parseExpr();
			return /*EnumExtract*/[40,path,bind,expr_5263,".EnumExtract"];
		};
		vars_5258.push(parseSingleVar());
		return vars_5258;
	};
		parseFunction(parseBody, external_5274) {
		const parseBody_5275 = (((parseBody != null))? (parseBody) : true);
		this.i++;
		let expr_5276 = null;
		let name_5277 = null;
		const vars_5278 = [];
		const atts_5279 = [];
		const types_5280 = [];
		const values_5281 = [];
		const pos_5282 = [];
		const params_5283 = null;
		let params_5284 = null;
		{
			const temp_5285 = this.tok();
			switch (temp_5285) {
			case 62: {
				{
					name_5277 = this.getgo(62);
					if (this.tok() == 99) {
						this.i++;
						const param = [this.parseType()];
						while (this.tok() == 75) {
							this.i++;
							param.push(this.parseType());
						};
						this.step(96);
						params_5284 = param;
					};
				}
			} break;
			
			case 61: {
				this.fail(('Function names can\'t start with uppercase `' + (this.print()) + '` -> `' + (Hint.toCamelCase(this.print())) + '`'))
			} break;
			
			default: 
			{
			}
			};
		};
		if ((name_5277 == null) && (external_5274)) { this.fail('Unnamed functions cannot be marked as `declare fun`') };
		this.step(80);
		{
			if (this.tok() != 79) { while (true) {
				const decorators = [];
				while (this.tok() == 70) {
					decorators.push(this.parseDecorator());
				};
				let expr_5286 = null;
				let t_5287 = null;
				if (this.tok() == 98) { this.i++ };
				pos_5282.push({line:this.lex.line[this.i], column:this.lex.column[this.i]});
				const name_5288 = this.getgo(62);
				if (this.tok() == 76) {
					this.i++;
					t_5287 = this.parseType();
				};
				if (this.tok() == 91) {
					this.i++;
					expr_5286 = this.parseExpr();
				};
				vars_5278.push(name_5288);
				atts_5279.push(decorators);
				types_5280.push(t_5287);
				values_5281.push(expr_5286);
				if (this.tok() == 75) { this.i++ } else {
					break;
				};
			} };
			this.step(79);
		};
		let rettype = null;
		if (this.tok() == 76) {
			this.i++;
			rettype = this.parseType();
		};
		if (parseBody_5275) {
			const temp_5289 = this.tok();
			switch (temp_5289) {
			case 25: {
				if (this.offset(1) == 80) {} else {
					expr_5276 = this.parseExpr();
				}
			} break;
			
			case 73: {
				{
				}
			} break;
			
			case 32: {
				{
				}
			} break;
			
			case 29: {
				{
				}
			} break;
			
			case 21: {
				{
				}
			} break;
			
			case 40: {
				{
				}
			} break;
			
			case 23: {
				{
				}
			} break;
			
			case 70: {
				{
					const tmp_5290 = this.i;
					while (this.tok() == 70) {
						this.parseDecorator();
					};
					if (this.tok() != 73 && this.tok() != 32 && this.tok() != 29 && this.tok() != 21) {
						this.i = tmp_5290;
						expr_5276 = this.parseExpr();
					} else {
						this.i = tmp_5290;
					};
				}
			} break;
			
			case 0: {
				{
					let step_5291 = 0;
					const name_5292 = name_5277;
					if (step_5291 == 0 && name_5292 != null) { step_5291 = 1 };
					if (step_5291 == 1) { this.fail(('Function `fun ' + (name_5292) + '` should have a `{ block }` as a body or must be marked as `declare fun ' + (name_5292) + '`')) } else {
						this.fail('Unnamed functions should have a `{ block }` as a body');
					};
				}
			} break;
			
			default: 
			expr_5276 = this.parseBlock()
			};
		};
		const v_5293 = [];
		{
			let i_5294 = 0;
			let it_5295 = 0;
			let at_5296 = vars_5278.length;
			while (it_5295 < at_5296) {
				i_5294 = it_5295;
				it_5295++;
				{
					const n_5297 = /*Var*/[24,vars_5278[i_5294],types_5280[i_5294],values_5281[i_5294],true,false,".Var"];
					this.project.data.set(n_5297, new NodeData(pos_5282[i_5294].line, pos_5282[i_5294].column, this.lex.fileName));
					{
						let step_5298 = 0;
						const decorators_5299 = atts_5279[i_5294];
						if (step_5298 == 0 && decorators_5299 != null) { step_5298 = 1 };
						if (step_5298 == 1) { this.project.mapDecorators.set(n_5297, decorators_5299) };
					};
					v_5293.push(n_5297);
				};
			};
		};
		{
			const temp_5300 = expr_5276;
			switch (temp_5300&&temp_5300[0]) {
			case null: case undefined: {
				{
				}
			} break;
			
			case 12: {
				{
				}
			} break;
			
			default: 
			{
				const named = (() => {
					const result_5301 = name_5277;
					if (result_5301 != null) { return result_5301 };
					return 'fun';
				})();
				this.i--;
				this.fail(('Function `' + (named) + '` should have a `{ block }` as a body'));
			}
			};
		};
		const result_5302 = /*Function*/[22,name_5277,expr_5276,v_5293,rettype,external_5274,".Function"];
		{
			let step_5303 = 0;
			const params_5304 = params_5284;
			if (step_5303 == 0 && params_5304 != null) { step_5303 = 1 };
			if (step_5303 == 1) { this.project.mapFuncParams.set(result_5302, params_5304) };
		};
		return result_5302;
	};
		backtickOr(prefix_5305, value_5306, placeholder) {
		{
			let step_5307 = 0;
			const value_5308 = value_5306;
			if (step_5307 == 0 && value_5308 != null) { step_5307 = 1 };
			if (step_5307 == 1) { return prefix_5305 + '`' + value_5308 + '`' };
		};
		return placeholder;
	};
		parseClass(external_5309) {
		const _classExternal = this.classExternal;
		this.classExternal = external_5309;
		const isInterface = ((this.tok() == 22)? (1) : 0);
		this.i++;
		const t_5310 = this.parseType();
		{
			const temp_5311 = t_5310;
			switch (temp_5311&&temp_5311[0]) {
			case 1: {
				{
				}
			} break;
			
			case 2: {
				{
				}
			} break;
			
			case 6: {
				const name_5312 = temp_5311[1];
				{
					if (name_5312.startsWith('_')) { this.fail('Class name cannot start with `_` underscore') };
					this.fail(('Class name cannot start with lowercase and should be formatted as `class ' + (Hint.toTitleCase(name_5312)) + '`'));
				}
			} break;
			
			default: 
			this.fail('Class name should be formatted as `class TitleCase`')
			};
		};
		const ext = (((this.tok() == 12))? ((() => {
			this.i++;
			return this.parseType();
		})()) : (null));
		const impl = [];
		while (this.tok() == 18) {
			this.i++;
			impl.push(this.parseType());
		};
		this.step(74);
		const fields_5313 = this.parseFields();
		this.step(73);
		const me_5314 = /*Class*/[25,t_5310,ext,impl,fields_5313,(() => {
			const result_5315 = external_5309;
			if (result_5315 != null) { return result_5315 };
			return false;
		})(),isInterface,".Class"];
		this.classExternal = _classExternal;
		return me_5314;
	};
		hasInterpolation(str_5316) {
		const chars = str_5316.split('');
		let i_5317 = 0;
		while (i_5317 < chars.length) {
			if (chars[i_5317] == '\\') { if (i_5317 + 1 < chars.length) { if (chars[i_5317 + 1] == '\\') { i_5317++ } else if (chars[i_5317 + 1] == '(') { return true } } };
			i_5317++;
		};
		return false;
	};
		parseInterpolations(str_5318) {
		const interpolate = (s) => {
			const out_5319 = ['"'];
			if (s.length < 2) { return s };
			let i_5320 = 0;
			const s_5321 = s.split('"').join('\\"');
			const pushInterpolator = () => {
				i_5320++;
				i_5320++;
				const pushParen = () => {
					i_5320++;
					while (i_5320 < s_5321.length) {
						out_5319.push(s_5321.charAt(i_5320));
						if (s_5321.charAt(i_5320) == '(') {
							pushParen();
							continue;
						};
						if (s_5321.charAt(i_5320) == ')') {
							i_5320++;
							return;
						};
						i_5320++;
					};
					throw 'String interpolation error: unclosed inner parenthesis';
				};
				while (i_5320 < s_5321.length) {
					out_5319.push(s_5321.charAt(i_5320));
					if (s_5321.charAt(i_5320) == '(') {
						pushParen();
						continue;
					};
					if (s_5321.charAt(i_5320) == ')') {
						i_5320++;
						return;
					};
					i_5320++;
				};
				throw 'String interpolation error: unclosed parenthesis';
			};
			const result_5322 = ['"'];
			while (i_5320 < s_5321.length) {
				if (s_5321.charAt(i_5320) == '\\' && s_5321.charAt(i_5320 + 1) == '(') {
					result_5322.push('" + ');
					out_5319.push('" + (');
					const ii = i_5320 + 1;
					pushInterpolator();
					result_5322.push(s_5321.substring(ii, i_5320 + 1));
					result_5322.push(' + "');
					out_5319.push(' + "');
				} else {
					out_5319.push(s_5321.charAt(i_5320));
					result_5322.push(s_5321.charAt(i_5320));
					i_5320++;
				};
			};
			result_5322.push('"');
			out_5319.push('"');
			return out_5319.join('');
		};
		const resStr = interpolate(str_5318);
		const tokens = Lexer.tokenize(Buffer.from(resStr), this.lex.fileName);
		try {
			const parsed_5324 = Parser.toNode(Parser.parseNodes(tokens, this.project));
			{
				const temp_5325 = parsed_5324;
				switch (temp_5325&&temp_5325[0]) {
				case 12: {
					throw 'String interpolation error: got a block'
				} break;
				
				default: 
				return parsed_5324
				};
			};
		} catch (temp_5323) {
			if (true) { 
			const e = temp_5323
			{
				this.fail('String interpolation error\n' + e);
			} } else
			
			throw temp_5323;
		};
	};
		parseDecorator() {
		this.i++;
		const name_5326 = this.getgo(62);
		const values_5327 = [];
		if (this.tok() == 80) {
			this.i++;
			if (this.tok() != 79) { while (true) {
				values_5327.push(this.parseExpr());
				if (this.tok() == 75) { this.i++ } else {
					break;
				};
			} };
			this.step(79);
		};
		return new Decorator(name_5326, values_5327);
	};
		parseType() {
		if (this.tok() == 70) {
			const decorators_5328 = [];
			while (this.tok() == 70) {
				decorators_5328.push(this.parseDecorator());
			};
			const type_5329 = this.parseUndecoratedType();
			this.project.typeDecorators.set(type_5329, decorators_5328);
			return type_5329;
		};
		return this.parseUndecoratedType();
	};
		parseUndecoratedType() {
		if (this.tok() == 62) { return /*Ident*/[6,this.getgo(62),".Ident"] };
		if (this.tok() == 63) { return /*Int*/[7,parseInt(this.getgo(63)),".Int"] };
		if (this.tok() == 60) { return /*Float*/[8,parseFloat(this.getgo(60)),".Float"] };
		if (this.tok() == 64) { return /*String*/[9,this.getgo(64),".String"] };
		if (this.tok() == 62 && this.offset(1) == 80) {
			const name_5330 = this.getgo(62);
			this.i++;
			const argNames_5331 = [];
			const values_5332 = [];
			while (this.tok() != 79) {
				if (this.tok() == 62) {
					argNames_5331.push(this.getgo(62));
					this.step(76);
				} else {
					argNames_5331.push(null);
				};
				values_5332.push(this.parseType());
				if (this.tok() == 79) { break } else {
					this.step(75);
				};
			};
			this.step(79);
			return /*Call*/[10,name_5330,argNames_5331,values_5332,".Call"];
		};
		const path_5333 = (((this.tok() == 62 && this.offset(1) == 77))? ((() => {
			const result_5334 = this.getgo(62);
			this.i++;
			return result_5334;
		})()) : null);
		let result_5335 = null;
		{
			const temp_5336 = this.tok();
			switch (temp_5336) {
			case 61: {
				{
					const name_5337 = this.getgo(61);
					while (this.tok() == 77) {
						this.i++;
						this.getgo(61);
					};
					let sresult = ((this.tok() == 99)? ((() => {
						this.i++;
						this.parametricTypeNesting++;
						let params_5338 = [this.parseType()];
						while (this.tok() == 75) {
							this.i++;
							params_5338.push(this.parseType());
						};
						if (this.parametricTypeNestingToken == 0) { this.parametricTypeNestingToken = this.tok() };
						{
							const temp_5339 = this.parametricTypeNestingToken;
							switch (temp_5339) {
							case 96: {
								{
									this.parametricTypeNesting -= 1;
									this.parametricTypeNestingToken = 0;
									this.i++;
								}
							} break;
							
							case 106: {
								{
									this.parametricTypeNesting -= 1;
									this.parametricTypeNestingToken = 96;
								}
							} break;
							
							case 108: {
								{
									this.parametricTypeNesting -= 1;
									this.parametricTypeNestingToken = 108;
								}
							} break;
							
							default: 
							this.unexpected()
							};
						};
						if (this.parametricTypeNesting < 0) { this.fail('parametricTypeNesting < 0') };
						return /*ParametricType*/[2,name_5337,params_5338,path_5333,".ParametricType"];
					})()) : /*Type*/[1,name_5337,path_5333,".Type"]);
					if (this.tok() == 90) {
						this.i++;
						sresult = /*Function*/[3,[sresult],this.parseType(),".Function"];
					};
					result_5335 = sresult;
				}
			} break;
			
			case 72: {
				{
					if (path_5333 != null) { this.fail('This path syntax is incorrect') };
					this.i++;
					let res_5340 = null;
					{
						const temp_5341 = this.tok();
						switch (temp_5341) {
						case 71: {
							{
								this.i++;
								res_5340 = /*ParametricType*/[2,'Array',[/*Object*/[5,[],[],".Object"]],path_5333,".ParametricType"];
							}
						} break;
						
						case 76: {
							{
								this.i++;
								if (this.tok() == 71) {
									this.i++;
									res_5340 = /*ParametricType*/[2,'Map',[/*Object*/[5,[],[],".Object"], /*Object*/[5,[],[],".Object"]],path_5333,".ParametricType"];
								} else {
									res_5340 = /*ParametricType*/[2,'Map',[/*Object*/[5,[],[],".Object"], this.parseType()],path_5333,".ParametricType"];
								};
							}
						} break;
						
						default: 
						{
							const key = this.parseType();
							let innerRes = (((this.tok() == 76))? ((() => {
								this.i++;
								return /*ParametricType*/[2,'Map',[key, this.parseType()],path_5333,".ParametricType"];
							})()) : /*ParametricType*/[2,'Array',[key],path_5333,".ParametricType"]);
							this.step(71);
							if (this.tok() == 90) {
								this.i++;
								innerRes = /*Function*/[3,[res_5340],this.parseType(),".Function"];
							};
							res_5340 = innerRes;
						}
						};
					};
					result_5335 = res_5340;
				}
			} break;
			
			case 74: {
				{
					if (path_5333 != null) { this.fail('This path syntax is incorrect') };
					this.i++;
					let sresult_5342 = (((this.tok() == 73))? (/*Object*/[5,[],[],".Object"]) : (() => {
						let names_5343 = [];
						let types_5344 = [];
						while (this.tok() != 73) {
							names_5343.push(this.getgo(62));
							if (this.tok() == 76) {
								this.i++;
								types_5344.push(this.parseType());
							};
							if (this.tok() == 75) { this.i++ };
						};
						return /*Object*/[5,names_5343,types_5344,".Object"];
					})());
					this.step(73);
					if (this.tok() == 90) {
						this.i++;
						sresult_5342 = /*Function*/[3,[sresult_5342],this.parseType(),".Function"];
					};
					result_5335 = sresult_5342;
				}
			} break;
			
			case 80: {
				{
					if (path_5333 != null) { this.fail('This path syntax is incorrect') };
					this.i++;
					const args_5345 = [];
					while (this.tok() != 79) {
						if (this.tok() == 62) {
							this.step(62);
							this.step(76);
						};
						args_5345.push(this.parseType());
						if (this.tok() == 75) { this.i++ };
					};
					this.step(79);
					this.step(90);
					result_5335 = /*Function*/[3,args_5345,this.parseType(),".Function"];
				}
			} break;
			
			case 62: {
				{
					let res_5346 = null;
					{
						const temp_5347 = this.offset(1);
						switch (temp_5347) {
						case 76: {
							{
								const argName = this.getgo(this.tok());
								this.step(76);
								const argType = this.parseType();
								res_5346 = /*FunctionArg*/[4,argName,argType,null,".FunctionArg"];
							}
						} break;
						
						default: 
						this.fail(('Type name `' + (this.print()) + '` can not start with lowercase'))
						};
					};
					result_5335 = res_5346;
				}
			} break;
			
			default: 
			this.fail('Expected type, parsed `' + Token.stringify(this.tok()) + '`')
			};
		};
		if (this.tok() == 81) { result_5335 = /*Optional*/[0,result_5335,".Optional"] };
		while (this.tok() == 81) {
			this.i++;
		};
		if (this.tok() == 90) {
			this.i++;
			result_5335 = /*Function*/[3,[result_5335],this.parseType(),".Function"];
		};
		return result_5335;
	};
	}
	Parser.toNode = (nodes) => {
		if (nodes.length == 0) { return null };
		if (nodes.length > 1) { return /*Block*/[12,nodes,".Block"] };
		return nodes[0];
	};
	Parser.parseNodes = (lexe, project, lint = false) => {
		const parser = new Parser(lexe, project, lint);
		if (parser.hints.length > 0) { throw new CompilerErrors(parser.hints) };
		return parser.nodes;
	};
	Parser.precedence = (op_5348) => {
		const left_5349 = 100;
		const right = 0;
		{
			const temp_5350 = op_5348;
			switch (temp_5350) {
			case 101: {
				return 100
			} break;
			
			case 102: {
				return 101
			} break;
			
			case 94: {
				return 101
			} break;
			
			case 110: {
				return 101
			} break;
			
			case 111: {
				return 102
			} break;
			
			case 107: {
				return 102
			} break;
			
			case 105: {
				return 103
			} break;
			
			case 106: {
				return 103
			} break;
			
			case 108: {
				return 103
			} break;
			
			case 104: {
				return 104
			} break;
			
			case 112: {
				return 104
			} break;
			
			case 109: {
				return 104
			} break;
			
			case 95: {
				return 105
			} break;
			
			case 103: {
				return 105
			} break;
			
			case 96: {
				return 105
			} break;
			
			case 99: {
				return 105
			} break;
			
			case 97: {
				return 105
			} break;
			
			case 100: {
				return 105
			} break;
			
			case 92: {
				return 107
			} break;
			
			case 93: {
				return 108
			} break;
			
			case 91: {
				return 10
			} break;
			
			default: 
			this.fail('No precedence for ' + Token.stringify(op_5348))
			};
		};
	};
	Parser.isBinop = (t_5351) => {
		const temp_5352 = t_5351;
		switch (temp_5352) {
		case 111: {
			return true
		} break;
		
		case 102: {
			return true
		} break;
		
		case 94: {
			return true
		} break;
		
		case 110: {
			return true
		} break;
		
		case 107: {
			return true
		} break;
		
		case 91: {
			return true
		} break;
		
		case 95: {
			return true
		} break;
		
		case 103: {
			return true
		} break;
		
		case 96: {
			return true
		} break;
		
		case 97: {
			return true
		} break;
		
		case 99: {
			return true
		} break;
		
		case 100: {
			return true
		} break;
		
		case 112: {
			return true
		} break;
		
		case 104: {
			return true
		} break;
		
		case 109: {
			return true
		} break;
		
		case 92: {
			return true
		} break;
		
		case 93: {
			return true
		} break;
		
		case 105: {
			return true
		} break;
		
		case 106: {
			return true
		} break;
		
		case 108: {
			return true
		} break;
		
		case 101: {
			return true
		} break;
		
		default: 
		return false
		};
	};
	var TestParser = class {
	}
	TestParser.passed = 0
	TestParser.overall = 0
	TestParser.test = () => {
		console.log('TestParser begin');
		TestParser.shouldAllEqual(new Map([['', '<!--null-->'], ['  ', '<!--null-->'], ['	', '<!--null-->'], ['   	', '<!--null-->'], ['\n', '<!--null-->'], ['\n\n', '<!--null-->'], ['\r\r\n\r\n\r\t', '<!--null-->'], ['{}', 'Block([])'], ['{{}}', 'Block([Block([])])'], ['{ 0 0 0 }', 'Block([Int(0),Int(0),Int(0)])'], ['0', 'Int(0)'], [' 0 ', 'Int(0)'], ['123', 'Int(123)'], ['12', 'Int(12)'], ['0x1', 'Int(1)'], ['0x0', 'Int(0)'], ['0xF', 'Int(15)'], ['0xFA', 'Int(250)'], ['0xFABCDEF', 'Int(262917615)'], ['0.0', 'Float(0)'], ['0.123', 'Float(0.123)'], ['\'s\'', 'String(s)'], ['\"s\"', 'String(s)']]));
		TestParser.shouldAllEqual(new Map([['i ++ ++ i', 'Block([Unop(++,true,Ident(i)),Unop(++,false,Ident(i))])'], ['a + b', 'Binop(Ident(a),+,Ident(b))'], ['a += b', 'AssignOp(Ident(a),+,Ident(b))']]));
		TestParser.shouldAllEqual(new Map([['"\\\\(v)"', 'String(\\\\(v))']]));
		TestParser.shouldAllEqualWithoutTrim([]);
		TestParser.shouldAllEqual(new Map([['import "test"', 'Import([],test)'], ['import xxx in "test"', 'Import([Lower(xxx)],test)'], ['import xxx as yyy in "test"', 'Import([Lower(xxx){as}Lower(yyy)],test)'], ['import XXX as YYY in "test"', 'Import([Upper(XXX){as}Upper(YYY)],test)'], ['import * as mmm in "test"', 'Import([*{as}Lower(mmm)],test)'], ['import XXX, YYY as ZZZ, www in "test"', 'Import([Upper(XXX),Upper(YYY){as}Upper(ZZZ),Lower(www)],test)']]));
		TestParser.shouldAllError(['import', 'import hehe', 'import _ as B in "test"', 'import * in "test"', 'import * as B in "test"']);
		TestParser.shouldAllEqual(new Map([['var a = new Array<A>()', 'Var(a,null,New([],ParametricType(Array,[Type(A)]),[],[],[],[]),false,false)'], ['a = Array<A>.staticField()', 'Binop(Ident(a),=,Call(Dot(NodeTypeValue(ParametricType(Array,[Type(A)])),staticField),[]))'], ['a = EnumTest.EnumField', 'Binop(Ident(a),=,DotUpper(NodeTypeValue(Type(EnumTest)),EnumField))'], ['a = EnumTest.EnumField(arg)', 'Binop(Ident(a),=,Call(DotUpper(NodeTypeValue(Type(EnumTest)),EnumField),[Ident(arg)]))'], ['a = EnumTest.EnumField(argName: argValue, arg2, arg3: arg3)', 'Binop(Ident(a),=,Call(DotUpper(NodeTypeValue(Type(EnumTest)),EnumField),[argName:Ident(argValue),Ident(arg2),arg3:Ident(arg3)]))'], ['a = EnumTest<A,B>.EnumField', 'Binop(Ident(a),=,DotUpper(NodeTypeValue(ParametricType(EnumTest,[Type(A),Type(B)])),EnumField))'], ['var a = b as B var c = d as! B var e = f as? B', 'Block([Var(a,null,As(Ident(b),<!--empty-->,Type(B)),false,false),Var(c,null,As(Ident(d),!,Type(B)),false,false),Var(e,null,As(Ident(f),?,Type(B)),false,false)])'], ['var a = b is B var c = d is B var e = f is B', 'Block([Var(a,null,As(Ident(b),Type(B)),false,false),Var(c,null,As(Ident(d),Type(B)),false,false),Var(e,null,As(Ident(f),Type(B)),false,false)])']]));
		TestParser.shouldAllEqual(new Map([['var x:[Array<T>]', 'Var(x,ParametricType(Array,[ParametricType(Array,[Type(T)])]),null,false,false)'], ['var x:[Map<K,V> : Array<T>]', 'Var(x,ParametricType(Map,[ParametricType(Map,[Type(K),Type(V)]),ParametricType(Array,[Type(T)])]),null,false,false)'], ['var x:{} var y:[] var z:[:] var w:()=>{}', 'Block([Var(x,Object([],[]),null,false,false),Var(y,ParametricType(Array,[Object([],[])]),null,false,false),Var(z,ParametricType(Map,[Object([],[]),Object([],[])]),null,false,false),Var(w,Function([],Object([],[])),null,false,false)])'], ['let x:()=>()=>()=>()=>Void', 'Var(x,Function([],Function([],Function([],Function([],Type(Void))))),null,true,false)']]));
		TestParser.shouldAllEqual(new Map([['enum A {}', 'Enum(Type(A),[])'], ['enum A { A B C }', 'Enum(Type(A),[NodeTypeValue(Type(A)),NodeTypeValue(Type(B)),NodeTypeValue(Type(C))])'], ['enum A { A(v:Int) B C(v:[K:V], a:Array<T>) }', 'Enum(Type(A),[\n					Call(NodeTypeValue(Type(A)),[v:NodeTypeValue(Type(Int))]),\n					NodeTypeValue(Type(B)),\n					Call(NodeTypeValue(Type(C)),[v:Map([NodeTypeValue(Type(K))],[NodeTypeValue(Type(V))]),a:NodeTypeValue(ParametricType(Array,[Type(T)]))])\n					])'], ['enum A { E(v: T<T>?) }', 'Enum(Type(A),[Call(NodeTypeValue(Type(E)),[v:NodeTypeValue(Optional(ParametricType(T,[Type(T)])))])])'], ['enum A { E(v: T<T?>) }', 'Enum(Type(A),[Call(NodeTypeValue(Type(E)),[v:NodeTypeValue(ParametricType(T,[Optional(Type(T))]))])])'], ['enum A { E(v: T?) }', 'Enum(Type(A),[Call(NodeTypeValue(Type(E)),[v:NodeTypeValue(Optional(Type(T)))])])']]));
		TestParser.shouldAllEqual(new Map([['new A(a: 1, b: 2)', 'New([],Type(A),[Int(1),Int(2)],[],[],[a,b])'], ['class A {} var a = new A { } ()', 'Block([Class(Type(A),null,[],[],false),Var(a,null,New([],Type(A),[],[],[],[]),false,false)])'], ['class A { var field: String } var a = new A { field: "Value" } ()', 'Block([Class(Type(A),null,[],[Var(field,Type(String),null,false,false)],false),Var(a,null,New([],Type(A),[],[field],[String(Value)],[]),false,false)])'], ['class A { var field: String var otherfield: Int } var a = new A { field: "Value", otherfield: 25 } ()', 'Block([Class(Type(A),null,[],[Var(field,Type(String),null,false,false),Var(otherfield,Type(Int),null,false,false)],false),Var(a,null,New([],Type(A),[],[field,otherfield],[String(Value),Int(25)],[]),false,false)])']]));
		TestParser.shouldAllError(['class A { new(a b) {} }', 'class A { new(a, b,) {} }', 'class A { new(,) {} }', 'fun f(a b c) {}', 'fun f(a b) {}', 'fun f(a, b,) {}', 'fun f(a,) {}', 'fun f(,) {}']);
		TestParser.shouldAllError(['class A { var i: Int { set (value) {} } }', 'class A { var i: Int { get {} set () {} } }', 'class A { var i: Int { get {} set {} } }', 'class A { let i: Int { get {} set (value) {} } }', 'class A { let i: Int { get {} set (value, val) {} } }', 'class A { var i: Int { get {} set (Value) {} } }', 'class A { var i: Int { get (value) {} set (value) {} } }', 'class A { var i: Int {} }']);
		TestParser.shouldAllError(['if (,) {}', 'if (a,) {}', 'switch (,) {}', 'switch (a,) {}', '@att(,) x', '@att(a,) x', '@att(a,b,) x', '@att(a b,) x', '@att(a b) x', 'new T(,)', 'new T(a b,)', 'new T(a,b,)', 'new T(a b)', 'call(1 2)', 'call(1 2,)', 'call(1,2,)', 'call(1,)', 'call(a:1,)', 'call(1:1,)', 'call(a:,)', 'call(a:)', 'call(,)', '[1 2]', '[,]', '[1,]', '[1,2,]', '[1:1 2:2]', '[1:1,2:2,]', '{a:1 b:2}', '{,}', '{a:1,}', '{a:1,b:2,}']);
		TestParser.shouldAllError(['=', '= 1']);
		TestParser.shouldAllEqual(new Map([['if this { this }', 'If([This],Block([This]),<!--null-->)'], ['if this, this { this } else { break }', 'If([This,This],Block([This]),Block([Break]))'], ['if this, let a = this { this } else { break }', 'If([This,Var(a,null,This,true,false)],Block([This]),Block([Break]))'], ['if let a = this, let b = this, this { this }', 'If([Var(a,null,This,true,false),Var(b,null,This,true,false),This],Block([This]),<!--null-->)']]));
		TestParser.shouldAllEqual(new Map([['declare var a: T', 'Var(a,Type(T),null,false,true)'], ['declare let a: T', 'Var(a,Type(T),null,true,true)'], ['declare fun name()', 'Function(name,null,[],null,true)'], ['declare fun name() hi()', 'Block([Function(name,null,[],null,true),Call(Ident(hi),[])])'], ['declare fun name() {}', 'Block([Function(name,null,[],null,true),Block([])])'], ['declare class A {}', 'Class(Type(A),null,[],[],true)'], ['declare A = B', 'TypeAlias(Type(A),Type(B))']]));
		TestParser.shouldAllError(['declare var a, b, c', 'declare anything']);
		TestParser.shouldAllEqual(new Map([['push([:])', 'Call(Ident(push),[Map([],[])])'], ['push([])', 'Call(Ident(push),[Array([])])'], ['[].length', 'Dot(Array([]),length)'], ['[:].length', 'Dot(Map([],[]),length)'], ['[[:]]', 'Array([Map([],[])])']]));
		console.log(('TestParser done ' + (Math.round((TestParser.passed / TestParser.overall) * 100)) + '% (' + (TestParser.passed) + '/' + (TestParser.overall) + ')'));
	};
	TestParser.shouldEqual = (input, test) => {
		const test_5354 = TestParser.deepTrim(test);
		TestParser.shouldEqualWithoutTrim(input, test_5354);
	};
	TestParser.shouldEqualWithoutTrim = (input_5355, test_5356) => {
		TestParser.overall++;
		const lexe = Lexer.tokenize(Buffer.from(input_5355), 'TEST');
		try {
			const parsed = Parser.toNode(Parser.parseNodes(lexe, new Project()));
			const res = TestParser.stringify(parsed);
			if (test_5356 != res) { throw ('TestParser test fail: `' + (input_5355) + '`\n!==: `' + (test_5356) + '`\nGot: `' + (res) + '`\nParsed: `' + (parsed) + '`') };
		} catch (temp) {
			if (true) { 
			const e = temp
			{
				console.log(e.toString());
				throw ('TestParser test fail: `' + (input_5355) + '` failed to parse');
			} } else
			
			throw temp;
		};
		TestParser.passed++;
	};
	TestParser.shouldAllEqual = (map) => { for (const input of $toIterator(map.keys())) {
		const test_5357 = map.get(input);
		TestParser.shouldEqual(input, test_5357);
	} };
	TestParser.shouldAllEqualWithoutTrim = (map_5358) => { for (const input of $toIterator(map_5358.keys())) {
		const test_5359 = map_5358.get(input);
		TestParser.shouldEqualWithoutTrim(input, test_5359);
	} };
	TestParser.shouldError = (input_5360) => {
		TestParser.overall++;
		try {
			const lexe_5362 = Lexer.tokenize(Buffer.from(input_5360), 'TEST');
			const parser = Parser.toNode(Parser.parseNodes(lexe_5362, new Project()));
		} catch (temp_5361) {
			if (true) { 
			const e = temp_5361
			{
				TestParser.passed++;
				return;
			} } else
			
			throw temp_5361;
		};
		throw ('TestParser test fail: `' + (input_5360) + '` did not throw exception.');
	};
	TestParser.shouldAllError = (input_5363) => { for (const str of $toIterator(input_5363)) {
		TestParser.shouldError(str);
	} };
	TestParser.deepTrim = (s) => { return s.split('\n').join('').split('\r').join('').split('\t').join('').split(' ').join('') };
	TestParser.stringify = (node) => {
		const temp_5364 = node;
		switch (temp_5364&&temp_5364[0]) {
		case null: case undefined: {
			return '<!--null-->'
		} break;
		
		case 0: {
			const s_5365 = temp_5364[1];
			return ('String(' + (s_5365) + ')')
		} break;
		
		case 1: {
			const s_5366 = temp_5364[1];
			return ('Ident(' + (s_5366) + ')')
		} break;
		
		case 2: {
			const b = temp_5364[1];
			return ('Bool(' + (b) + ')')
		} break;
		
		case 3: {
			return 'This'
		} break;
		
		case 4: {
			return 'Super'
		} break;
		
		case 5: {
			const s_5367 = temp_5364[1];
			return ('Int(' + (s_5367) + ')')
		} break;
		
		case 7: {
			const s_5368 = temp_5364[1];
			return ('Float(' + (s_5368) + ')')
		} break;
		
		case 8: {
			return 'Null'
		} break;
		
		case 18: {
			return 'Break'
		} break;
		
		case 19: {
			return 'Continue'
		} break;
		
		case 43: {
			const expr = temp_5364[1];
			const type = temp_5364[2];
			return 'As(' + TestParser.stringify(expr) + ',' + TestParser.stringifyType(type) + ')'
		} break;
		
		case 44: {
			const expr_5369 = temp_5364[1];
			const kind = temp_5364[2];
			const type_5370 = temp_5364[3];
			return 'As(' + TestParser.stringify(expr_5369) + ',' + Token.stringify(kind) + ',' + TestParser.stringifyType(type_5370) + ')'
		} break;
		
		case 10: {
			const a = temp_5364[1];
			const op = temp_5364[2];
			const b_5371 = temp_5364[3];
			return 'Binop(' + TestParser.stringify(a) + ',' + Token.stringify(op) + ',' + TestParser.stringify(b_5371) + ')'
		} break;
		
		case 11: {
			const a_5372 = temp_5364[1];
			const op_5373 = temp_5364[2];
			const b_5374 = temp_5364[3];
			return 'AssignOp(' + TestParser.stringify(a_5372) + ',' + Token.stringify(op_5373) + ',' + TestParser.stringify(b_5374) + ')'
		} break;
		
		case 12: {
			const els = temp_5364[1];
			return 'Block(' + TestParser.stringifyNodeArray(els) + ')'
		} break;
		
		case 24: {
			const name = temp_5364[1];
			const t = temp_5364[2];
			const expr_5375 = temp_5364[3];
			const const_5376 = temp_5364[4];
			const external = temp_5364[5];
			return ('Var(' + (name) + ',') + ((((t != null))? (TestParser.stringifyType(t)) : 'null')) + ',' + ((((expr_5375 != null))? (TestParser.stringify(expr_5375)) : 'null')) + (',' + (const_5376) + ',' + (external) + ')')
		} break;
		
		case 22: {
			const name_5377 = temp_5364[1];
			const expr_5378 = temp_5364[2];
			const vars = temp_5364[3];
			const rettype = temp_5364[4];
			const external_5379 = temp_5364[5];
			return ('Function(' + (name_5377) + ',') + (((expr_5378 == null)? ('null') : TestParser.stringify(expr_5378))) + ',' + TestParser.stringifyNodeArray(vars) + ',' + ((((rettype != null))? (TestParser.stringifyType(rettype)) : 'null')) + (',' + (external_5379) + ')')
		} break;
		
		case 23: {
			const expr_5380 = temp_5364[1];
			const vars_5381 = temp_5364[2];
			const rettype_5382 = temp_5364[3];
			return 'Arrow(' + (((expr_5380 == null)? ('null') : TestParser.stringify(expr_5380))) + ',' + TestParser.stringifyNodeArray(vars_5381) + ',' + ((((rettype_5382 != null))? (TestParser.stringifyType(rettype_5382)) : 'null')) + ')'
		} break;
		
		case 13: {
			const e = temp_5364[1];
			const el = temp_5364[2];
			const argNames = temp_5364[3];
			{
				let res_5383 = 'Call(' + TestParser.stringify(e) + ',[';
				{
					let i = 0;
					let it = 0;
					let at = el.length;
					while (it < at) {
						i = it;
						it++;
						{
							res_5383 += (((argNames[i] == null))? ('') : argNames[i] + ':');
							res_5383 += TestParser.stringify(el[i]) + ((((i != el.length - 1))? (',') : ''));
						};
					};
				};
				return res_5383 + '])';
			}
		} break;
		
		case 15: {
			const e_5384 = temp_5364[1];
			return 'Parenthesis(' + TestParser.stringify(e_5384) + ')'
		} break;
		
		case 16: {
			const e_5385 = temp_5364[1];
			return 'Return(' + TestParser.stringify(e_5385) + ')'
		} break;
		
		case 17: {
			const e_5386 = temp_5364[1];
			return 'Throw(' + TestParser.stringify(e_5386) + ')'
		} break;
		
		case 39: {
			const t_5387 = temp_5364[1];
			const els_5388 = temp_5364[2];
			return 'Enum(' + TestParser.stringifyType(t_5387) + ',' + TestParser.stringifyNodeArray(els_5388) + ')'
		} break;
		
		case 35: {
			const path = temp_5364[1];
			const els_5389 = temp_5364[2];
			return 'Module(' + path + ',' + TestParser.stringifyNodeArray(els_5389) + ')'
		} break;
		
		case 37: {
			const els_5390 = temp_5364[1];
			const path_5391 = temp_5364[2];
			{
				const stringifyImportNode = (node_5392) => {
					const temp_5393 = node_5392;
					switch (temp_5393&&temp_5393[0]) {
					case 0: {
						const name_5394 = temp_5393[1];
						return ('Lower(' + (name_5394) + ')')
					} break;
					
					case 1: {
						const name_5395 = temp_5393[1];
						return ('Upper(' + (name_5395) + ')')
					} break;
					
					case 2: {
						return '*'
					} break;
					
					case 3: {
						const left = temp_5393[1];
						const right = temp_5393[2];
						return stringifyImportNode(left) + '{as}' + stringifyImportNode(right)
					} break;
					};
				};
				return 'Import([' + (() => {
					const result = [];
					const value = els_5390;
					for (const p of $toIterator(value)) result.push(stringifyImportNode(p));
					return result;
				})().join(',') + '],' + path_5391 + ')';
			}
		} break;
		
		case 32: {
			const k = temp_5364[1];
			const v = temp_5364[2];
			return 'Map([' + TestParser.stringifyArray(k) + '],[' + TestParser.stringifyArray(v) + '])'
		} break;
		
		case 25: {
			const type_5396 = temp_5364[1];
			const extend = temp_5364[2];
			const implement = temp_5364[3];
			const fields = temp_5364[4];
			const external_5397 = temp_5364[5];
			{
				let res_5398 = 'Class(' + TestParser.stringifyType(type_5396) + ',';
				res_5398 += (((extend != null))? (TestParser.stringifyType(extend)) : 'null,');
				res_5398 += TestParser.stringifyNodeTypeArray(implement) + ',';
				res_5398 += TestParser.stringifyNodeArray(fields) + ',';
				res_5398 += external_5397 + ')';
				return res_5398;
			}
		} break;
		
		case 30: {
			const path_5399 = temp_5364[1];
			const t_5400 = temp_5364[2];
			const args = temp_5364[3];
			const names = temp_5364[4];
			const values = temp_5364[5];
			const argNames_5401 = temp_5364[6];
			return 'New([' + path_5399.join('.') + '],' + TestParser.stringifyType(t_5400) + ',' + TestParser.stringifyNodeArray(args) + ',[' + names.join(',') + '],' + TestParser.stringifyNodeArray(values) + ',[' + argNames_5401.join(',') + '])'
		} break;
		
		case 51: {
			const type_5402 = temp_5364[1];
			return 'NodeTypeValue(' + TestParser.stringifyType(type_5402) + ')'
		} break;
		
		case 9: {
			const alias = temp_5364[1];
			const value_5403 = temp_5364[2];
			return 'TypeAlias(' + TestParser.stringifyType(alias) + ',' + TestParser.stringifyType(value_5403) + ')'
		} break;
		
		case 28: {
			const l = temp_5364[1];
			const r = temp_5364[2];
			return 'Dot(' + TestParser.stringify(l) + ',' + r + ')'
		} break;
		
		case 29: {
			const l_5404 = temp_5364[1];
			const r_5405 = temp_5364[2];
			return 'DotUpper(' + TestParser.stringify(l_5404) + ',' + r_5405 + ')'
		} break;
		
		case 48: {
			const expr_5406 = temp_5364[1];
			return 'Private(' + TestParser.stringify(expr_5406) + ')'
		} break;
		
		case 14: {
			const econd = temp_5364[1];
			const eif = temp_5364[2];
			const eelse = temp_5364[3];
			return 'If(' + TestParser.stringifyNodeArray(econd) + ',' + TestParser.stringify(eif) + ',' + TestParser.stringify(eelse) + ')'
		} break;
		
		case 31: {
			const el_5407 = temp_5364[1];
			return 'Array(' + TestParser.stringifyNodeArray(el_5407) + ')'
		} break;
		
		case 20: {
			const op_5408 = temp_5364[1];
			const postfix = temp_5364[2];
			const e_5409 = temp_5364[3];
			return 'Unop(' + Token.stringify(op_5408) + ',' + postfix + ',' + TestParser.stringify(e_5409) + ')'
		} break;
		
		default: 
		throw '<!--' + node + '-->'
		};
	};
	TestParser.stringifyArray = (nodes) => { return (() => {
		const result_5410 = [];
		const value_5411 = nodes;
		for (const node of $toIterator(value_5411)) result_5410.push(TestParser.stringify(node));
		return result_5410;
	})().join(',') };
	TestParser.stringifyNodeArray = (arr) => { return '[' + TestParser.stringifyArray(arr) + ']' };
	TestParser.stringifyNodeTypeArray = (arr_5412) => { return '[' + (() => {
		const result_5413 = [];
		const value_5414 = arr_5412;
		for (const e of $toIterator(value_5414)) result_5413.push(TestParser.stringifyType(e));
		return result_5413;
	})().join(',') + ']' };
	TestParser.stringifyType = (node_5415) => {
		const temp_5416 = node_5415;
		switch (temp_5416&&temp_5416[0]) {
		case 1: {
			const s_5417 = temp_5416[1];
			return ('Type(' + (s_5417) + ')')
		} break;
		
		case 2: {
			const name_5418 = temp_5416[1];
			const params = temp_5416[2];
			return ('ParametricType(' + (name_5418) + ',[') + (() => {
				const result_5419 = [];
				const value_5420 = params;
				for (const p of $toIterator(value_5420)) result_5419.push(TestParser.stringifyType(p));
				return result_5419;
			})().join(',') + '])'
		} break;
		
		case 3: {
			const args_5421 = temp_5416[1];
			const rettype_5422 = temp_5416[2];
			return 'Function([' + (() => {
				const result_5423 = [];
				const value_5424 = args_5421;
				for (const e of $toIterator(value_5424)) result_5423.push(TestParser.stringifyType(e));
				return result_5423;
			})().join(',') + '],' + TestParser.stringifyType(rettype_5422) + ')'
		} break;
		
		case 5: {
			const names_5425 = temp_5416[1];
			const types = temp_5416[2];
			return 'Object([' + names_5425.join(',') + '],[' + (() => {
				const result_5426 = [];
				const value_5427 = types;
				for (const e of $toIterator(value_5427)) result_5426.push(TestParser.stringifyType(e));
				return result_5426;
			})().join(',') + '])'
		} break;
		
		case 0: {
			const type_5428 = temp_5416[1];
			return 'Optional(' + TestParser.stringifyType(type_5428) + ')'
		} break;
		
		default: 
		throw '<!--' + node_5415 + '-->'
		};
	};
	var GenJs = class {
		constructor() { 
			this.extension = '.js'
			this.nativeEnums = false
			this.toIterator = false
			this.tabs = '\t'
			this.globalAccessor = ''
			this.reserved = ['with', 'const', 'instanceof', 'typeof', 'delete', 'undefined', 'package_TODO', 'async', 'await', 'arguments']
			this.bi = 0
		{
	} };
		perform(normalizer) {
		this.project = normalizer;
		return this.stringify();
	};
		stringify() {
		const out = [('// Generated by Hexa ' + (version) + ' https://hexalang.github.io\n')];
		if (this.project.package.addLicenseNoticeToOutput) {
			out.push(('// Project: ' + (this.project.package.name) + '\n'));
			out.push(('// LICENSE ' + (this.project.package.license) + '\n'));
		} else {
			out.push('// The generated code is subject to the original license\n');
		};
		out.push(';(() => {\n\t"use strict"\n\tconst $global = typeof(window) === "undefined"? global : window');
		out.push('\n\tif (typeof($global.require) === "undefined") { $global.require = () => {} };');
		out.push(('\n\tconst selfVersion=\"' + (this.project.package.version) + '\";'));
		const constantsIndex = out.length;
		const constants = [];
		out.push('');
		for (const e of $toIterator(this.project.enumsSimple)) {
			if (e.staticVars.length + e.staticMethods.length == 0) { continue };
			out.push('\n\tvar ' + e.name + ' = {');
			for (const v of $toIterator(e.staticMethods)) {
				const temp = v;
				switch (temp&&temp[0]) {
				case 5: {
					const name = temp[1];
					const expr = temp[2];
					const args = temp[3];
					const defaults = temp[4];
					{
						out.push('\n\t\t' + name + ': ');
						out.push(this.printFunctionArguments(args, defaults) + ' => { ' + this.printStatement(expr) + ' }');
						out.push(',');
					}
				} break;
				};
			};
			out.push('\n\t}');
			for (const v of $toIterator(e.staticVars)) {
				const temp_5444 = v;
				switch (temp_5444&&temp_5444[0]) {
				case 3: {
					const name_5445 = temp_5444[1];
					const expr_5446 = temp_5444[2];
					{
						out.push('\n\t' + e.name + '.' + name_5445);
						if (expr_5446 != null) { out.push(' = ' + this.printExpression(expr_5446)) };
					}
				} break;
				
				case 4: {
					const name_5447 = temp_5444[1];
					const expr_5448 = temp_5444[2];
					{
						out.push('\n\t' + e.name + '.' + name_5447);
						out.push(' = ' + this.printExpression(expr_5448));
					}
				} break;
				};
			};
		};
		for (const e of $toIterator(this.project.enumsComplex)) {
			if ((e.staticMethods.length == 0) && (e.names.length == 0)) { out.push('\n\tvar ' + e.name + ' = {}') } else {
				out.push('\n\tvar ' + e.name + ' = {');
				for (const v of $toIterator(e.staticMethods)) {
					const temp_5449 = v;
					switch (temp_5449&&temp_5449[0]) {
					case 5: {
						const name_5450 = temp_5449[1];
						const expr_5451 = temp_5449[2];
						const args_5452 = temp_5449[3];
						const defaults_5453 = temp_5449[4];
						{
							out.push('\n\t\t' + name_5450 + ': ');
							out.push(this.printFunctionArguments(args_5452, defaults_5453) + ' => { ' + this.printStatement(expr_5451) + ' }');
							out.push(',');
						}
					} break;
					};
				};
				let i = 0;
				for (const name of $toIterator(e.names)) {
					if ((!e.expose)) { break };
					if (e.constructors[i] != null) {
						out.push('\n\t\t' + name + ': ');
						out.push('(' + e.constructors[i].join(',') + ')=>[');
						out.push('' + i + ',' + e.constructors[i].join(','));
						out.push('],');
					};
					i++;
				};
				out.push('\n\t}');
			};
			let i_5454 = 0;
			for (const name of $toIterator(e.names)) {
				if ((!e.expose)) { break };
				if (e.constructors[i_5454] != null) {} else {
					out.push('\n\tObject.defineProperty(' + e.name + ', "' + name + '", { get: () => { return [' + i_5454 + '] }})');
				};
				i_5454++;
			};
			for (const v of $toIterator(e.staticVars)) {
				const temp_5455 = v;
				switch (temp_5455&&temp_5455[0]) {
				case 3: {
					const name_5456 = temp_5455[1];
					const expr_5457 = temp_5455[2];
					{
						out.push('\n\t' + e.name + '.' + name_5456);
						if (expr_5457 != null) { out.push(' = ' + this.printExpression(expr_5457)) };
					}
				} break;
				
				case 4: {
					const name_5458 = temp_5455[1];
					const expr_5459 = temp_5455[2];
					{
						out.push('\n\t' + e.name + '.' + name_5458);
						out.push(' = ' + this.printExpression(expr_5459));
					}
				} break;
				};
			};
		};
		for (const i of $toIterator(this.project.interfaces)) {
			throw i;
		};
		for (const c of $toIterator(this.project.classes)) {
			if (c.useless || c.template) { continue };
			if (c.external) {
				if (c.jsRequire != null) {
					constants.push('\n\t' + 'const ' + c.name + ' = require("' + c.jsRequire + '")');
					continue;
				};
				{
					let step = 0;
					const jsNative = c.jsNative;
					let temp_5460 = null;
					if (step == 0 && jsNative != null) {
						temp_5460 = jsNative != c.name;
						step = 1;
					};
					if (step == 1 && temp_5460 != false) { step = 2 };
					if (step == 2) { out.push('\n\t' + 'var ' + c.name + ' = $global.' + jsNative) };
				};
				continue;
			};
			out.push('\n\t' + 'var ' + c.name + ' = class');
			{
				let step_5461 = 0;
				const extend = c.extend;
				if (step_5461 == 0 && extend != null) { step_5461 = 1 };
				if (step_5461 == 1) { out.push(' extends ' + extend) };
			};
			out.push(' {');
			for (const v of $toIterator(c.methods)) {
				const temp_5462 = v;
				switch (temp_5462&&temp_5462[0]) {
				case 5: {
					const name_5463 = temp_5462[1];
					const expr_5464 = temp_5462[2];
					const args_5465 = temp_5462[3];
					{
						if (name_5463 == null || name_5463 == 'new') { out.push('\n\t\tconstructor') } else {
							out.push('\n\t\t' + name_5463);
						};
						out.push('(' + args_5465.join(', ') + ') ');
						if ((name_5463 == null || name_5463 == 'new') && (c.vars.length > 0)) {
							out.push('{ ');
							for (const v of $toIterator(c.vars)) {
								const temp_5466 = v;
								switch (temp_5466&&temp_5466[0]) {
								case 3: {
									const name_5467 = temp_5466[1];
									const expr_5468 = temp_5466[2];
									if (expr_5468 != null) { out.push('\n\t\t\tthis.' + name_5467 + ' = ' + this.printExpression(expr_5468) + '') }
								} break;
								
								case 4: {
									const name_5469 = temp_5466[1];
									const expr_5470 = temp_5466[2];
									if (expr_5470 != null) { out.push('\n\t\t\tthis.' + name_5469 + ' = ' + this.printExpression(expr_5470) + '') }
								} break;
								};
							};
							out.push('\n\t\t');
							out.push(this.printStatement(expr_5464) + ' };');
						} else {
							out.push(this.printBlock(expr_5464) + ';');
						};
					}
				} break;
				};
			};
			for (const name of $toIterator(c.property)) {
				out.push('\n\t\tget ' + name + ('() { return this.get_' + (name) + '(); };'));
				out.push('\n\t\tset ' + name + ('(value) { return this.set_' + (name) + '(value); };'));
			};
			out.push('\n\t}');
			for (const v of $toIterator(c.staticVars)) {
				const temp_5471 = v;
				switch (temp_5471&&temp_5471[0]) {
				case 3: {
					const name_5472 = temp_5471[1];
					const expr_5473 = temp_5471[2];
					{
						out.push('\n\t' + c.name + '.' + name_5472);
						if (expr_5473 != null) { out.push(' = ' + this.printExpression(expr_5473)) };
					}
				} break;
				
				case 4: {
					const name_5474 = temp_5471[1];
					const expr_5475 = temp_5471[2];
					{
						out.push('\n\t' + c.name + '.' + name_5474);
						out.push(' = ' + this.printExpression(expr_5475));
					}
				} break;
				};
			};
			for (const v of $toIterator(c.staticMethods)) {
				const temp_5476 = v;
				switch (temp_5476&&temp_5476[0]) {
				case 5: {
					const name_5477 = temp_5476[1];
					const expr_5478 = temp_5476[2];
					const args_5479 = temp_5476[3];
					const defaults_5480 = temp_5476[4];
					{
						out.push('\n\t' + c.name + '.' + name_5477 + ' = ');
						out.push(this.printFunctionArguments(args_5479, defaults_5480) + ' => ' + this.printBlock(expr_5478) + ';');
					}
				} break;
				};
			};
		};
		for (const g of $toIterator(this.project.globalFuncs)) {
			const temp_5481 = g;
			switch (temp_5481&&temp_5481[0]) {
			case 5: {
				const name_5482 = temp_5481[1];
				const expr_5483 = temp_5481[2];
				const args_5484 = temp_5481[3];
				const defaults_5485 = temp_5481[4];
				{
					out.push('\n\tfunction ' + name_5482);
					out.push(this.printFunctionArguments(args_5484, defaults_5485) + ' ' + this.printBlock(expr_5483) + ';');
				}
			} break;
			};
		};
		for (const g of $toIterator(this.project.globalVars)) {
			const temp_5486 = g;
			switch (temp_5486&&temp_5486[0]) {
			case 3: {
				const name_5487 = temp_5486[1];
				const expr_5488 = temp_5486[2];
				{
					out.push('\n\tvar ' + name_5487);
					if (expr_5488 != null) { out.push(' = ' + this.printExpression(expr_5488)) } else {
						out.push(' = null');
					};
				}
			} break;
			
			case 4: {
				const name_5489 = temp_5486[1];
				const expr_5490 = temp_5486[2];
				out.push('\n\tvar ' + name_5489 + ' = ' + this.printExpression(expr_5490))
			} break;
			};
		};
		this.tabs = '\t\t';
		for (const init of $toIterator(this.project.init)) {
			out.push('\n\t{\n\t\t');
			out.push(this.printStatement(init));
			out.push('\n\t}');
		};
		if (this.toIterator) { constants.unshift('\n\tconst $toIterator = (v) => typeof(v) === "number"? Array(Math.max(v, 0)).keys() : v;') };
		out[constantsIndex] = constants.join('');
		out.push('\n})();\n');
		return out.join('');
	};
		pushTab() { this.tabs += '\t' };
		popTab() { this.tabs = this.tabs.substring(0, this.tabs.length - 1) };
		printBlock(s) {
		const temp_5491 = s;
		switch (temp_5491&&temp_5491[0]) {
		case 1: {
			const el = temp_5491[1];
			{
				if (el.length == 1) {
					const temp_5492 = el[0];
					switch (temp_5492&&temp_5492[0]) {
					case 1: {
						return this.printStatement(el[0])
					} break;
					};
				};
				if (el.length == 1) { return '{ ' + this.printStatement(el[0]) + ' }' };
				if (el.length == 0) { return '{}' };
				return this.printStatement(s);
			}
		} break;
		
		default: 
		return '{ ' + this.printStatement(s) + ' }'
		};
	};
		printStatement(s_5493) {
		{
			const temp_5494 = s_5493;
			switch (temp_5494&&temp_5494[0]) {
			case 0: {
				const els = temp_5494[1];
				{
					let r = '';
					for (const s of $toIterator(els)) {
						if (s != null) { r += '\n' + this.tabs + this.printStatement(s) + ';' };
					};
					return r;
				}
			} break;
			
			case 18: {
				return 'break'
			} break;
			
			case 17: {
				return 'continue'
			} break;
			
			case 1: {
				const el_5495 = temp_5494[1];
				{
					if (el_5495.length == 1) {
						const temp_5496 = el_5495[0];
						switch (temp_5496&&temp_5496[0]) {
						case 1: {
							return this.printStatement(el_5495[0])
						} break;
						};
					};
					this.pushTab();
					let r_5497 = '{';
					for (const e of $toIterator(el_5495)) {
						const temp_5498 = e;
						switch (temp_5498&&temp_5498[0]) {
						case null: case undefined: {
							{
							}
						} break;
						
						case 0: {
							const els_5499 = temp_5498[1];
							for (const s of $toIterator(els_5499)) {
								if (s != null) { r_5497 += '\n' + this.tabs + this.printStatement(s) + ';' };
							}
						} break;
						
						default: 
						r_5497 += '\n' + this.tabs + this.printStatement(e) + ';'
						};
					};
					this.popTab();
					return r_5497 + '\n' + this.tabs + '}';
				}
			} break;
			
			case 4: {
				const name_5500 = temp_5494[1];
				const expr_5501 = temp_5494[2];
				return 'const ' + name_5500 + (((expr_5501 == null)? (' = null') : ' = ' + this.printExpression(expr_5501)))
			} break;
			
			case 3: {
				const name_5502 = temp_5494[1];
				const expr_5503 = temp_5494[2];
				return 'let ' + name_5502 + (((expr_5503 == null)? ('') : ' = ' + this.printExpression(expr_5503)))
			} break;
			
			case 5: {
				const name_5504 = temp_5494[1];
				const expr_5505 = temp_5494[2];
				const args_5506 = temp_5494[3];
				const defaults_5507 = temp_5494[4];
				return 'const ' + name_5504 + ' = ' + this.printFunctionArguments(args_5506, defaults_5507) + ' => ' + this.printBlock(expr_5505)
			} break;
			
			case 6: {
				const e = temp_5494[1];
				{
					if (e == null) { return 'return' };
					return 'return ' + this.printExpression(e);
				}
			} break;
			
			case 7: {
				const econd = temp_5494[1];
				const eif = temp_5494[2];
				const eelse = temp_5494[3];
				{
					let r_5508 = 'if (' + this.printExpression(econd) + ') ' + this.printBlock(eif);
					if (eelse != null) { r_5508 += ' else ' + this.printStatement(eelse) };
					return r_5508;
				}
			} break;
			
			case 2: {
				const e_5509 = temp_5494[1];
				const args_5510 = temp_5494[2];
				return this.printExpression(e_5509) + this.printCallArguments(args_5510)
			} break;
			
			case 19: {
				const args_5511 = temp_5494[1];
				return 'super' + this.printCallArguments(args_5511)
			} break;
			
			case 8: {
				const expr_5512 = temp_5494[1];
				const t = temp_5494[2];
				const v = temp_5494[3];
				const catches = temp_5494[4];
				const temp_5513 = temp_5494[5];
				{
					let r_5514 = 'try ';
					r_5514 += this.printBlock(expr_5512);
					r_5514 += (' catch (' + (temp_5513) + ') {\n') + this.tabs + '\t';
					this.pushTab();
					{
						let i_5515 = 0;
						let it = 0;
						let at = catches.length;
						while (it < at) {
							i_5515 = it;
							it++;
							{
								let typeof_5516 = 'T';
								{
									const temp_5517 = t[i_5515];
									switch (temp_5517&&temp_5517[0]) {
									case 6: {
										const type = temp_5517[1];
										typeof_5516 = type.name
									} break;
									
									default: 
									throw '' + t[i_5515]
									};
								};
								{
									const temp_5518 = typeof_5516;
									switch (temp_5518) {
									case 'Any': {
										r_5514 += 'if (true) { '
									} break;
									
									case 'String': {
										r_5514 += ('if (typeof(' + (temp_5513) + ') == \"string\") { ')
									} break;
									
									case 'Int': {
										r_5514 += ('if (typeof(' + (temp_5513) + ') == \"number\") { ')
									} break;
									
									case 'Float': {
										r_5514 += ('if (typeof(' + (temp_5513) + ') == \"number\") { ')
									} break;
									
									case 'Bool': {
										r_5514 += ('if (typeof(' + (temp_5513) + ') == \"boolean\") { ')
									} break;
									
									default: 
									r_5514 += ('if (' + (temp_5513) + ' instanceof ' + (typeof_5516) + ') { ')
									};
								};
								r_5514 += '\n' + this.tabs;
								r_5514 += ('const ' + (v[i_5515]) + ' = ' + (temp_5513) + '');
								r_5514 += '\n' + this.tabs;
								r_5514 += this.printStatement(catches[i_5515]);
								r_5514 += ' }';
								r_5514 += ' else';
								r_5514 += '\n' + this.tabs;
							};
						};
					};
					r_5514 += '\n' + this.tabs + ('throw ' + (temp_5513) + ';');
					this.popTab();
					return r_5514 + '\n' + this.tabs + '}';
				}
			} break;
			
			case 10: {
				const a = temp_5494[1];
				const v_5519 = temp_5494[2];
				return this.printExpression(a) + ' = ' + this.printExpression(v_5519)
			} break;
			
			case 9: {
				const e_5520 = temp_5494[1];
				return 'throw ' + this.printExpression(e_5520)
			} break;
			
			case 12: {
				const name_5521 = temp_5494[1];
				const over = temp_5494[2];
				const by = temp_5494[3];
				{
					{
						const temp_5522 = over;
						switch (temp_5522&&temp_5522[0]) {
						case 17: {
							return 'for (const ' + name_5521 + ' of ' + this.printExpression(over) + ') ' + this.printStatement(by)
						} break;
						};
					};
					this.toIterator = true;
					return 'for (const ' + name_5521 + ' of $toIterator(' + this.printExpression(over) + ')) ' + this.printStatement(by);
				}
			} break;
			
			case 14: {
				const e_5523 = temp_5494[1];
				return this.printExpression(e_5523) + '++'
			} break;
			
			case 15: {
				const e_5524 = temp_5494[1];
				return this.printExpression(e_5524) + '--'
			} break;
			
			case 13: {
				const econd_5525 = temp_5494[1];
				const e_5526 = temp_5494[2];
				const pre = temp_5494[3];
				{
					if (pre) { return 'while (' + this.printExpression(econd_5525) + ') ' + this.printStatement(e_5526) };
					return 'do {' + this.printStatement(e_5526) + '} while (' + this.printExpression(econd_5525) + ')';
				}
			} break;
			
			case 11: {
				const a_5527 = temp_5494[1];
				const op = temp_5494[2];
				const value = temp_5494[3];
				return this.printExpression(a_5527) + ' ' + Token.stringify(op) + '= ' + this.printExpression(value)
			} break;
			
			case 16: {
				const expr_5528 = temp_5494[1];
				const cases = temp_5494[2];
				const statements = temp_5494[3];
				const guards = temp_5494[4];
				const binds = temp_5494[5];
				{
					let r_5529 = 'switch (' + this.printExpression(expr_5528) + ') {';
					{
						let i_5530 = 0;
						let it_5531 = 0;
						let at_5532 = cases.length;
						while (it_5531 < at_5532) {
							i_5530 = it_5531;
							it_5531++;
							{
								if (cases[i_5530].length > 0) {
									r_5529 += '\n' + this.tabs;
									for (const cc of $toIterator(cases[i_5530])) {
										const temp_5533 = cc;
										switch (temp_5533&&temp_5533[0]) {
										case 7: {
											r_5529 += 'case null: case undefined: '
										} break;
										
										default: 
										r_5529 += 'case ' + this.printExpression(cc) + ': '
										};
									};
									this.pushTab();
									r_5529 += '{\n' + this.tabs;
									{
										let step_5534 = 0;
										const binders = binds[i_5530];
										if (step_5534 == 0 && binders != null) { step_5534 = 1 };
										if (step_5534 == 1) { for (const bind of $toIterator(binders)) {
											r_5529 += this.printStatement(bind) + ';\n' + this.tabs;
										} };
									};
									{
										let step_5535 = 0;
										const guard = guards[i_5530];
										if (step_5535 == 0 && guard != null) { step_5535 = 1 };
										if (step_5535 == 1) {
											this.pushTab();
											r_5529 += 'if (' + this.printExpression(guard) + ') {\n' + this.tabs;
										};
									};
									r_5529 += this.printStatement(statements[i_5530]);
									this.popTab();
									{
										let step_5536 = 0;
										const guard_5537 = guards[i_5530];
										if (step_5536 == 0 && guard_5537 != null) { step_5536 = 1 };
										if (step_5536 == 1) {
											this.popTab();
											r_5529 += '\n\t' + this.tabs + 'break; } }\n' + this.tabs;
										} else {
											r_5529 += '\n' + this.tabs + '} break;\n' + this.tabs;
										};
									};
								};
							};
						};
					};
					{
						let i_5538 = 0;
						let it_5539 = 0;
						let at_5540 = cases.length;
						while (it_5539 < at_5540) {
							i_5538 = it_5539;
							it_5539++;
							{
								if (cases[i_5538].length == 0) {
									r_5529 += '\n' + this.tabs + 'default: ';
									r_5529 += '\n' + this.tabs;
									r_5529 += this.printStatement(statements[i_5538]);
									r_5529 += '\n' + this.tabs;
								};
							};
						};
					};
					return r_5529 + '}';
				}
			} break;
			
			case null: case undefined: {
				console.error('Got null statement kind in JavaScript generator, probably unsupported feature was used, ignoring')
			} break;
			
			default: 
			console.error('Unknown statement kind:', s_5493)
			};
		};
		return '{/* undefined */}';
	};
		printCallArguments(args_5541) { return '(' + (() => {
		const result = [];
		const value_5542 = args_5541;
		for (const a of $toIterator(value_5542)) result.push(this.printExpression(a));
		return result;
	})().join(', ') + ')' };
		printFunctionArguments(args_5543, defaults_5544) { return '(' + (() => {
		const result_5545 = [];
		const value_5546 = args_5543.length;
		for (const a of $toIterator(value_5546)) result_5545.push(args_5543[a] + ((((defaults_5544 != null && defaults_5544[a] != null))? (' = ' + this.printExpression(defaults_5544[a])) : '')));
		return result_5545;
	})().join(', ') + ')' };
		printExpression(e_5547) {
		{
			const temp_5548 = e_5547;
			switch (temp_5548&&temp_5548[0]) {
			case 7: {
				return 'null'
			} break;
			
			case 8: {
				return 'this'
			} break;
			
			case 6: {
				const name_5549 = temp_5548[1];
				return name_5549
			} break;
			
			case 1: {
				const v_5550 = temp_5548[1];
				return '' + v_5550
			} break;
			
			case 2: {
				const v_5551 = temp_5548[1];
				const meta = temp_5548[2];
				const type_5552 = temp_5548[3];
				return '' + v_5551 + 'n'
			} break;
			
			case 3: {
				const v_5553 = temp_5548[1];
				return '' + v_5553
			} break;
			
			case 0: {
				const s_5554 = temp_5548[1];
				{
					const s_5555 = s_5554.split('');
					const charsOut = [];
					while (s_5555.length > 0) {
						const temp_5556 = s_5555[0];
						switch (temp_5556) {
						case '\'': {
							{
								charsOut.push('\\');
								charsOut.push('\'');
								s_5555.shift();
							}
						} break;
						
						case '\n': {
							{
								charsOut.push('\\n');
								s_5555.shift();
							}
						} break;
						
						case '\r': {
							{
								charsOut.push('\\r');
								s_5555.shift();
							}
						} break;
						
						case '\\': {
							{
								s_5555.shift();
								if (s_5555[0] == '\'') {
									charsOut.push('\\\'');
									s_5555.shift();
								} else if (s_5555[0] == '"') {
									charsOut.push('\\"');
									s_5555.shift();
								} else if (s_5555[0] == '\\') {
									charsOut.push('\\\\');
									s_5555.shift();
								} else {
									charsOut.push('\\');
								};
							}
						} break;
						
						default: 
						{
							charsOut.push(s_5555[0]);
							s_5555.shift();
						}
						};
					};
					return '\'' + charsOut.join('') + '\'';
				}
			} break;
			
			case 4: {
				return 'true'
			} break;
			
			case 5: {
				return 'false'
			} break;
			
			case 9: {
				const expr_5557 = temp_5548[1];
				const name_5558 = temp_5548[2];
				{
					{
						const temp_5559 = expr_5557;
						switch (temp_5559&&temp_5559[0]) {
						case 1: {
							return '(' + this.printExpression(expr_5557) + ').' + name_5558
						} break;
						
						case 3: {
							return '(' + this.printExpression(expr_5557) + ').' + name_5558
						} break;
						};
					};
					return this.printExpression(expr_5557) + '.' + name_5558;
				}
			} break;
			
			case 10: {
				const e_5560 = temp_5548[1];
				const args_5561 = temp_5548[2];
				return this.printExpression(e_5560) + this.printCallArguments(args_5561)
			} break;
			
			case 13: {
				const name_5562 = temp_5548[1];
				const expr_5563 = temp_5548[2];
				const args_5564 = temp_5548[3];
				const defaults_5565 = temp_5548[4];
				{
					if (name_5562 == null) { return this.printFunctionArguments(args_5564, defaults_5565) + ' => ' + this.printBlock(expr_5563) };
					return '((() => { const ' + name_5562 + ' = ' + this.printFunctionArguments(args_5564, defaults_5565) + ' => ' + this.printBlock(expr_5563) + '; return ' + name_5562 + ' })())';
				}
			} break;
			
			case 14: {
				const expr_5566 = temp_5548[1];
				const args_5567 = temp_5548[2];
				const defaults_5568 = temp_5548[3];
				return this.printFunctionArguments(args_5567, defaults_5568) + ' => (' + this.printExpression(expr_5566) + ')'
			} break;
			
			case 11: {
				const e_5569 = temp_5548[1];
				const args_5570 = temp_5548[2];
				return 'new ' + this.printExpression(e_5569) + this.printCallArguments(args_5570)
			} break;
			
			case 17: {
				const el_5571 = temp_5548[1];
				return '[' + (() => {
					const result_5572 = [];
					const value_5573 = el_5571;
					for (const a of $toIterator(value_5573)) result_5572.push(this.printExpression(a));
					return result_5572;
				})().join(', ') + ']'
			} break;
			
			case 19: {
				const op_5574 = temp_5548[1];
				const postfix = temp_5548[2];
				const e_5575 = temp_5548[3];
				{
					if (postfix) { return '(' + this.printExpression(e_5575) + Token.stringify(op_5574) + ')' };
					return '(' + Token.stringify(op_5574) + this.printExpression(e_5575) + ')';
				}
			} break;
			
			case 20: {
				const nullable = temp_5548[1];
				const othewise = temp_5548[2];
				return '((' + this.printExpression(nullable) + ') || (' + this.printExpression(othewise) + '))'
			} break;
			
			case 15: {
				const e_5576 = temp_5548[1];
				return '(' + this.printExpression(e_5576) + ')'
			} break;
			
			case 12: {
				const a_5577 = temp_5548[1];
				const op_5578 = temp_5548[2];
				const b = temp_5548[3];
				{
					const bn = (this.bi++);
					return '' + this.printExpression(a_5577) + ' ' + Token.stringify(op_5578) + ' ' + this.printExpression(b) + '';
				}
			} break;
			
			case 22: {
				const expr_5579 = temp_5548[1];
				const index = temp_5548[2];
				return this.printExpression(expr_5579) + '[' + this.printExpression(index) + ']'
			} break;
			
			case 21: {
				const econd_5580 = temp_5548[1];
				const eif_5581 = temp_5548[2];
				const eelse_5582 = temp_5548[3];
				{
					let r_5583 = '';
					try {
						r_5583 += '((' + this.printExpression(econd_5580) + ')?';
						r_5583 += ' (' + this.printExpression(eif_5581) + ')';
						r_5583 += ' : ' + this.printExpression(eelse_5582);
						return r_5583 + ')';
					} catch (temp_5584) {
						if (true) { 
						const error = temp_5584
						{
							console.log('If =>', e_5547, error);
							return r_5583 + '<!--If => error-->';
						} } else
						
						throw temp_5584;
					};
				}
			} break;
			
			case 27: {
				const expr_5585 = temp_5548[1];
				{
					const e_5586 = this.printExpression(expr_5585);
					return e_5586 + '&&' + e_5586 + '[0]';
				}
			} break;
			
			case 16: {
				const names = temp_5548[1];
				const el_5587 = temp_5548[2];
				return '{' + (() => {
					const result_5588 = [];
					const value_5589 = el_5587.length;
					for (const i of $toIterator(value_5589)) result_5588.push(((names[i]) + ':' + this.printExpression(el_5587[i])));
					return result_5588;
				})().join(', ') + '}'
			} break;
			
			case 18: {
				const keys = temp_5548[1];
				const values = temp_5548[2];
				{
					if (keys.length == 0) { return 'new Map()' };
					return 'new Map([' + (() => {
						const result_5590 = [];
						const value_5591 = keys.length;
						for (const i of $toIterator(value_5591)) result_5590.push('[' + this.printExpression(keys[i]) + ', ' + this.printExpression(values[i]) + ']');
						return result_5590;
					})().join(', ') + '])';
				}
			} break;
			
			case 25: {
				const a_5592 = temp_5548[1];
				const op_5593 = temp_5548[2];
				const value_5594 = temp_5548[3];
				return this.printExpression(a_5592) + ' ' + Token.stringify(op_5593) + '= ' + this.printExpression(value_5594)
			} break;
			
			case 26: {
				const kind = temp_5548[1];
				const args_5595 = temp_5548[2];
				const s_5596 = temp_5548[3];
				{
					const temp_5597 = kind;
					switch (temp_5597) {
					case 0: {
						return '((' + this.printExpression(args_5595[0]) + ') ' + s_5596 + ' (' + this.printExpression(args_5595[1]) + '))'
					} break;
					
					case 1: {
						return s_5596 + this.printCallArguments(args_5595)
					} break;
					
					case 2: {
						return '(' + s_5596 + '(' + this.printExpression(args_5595[0]) + '))'
					} break;
					
					case 3: {
						return '((' + this.printExpression(args_5595[1]) + ')' + s_5596 + ')'
					} break;
					};
				}
			} break;
			
			case 23: {
				const e_5598 = temp_5548[1];
				const t_5599 = temp_5548[2];
				return '(' + this.printExpression(e_5598) + ')'
			} break;
			
			case 24: {
				const e_5600 = temp_5548[1];
				const t_5601 = temp_5548[2];
				return '((' + this.printExpression(e_5600) + ') instanceof ' + Type.stringify(t_5601) + ')'
			} break;
			
			case 28: {
				const type_5602 = temp_5548[1];
				const tagName = temp_5548[2];
				const tag = temp_5548[3];
				const args_5603 = temp_5548[4];
				{
					if (args_5603.length == 0) { return ('/*' + (tagName) + '*/[') + this.printExpression(tag) + ']' };
					const i_5604 = 1;
					return (('/*' + (tagName) + '*/[') + this.printExpression(tag) + ',' + (() => {
						const result_5605 = [];
						const value_5606 = args_5603;
						for (const a of $toIterator(value_5606)) result_5605.push(this.printExpression(a));
						return result_5605;
					})().join(',') + ',".' + tagName + '"]');
				}
			} break;
			
			case 29: {
				const expr_5607 = temp_5548[1];
				const index_5608 = temp_5548[2];
				return this.printExpression(expr_5607) + '[' + (1 + index_5608) + ']'
			} break;
			
			case null: case undefined: {
				console.error('Got null expression kind in JavaScript generator, probably unsupported feature was used, ignoring')
			} break;
			
			default: 
			console.error('Unknown expression kind:', e_5547)
			};
		};
		return '{/* undefined */}';
	};
	}
	GenJs.spawn = () => { return new GenJs() };
	var GenCxx = class {
		constructor() { 
			this.globalAccessor = ''
			this.declarationsOfFunctions = []
			this.declarationsOfOpaqueTypes = []
			this.declarationsOfFullTypes = []
			this.declarationsOfStringsMap = new Map()
			this.declarationsOfStrings = []
			this.forwardFunctions = []
			this.typedefFunctions = []
			this.globalVariables = []
			this.globalFunctions = []
			this.types = []
			this.tabs = ''
			this.reserved = []
			this.currentReturnType = null
			this.metaBlock = []
			this.tempId = 0
			this.last = ('')
			this.thisArgument = null
			this.customThis = null
		{
	} };
		perform(normalizer) {
		this.project = normalizer;
		return this.stringify();
	};
		stringify() {
		const header = [('// Generated by Hexa ' + (version) + ' https://hexalang.github.io')];
		if (this.project.package.addLicenseNoticeToOutput) {
			header.push(('// Project: ' + (this.project.package.name) + ''));
			header.push(('// LICENSE ' + (this.project.package.license) + ''));
		} else {
			header.push('// The generated code is subject to the original license');
		};
		header.push(Fs.readFileSync(__dirname + '/library/cxx/hexa.c').toString('utf8').split('\r\n').join('\n'));
		header.push('#ifdef __cplusplus');
		header.push('extern "C" {');
		header.push('#endif');
		const out = [];
		const forward = [];
		this.registerString('');
		this.declarationsOfStringsMap.set('', 0);
		this.registerString('null');
		this.declarationsOfStringsMap.set('null', 1);
		for (const e of $toIterator(this.project.enumsSimple)) {
			forward.push('struct ' + e.name + '_;');
			if (e.staticVars.length + e.staticMethods.length == 0) { continue };
			this.types.push(e.name + '_ {\n\t');
			for (const v of $toIterator(e.staticVars)) {
				const temp = v;
				switch (temp&&temp[0]) {
				case 3: {
					const name = temp[1];
					const expr = temp[2];
					const type = temp[3];
					this.globalVariables.push(('' + (this.stringifyType(type, false)) + ' ') + e.name + '_$' + name + '_;\n')
				} break;
				
				case 4: {
					const name_5609 = temp[1];
					const expr_5610 = temp[2];
					const type_5611 = temp[3];
					this.globalVariables.push(('' + (this.stringifyType(type_5611, false)) + ' ') + e.name + '_$' + name_5609 + '_;\n')
				} break;
				};
			};
			this.types.push('\n};\n');
			for (const v of $toIterator(e.staticMethods)) {
				const temp_5612 = v;
				switch (temp_5612&&temp_5612[0]) {
				case 5: {
					const name_5613 = temp_5612[1];
					const expr_5614 = temp_5612[2];
					const args = temp_5612[3];
					const defaults = temp_5612[4];
					const funcType = temp_5612[5];
					{
						this.forwardFunctions.push(this.printFunctionReturnType(funcType));
						this.forwardFunctions.push(' ' + e.name + '_$' + name_5613 + '_');
						this.forwardFunctions.push(this.printFunctionArguments(args, funcType, false));
						this.forwardFunctions.push(';\n');
						out.push(this.printFunctionReturnType(funcType));
						out.push(' ' + e.name + '_$' + name_5613 + '_');
						out.push(this.printFunctionArguments(args, funcType, false));
						const _currentReturnType = this.currentReturnType;
						this.currentReturnType = this.getFunctionReturnType(funcType);
						out.push(' ' + this.printBlock(expr_5614) + ';\n\n');
						this.currentReturnType = _currentReturnType;
					}
				} break;
				};
			};
		};
		for (const e of $toIterator(this.project.enumsComplex)) {
			forward.push('struct ' + e.name + '_;');
			this.types.push(e.name + '_ : Unknown_ {\n\t');
			this.types.push('\n\tAny_** enum_;');
			this.types.push('\n\tuint16_t is_;');
			this.types.push('\n\tuint8_t length_;');
			let i = 0;
			for (const name of $toIterator(e.names)) {
				if (e.constructors[i] != null) {
					out.push(e.name + '_* ' + e.name + '_$' + name + '_(');
					out.push((() => {
						const result = [];
						const value = e.constructors[i].length;
						for (const c of $toIterator(value)) result.push(this.stringifyType(e.constructorsTypes[i][c], false) + ' ' + e.constructors[i][c] + '_');
						return result;
					})().join(', '));
					out.push(') {\n');
					out.push('\t' + e.name + '_* _ = (' + e.name + '_*)(HEXA_NEW(sizeof(' + e.name + '_)));\n');
					out.push(('\t_->length_ = ' + (e.constructors[i].length) + ';\n'));
					out.push(('\t_->enum_ = (Any_**)(HEXA_NEW(sizeof(Any_*) * ' + (e.constructors[i].length) + '));\n'));
					out.push(('\t_->is_ = ' + (i) + ';\n'));
					{
						let c = 0;
						let it = 0;
						let at = e.constructors[i].length;
						while (it < at) {
							c = it;
							it++;
							{
								out.push(('\t_->enum_[' + (c) + '] = '));
								out.push(this.printToAnyConverter(e.constructors[i][c] + '_', e.constructorsTypes[i][c]));
								out.push(';\n');
							};
						};
					};
					out.push('\treturn _;\n');
					out.push('};\n');
				} else {
					out.push(e.name + '_* ' + e.name + '_$' + name + '_() {\n');
					out.push('\t' + e.name + '_* _ = (' + e.name + '_*)(HEXA_NEW(sizeof(' + e.name + '_)));\n');
					out.push('\t_->length_ = 0;\n');
					out.push(('\t_->is_ = ' + (i) + ';\n'));
					out.push('\treturn _;\n');
					out.push('};\n');
				};
				i++;
			};
			for (const v of $toIterator(e.staticVars)) {
				const temp_5615 = v;
				switch (temp_5615&&temp_5615[0]) {
				case 3: {
					const name_5616 = temp_5615[1];
					const expr_5617 = temp_5615[2];
					const type_5618 = temp_5615[3];
					this.globalVariables.push(('' + (this.stringifyType(type_5618, false)) + ' ') + e.name + '_$' + name_5616 + '_;\n')
				} break;
				
				case 4: {
					const name_5619 = temp_5615[1];
					const expr_5620 = temp_5615[2];
					const type_5621 = temp_5615[3];
					this.globalVariables.push(('' + (this.stringifyType(type_5621, false)) + ' ') + e.name + '_$' + name_5619 + '_;\n')
				} break;
				};
			};
			for (const v of $toIterator(e.staticMethods)) {
				const temp_5622 = v;
				switch (temp_5622&&temp_5622[0]) {
				case 5: {
					const name_5623 = temp_5622[1];
					const expr_5624 = temp_5622[2];
					const args_5625 = temp_5622[3];
					const defaults_5626 = temp_5622[4];
					const funcType_5627 = temp_5622[5];
					{
						this.forwardFunctions.push(this.printFunctionReturnType(funcType_5627));
						this.forwardFunctions.push(' ' + e.name + '_$' + name_5623 + '_');
						this.forwardFunctions.push(this.printFunctionArguments(args_5625, funcType_5627, false));
						this.forwardFunctions.push(';\n');
						out.push(this.printFunctionReturnType(funcType_5627));
						out.push(' ' + e.name + '_$' + name_5623 + '_');
						out.push(this.printFunctionArguments(args_5625, funcType_5627, false));
						const _currentReturnType_5628 = this.currentReturnType;
						this.currentReturnType = this.getFunctionReturnType(funcType_5627);
						out.push(' ' + this.printBlock(expr_5624) + ';\n\n');
						this.currentReturnType = _currentReturnType_5628;
					}
				} break;
				};
			};
			this.types.push('\n};\n');
		};
		for (const c of $toIterator(this.project.classes)) {
			if (c.external) {
				if (c.jsRequire != null) { forward.push(c.jsRequire) };
				{
					let step = 0;
					const jsNative = c.jsNative;
					let temp_5629 = null;
					if (step == 0 && jsNative != null) {
						temp_5629 = jsNative != c.name;
						step = 1;
					};
					if (step == 1 && temp_5629 != false) { step = 2 };
					if (step == 2) { forward.push('#define ' + c.name + ' ' + jsNative) };
				};
				continue;
			};
			if (c.name == 'Any') { continue };
			if (c.name == 'Bool') { continue };
			if (c.useless) {};
			if (c.template) {
				console.log('template', c.name);
				continue;
			};
			forward.push('struct ' + c.name + '_;');
			forward.push(('typedef struct ' + (c.name) + '_ ' + (c.name) + '_;'));
			this.types.push('struct ' + c.name + '_ {\n\t');
			const vtable = ['struct ' + c.name + '__ {\n\t'];
			this.types.push('\n\tconst struct ' + c.name + '__ * const _;');
			const vtableValue = ['const struct ' + c.name + '__ ' + c.name + '__$ = {\n\t'];
			const vtableBind = [];
			for (const v of $toIterator(c.vars)) {
				const temp_5630 = v;
				switch (temp_5630&&temp_5630[0]) {
				case 3: {
					const name_5631 = temp_5630[1];
					const expr_5632 = temp_5630[2];
					const type_5633 = temp_5630[3];
					this.types.push(('\n\t' + (this.stringifyType(type_5633, false)) + ' ') + name_5631 + '_;')
				} break;
				
				case 4: {
					const name_5634 = temp_5630[1];
					const expr_5635 = temp_5630[2];
					const type_5636 = temp_5630[3];
					this.types.push(('\n\t' + (this.stringifyType(type_5636, false)) + ' ') + name_5634 + '_;')
				} break;
				};
			};
			let nonEmptyTable = false;
			for (const v of $toIterator(c.methods)) {
				const temp_5637 = v;
				switch (temp_5637&&temp_5637[0]) {
				case 5: {
					const name_5638 = temp_5637[1];
					const expr_5639 = temp_5637[2];
					const args_5640 = temp_5637[3];
					const defaults_5641 = temp_5637[4];
					const funcType_5642 = temp_5637[5];
					if (name_5638 == null || name_5638 == 'new') {
						this.forwardFunctions.push(c.name + '_* ' + c.name + '_$new_');
						this.forwardFunctions.push(this.printFunctionArguments(args_5640, funcType_5642, false));
						this.forwardFunctions.push(';\n');
						out.push('void ' + c.name + '_$this_');
						this.thisArgument = c.name + '_* $this';
						out.push(this.printFunctionArguments(args_5640, funcType_5642, false));
						this.thisArgument = null;
						out.push(' {\n');
						this.customThis = '$this';
						for (const v of $toIterator(c.vars)) {
							const temp_5643 = v;
							switch (temp_5643&&temp_5643[0]) {
							case 3: {
								const name_5644 = temp_5643[1];
								const expr_5645 = temp_5643[2];
								const type_5646 = temp_5643[3];
								if (expr_5645 != null) { out.push('\t$this->' + name_5644 + '_ = ' + this.printExpression(expr_5645) + ';\n') }
							} break;
							
							case 4: {
								const name_5647 = temp_5643[1];
								const expr_5648 = temp_5643[2];
								const type_5649 = temp_5643[3];
								out.push('\t$this->' + name_5647 + '_ = ' + this.printExpression(expr_5648) + ';\n')
							} break;
							};
						};
						this.pushTab();
						{
							const temp_5650 = expr_5639;
							switch (temp_5650&&temp_5650[0]) {
							case 1: {
								const el = temp_5650[1];
								if (el.length > 0) { out.push('\t' + this.printBlock(expr_5639) + ';\n') }
							} break;
							
							default: 
							out.push('\t' + this.printBlock(expr_5639) + ';\n')
							};
						};
						this.popTab();
						this.customThis = null;
						out.push('};\n\n');
						out.push(c.name + '_* ' + c.name + '_$new_');
						out.push(this.printFunctionArguments(args_5640, funcType_5642, false));
						out.push(' {\n');
						out.push('\tvoid** $_ = (void**)(HEXA_NEW(sizeof(' + c.name + '_)));\n');
						out.push('\t$_[0] = (void *)&' + c.name + '__$;\n');
						out.push('\t' + c.name + '_* _ = (' + c.name + '_*)($_);\n');
						out.push('\t' + c.name + '_$this_(');
						const arg = (() => {
							const result_5651 = [];
							const value_5652 = args_5640;
							for (const a of $toIterator(value_5652)) result_5651.push(a + '_');
							return result_5651;
						})();
						arg.unshift('_');
						out.push(arg.join(', '));
						out.push(');\n');
						out.push('\treturn _;\n');
						out.push('};\n\n');
					} else {
						this.thisArgument = c.name + '_* $this';
						vtable.push('\n\t');
						vtable.push(this.printFunctionReturnType(funcType_5642));
						vtable.push(' (*const ' + name_5638 + '_) ');
						vtable.push(this.printFunctionArguments(args_5640, funcType_5642, false));
						vtable.push(';');
						nonEmptyTable = true;
						this.forwardFunctions.push(this.printFunctionReturnType(funcType_5642));
						this.forwardFunctions.push(' ' + c.name + '_$' + name_5638 + '_');
						this.forwardFunctions.push(this.printFunctionArguments(args_5640, funcType_5642, false));
						this.forwardFunctions.push(';\n');
						const vbind = '&' + c.name + '_$' + name_5638 + '_';
						vtableBind.push(vbind);
						out.push(this.printFunctionReturnType(funcType_5642));
						out.push(' ' + c.name + '_$' + name_5638 + '_');
						out.push(this.printFunctionArguments(args_5640, funcType_5642, false));
						const _currentReturnType_5653 = this.currentReturnType;
						this.currentReturnType = this.getFunctionReturnType(funcType_5642);
						this.customThis = '$this';
						this.thisArgument = null;
						out.push(' ' + this.printBlock(expr_5639) + ';\n\n');
						this.customThis = null;
						this.currentReturnType = _currentReturnType_5653;
						this.currentReturnType = _currentReturnType_5653;
					}
				} break;
				};
			};
			if (nonEmptyTable == false) { vtable.push('uint8_t padding_;') };
			for (const v of $toIterator(c.staticVars)) {
				const temp_5658 = v;
				switch (temp_5658&&temp_5658[0]) {
				case 3: {
					const name_5659 = temp_5658[1];
					const expr_5660 = temp_5658[2];
					const type_5661 = temp_5658[3];
					this.globalVariables.push(('' + (this.stringifyType(type_5661, false)) + ' ') + c.name + '_$' + name_5659 + '_;\n')
				} break;
				
				case 4: {
					const name_5662 = temp_5658[1];
					const expr_5663 = temp_5658[2];
					const type_5664 = temp_5658[3];
					this.globalVariables.push(('' + (this.stringifyType(type_5664, false)) + ' ') + c.name + '_$' + name_5662 + '_;\n')
				} break;
				};
			};
			this.types.push('\n};\n');
			vtable.push('\n};\n');
			vtableValue.push(vtableBind.join(',\n\t'));
			vtable.push(vtableValue.join('') + '\n};\n');
			this.types.unshift(vtable.join(''));
			for (const v of $toIterator(c.staticMethods)) {
				const temp_5665 = v;
				switch (temp_5665&&temp_5665[0]) {
				case 5: {
					const name_5666 = temp_5665[1];
					const expr_5667 = temp_5665[2];
					const args_5668 = temp_5665[3];
					const defaults_5669 = temp_5665[4];
					const funcType_5670 = temp_5665[5];
					{
						this.forwardFunctions.push(this.printFunctionReturnType(funcType_5670));
						this.forwardFunctions.push(' ' + c.name + '_$' + name_5666 + '_');
						this.forwardFunctions.push(this.printFunctionArguments(args_5668, funcType_5670, false));
						this.forwardFunctions.push(';\n');
						out.push(this.printFunctionReturnType(funcType_5670));
						out.push(' ' + c.name + '_$' + name_5666 + '_');
						out.push(this.printFunctionArguments(args_5668, funcType_5670, false));
						const _currentReturnType_5671 = this.currentReturnType;
						this.currentReturnType = this.getFunctionReturnType(funcType_5670);
						out.push(' ' + this.printBlock(expr_5667) + ';\n\n');
						this.currentReturnType = _currentReturnType_5671;
					}
				} break;
				};
			};
		};
		for (const g of $toIterator(this.project.globalFuncs)) {
			const temp_5672 = g;
			switch (temp_5672&&temp_5672[0]) {
			case 5: {
				const name_5673 = temp_5672[1];
				const expr_5674 = temp_5672[2];
				const args_5675 = temp_5672[3];
				const defaults_5676 = temp_5672[4];
				const funcType_5677 = temp_5672[5];
				{
					this.types.push(this.printFunctionReturnType(funcType_5677));
					this.types.push(' ' + name_5673 + '_');
					this.types.push(this.printFunctionArguments(args_5675, funcType_5677, false));
					this.types.push(';\n');
					out.push(this.printFunctionReturnType(funcType_5677));
					out.push(' ' + name_5673 + '_');
					out.push(this.printFunctionArguments(args_5675, funcType_5677, false));
					const _currentReturnType_5678 = this.currentReturnType;
					this.currentReturnType = this.getFunctionReturnType(funcType_5677);
					out.push(' ' + this.printBlock(expr_5674) + ';\n\n');
					this.currentReturnType = _currentReturnType_5678;
				}
			} break;
			};
		};
		out.push('int HEXA_MAIN(int argc, char **argv) {\n');
		out.push('%%%HEXA_STRINGS@@@\n');
		this.pushTab();
		for (const e of $toIterator(this.project.enumsSimple)) {
			for (const v of $toIterator(e.staticVars)) {
				const temp_5679 = v;
				switch (temp_5679&&temp_5679[0]) {
				case 3: {
					const name_5680 = temp_5679[1];
					const expr_5681 = temp_5679[2];
					const type_5682 = temp_5679[3];
					if (expr_5681 != null) { out.push('\t' + e.name + '_$' + name_5680 + '_ = ' + this.printExpression(expr_5681) + ';\n') }
				} break;
				
				case 4: {
					const name_5683 = temp_5679[1];
					const expr_5684 = temp_5679[2];
					const type_5685 = temp_5679[3];
					if (expr_5684 != null) { out.push('\t' + e.name + '_$' + name_5683 + '_ = ' + this.printExpression(expr_5684) + ';\n') }
				} break;
				};
			};
		};
		for (const e of $toIterator(this.project.enumsComplex)) {
			for (const v of $toIterator(e.staticVars)) {
				const temp_5686 = v;
				switch (temp_5686&&temp_5686[0]) {
				case 3: {
					const name_5687 = temp_5686[1];
					const expr_5688 = temp_5686[2];
					const type_5689 = temp_5686[3];
					if (expr_5688 != null) { out.push('\t' + e.name + '_$' + name_5687 + '_ = ' + this.printExpression(expr_5688) + ';\n') }
				} break;
				
				case 4: {
					const name_5690 = temp_5686[1];
					const expr_5691 = temp_5686[2];
					const type_5692 = temp_5686[3];
					if (expr_5691 != null) { out.push('\t' + e.name + '_$' + name_5690 + '_ = ' + this.printExpression(expr_5691) + ';\n') }
				} break;
				};
			};
		};
		for (const e of $toIterator(this.project.classes)) {
			for (const v of $toIterator(e.staticVars)) {
				const temp_5693 = v;
				switch (temp_5693&&temp_5693[0]) {
				case 3: {
					const name_5694 = temp_5693[1];
					const expr_5695 = temp_5693[2];
					const type_5696 = temp_5693[3];
					if (expr_5695 != null) { out.push('\t' + e.name + '_$' + name_5694 + '_ = ' + this.printExpression(expr_5695) + ';\n') }
				} break;
				
				case 4: {
					const name_5697 = temp_5693[1];
					const expr_5698 = temp_5693[2];
					const type_5699 = temp_5693[3];
					if (expr_5698 != null) { out.push('\t' + e.name + '_$' + name_5697 + '_ = ' + this.printExpression(expr_5698) + ';\n') }
				} break;
				};
			};
		};
		for (const g of $toIterator(this.project.globalVars)) {
			const temp_5700 = g;
			switch (temp_5700&&temp_5700[0]) {
			case 3: {
				const name_5701 = temp_5700[1];
				const expr_5702 = temp_5700[2];
				const type_5703 = temp_5700[3];
				{
					this.globalVariables.push(this.stringifyType(type_5703, false));
					this.globalVariables.push(' ' + name_5701 + '_;\n');
					if (expr_5702 != null) { out.push('\t' + name_5701 + '_ = ' + this.printExpression(expr_5702) + ';\n') };
				}
			} break;
			
			case 4: {
				const name_5704 = temp_5700[1];
				const expr_5705 = temp_5700[2];
				const type_5706 = temp_5700[3];
				{
					this.globalVariables.push(this.stringifyType(type_5706, false));
					this.globalVariables.push(' ' + name_5704 + '_;\n');
					if (expr_5705 != null) { out.push('\t' + name_5704 + '_ = ' + this.printExpression(expr_5705) + ';\n') };
				}
			} break;
			};
		};
		if (this.project.init.length > 1) { throw 'project.init.length > 1' };
		const init_5707 = this.printStatement(this.project.init[0]);
		const strings = ['\tString_$root_ = String_$new_();\n'];
		{
			let id = 0;
			let it_5708 = 0;
			let at_5709 = this.declarationsOfStrings.length;
			while (it_5708 < at_5709) {
				id = it_5708;
				it_5708++;
				{
					strings.push(('\tString_' + (id) + ' = String_$fromUTF16z_((const uint16_t*)String_' + (id) + '_);\n'));
					forward.push(('String_* String_' + (id) + '; static const wchar_t *String_' + (id) + '_ = L\"' + (this.declarationsOfStrings[id]) + '\";'));
				};
			};
		};
		out.push('\t');
		out.push(init_5707);
		this.popTab();
		out.push('\tfflush(stdout);\n');
		out.push('\treturn 0;\n}\n');
		out.push('#ifdef __cplusplus\n');
		out.push('}\n');
		out.push('#endif\n');
		return (header.join('\n') + '\n// Forward\n' + forward.join('\n') + '\n// Typedef functions\n' + this.typedefFunctions.join('') + '\n// Forward functions\n' + this.forwardFunctions.join('') + '\n// Types\n' + this.types.join('') + '\n// Global variables\n' + this.globalVariables.join('') + '\n// Global functions\n' + this.globalFunctions.join('') + '// Statements\n' + out.join('').split('%%%HEXA_STRINGS@@@').join(strings.join(''))).split('\n').join('\r\n');
	};
		pushTab() { this.tabs += '\t' };
		popTab() { this.tabs = this.tabs.substring(0, this.tabs.length - 1) };
		printBlock(s) {
		const temp_5743 = s;
		switch (temp_5743&&temp_5743[0]) {
		case 1: {
			const el_5744 = temp_5743[1];
			return this.printStatement(s)
		} break;
		
		default: 
		return this.printStatement(/*Block*/[1,[s],".Block"])
		};
	};
		printStatement(s_5746) {
		this.last = (() => {
			const result_5747 = s_5746;
			if (result_5747 != null) { return result_5747 };
			return this.last;
		})();
		{
			const temp_5748 = s_5746;
			switch (temp_5748&&temp_5748[0]) {
			case 0: {
				const els = temp_5748[1];
				{
					let r = '';
					for (const s of $toIterator(els)) {
						if (s != null) { r += '\n' + this.tabs + this.printStatement(s) + ';' };
					};
					return r;
				}
			} break;
			
			case 18: {
				return 'break'
			} break;
			
			case 17: {
				return 'continue'
			} break;
			
			case 1: {
				const el_5749 = temp_5748[1];
				{
					if (el_5749.length == 0) { return '{}' };
					this.pushTab();
					const printMetaBlock = (e) => {
						const meta = this.metaBlock;
						this.metaBlock = [];
						const ss = this.printStatement(e);
						const r_5750 = [];
						for (const line of $toIterator(this.metaBlock)) {
							r_5750.push(line);
						};
						r_5750.push(ss);
						this.metaBlock = meta;
						return r_5750.join(';\n' + this.tabs);
					};
					let r_5751 = '{';
					for (const e of $toIterator(el_5749)) {
						const temp_5752 = e;
						switch (temp_5752&&temp_5752[0]) {
						case null: case undefined: {
							{
							}
						} break;
						
						case 0: {
							const els_5753 = temp_5752[1];
							for (const s of $toIterator(els_5753)) {
								if (s != null) { r_5751 += '\n' + this.tabs + printMetaBlock(s) + ';' };
							}
						} break;
						
						default: 
						r_5751 += '\n' + this.tabs + printMetaBlock(e) + ';'
						};
					};
					this.popTab();
					return r_5751 + '\n' + this.tabs + '}';
				}
			} break;
			
			case 4: {
				const name_5754 = temp_5748[1];
				const expr_5755 = temp_5748[2];
				const type_5756 = temp_5748[3];
				return this.printStatement(/*Var*/[3,name_5754,expr_5755,type_5756,".Var"])
			} break;
			
			case 3: {
				const name_5757 = temp_5748[1];
				const expr_5758 = temp_5748[2];
				const type_5759 = temp_5748[3];
				{
					{
						const temp_5760 = type_5759;
						switch (temp_5760&&temp_5760[0]) {
						case 6: {
							const type_5761 = temp_5760[1];
							const generics = temp_5760[2];
							{
								let arraySize = '';
								if (type_5761.name == 'ArrayByValue') {
									{
										let step_5762 = 0;
										const count = generics[1];
										if (step_5762 == 0 && count != null) { step_5762 = 1 };
										if (step_5762 == 1) { arraySize = '[' + Type.stringify(count) + ']' } else {
											arraySize = '[]';
										};
									};
									{
										const temp_5763 = expr_5758;
										switch (temp_5763&&temp_5763[0]) {
										case 17: {
											const el_5764 = temp_5763[1];
											{
												const valueType = generics[0];
												return this.stringifyType(valueType, false) + ' ' + name_5757 + '_' + arraySize + ' = {' + (() => {
													const result_5765 = [];
													const value_5766 = el_5764;
													for (const a of $toIterator(value_5766)) result_5765.push(this.printTypeConverter(this.printExpression(a), this.getType(a), valueType));
													return result_5765;
												})().join(', ') + '}';
											}
										} break;
										
										case null: case undefined: {
											throw 'Array initializer required'
										} break;
										};
									};
								};
							}
						} break;
						};
					};
					return this.stringifyType(type_5759, false) + ' ' + name_5757 + '_' + (((expr_5758 == null)? ('') : ' = ' + this.printTypeConverter(this.printExpression(expr_5758), this.getType(expr_5758), type_5759)));
				}
			} break;
			
			case 5: {
				const name_5767 = temp_5748[1];
				const expr_5768 = temp_5748[2];
				const args_5769 = temp_5748[3];
				const defaults_5770 = temp_5748[4];
				const funcType_5771 = temp_5748[5];
				{
					const _currentReturnType_5772 = this.currentReturnType;
					this.currentReturnType = this.getFunctionReturnType(funcType_5771);
					const temp_5773 = (this.tempId++);
					const rt = this.printFunctionReturnType(funcType_5771);
					this.forwardFunctions.push(rt);
					this.forwardFunctions.push((' _$' + (temp_5773) + ''));
					this.forwardFunctions.push(this.printFunctionArguments(args_5769, funcType_5771, false));
					this.forwardFunctions.push(';\n');
					const tab = this.tabs;
					this.tabs = '';
					this.globalFunctions.push(rt);
					this.globalFunctions.push((' _$' + (temp_5773) + ''));
					this.globalFunctions.push(this.printFunctionArguments(args_5769, funcType_5771, true));
					this.globalFunctions.push(' ');
					this.globalFunctions.push(this.printBlock(expr_5768));
					this.tabs = tab;
					this.currentReturnType = _currentReturnType_5772;
					return this.stringifyType(funcType_5771, false) + (' ' + (name_5767) + '_ = _$' + (temp_5773) + '');
				}
			} break;
			
			case 6: {
				const e_5774 = temp_5748[1];
				{
					if (e_5774 == null) { return 'return' };
					return 'return ' + this.printTypeConverter(this.printExpression(e_5774), this.getType(e_5774), this.currentReturnType);
				}
			} break;
			
			case 7: {
				const econd = temp_5748[1];
				const eif = temp_5748[2];
				const eelse = temp_5748[3];
				{
					let r_5775 = ('\n' + (this.tabs) + 'if (') + this.printExpression(econd) + ') ' + this.printBlock(eif);
					if (eelse != null) { r_5775 += ' else ' + this.printStatement(eelse) };
					return r_5775;
				}
			} break;
			
			case 2: {
				const e_5776 = temp_5748[1];
				const args_5777 = temp_5748[2];
				const expects = temp_5748[3];
				const kind = temp_5748[4];
				{
					{
						const temp_5778 = kind;
						switch (temp_5778) {
						case 12: {
							{
								const temp_5779 = e_5776;
								switch (temp_5779&&temp_5779[0]) {
								case 9: {
									const expr_5780 = temp_5779[1];
									const name_5781 = temp_5779[2];
									const result_5782 = temp_5779[3];
									{
										const temp_5783 = (this.tempId++);
										this.metaBlock.push(this.stringifyType(this.getType(expr_5780), false) + (' _$' + (temp_5783) + ' = ') + this.printExpression(expr_5780));
										return ('_$' + (temp_5783) + '->_->') + name_5781 + '_' + this.printCallArgumentsVirtual(('_$' + (temp_5783) + ''), args_5777, expects);
									}
								} break;
								};
							}
						} break;
						};
					};
					return this.printExpression(e_5776) + this.printCallArguments(args_5777, expects);
				}
			} break;
			
			case 8: {
				const expr_5784 = temp_5748[1];
				const t_5785 = temp_5748[2];
				const v = temp_5748[3];
				const catches = temp_5748[4];
				{
					this.pushTab();
					let r_5786 = '_try {\n' + this.tabs;
					r_5786 += 'struct Any_* $try = (struct Any_*)0;' + '\n' + this.tabs;
					r_5786 += this.printStatement(expr_5784);
					this.popTab();
					r_5786 += '\n' + this.tabs + '$catch: ; } _catch(' + this.printType(t_5785[0]) + ' _x' + v[0] + ') {\n' + this.tabs + ' ';
					this.pushTab();
					r_5786 += this.printStatement(catches[0]);
					this.popTab();
					return r_5786 + '\n' + this.tabs + '}';
				}
			} break;
			
			case 10: {
				const a = temp_5748[1];
				const v_5787 = temp_5748[2];
				{
					{
						const temp_5788 = a;
						switch (temp_5788&&temp_5788[0]) {
						case 9: {
							const expr_5789 = temp_5788[1];
							const name_5790 = temp_5788[2];
							{
								const type_5791 = this.getType(expr_5789);
								if ((type_5791 == this.project.typer.typeAny) || (type_5791 == null)) { return this.printExpression(expr_5789) + '->$set(String_$fromUTF16z_(L"' + name_5790 + '"), ' + this.printToAnyConverter(this.printExpression(v_5787), this.getType(v_5787)) + ')' };
							}
						} break;
						
						case 22: {
							const expr_5792 = temp_5788[1];
							const index = temp_5788[2];
							{
								const temp_5793 = this.getType(expr_5792);
								switch (temp_5793&&temp_5793[0]) {
								case 6: {
									const type_5794 = temp_5793[1];
									const generic = temp_5793[2];
									{
										if (type_5794.name != 'Array') { return this.printExpression(expr_5792) + '[' + this.printTypeConverter(this.printExpression(index), this.getType(index), this.project.typer.typeInt) + ']' + ' = ' + this.printExpression(v_5787) };
										return this.printExpression(/*Call*/[10,/*Dot*/[9,expr_5792,'set',null,".Dot"],[index, v_5787],[this.project.typer.typeInt, generic[0]],12,".Call"]);
									}
								} break;
								};
							}
						} break;
						};
					};
					return this.printExpression(a) + ' = ' + this.printExpression(v_5787);
				}
			} break;
			
			case 9: {
				const e_5795 = temp_5748[1];
				return '_throw(' + this.printExpression(e_5795) + ')'
			} break;
			
			case 12: {
				const name_5796 = temp_5748[1];
				const over = temp_5748[2];
				const by = temp_5748[3];
				return 'for (struct Any_* ' + name_5796 + '_; ' + this.printExpression(over) + ';) ' + this.printStatement(by)
			} break;
			
			case 14: {
				const e_5797 = temp_5748[1];
				return this.printExpression(e_5797) + '++'
			} break;
			
			case 15: {
				const e_5798 = temp_5748[1];
				return this.printExpression(e_5798) + '--'
			} break;
			
			case 13: {
				const econd_5799 = temp_5748[1];
				const e_5800 = temp_5748[2];
				const pre = temp_5748[3];
				{
					if (pre) { return ('\n' + (this.tabs) + 'while (') + this.printExpression(econd_5799) + ') ' + this.printStatement(e_5800) };
					return ('\n' + (this.tabs) + 'do {') + this.printStatement(e_5800) + '} while (' + this.printExpression(econd_5799) + ')';
				}
			} break;
			
			case 11: {
				const a_5801 = temp_5748[1];
				const op = temp_5748[2];
				const value_5802 = temp_5748[3];
				return this.printExpression(a_5801) + ' ' + Token.stringify(op) + '= ' + this.printExpression(value_5802)
			} break;
			
			case 16: {
				const expr_5803 = temp_5748[1];
				const cases = temp_5748[2];
				const statements = temp_5748[3];
				{
					const value_5804 = this.printExpression(expr_5803);
					const valueType_5805 = this.stringifyType(this.getType(expr_5803), false);
					let r_5806 = ('{ ' + (valueType_5805) + ' switch_ = ') + value_5804 + ';';
					let else_ = false;
					{
						let i_5807 = 0;
						let it_5808 = 0;
						let at_5809 = cases.length;
						while (it_5808 < at_5809) {
							i_5807 = it_5808;
							it_5808++;
							{
								if (cases[i_5807].length > 1) {
									if (else_) { r_5806 += ' else' };
									r_5806 += '\n' + this.tabs + 'if ((';
									const conds = [];
									for (const cc of $toIterator(cases[i_5807])) {
										const temp_5810 = cc;
										switch (temp_5810&&temp_5810[0]) {
										case 7: {
											conds.push('switch_ == -1')
										} break;
										
										default: 
										conds.push('switch_ == ' + this.printExpression(cc))
										};
									};
									r_5806 += conds.join(') || (') + ')) ';
									this.pushTab();
									r_5806 += this.printBlock(statements[i_5807]);
									this.popTab();
									else_ = true;
								} else {
									let step_5811 = 0;
									const cc = cases[i_5807][0];
									if (step_5811 == 0 && cc != null) { step_5811 = 1 };
									if (step_5811 == 1) {
										if (else_) { r_5806 += ' else' };
										r_5806 += '\n' + this.tabs + 'if (';
										{
											const temp_5812 = cc;
											switch (temp_5812&&temp_5812[0]) {
											case 7: {
												r_5806 += 'switch_ == -1) '
											} break;
											
											default: 
											r_5806 += 'switch_ == ' + this.printExpression(cc) + ') '
											};
										};
										this.pushTab();
										r_5806 += this.printBlock(statements[i_5807]);
										this.popTab();
										else_ = true;
									};
								};
							};
						};
					};
					{
						let i_5813 = 0;
						let it_5814 = 0;
						let at_5815 = cases.length;
						while (it_5814 < at_5815) {
							i_5813 = it_5814;
							it_5814++;
							{
								if (cases[i_5813].length == 0) {
									if (else_) { r_5806 += ' else' };
									r_5806 += '\n' + this.tabs;
									r_5806 += this.printBlock(statements[i_5813]);
								};
							};
						};
					};
					r_5806 += ';\n' + this.tabs;
					return r_5806 + '}';
				}
			} break;
			
			default: 
			{
				console.error('Unknown statement kind (GenCxx):', s_5746);
				console.trace('Here I am!');
			}
			};
		};
	};
		printCallArguments(args_5823, expects_5824) {
		{
			let step_5825 = 0;
			const exp = expects_5824;
			if (step_5825 == 0 && exp != null) { step_5825 = 1 };
			if (step_5825 == 1) { return '(' + (() => {
				const result_5826 = [];
				const value_5827 = args_5823.length;
				for (const i of $toIterator(value_5827)) result_5826.push(this.printTypeConverter(this.printExpression(args_5823[i]), this.getType(args_5823[i]), exp[i]));
				return result_5826;
			})().join(', ') + ')' };
		};
		return '(' + (() => {
			const result_5828 = [];
			const value_5829 = args_5823;
			for (const a of $toIterator(value_5829)) result_5828.push(this.printExpression(a));
			return result_5828;
		})().join(', ') + ')';
	};
		printCallArgumentsVirtual(me, args_5830, expects_5831) {
		if (args_5830.length == 0) { return '(' + me + ')' };
		{
			let step_5832 = 0;
			const exp_5833 = expects_5831;
			if (step_5832 == 0 && exp_5833 != null) { step_5832 = 1 };
			if (step_5832 == 1) { return '(' + me + ', ' + (() => {
				const result_5834 = [];
				const value_5835 = args_5830.length;
				for (const i of $toIterator(value_5835)) result_5834.push(this.printTypeConverter(this.printExpression(args_5830[i]), this.getType(args_5830[i]), exp_5833[i]));
				return result_5834;
			})().join(', ') + ')' };
		};
		return '(' + me + ', ' + (() => {
			const result_5836 = [];
			const value_5837 = args_5830;
			for (const a of $toIterator(value_5837)) result_5836.push(this.printExpression(a));
			return result_5836;
		})().join(', ') + ')';
	};
		getFunctionReturnType(funcType_5838) {
		const temp_5839 = funcType_5838;
		switch (temp_5839&&temp_5839[0]) {
		case 12: {
			const args_5840 = temp_5839[1];
			const returns_5841 = temp_5839[2];
			return returns_5841
		} break;
		
		default: 
		return null
		};
	};
		printFunctionReturnType(funcType_5842) {
		const temp_5843 = funcType_5842;
		switch (temp_5843&&temp_5843[0]) {
		case 12: {
			const args_5844 = temp_5843[1];
			const returns_5845 = temp_5843[2];
			return this.stringifyType(returns_5845, false)
		} break;
		
		default: 
		return 'void'
		};
	};
		printToAnyConverter(string, type_5846) {
		if (type_5846 == this.project.typer.typeAny) { return string };
		if (type_5846 == this.project.typer.typeBool) { return 'Any_fromBool(' + string + ')' };
		if (type_5846 == this.project.typer.typeInt) { return 'Any_fromInt(' + string + ')' };
		return '(struct Any_*)(' + string + ')';
	};
		printValueToNullableConverter(string_5847, fromValue, to) { return '%printValueToNullableConverter%' };
		printNullableToValueConverter(string_5848, fromValue_5849, to_5850) { return '%printNullableToValueConverter%' };
		printTypeConverter(string_5851, fromValue_5852, to_5853) {
		if (fromValue_5852 == to_5853) { return string_5851 };
		if ((fromValue_5852 == this.project.typer.typeUInt16) && (to_5853 == this.project.typer.typeInt)) { return '(int32_t/*!*/)(' + string_5851 + ')' };
		if ((fromValue_5852 == this.project.typer.typeBool) && (to_5853 == this.project.typer.typeAny)) { return 'Any_fromBool(' + string_5851 + ')' };
		if ((fromValue_5852 == this.project.typer.typeAny) && (to_5853 == this.project.typer.typeBool)) { return '(' + string_5851 + ')->_toBool()' };
		if ((fromValue_5852 == this.project.typer.typeAny) && (to_5853 == this.project.typer.typeInt)) { return '(' + string_5851 + ')->_toInt()' };
		if ((fromValue_5852 == this.project.typer.typeAny) && (to_5853 == this.project.typer.typeFloat)) { return '(' + string_5851 + ')->_toFloat()' };
		if ((fromValue_5852 == this.project.typer.typeInt) && (to_5853 == this.project.typer.typeString)) { return 'String_$fromInt32_(' + string_5851 + ')' };
		if (fromValue_5852 == this.project.typer.typeString) {
			const temp_5854 = to_5853;
			switch (temp_5854&&temp_5854[0]) {
			case 6: {
				const type_5855 = temp_5854[1];
				if (type_5855.name == 'ConstCharPointer') {
					console.log(type_5855);
					return '(' + string_5851 + ')->bytes_';
				}
			} break;
			};
		};
		if (to_5853 == this.project.typer.typeAny) { return this.printToAnyConverter(string_5851, fromValue_5852) };
		if (fromValue_5852 != to_5853) {
			const temp_5856 = to_5853;
			switch (temp_5856&&temp_5856[0]) {
			case 4: {
				const toNull = temp_5856[1];
				{
					const temp_5857 = fromValue_5852;
					switch (temp_5857&&temp_5857[0]) {
					case 4: {
						const fromNull = temp_5857[1];
						{
							if (toNull == fromNull) { return string_5851 };
							return '(/*A? = B?*/' + this.stringifyType(to_5853, false) + ')(' + string_5851 + ')';
						}
					} break;
					
					default: 
					{
						if (toNull == fromValue_5852) {
							if (toNull == this.project.typer.typeInt) { return '((int32_t$)(' + string_5851 + '))' };
							return string_5851;
						};
						{
							const temp_5858 = fromValue_5852;
							switch (temp_5858&&temp_5858[0]) {
							case 3: {
								const value_5859 = temp_5858[1];
								if (value_5859.value == null) {
									if (toNull == this.project.typer.typeInt || toNull == this.project.typer.typeInt32) { return 'int32_t$null' };
									if (toNull == this.project.typer.typeUInt32) { return 'uint32_t$null' };
									if (toNull == this.project.typer.typeBool) { return '(uint8_t)2' };
									if (toNull == null) { return string_5851 };
									return '/*%T? = null%*/(' + string_5851 + ')';
								}
							} break;
							};
						};
						return '(/*A? = B*/' + this.stringifyType(to_5853, false) + ')(' + string_5851 + ')';
					}
					};
				}
			} break;
			
			default: 
			{
				const temp_5860 = fromValue_5852;
				switch (temp_5860&&temp_5860[0]) {
				case 4: {
					const fromNull_5861 = temp_5860[1];
					{
						if (to_5853 == fromNull_5861) {
							if (fromNull_5861 == this.project.typer.typeInt) { return string_5851 + '.value_' };
							return string_5851;
						};
						return '(/*A = B?*/' + this.stringifyType(to_5853, false) + ')(' + string_5851 + ')';
					}
				} break;
				
				default: 
				{
					if (to_5853 == fromValue_5852) { return string_5851 };
					{
						const temp_5862 = fromValue_5852;
						switch (temp_5862&&temp_5862[0]) {
						case 3: {
							const value_5863 = temp_5862[1];
							if (value_5863.value == null) {
								if (to_5853 == this.project.typer.typeInt || to_5853 == this.project.typer.typeInt32) { return 'int32_t$null' };
								if (to_5853 == this.project.typer.typeUInt32) { return 'uint32_t$null' };
								if (to_5853 == this.project.typer.typeInt) { return '(int32_t)0' };
								if (to_5853 == null) { return string_5851 };
								return '(/*T = null*/' + this.stringifyType(to_5853, false) + ')(' + string_5851 + ')';
							}
						} break;
						};
					};
					const tot = JSON.stringify('' + to_5853);
					if (to_5853 == null) { return string_5851 };
					let fromStructByValue = false;
					{
						const temp_5864 = fromValue_5852;
						switch (temp_5864&&temp_5864[0]) {
						case 6: {
							const type_5865 = temp_5864[1];
							{
								const atts = this.project.mapDecorators.get(type_5865.parent);
								fromStructByValue = Normalizer.getDec(atts, 'byValue') != null;
							}
						} break;
						};
					};
					let toStructByPointer = false;
					{
						const temp_5866 = to_5853;
						switch (temp_5866&&temp_5866[0]) {
						case 6: {
							const type_5867 = temp_5866[1];
							{
								const atts_5868 = this.project.mapDecorators.get(type_5867.parent);
								toStructByPointer = Normalizer.getDec(atts_5868, 'struct') != null;
							}
						} break;
						};
					};
					if (fromStructByValue && toStructByPointer) { return '(/*struct to pointer*/' + this.stringifyType(to_5853, false) + ')&(' + string_5851 + ')' };
					return '(' + this.stringifyType(to_5853, false) + ')(' + string_5851 + ')';
				}
				};
			}
			};
		};
		return string_5851 + '/*TO*/';
	};
		printFunctionArguments(args_5869, funcType_5870, defaults_5871) {
		if ((args_5869.length == 0) && (this.thisArgument != null)) { return '(' + this.thisArgument + ')' };
		if (args_5869.length == 0) { return '(void)' };
		{
			const temp_5872 = funcType_5870;
			switch (temp_5872&&temp_5872[0]) {
			case 12: {
				const types_5873 = temp_5872[1];
				{
					const results = [];
					{
						let step_5874 = 0;
						const thisArgument = this.thisArgument;
						if (step_5874 == 0 && thisArgument != null) { step_5874 = 1 };
						if (step_5874 == 1) { results.push(thisArgument) };
					};
					{
						let a_5875 = 0;
						let it_5876 = 0;
						let at_5877 = args_5869.length;
						while (it_5876 < at_5877) {
							a_5875 = it_5876;
							it_5876++;
							{
								let result_5878 = this.stringifyType(types_5873[a_5875], false) + ' ' + args_5869[a_5875] + '_';
								if (defaults_5871) {
									const temp_5879 = types_5873[a_5875];
									switch (temp_5879&&temp_5879[0]) {
									case 4: {
										result_5878 += ' = ((Unknown_ *)0)'
									} break;
									
									case 3: {
										result_5878 += ' = ((Unknown_ *)0)'
									} break;
									};
								};
								results.push(result_5878);
							};
						};
					};
					return '(' + results.join(', ') + ')';
				}
			} break;
			};
		};
		return '(' + (() => {
			const result_5884 = [];
			const value_5885 = args_5869.length;
			for (const a of $toIterator(value_5885)) result_5884.push('Any_* ' + args_5869[a] + '_');
			return result_5884;
		})().join(', ') + ')';
	};
		stringType(t_5886, prefix) {
		if (t_5886 == null) { return 'void*' };
		{
			const temp_5887 = t_5886;
			switch (temp_5887&&temp_5887[0]) {
			case 2: {
				const name_5888 = temp_5887[1];
				const params = temp_5887[2];
				return '_x' + name_5888
			} break;
			
			case 1: {
				const name_5889 = temp_5887[1];
				return '_x' + name_5889
			} break;
			
			case 5: {
				{
				}
			} break;
			
			case 0: {
				const t_5890 = temp_5887[1];
				return this.stringType(t_5890, '')
			} break;
			};
		};
		return prefix + 'void*';
	};
		printType(t_5891) {
		const type_5892 = this.stringType(t_5891, '');
		return type_5892;
	};
		stringifyType(t_5893, prefixNull) {
		const temp_5894 = t_5893;
		switch (temp_5894&&temp_5894[0]) {
		case 1: {
			const index_5895 = temp_5894[1];
			const name_5896 = temp_5894[2];
			return 'Any_*'
		} break;
		
		case 4: {
			const t_5897 = temp_5894[1];
			{
				const name_5898 = this.stringifyType(t_5897, false);
				if (name_5898 == 'int32_t') { return 'int32_t$' };
				if (name_5898 == 'Bool') { return 'Bool_' };
				if (name_5898 == 'double') { return 'Null$Float64' };
				if (prefixNull == true) { return 'Null$' + name_5898 };
				return name_5898;
			}
		} break;
		
		case 2: {
			const handle = temp_5894[1];
			return this.stringifyType(handle.value, prefixNull)
		} break;
		
		case 3: {
			const handle_5899 = temp_5894[1];
			return this.stringifyType(handle_5899.value, prefixNull)
		} break;
		
		case 6: {
			const type_5900 = temp_5894[1];
			const generics_5901 = temp_5894[2];
			{
				if (type_5900.name == 'Int') { return 'int32_t' };
				if (type_5900.name == 'Int8') { return 'int8_t' };
				if (type_5900.name == 'Int16') { return 'int16_t' };
				if (type_5900.name == 'Int32') { return 'int32_t' };
				if (type_5900.name == 'Int64') { return 'int64_t' };
				if (type_5900.name == 'UInt8') { return 'uint8_t' };
				if (type_5900.name == 'UInt16') { return 'uint16_t' };
				if (type_5900.name == 'UInt32') { return 'uint32_t' };
				if (type_5900.name == 'UInt64') { return 'uint64_t' };
				const atts_5902 = this.project.mapDecorators.get(type_5900.parent);
				let renamed_5903 = '';
				{
					let step_5904 = 0;
					const rename = Normalizer.getDec(atts_5902, 'rename');
					if (step_5904 == 0 && rename != null) { step_5904 = 1 };
					if (step_5904 == 1) { renamed_5903 = DataHelper.asStringAttValue(rename, 0) };
				};
				{
					let step_5905 = 0;
					const generic_5906 = generics_5901;
					let temp_5907 = null;
					if (step_5905 == 0 && generic_5906 != null) {
						temp_5907 = renamed_5903 == 'ConstArrayPointer';
						step_5905 = 1;
					};
					if (step_5905 == 1 && temp_5907 != false) { step_5905 = 2 };
					if (step_5905 == 2) { return 'const ' + this.stringifyType(generic_5906[0], false) + '*' };
				};
				{
					let step_5908 = 0;
					const generic_5909 = generics_5901;
					let temp_5910 = null;
					if (step_5908 == 0 && generic_5909 != null) {
						temp_5910 = renamed_5903 == 'ArrayPointer';
						step_5908 = 1;
					};
					if (step_5908 == 1 && temp_5910 != false) { step_5908 = 2 };
					if (step_5908 == 2) { return this.stringifyType(generic_5909[0], false) + '*' };
				};
				{
					let step_5911 = 0;
					const generic_5912 = generics_5901;
					let temp_5913 = null;
					if (step_5911 == 0 && generic_5912 != null) {
						temp_5913 = renamed_5903 == 'ArrayByValue';
						step_5911 = 1;
					};
					if (step_5911 == 1 && temp_5913 != false) { step_5911 = 2 };
					if (step_5911 == 2) { return this.stringifyType(generic_5912[0], false) };
				};
				if (type_5900.name == 'Bool') { return 'Bool_' };
				if (type_5900.name == 'Bool32') { return 'int32_t' };
				if (type_5900.name == 'Bool8') { return 'uint8_t' };
				if (type_5900.name == 'Void') { return 'void' };
				if (type_5900.name == 'Float') { return 'double' };
				const atts_5914 = this.project.mapDecorators.get(type_5900.parent);
				const struct = Normalizer.getDec(atts_5914, 'struct') != null;
				const byValue = Normalizer.getDec(atts_5914, 'byValue') != null;
				if (byValue && (!struct)) { throw 'Must be @struct to be @byValue' };
				const native = Normalizer.getDec(atts_5914, 'rename');
				{
					let step_5915 = 0;
					const native_5916 = native;
					if (step_5915 == 0 && native_5916 != null) { step_5915 = 1 };
					if (step_5915 == 1) {
						const temp_5917 = (native_5916.values[0]);
						switch (temp_5917&&temp_5917[0]) {
						case 0: {
							const s_5918 = temp_5917[1];
							{
								if (struct && byValue) { return s_5918 };
								if (struct) { return s_5918 + '*' };
								return s_5918;
							}
						} break;
						};
					};
				};
				{
					let step_5919 = 0;
					const generic_5920 = generics_5901;
					let temp_5921 = null;
					if (step_5919 == 0 && generic_5920 != null) {
						temp_5921 = generic_5920.length > 0;
						step_5919 = 1;
					};
					if (step_5919 == 1 && temp_5921 != false) { step_5919 = 2 };
					if (step_5919 == 2) {
						let name_5922 = type_5900.name;
						{
							let step_5923 = 0;
							const instanceOf = type_5900.instanceOf;
							if (step_5923 == 0 && instanceOf != null) { step_5923 = 1 };
							if (step_5923 == 1) { name_5922 = instanceOf.name };
						};
						name_5922 += '_$' + (() => {
							const result_5924 = [];
							const value_5925 = generic_5920;
							for (const param of $toIterator(value_5925)) result_5924.push(this.omitPointer(this.stringifyType(param, true)));
							return result_5924;
						})().join('$');
						if (name_5922.endsWith('_')) { return name_5922 + '*' };
						return name_5922 + '_*';
					};
				};
				return type_5900.name + '_*';
			}
		} break;
		
		case 5: {
			const type_5926 = temp_5894[1];
			return type_5926.name + '_*'
		} break;
		
		case 8: {
			const type_5927 = temp_5894[1];
			{
				{
					let step_5928 = 0;
					const sub = type_5927.fieldsTypeSimple;
					if (step_5928 == 0 && sub != null) { step_5928 = 1 };
					if (step_5928 == 1) { return this.stringifyType(sub, false) };
				};
				return type_5927.name + '_*';
			}
		} break;
		
		case 9: {
			const type_5929 = temp_5894[1];
			return type_5929.name + '_*'
		} break;
		
		case 13: {
			return 'Any_*/*Struct*/'
		} break;
		
		case 12: {
			const args_5930 = temp_5894[1];
			const returns_5931 = temp_5894[2];
			{
				const temp_5932 = (this.tempId++);
				this.typedefFunctions.push('typedef ');
				this.typedefFunctions.push(this.stringifyType(returns_5931, false));
				this.typedefFunctions.push((' (*_$' + (temp_5932) + ')('));
				const a_5933 = [];
				for (const arg of $toIterator(args_5930)) {
					a_5933.push(this.stringifyType(arg, false));
				};
				this.typedefFunctions.push(a_5933.join(', '));
				this.typedefFunctions.push(');\n');
				return ('_$' + (temp_5932) + '');
			}
		} break;
		
		case null: case undefined: {
			return 'Any_*'
		} break;
		
		default: 
		throw 'stringifyType ' + t_5893
		};
	};
		getType(e_5934) {
		const temp_5935 = e_5934;
		switch (temp_5935&&temp_5935[0]) {
		case 1: {
			return this.project.typer.typeInt
		} break;
		
		case 2: {
			const kind_5936 = temp_5935[2];
			{
				const temp_5937 = kind_5936;
				switch (temp_5937) {
				case 5: {
					return this.project.typer.typeInt8
				} break;
				
				case 4: {
					return this.project.typer.typeInt16
				} break;
				
				case 2: {
					return this.project.typer.typeInt32
				} break;
				
				case 3: {
					return this.project.typer.typeInt64
				} break;
				
				case 9: {
					return this.project.typer.typeUInt8
				} break;
				
				case 8: {
					return this.project.typer.typeUInt16
				} break;
				
				case 6: {
					return this.project.typer.typeUInt32
				} break;
				
				case 7: {
					return this.project.typer.typeUInt64
				} break;
				};
			}
		} break;
		
		case 3: {
			return this.project.typer.typeFloat
		} break;
		
		case 0: {
			return this.project.typer.typeString
		} break;
		
		case 4: {
			return this.project.typer.typeBool
		} break;
		
		case 5: {
			return this.project.typer.typeBool
		} break;
		
		case 6: {
			const type_5938 = temp_5935[2];
			return type_5938
		} break;
		
		case 15: {
			const expr_5939 = temp_5935[1];
			return this.getType(expr_5939)
		} break;
		
		case 10: {
			const type_5940 = temp_5935[3];
			return type_5940
		} break;
		
		case 12: {
			const type_5941 = temp_5935[4];
			return type_5941
		} break;
		
		case 26: {
			const type_5942 = temp_5935[5];
			return type_5942
		} break;
		
		case 9: {
			const type_5943 = temp_5935[3];
			return type_5943
		} break;
		
		case 8: {
			const type_5944 = temp_5935[1];
			return type_5944
		} break;
		
		case 7: {
			return /*UnknownNullable*/[3,{value:null},".UnknownNullable"]
		} break;
		
		case 23: {
			const to_5945 = temp_5935[2];
			return to_5945
		} break;
		
		case 22: {
			const result_5946 = temp_5935[3];
			return result_5946
		} break;
		
		case 11: {
			const result_5947 = temp_5935[3];
			return result_5947
		} break;
		
		case 17: {
			const result_5948 = temp_5935[2];
			return result_5948
		} break;
		
		default: 
		return this.project.typer.typeAny
		};
	};
		omitPointer(type_5949) {
		if (type_5949.endsWith('*')) { return type_5949.substr(0, type_5949.length - 1) };
		return type_5949;
	};
		registerString(string_5950) {
		this.declarationsOfStrings.push(string_5950);
		return this.declarationsOfStrings.length - 1;
	};
		printExpression(e_5951) {
		const temp_5952 = e_5951;
		switch (temp_5952&&temp_5952[0]) {
		case 8: {
			return (() => {
				const result_5953 = this.customThis;
				if (result_5953 != null) { return result_5953 };
				return 'this';
			})()
		} break;
		
		case 6: {
			const name_5954 = temp_5952[1];
			{
				if (this.project.native.get(e_5951) == true) { return name_5954 };
				return '' + name_5954 + '_';
			}
		} break;
		
		case 7: {
			const type_5955 = temp_5952[1];
			{
				let type_5956 = type_5955;
				{
					const temp_5957 = type_5956;
					switch (temp_5957&&temp_5957[0]) {
					case 3: {
						const handle_5958 = temp_5957[1];
						{
							let step_5959 = 0;
							const of = handle_5958.value;
							if (step_5959 == 0 && of != null) { step_5959 = 1 };
							if (step_5959 == 1) { type_5956 = of };
						}
					} break;
					
					case 4: {
						const of_5960 = temp_5957[1];
						type_5956 = of_5960
					} break;
					};
				};
				if (type_5956 == this.project.typer.typeInt) { return 'int32_t$null' };
				if (type_5956 == this.project.typer.typeUInt32) { return 'uint32_t$null' };
				if (type_5956 == this.project.typer.typeBool) { return '(uint8_t)2' };
				return 'nullptr';
			}
		} break;
		
		case 1: {
			const v_5961 = temp_5952[1];
			return '(int32_t)' + v_5961
		} break;
		
		case 2: {
			const v_5962 = temp_5952[1];
			const meta_5963 = temp_5952[2];
			const type_5964 = temp_5952[3];
			{
				const temp_5965 = meta_5963;
				switch (temp_5965) {
				case 2: {
					return '(int32_t)' + v_5962
				} break;
				
				case 3: {
					return '(int64_t)' + v_5962
				} break;
				
				case 4: {
					return '(int16_t)' + v_5962
				} break;
				
				case 5: {
					return '(int8_t)' + v_5962
				} break;
				
				case 6: {
					return '(uint32_t)' + v_5962
				} break;
				
				case 7: {
					return '(uint64_t)' + v_5962
				} break;
				
				case 8: {
					return '(uint16_t)' + v_5962
				} break;
				
				case 9: {
					return '(uint8_t)' + v_5962
				} break;
				};
			}
		} break;
		
		case 3: {
			const v_5966 = temp_5952[1];
			{
				const v_5967 = '' + v_5966;
				if (v_5967.indexOf('.') == (-1)) { return '(double)' + v_5967 + '.0' };
				return '(double)' + v_5967;
			}
		} break;
		
		case 0: {
			const string_5968 = temp_5952[1];
			{
				{
					let step_5969 = 0;
					const id_5970 = this.declarationsOfStringsMap.get(string_5968);
					if (step_5969 == 0 && id_5970 != null) { step_5969 = 1 };
					if (step_5969 == 1) { return ('String_' + (id_5970) + '') };
				};
				const s_5971 = string_5968.split('');
				const charsOut = [];
				while (s_5971.length > 0) {
					const temp_5972 = s_5971[0];
					switch (temp_5972) {
					case '\'': {
						{
							charsOut.push('\\\'');
							s_5971.shift();
						}
					} break;
					
					case '"': {
						{
							charsOut.push('\\"');
							s_5971.shift();
						}
					} break;
					
					case '\n': {
						{
							charsOut.push('\\n');
							s_5971.shift();
						}
					} break;
					
					case '\r': {
						{
							charsOut.push('\\r');
							s_5971.shift();
						}
					} break;
					
					case '\\': {
						{
							s_5971.shift();
							if (s_5971[0] == '\'') {
								charsOut.push('\\\'');
								s_5971.shift();
							} else if (s_5971[0] == '"') {
								charsOut.push('\\"');
								s_5971.shift();
							} else if (s_5971[0] == '\\') {
								charsOut.push('\\\\');
								s_5971.shift();
							} else {
								charsOut.push('\\');
							};
						}
					} break;
					
					default: 
					{
						charsOut.push(s_5971[0]);
						s_5971.shift();
					}
					};
				};
				const id_5973 = this.registerString(charsOut.join(''));
				this.declarationsOfStringsMap.set(string_5968, id_5973);
				return ('String_' + (id_5973) + '');
			}
		} break;
		
		case 4: {
			return 'true_'
		} break;
		
		case 5: {
			return 'false_'
		} break;
		
		case 9: {
			const expr_5974 = temp_5952[1];
			const name_5975 = temp_5952[2];
			{
				const temp_5976 = expr_5974;
				switch (temp_5976&&temp_5976[0]) {
				case 8: {
					return ((() => {
						const result_5977 = this.customThis;
						if (result_5977 != null) { return result_5977 };
						return 'this';
					})()) + '->' + name_5975 + '_'
				} break;
				
				case 6: {
					const id_5978 = temp_5976[1];
					const typed = temp_5976[2];
					{
						if (id_5978.charAt(0) == id_5978.charAt(0).toUpperCase()) { return id_5978 + '_$' + name_5975 + '_' };
						const type_5979 = this.getType(expr_5974);
						if ((type_5979 == this.project.typer.typeAny) || (type_5979 == null)) { return this.printExpression(expr_5974) + '->let_(String_$fromUTF16z_(L"' + name_5975 + '"))' };
						{
							const temp_5980 = typed;
							switch (temp_5980&&temp_5980[0]) {
							case 6: {
								const c_5981 = temp_5980[1];
								if (c_5981.fieldRenames.includes(name_5975)) { return this.printExpression(expr_5974) + '->' + name_5975 }
							} break;
							};
						};
						return this.printExpression(expr_5974) + '->' + name_5975 + '_';
					}
				} break;
				
				default: 
				return this.printExpression(expr_5974) + '->' + name_5975 + '_'
				};
			}
		} break;
		
		case 10: {
			const e_5982 = temp_5952[1];
			const args_5983 = temp_5952[2];
			const type_5984 = temp_5952[3];
			const kind_5985 = temp_5952[4];
			{
				{
					const temp_5986 = kind_5985;
					switch (temp_5986) {
					case 10: {
						return this.printExpression(e_5982) + this.printCallArguments(args_5983)
					} break;
					
					case 12: {
						{
							const temp_5987 = e_5982;
							switch (temp_5987&&temp_5987[0]) {
							case 9: {
								const expr_5988 = temp_5987[1];
								const name_5989 = temp_5987[2];
								const result_5990 = temp_5987[3];
								{
									const temp_5991 = (this.tempId++);
									const temp1 = (this.tempId++);
									const mb = this.metaBlock;
									this.metaBlock = [];
									const meta_5992 = this.stringifyType(this.getType(expr_5988), false) + (' _$' + (temp_5991) + ' = ') + this.printExpression(expr_5988);
									const result_5993 = ('_$' + (temp_5991) + '->_->') + name_5989 + '_' + this.printCallArgumentsVirtual(('_$' + (temp_5991) + ''), args_5983);
									for (const b of $toIterator(this.metaBlock)) {
										mb.push(b);
									};
									mb.push(meta_5992);
									this.metaBlock = mb;
									return result_5993;
								}
							} break;
							};
						}
					} break;
					};
				};
				return this.printExpression(e_5982) + this.printCallArguments(args_5983);
			}
		} break;
		
		case 14: {
			const expr_5994 = temp_5952[1];
			const args_5995 = temp_5952[2];
			const defaults_5996 = temp_5952[3];
			const types_5997 = temp_5952[4];
			const returns_5998 = temp_5952[5];
			const funcType_5999 = temp_5952[6];
			return this.printExpression(/*Function*/[13,null,/*Return*/[6,expr_5994,".Return"],args_5995,defaults_5996,funcType_5999,".Function"])
		} break;
		
		case 13: {
			const name_6000 = temp_5952[1];
			const expr_6001 = temp_5952[2];
			const args_6002 = temp_5952[3];
			const defaults_6003 = temp_5952[4];
			const funcType_6004 = temp_5952[5];
			{
				const _currentReturnType_6005 = this.currentReturnType;
				this.currentReturnType = this.getFunctionReturnType(funcType_6004);
				const temp_6006 = (this.tempId++);
				const rt_6007 = this.printFunctionReturnType(funcType_6004);
				this.forwardFunctions.push(rt_6007);
				this.forwardFunctions.push((' _$' + (temp_6006) + ''));
				this.forwardFunctions.push(this.printFunctionArguments(args_6002, funcType_6004, false));
				this.forwardFunctions.push(';\n');
				const tab_6008 = this.tabs;
				this.tabs = '';
				this.globalFunctions.push(rt_6007);
				this.globalFunctions.push((' _$' + (temp_6006) + ''));
				this.globalFunctions.push(this.printFunctionArguments(args_6002, funcType_6004, true));
				this.globalFunctions.push(' ');
				this.globalFunctions.push(this.printBlock(expr_6001));
				this.globalFunctions.push('\n\n');
				this.tabs = tab_6008;
				this.currentReturnType = _currentReturnType_6005;
				return ('_$' + (temp_6006) + '');
			}
		} break;
		
		case 11: {
			const e_6009 = temp_5952[1];
			const args_6010 = temp_5952[2];
			const result_6011 = temp_5952[3];
			{
				const name_6012 = this.omitPointer(this.stringifyType(result_6011, false));
				return name_6012 + '$new_' + this.printCallArguments(args_6010);
			}
		} break;
		
		case 17: {
			const el_6013 = temp_5952[1];
			const arrayType = temp_5952[2];
			{
				const type_6014 = this.stringifyType(arrayType, false);
				if (el_6013.length == 0) { return ('' + (this.omitPointer(type_6014)) + '$new_(0)') };
				{
					const temp_6015 = arrayType;
					switch (temp_6015&&temp_6015[0]) {
					case 6: {
						const generic_6016 = temp_6015[2];
						{
							const elType = this.stringifyType(generic_6016[0], false);
							return ('' + (this.omitPointer(type_6014)) + '$from_(' + (this.omitPointer(type_6014)) + '$new_(' + (el_6013.length) + '), (' + (elType) + '[]){') + (() => {
								const result_6017 = [];
								const value_6018 = el_6013;
								for (const a of $toIterator(value_6018)) result_6017.push(this.printExpression(a));
								return result_6017;
							})().join(', ') + '})';
						}
					} break;
					};
				};
				return ('' + (this.omitPointer(type_6014)) + '$from_(' + (this.omitPointer(type_6014)) + '$new_(' + (el_6013.length) + '), {') + (() => {
					const result_6019 = [];
					const value_6020 = el_6013;
					for (const a of $toIterator(value_6020)) result_6019.push(this.printExpression(a));
					return result_6019;
				})().join(', ') + '})';
			}
		} break;
		
		case 19: {
			const op_6021 = temp_5952[1];
			const postfix = temp_5952[2];
			const e_6022 = temp_5952[3];
			{
				if (postfix) { return this.printExpression(e_6022) + Token.stringify(op_6021) };
				return Token.stringify(op_6021) + this.printExpression(e_6022);
			}
		} break;
		
		case 20: {
			const nullable = temp_5952[1];
			const othewise = temp_5952[2];
			return '((' + this.printExpression(nullable) + ')||(' + this.printExpression(othewise) + '))'
		} break;
		
		case 15: {
			const e_6023 = temp_5952[1];
			return '(' + this.printExpression(e_6023) + ')'
		} break;
		
		case 12: {
			const a_6024 = temp_5952[1];
			const op_6025 = temp_5952[2];
			const b = temp_5952[3];
			{
				if (op_6025 == 111) {
					if (this.getType(a_6024) == this.project.typer.typeString) { return 'String_$combine_(' + this.printExpression(a_6024) + ', ' + this.printTypeConverter(this.printExpression(b), this.getType(b), this.project.typer.typeString) + ')' };
					if (this.getType(b) == this.project.typer.typeString) { return 'String_$combine_(' + this.printTypeConverter(this.printExpression(a_6024), this.getType(a_6024), this.project.typer.typeString) + ', ' + this.printExpression(b) + ')' };
				};
				const token = ((op_6025 == 110)? ('/') : Token.stringify(op_6025));
				return this.printExpression(a_6024) + ' ' + token + ' ' + this.printExpression(b);
			}
		} break;
		
		case 22: {
			const expr_6026 = temp_5952[1];
			const index_6027 = temp_5952[2];
			{
				{
					const temp_6028 = (this.getType(expr_6026));
					switch (temp_6028&&temp_6028[0]) {
					case 6: {
						const type_6029 = temp_6028[1];
						const generic_6030 = temp_6028[2];
						if (type_6029.name != 'Array') { return this.printExpression(expr_6026) + '[' + this.printTypeConverter(this.printExpression(index_6027), this.getType(index_6027), this.project.typer.typeInt) + ']' }
					} break;
					};
				};
				return this.printExpression(/*Call*/[10,/*Dot*/[9,expr_6026,'get',null,".Dot"],[index_6027],[this.project.typer.typeInt],12,".Call"]);
			}
		} break;
		
		case 21: {
			const econd_6031 = temp_5952[1];
			const eif_6032 = temp_5952[2];
			const eelse_6033 = temp_5952[3];
			{
				let r_6034 = '';
				try {
					r_6034 += '(' + this.printExpression(econd_6031) + ')?';
					r_6034 += '(' + this.printExpression(eif_6032) + ')';
					r_6034 += ':' + this.printExpression(eelse_6033);
					return r_6034;
				} catch (temp_6035) {
					if (true) { 
					const error = temp_6035
					{
						console.log('If =>', e_5951, error);
						return r_6034 + '<!--If => error-->';
					} } else
					
					throw temp_6035;
				};
			}
		} break;
		
		case 27: {
			const expr_6036 = temp_5952[1];
			{
				const e_6037 = this.printExpression(expr_6036);
				return '(' + e_6037 + ' == ((Unknown_ *)0)? -1 : ' + e_6037 + '->is_)';
			}
		} break;
		
		case 16: {
			const names = temp_5952[1];
			const el_6038 = temp_5952[2];
			return 'Object_from(' + (() => {
				const result_6039 = [];
				const value_6040 = el_6038.length;
				for (const i of $toIterator(value_6040)) result_6039.push(((names[i]) + ', ' + this.printExpression(el_6038[i])));
				return result_6039;
			})().join(', ') + ')'
		} break;
		
		case 18: {
			const keys = temp_5952[1];
			const values = temp_5952[2];
			{
				if (keys.length == 0) { return 'Map_$new_()' };
				return 'Map_from(' + (() => {
					const result_6041 = [];
					const value_6042 = keys.length;
					for (const i of $toIterator(value_6042)) result_6041.push('' + this.printExpression(keys[i]) + ', ' + this.printExpression(values[i]) + '');
					return result_6041;
				})().join(', ') + ')';
			}
		} break;
		
		case 25: {
			const a_6043 = temp_5952[1];
			const op_6044 = temp_5952[2];
			const value_6045 = temp_5952[3];
			return this.printExpression(a_6043) + ' ' + Token.stringify(op_6044) + '= ' + this.printExpression(value_6045)
		} break;
		
		case 26: {
			const kind_6046 = temp_5952[1];
			const args_6047 = temp_5952[2];
			const s_6048 = temp_5952[3];
			const params_6049 = temp_5952[4];
			const result_6050 = temp_5952[5];
			{
				const temp_6051 = kind_6046;
				switch (temp_6051) {
				case 0: {
					return '((' + this.printExpression(args_6047[0]) + ')' + s_6048 + '(' + this.printExpression(args_6047[1]) + '))'
				} break;
				
				case 1: {
					{
						{
							let step_6052 = 0;
							const params_6053 = params_6049;
							let temp_6054 = null;
							if (step_6052 == 0 && params_6053 != null) {
								temp_6054 = s_6048 == '*sizeof';
								step_6052 = 1;
							};
							if (step_6052 == 1 && temp_6054 != false) { step_6052 = 2 };
							if (step_6052 == 2) { return 'sizeof(' + this.omitPointer(this.stringifyType(params_6053[0], false)) + ')' };
						};
						{
							let step_6055 = 0;
							const params_6056 = params_6049;
							let temp_6057 = null;
							if (step_6055 == 0 && params_6056 != null) {
								temp_6057 = s_6048 == '&sizeof';
								step_6055 = 1;
							};
							if (step_6055 == 1 && temp_6057 != false) { step_6055 = 2 };
							if (step_6055 == 2) { return 'sizeof(' + this.stringifyType(params_6056[0], false) + ')' };
						};
						return s_6048 + this.printCallArguments(args_6047);
					}
				} break;
				
				case 2: {
					return '(' + s_6048 + '(' + this.printExpression(args_6047[0]) + '))'
				} break;
				
				case 3: {
					return '((' + this.printExpression(args_6047[1]) + ')' + s_6048 + ')'
				} break;
				};
			}
		} break;
		
		case 23: {
			const e_6058 = temp_5952[1];
			const to_6059 = temp_5952[2];
			return this.printTypeConverter(this.printExpression(e_6058), this.getType(e_6058), to_6059)
		} break;
		
		case 28: {
			const typeName = temp_5952[1];
			const tagName = temp_5952[2];
			const tag = temp_5952[3];
			const args_6060 = temp_5952[4];
			return '' + typeName + '_$' + tagName + '_(' + (() => {
				const result_6061 = [];
				const value_6062 = args_6060;
				for (const a of $toIterator(value_6062)) result_6061.push(this.printExpression(a));
				return result_6061;
			})().join(', ') + ')'
		} break;
		
		case 29: {
			const expr_6063 = temp_5952[1];
			const index_6064 = temp_5952[2];
			return this.printExpression(expr_6063) + '->enum_[' + index_6064 + ']'
		} break;
		
		default: 
		{
			console.error('Unknown expression kind:', e_5951);
			return '<!--' + ((() => {
				const result_6065 = ((e_5951));
				if (result_6065 != null) { return result_6065 };
				return [];
			})())[0] + '-->';
		}
		};
	};
	}
	GenCxx.spawn = () => { return new GenCxx() };
	var NiceProject = class {
		constructor() { 
			this.interfaces = []
			this.classes = []
			this.enumsSimple = []
			this.enumsComplex = []
			this.globalVars = []
			this.globalFuncs = []
			this.init = []
			this.expressionType = new Map()
			this.expressionPosition = new Map()
			this.statementPosition = new Map()
			this.native = new Map()
			this.mapDecorators = new Map()
		{
	} };
	}
	var NiceClass = class {
		constructor() { 
			this.staticMethods = []
			this.staticVars = []
			this.methods = []
			this.vars = []
			this.property = []
			this.jsRequire = null
			this.jsNative = null
		{
	} };
	}
	var NiceSimpleEnum = class {
		constructor() { 
			this.staticMethods = []
			this.staticVars = []
		{
	} };
	}
	var NiceComplexEnum = class {
		constructor() { 
			this.staticMethods = []
			this.staticVars = []
		{
	} };
	}
	var Decorator = class {
		constructor(name, values) { 
		{
		this.name = name;
		this.values = values;
	} };
	}
	var NodeData = class {
		constructor(atLine, atColumn, atFile) { 
		{
		this.line = atLine;
		this.column = atColumn;
		this.fileName = atFile;
	} };
	}
	var DataHelper = class {
	}
	DataHelper.varName = (v) => {
		const temp = v;
		switch (temp&&temp[0]) {
		case 24: {
			const name = temp[1];
			return name
		} break;
		
		default: 
		throw ('varName got not a Var, but `' + (v) + '`')
		};
	};
	DataHelper.nameOf = (v_6313) => {
		const temp_6314 = v_6313;
		switch (temp_6314&&temp_6314[0]) {
		case 48: {
			const node = temp_6314[1];
			return DataHelper.nameOf(node)
		} break;
		
		case 26: {
			const node_6315 = temp_6314[1];
			return DataHelper.nameOf(node_6315)
		} break;
		
		case 24: {
			const name_6316 = temp_6314[1];
			return name_6316
		} break;
		
		case 39: {
			const t = temp_6314[1];
			{
				{
					const temp_6317 = t;
					switch (temp_6317&&temp_6317[0]) {
					case 1: {
						const name_6318 = temp_6317[1];
						return name_6318
					} break;
					
					case 2: {
						const name_6319 = temp_6317[1];
						return name_6319
					} break;
					};
				};
				throw 'unreachable #1';
			}
		} break;
		
		case 22: {
			const name_6320 = temp_6314[1];
			return name_6320
		} break;
		
		case 25: {
			const t_6321 = temp_6314[1];
			{
				{
					const temp_6322 = t_6321;
					switch (temp_6322&&temp_6322[0]) {
					case 1: {
						const name_6323 = temp_6322[1];
						return name_6323
					} break;
					
					case 2: {
						const name_6324 = temp_6322[1];
						return name_6324
					} break;
					};
				};
				throw 'unreachable #2';
			}
		} break;
		
		case 9: {
			const t_6325 = temp_6314[1];
			{
				const temp_6326 = t_6325;
				switch (temp_6326&&temp_6326[0]) {
				case 1: {
					const name_6327 = temp_6326[1];
					return name_6327
				} break;
				
				case 2: {
					const name_6328 = temp_6326[1];
					return name_6328
				} break;
				};
			}
		} break;
		
		case 47: {
			const field = temp_6314[1];
			return DataHelper.nameOf(field)
		} break;
		
		default: 
		throw ('nameOf expected named node, but got `' + (v_6313) + '`')
		};
	};
	DataHelper.asStringAttValue = (a, index) => {
		const temp_6329 = a.values[index];
		switch (temp_6329&&temp_6329[0]) {
		case null: case undefined: {
			throw 'Got null, not a string'
		} break;
		
		case 0: {
			const s = temp_6329[1];
			return s
		} break;
		
		default: 
		throw ('Got `' + (a.values[index]) + '`, not a string')
		};
	};
	DataHelper.getLastOfBlock = (block) => {
		const temp_6330 = block;
		switch (temp_6330&&temp_6330[0]) {
		case null: case undefined: {
			throw 'Got null, not a block'
		} break;
		
		case 12: {
			const el = temp_6330[1];
			return el[el.length - 1]
		} break;
		
		default: 
		throw ('Got `' + (block) + '`, not a block')
		};
	};
	DataHelper.isVoidValue = (block_6331) => {
		{
			const temp_6332 = block_6331;
			switch (temp_6332&&temp_6332[0]) {
			case null: case undefined: {
				return true
			} break;
			
			case 16: {
				return true
			} break;
			
			case 18: {
				return true
			} break;
			
			case 19: {
				return true
			} break;
			
			case 24: {
				return true
			} break;
			
			case 14: {
				const eelse = temp_6332[3];
				if (eelse == null) { return true }
			} break;
			
			case 39: {
				return true
			} break;
			
			case 25: {
				return true
			} break;
			
			case 34: {
				return true
			} break;
			
			case 12: {
				const el_6333 = temp_6332[1];
				{
					if (el_6333.length == 0) { return true };
					return DataHelper.isVoidValue(el_6333[el_6333.length - 1]);
				}
			} break;
			
			default: 
			return false
			};
		};
		return false;
	};
	DataHelper.extractTypeName = (t_6334) => {
		const temp_6335 = t_6334;
		switch (temp_6335&&temp_6335[0]) {
		case 1: {
			const name_6336 = temp_6335[1];
			return name_6336
		} break;
		
		case 6: {
			const name_6337 = temp_6335[1];
			return name_6337
		} break;
		
		case 2: {
			const name_6338 = temp_6335[1];
			return name_6338
		} break;
		
		case null: case undefined: {
			return null
		} break;
		
		default: 
		return null
		};
	};
	DataHelper.getDecorator = (atts, name_6339) => {
		{
			let step = 0;
			const atts_6340 = atts;
			let temp_6341 = null;
			if (step == 0 && atts_6340 != null) {
				temp_6341 = atts_6340.length > 0;
				step = 1;
			};
			if (step == 1 && temp_6341 != false) { step = 2 };
			if (step == 2) { for (const att of $toIterator(atts_6340)) {
				if (att.name == name_6339) { return att };
			} };
		};
		return null;
	};
	DataHelper.isTitleCase = (string) => { return string.charAt(0) == string.charAt(0).toUpperCase() };
	var ClassType = class {
		constructor() { 
			this.owner = null
			this.fieldNames = []
			this.fieldRenames = []
			this.fieldStatic = []
			this.fieldInitialized = []
			this.protected = []
			this.immutable = []
			this.constructor = (-1)
			this.indexKeyType = null
			this.indexValueType = null
			this.fields = new Map()
			this.genericParams = []
			this.useless = true
			this.extend = null
			this.instanceOf = null
			this.instanceParams = null
			this.instances = []
			this.instanceCache = /*ClassInstance*/[6,this,null,".ClassInstance"]
			this.genericCache = []
		{
	} };
		instantiate() { return this.instanceCache };
		instantiateGeneric(params) {
		for (const cached of $toIterator(this.genericCache)) {
			if (cached.length != (params.length + 1)) { continue };
			let found = true;
			{
				let i = 0;
				let it = 0;
				let at = cached.length - 1;
				while (it < at) {
					i = it;
					it++;
					{
						if (params[i] != cached[i + 1]) {
							found = false;
							break;
						};
					};
				};
			};
			if (found) {
				const result_6384 = cached[0];
				return result_6384;
			};
		};
		const result_6385 = /*ClassInstance*/[6,this,params,".ClassInstance"];
		const cache = [result_6385];
		for (const param of $toIterator(params)) {
			cache.push(param);
		};
		this.genericCache.push(cache);
		return result_6385;
	};
	}
	var EnumType = class {
		constructor() { 
			this.fieldNames = []
			this.tagBindVars = []
			this.tagBindVarsNames = []
			this.fieldStatic = []
			this.fieldEnumConstructor = []
			this.fieldType = []
			this.fieldsTypeSimple = null
		{
	} };
	}
	var AliasType = class {
		constructor(value_6386) { 
		this.value = value_6386 };
	}
	var Module = class {
		constructor() { 
			this.file = '.hexa'
			this.path = 'module'
			this.nodes = []
			this.exported = new Map()
			this.imported = new Map()
		{
	} };
	}
	var Project = class {
		constructor() { 
			this.mapDecorators = new Map()
			this.typeDecorators = new Map()
			this.mapNames = new Map()
			this.mapModules = new Map()
			this.data = new Map()
			this.hints = []
			this.defines = {}
			this.name = 'Hexa Project'
			this.json = 'hexa.json'
			this.roots = []
			this.globals = new Map()
			this.moduleName = []
			this.moduleInfo = []
			this.mapFuncParams = new Map()
		{
	} };
	}
	var CompilerError = class {
		constructor(except, details, line, column, filename) { 
		{
		this.exception = except;
		this.details = (((details == null))? ('') : details);
		this.line = (((line == null))? (0) : line);
		this.column = (((column == null))? (0) : column);
		this.fileName = (((filename == null))? ('') : filename);
	} };
		toString() {
		if (alternativeErrorFormat) { return '' + this.fileName + ':' + this.line + ':' + this.column + ': ' + this.details };
		return '[' + this.fileName + ':' + this.line + ':' + this.column + ']: ' + this.details;
	};
	}
	var CompilerErrors = class {
		constructor(errors) { 
		this.errors = errors };
		toString() {
		{
			let step = 0;
			const error = this.errors[0];
			let temp = null;
			if (step == 0 && error != null) {
				temp = this.errors.length == 1;
				step = 1;
			};
			if (step == 1 && temp != false) { step = 2 };
			if (step == 2) { return error.toString() };
		};
		return (() => {
			const result = [];
			const value = this.errors;
			for (const error of $toIterator(value)) result.push(error.toString());
			return result;
		})().join('\n') + '\nFound ' + this.errors.length + ' errors.';
	};
	}
	var Hint = class {
		constructor(code, details, position) { 
		{
		this.code = code;
		this.details = details;
		this.at = position;
	} };
		toString() { return '[' + this.at.fileName + ':' + this.at.line + ':' + this.at.column + ']: Hint#' + this.code + ': ' + this.details };
	}
	Hint.toTitleCase = (text) => {
		if (text.length == 0) { return text.toUpperCase() };
		return text.substr(0, 1).toUpperCase() + text.substr(1);
	};
	Hint.toCamelCase = (text_6387) => {
		if (text_6387.length == 0) { return text_6387.toLowerCase() };
		return text_6387.substr(0, 1).toLowerCase() + text_6387.substr(1);
	};
	var Main = class {
		processFile(target, project) {
		const content = Fs.readFileSync(target);
		const tokens = Lexer.tokenize(content, target);
		if (tokens.length > 0) { this.lines += tokens.line[tokens.length - 1] };
		const parsed = Parser.parseNodes(tokens, project);
		return parsed;
	};
		simplyCompileToJs(buffer, path) {
		process.argv[0] = __dirname + '/repl.json';
		const resolved = Path.resolve(__dirname + '/repl.hexa');
		fileContents.set(resolved, buffer);
		return new Main().perform(true);
	};
		repl() {
		console.log('\x1b[35m' + ('Hexa ' + (version) + ' on node.js ') + process_3459.versions.node + '\x1b[0m');
		console.log('\x1b[33mTo print something onto screen use `console.log(value)`\x1b[0m');
		console.log('\x1b[33mTo clear REPL memory use `.clear`\x1b[0m');
		console.log('\x1b[33mTo close REPL use `.exit`\x1b[0m');
		let linesAll = [];
		let linesLatest = [];
		while (true) {
			const line = question('\x1b[32m> \x1b[0m').trim();
			if (line == '.clear') {
				linesAll = [];
				linesLatest = [];
				continue;
			};
			if (line == '.exit') { return };
			if (line.length == 0) { continue };
			linesLatest.push(line);
			try {
				let code = '"use strict"\r\n';
				try {
					const content_6399 = linesAll.join('\n') + '\n' + linesLatest.join('\n');
					const compiled = this.simplyCompileToJs(Buffer.from(content_6399), 'REPL');
					if (compiled == null) {
						linesLatest.pop();
						continue;
					};
					{
						let step = 0;
						const compiled_6400 = compiled;
						if (step == 0 && compiled_6400 != null) { step = 1 };
						if (step == 1) { code = compiled_6400 };
					};
				} catch (temp_6398) {
					if (true) { 
					const e = temp_6398
					{
						const error = '' + e;
						if (error.indexOf('<!--end-->') == (-1)) {
							linesLatest = [];
							console.error('\x1b[31mCompilation Error: ' + e, '\x1b[0m');
						} else {
							process_3459.stdout.write('\x1b[32m>\x1b[0m');
						};
						continue;
					} } else
					
					throw temp_6398;
				};
				for (const line of $toIterator(linesLatest)) {
					linesAll.push(line);
				};
				linesLatest = [];
				const result = eval(code);
			} catch (temp) {
				if (true) { 
				const e = temp
				{
					console.error('Error: ' + e);
				} } else
				
				throw temp;
			};
		};
	};
		processFiles(targets, relativePath, loaded, project_6430) {
		const res = [];
		const imports = [];
		for (const target of $toIterator(targets)) {
			if ((!Fs.existsSync(target))) {
				console.log(('No such source file on disk `' + (target) + '`'));
				continue;
			};
			try {
				const parsed_6432 = this.processFile(target, project_6430);
				res.push(parsed_6432);
				for (const e of $toIterator(parsed_6432)) {
					const temp_6433 = e;
					switch (temp_6433&&temp_6433[0]) {
					case 37: {
						const el = temp_6433[1];
						const path_6434 = temp_6433[2];
						{
							const resolved_6435 = Path.resolve(relativePath + path_6434 + '.hexa');
							console.log('processFiles! ' + resolved_6435);
							if (loaded.get(resolved_6435) == true) { console.log('loaded! ' + resolved_6435) };
							if (loaded.get(resolved_6435) != true) {
								loaded.set(resolved_6435, true);
								imports.push(resolved_6435);
							};
						}
					} break;
					};
				};
			} catch (temp_6431) {
				if (true) { 
				const e = temp_6431
				{
					console.log('\x1b[31m' + e.toString() + '\x1b[0m');
				} } else
				
				throw temp_6431;
			};
		};
		if (targets.length != res.length) {
			console.log('[Stopped on errors]');
			process_3459.exit(1);
		};
		if (imports.length > 0) { for (const file of $toIterator(this.processFiles(imports, relativePath, loaded, project_6430))) {
			res.unshift(file);
		} };
		return res;
	};
		incorrect(what, project_6436) {
		const msg_6437 = ('Incorrect package file! Field `' + (what) + '` does not exists');
		throw new CompilerErrors([new CompilerError(5, msg_6437, 1, 1, project_6436.json)]);
	};
		readPackage(filename) { try {
		const pack = JSON.parse(Fs.readFileSync(Path.resolve(filename)).toString('utf8').split('\r\n').join('\n'));
		return pack;
	} catch (temp_6438) {
		if (true) { 
		const e = temp_6438
		{
			const msg_6439 = 'Cannot open ' + filename;
			throw new CompilerErrors([new CompilerError(5, msg_6439, 1, 1, 'hexa.json')]);
		} } else
		
		throw temp_6438;
	} };
		loadPackage(filename_6440, target_6441, project_6442) {
		const pack_6443 = this.readPackage(filename_6440);
		project_6442.json = filename_6440;
		{
			let step_6444 = 0;
			const name_6445 = pack_6443.name;
			if (step_6444 == 0 && name_6445 != null) { step_6444 = 1 };
			if (step_6444 == 1) { project_6442.name = name_6445 } else {
				this.incorrect('name', project_6442);
			};
		};
		if (pack_6443.targets == null) { this.incorrect('targets', project_6442) };
		{
			let step_6446 = 0;
			const entry = pack_6443.entry;
			if (step_6446 == 0 && entry != null) { step_6446 = 1 };
			if (step_6446 == 1) { if ((!entry.startsWith('/'))) { pack_6443.entry = '/' + entry } } else {
				this.incorrect('entry', project_6442);
			};
		};
		{
			let step_6447 = 0;
			const define = pack_6443.define;
			if (step_6447 == 0 && define != null) { step_6447 = 1 };
			if (step_6447 == 1) { for (const key of $toIterator(Reflect.ownKeys(define))) {
				if ((!Reflect.has(project_6442.defines, key))) { Reflect.set(project_6442.defines, key, Reflect.get(define, key)) };
			} };
		};
		const t = (() => {
			{
				let t_6448 = 0;
				let it = 0;
				let at = pack_6443.targets.length;
				while (it < at) {
					t_6448 = it;
					it++;
					{
						if (pack_6443.targets[t_6448].name == target_6441) {
							this.targetIndex = t_6448;
							return pack_6443.targets[t_6448];
						};
					};
				};
			};
			const msg_6449 = ('Cannot find `' + (target_6441) + '` target in package file\n');
			throw new CompilerErrors([new CompilerError(5, msg_6449, 1, 1, project_6442.json)]);
		})();
		const generator = availableGenerators(t.generator);
		if (generator == null) {
			const msg_6450 = ('Generator `' + (t.generator) + '` not available or not supported by this compiler version\n');
			throw new CompilerErrors([new CompilerError(5, msg_6450, 1, 1, project_6442.json)]);
		};
		project_6442.roots.push(Path.resolve(__dirname + '/library/'));
		const dir = Path.dirname(filename_6440);
		{
			let step_6451 = 0;
			const roots_6452 = pack_6443.roots;
			if (step_6451 == 0 && roots_6452 != null) { step_6451 = 1 };
			if (step_6451 == 1) { for (const root of $toIterator(roots_6452)) {
				project_6442.roots.push(Path.resolve(dir + '/' + root));
			} } else {
				project_6442.roots.push(Path.resolve(dir));
			};
		};
		if (pack_6443.files == null) { pack_6443.files = [] };
		pack_6443.global = (() => {
			const result_6453 = pack_6443.global;
			if (result_6453 != null) { return result_6453 };
			return [];
		})();
		{
			let i = 0;
			let it_6454 = 0;
			let at_6455 = pack_6443.global.length;
			while (it_6454 < at_6455) {
				i = it_6454;
				it_6454++;
				{
					let step_6456 = 0;
					const file_6457 = pack_6443.global[i];
					let temp_6458 = null;
					if (step_6456 == 0 && file_6457 != null) {
						temp_6458 = (!file_6457.startsWith('/'));
						step_6456 = 1;
					};
					if (step_6456 == 1 && temp_6458 != false) { step_6456 = 2 };
					if (step_6456 == 2) { pack_6443.global[i] = '/' + file_6457 };
				};
			};
		};
		const global_6459 = pack_6443.global;
		global_6459.forEach((item, index_6460) => { if (global_6459.indexOf(item) != index_6460) {
			const msg_6461 = ('Package `' + (item) + '` included multiple times in the `global` section of `hexa.json`\n');
			throw new CompilerErrors([new CompilerError(5, msg_6461, 1, 1, project_6442.json)]);
		} });
		if (pack_6443.noLib == true) {} else {
			const libraries = setLibrary(generator, t.options, project_6442.defines);
			for (const file of $toIterator(libraries)) {
				pack_6443.global.unshift(file);
			};
		};
		if (pack_6443.addLicenseNoticeToOutput == null) { pack_6443.addLicenseNoticeToOutput = true };
		return pack_6443;
	};
		constructor() { 
			this.lines = 0
			this.targetName = 'default'
			this.targetIndex = 0
			this.typecheckProject = new Project()
		{
	} };
		loadModules(project_6462, input) {
		const moduleErrors = [];
		{
			let step_6463 = 0;
			const global_6464 = input.global;
			if (step_6463 == 0 && global_6464 != null) { step_6463 = 1 };
			if (step_6463 == 1) { for (const path of $toIterator(global_6464)) {
				try { this.lines += Main.processModule(project_6462, path, true) } catch (temp_6465) {
					if (temp_6465 instanceof CompilerErrors) { 
					const e = temp_6465
					{
						const errors = e.errors;
						for (const error of $toIterator(errors)) {
							moduleErrors.push(error);
						};
					} } else
					
					throw temp_6465;
				};
			} };
		};
		try { Main.processModule(project_6462, input.entry, false) } catch (temp_6466) {
			if (temp_6466 instanceof CompilerErrors) { 
			const e = temp_6466
			{
				const errors_6467 = e.errors;
				for (const error of $toIterator(errors_6467)) {
					moduleErrors.push(error);
				};
			} } else
			
			throw temp_6466;
		};
		if (moduleErrors.length > 0) { throw new CompilerErrors(moduleErrors) };
	};
		perform(noWrite) {
		const begin = Date.now();
		Lexer.init();
		if (process_3459.argv[0] == '--alt-error-format') {
			alternativeErrorFormat = true;
			process_3459.argv.shift();
		};
		const defines = {};
		while (process_3459.argv[0] == '--define') {
			if (process_3459.argv.length < 2) {
				console.log('Usage: `--define name=value`');
				process_3459.exit(1);
			};
			process_3459.argv.shift();
			const kv = ((() => {
				const result_6468 = process_3459.argv.shift();
				if (result_6468 != null) { return result_6468 };
				return '';
			})()).split('=');
			if (kv.length < 2) {
				console.log('Usage: `--define name=value`');
				process_3459.exit(1);
			};
			const k = kv[0];
			const v = JSON.parse(kv[1]);
			defines[k] = v;
		};
		const project_6469 = new Project();
		project_6469.defines = defines;
		if (process_3459.argv[0] == 'syntax-linter') {
			if (process_3459.argv.length < 2) { console.log('Usage: `hexa syntax-linter file.hexa`') } else {
				const file_6470 = process_3459.argv[1];
				try {
					const content_6472 = Fs.readFileSync(file_6470);
					try {
						const tokens_6474 = Lexer.tokenize(content_6472, file_6470);
						try { const parser = Parser.parseNodes(tokens_6474, project_6469, true) } catch (temp_6475) {
							if (true) { 
							const e = temp_6475
							{
								console.log(('' + (e) + ''));
							} } else
							
							throw temp_6475;
						};
					} catch (temp_6473) {
						if (true) { 
						const e = temp_6473
						{
							console.log(('' + (e) + ''));
						} } else
						
						throw temp_6473;
					};
				} catch (temp_6471) {
					if (true) { 
					const e = temp_6471
					{
						console.log(('ERROR: Unable to open file ' + (file_6470) + ''));
					} } else
					
					throw temp_6471;
				};
			};
			process_3459.exit(0);
		};
		const ignoreArguments = (fromIndex) => {
			if (fromIndex == process_3459.argv.length) { return };
			const args = [];
			const count = process_3459.argv.length - fromIndex;
			let i_6476 = 0;
			while (i_6476 < count) {
				args.push(process_3459.argv[(i_6476++) + fromIndex]);
			};
			console.log('Argument' + (((args.length > 1)? ('s') : '')) + ' `' + args.join('`, `') + '` ignored');
		};
		if (process_3459.argv[0] == null) {
			this.repl();
			process_3459.exit(0);
		} else if (process_3459.argv[0] == 'init') {
			init();
			ignoreArguments(3);
			process_3459.exit(0);
		} else if (process_3459.argv[0] == 'symlink') {
			symlink();
			process_3459.exit(0);
		};
		const currentFile = Path.resolve(process_3459.argv[0]);
		const currentParsedFile = Path.parse(currentFile);
		let input_6477 = (null);
		let packageFolder = currentParsedFile.dir;
		if (currentParsedFile.ext == '.json') {
			process.argv.shift();
			if (process.argv[0] == 'targets') {
				const pack_6478 = this.readPackage(currentFile);
				if (pack_6478.name == null) { this.incorrect('name', project_6469) };
				if (pack_6478.targets == null) { this.incorrect('targets', project_6469) };
				const targets_6479 = [];
				for (const target of $toIterator(pack_6478.targets)) {
					targets_6479.push(target.name);
				};
				console.log(quote(('The project `' + (pack_6478.name) + '` has following targets: ') + targets_6479.join(', ')));
				return null;
			};
			if (process.argv[0] == '--target') {
				process.argv.shift();
				this.targetName = (() => {
					const result_6480 = process.argv[0];
					if (result_6480 != null) { return result_6480 };
					return 'default';
				})();
				process.argv.shift();
			};
			input_6477 = this.loadPackage(currentFile, this.targetName, project_6469);
			ignoreArguments(0);
			if ((!noWrite)) {
				if (this.targetName != 'default') { console.log(('[Building ' + (input_6477.name) + ' - ' + (this.targetName) + ']')) } else {
					console.log(('[Building ' + (input_6477.name) + ']'));
				};
				console.log(('[Using 1 of ' + (require('os').cpus().length) + ' CPU cores]'));
			};
		} else if ((Fs.existsSync(currentFile)) && (Fs.lstatSync(currentFile).isDirectory())) {
			ignoreArguments(3);
			input_6477 = this.loadPackage(currentFile + Path.sep + 'hexa.json', this.targetName, project_6469);
			packageFolder = currentFile;
		} else if (currentParsedFile.ext == '.hexa') {
			try { eval(this.simplyCompileToJs(Fs.readFileSync(currentFile), currentFile)) } catch (temp_6481) {
				if (true) { 
				const e = temp_6481
				{
					console.error('' + e);
				} } else
				
				throw temp_6481;
			};
			process_3459.exit(0);
			return null;
		} else {
			console.error(('Unknown command: ' + (process_3459.argv[0]) + ''));
			console.error(quote('Try `hexa help`'));
			printVersion();
			process_3459.exit(1);
			return null;
		};
		let files = [];
		if ((false) && (input_6477.files != null)) {
			const relativePath_6482 = packageFolder + Path.sep;
			const loaded_6483 = new Map();
			const fileList = input_6477.files.map((file_6484) => {
				if (file_6484.startsWith('/') || file_6484.charAt(1) == ':') { return Path.resolve(file_6484) };
				const resolved_6485 = Path.resolve(relativePath_6482 + file_6484);
				loaded_6483.set(resolved_6485, true);
				return resolved_6485;
			});
			files = this.processFiles(fileList, relativePath_6482 + '/' + input_6477.root + '/', loaded_6483, project_6469);
		};
		try { this.loadModules(project_6469, input_6477) } catch (temp_6486) {
			if (true) { 
			const e = temp_6486
			{
				console.error(e.toString());
				process_3459.exit(500);
			} } else
			
			throw temp_6486;
		};
		const typer = new Typer(project_6469);
		try { typer.fillModules() } catch (temp_6487) {
			if (true) { 
			const e = temp_6487
			{
				console.log('\x1b[31m' + e.toString() + '\x1b[0m');
				if (noWrite) { return null };
				process_3459.exit(1);
			} } else
			
			throw temp_6487;
		};
		const normalizer = new Normalizer(project_6469);
		const generators = new Map();
		const registerTarget = (name_6488, generator_6489) => {
			{
				let step_6490 = 0;
				const generator_6491 = generators.get(name_6488);
				if (step_6490 == 0 && generator_6491 != null) { step_6490 = 1 };
				if (step_6490 == 1) { console.log(('Note: generator `' + (name_6488) + '` was overridden')) };
			};
			generators.set(name_6488, generator_6489);
		};
		registerTarget('js', GenJs.spawn);
		registerTarget('c', GenCxx.spawn);
		{
			let step_6492 = 0;
			const generatorName = input_6477.targets[this.targetIndex].generator;
			if (step_6492 == 0 && generatorName != null) { step_6492 = 1 };
			if (step_6492 == 1) {
				let step_6493 = 0;
				const generatorSpawner = generators.get(generatorName);
				if (step_6493 == 0 && generatorSpawner != null) { step_6493 = 1 };
				if (step_6493 == 1) {
					const generator_6494 = generatorSpawner();
					const target_6495 = packageFolder + Path.sep + Path.parse(input_6477.targets[this.targetIndex].output).name + generator_6494.extension;
					const target_6496 = Path.join(packageFolder, input_6477.targets[this.targetIndex].output);
					normalizer.keywords = generator_6494.reserved;
					normalizer.collected = files;
					normalizer.nativeEnums = generator_6494.nativeEnums;
					normalizer.reservedGlobals = (() => {
						const result_6497 = generator_6494.reservedGlobals;
						if (result_6497 != null) { return result_6497 };
						return normalizer.reservedGlobals;
					})();
					normalizer.package = input_6477;
					{
						let step_6498 = 0;
						const randomSeed = input_6477.randomSeed;
						if (step_6498 == 0 && randomSeed != null) { step_6498 = 1 };
						if (step_6498 == 1) { normalizer.id = randomSeed };
					};
					{
						let step_6499 = 0;
						const globalAccessor = generator_6494.globalAccessor;
						if (step_6499 == 0 && globalAccessor != null) { step_6499 = 1 };
						if (step_6499 == 1) { normalizer.globalAccessor = globalAccessor };
					};
					normalizer.typer = typer;
					const normal = normalizer.normalize();
					for (const hint of $toIterator(project_6469.hints)) {
						console.log(hint.toString());
					};
					const outs = generator_6494.perform(normal);
					if (noWrite) { return outs };
					Fs.writeFileSync(target_6496, outs);
				} else {
					console.log(('Generator for `' + (generatorName) + '` is not registered.'));
					process_3459.exit(1);
				};
			} else {
				console.log('Generator is not defined or unknown. Is there `target.generator` field in `hexa.json`?');
				process_3459.exit(1);
			};
		};
		const delta = Date.now() - begin;
		const lps = Math.round(this.lines / (delta / 1000));
		console.log(('[Finished in ' + (delta) + ' ms, ' + (this.lines) + ' lines, ' + (lps) + ' lines per second]'));
		process_3459.stdout.once('drain', () => { process_3459.exit(0) });
		process_3459.stdout.write('');
		return null;
	};
		typecheck(dir_6500) {
		try {
			const project_6502 = new Project();
			this.typecheckProject = project_6502;
			const defines_6503 = {};
			project_6502.defines = defines_6503;
			const input_6504 = this.loadPackage(dir_6500 + Path.sep + 'hexa.json', this.targetName, project_6502);
			try { this.loadModules(project_6502, input_6504) } catch (temp_6505) {
				if (true) { 
				const e = temp_6505
				{
					return e;
				} } else
				
				throw temp_6505;
			};
			const typer_6506 = new Typer(project_6502);
			try { typer_6506.fillModules() } catch (temp_6507) {
				if (true) { 
				const e = temp_6507
				{
					return e;
				} } else
				
				throw temp_6507;
			};
		} catch (temp_6501) {
			if (true) { 
			const e = temp_6501
			{
				return e;
			} } else
			
			throw temp_6501;
		};
		return new CompilerErrors([]);
	};
	}
	Main.processGlobals = (project_6401, path_6402, fullPath) => {
		const index = project_6401.moduleName.indexOf((() => {
			const result_6403 = fullPath;
			if (result_6403 != null) { return result_6403 };
			return path_6402;
		})());
		{
			let step_6404 = 0;
			const info = project_6401.moduleInfo[index];
			if (step_6404 == 0 && info != null) { step_6404 = 1 };
			if (step_6404 == 1) {
				const nodes = info.nodes;
				for (const e of $toIterator(nodes)) {
					let named = true;
					{
						const temp_6405 = e;
						switch (temp_6405&&temp_6405[0]) {
						case 24: {
							{
							}
						} break;
						
						case 39: {
							{
							}
						} break;
						
						case 22: {
							{
							}
						} break;
						
						case 25: {
							{
							}
						} break;
						
						default: 
						named = false
						};
					};
					if (named) {
						const name = DataHelper.nameOf(e);
						if (project_6401.globals.has(name)) {
							const data = project_6401.data.get(e);
							const already = project_6401.data.get(project_6401.globals.get(name));
							const msg = ('Global node `' + (name) + '` declared in `' + (path_6402) + '` already defined at `' + (already.fileName) + '` line `' + (already.line) + '`');
							throw new CompilerErrors([new CompilerError(5, msg, data.line, data.column, data.fileName)]);
						} else {
							project_6401.globals.set(name, e);
						};
					};
				};
			};
		};
	};
	Main.processModule = (project_6406, path_6407, global, relative, node) => {
		let lines = 0;
		const tryInRoot = (root, fullPath_6408) => {
			const file = Path.join(root, path_6407 + '.hexa');
			if (Fs.existsSync(file)) { try {
				const resolved_6410 = Path.resolve(file);
				let cachedBuffer = Buffer.from('');
				{
					let step_6411 = 0;
					const cached = fileContents.get(resolved_6410);
					if (step_6411 == 0 && cached != null) { step_6411 = 1 };
					if (step_6411 == 1) { cachedBuffer = cached } else {
						cachedBuffer = Fs.readFileSync(file);
					};
				};
				const content_6412 = cachedBuffer;
				const tokens_6413 = Lexer.tokenize(content_6412, file);
				if (tokens_6413.length > 0) { lines += tokens_6413.line[tokens_6413.length - 1] };
				const parsed_6414 = Parser.parseNodes(tokens_6413, project_6406);
				project_6406.moduleName.push(fullPath_6408);
				const info_6415 = new Module();
				info_6415.nodes = parsed_6414;
				info_6415.file = file;
				info_6415.path = fullPath_6408;
				project_6406.moduleInfo.push(info_6415);
				project_6406.mapModules.set(node, info_6415);
				for (const e of $toIterator(parsed_6414)) {
					const temp_6416 = e;
					switch (temp_6416&&temp_6416[0]) {
					case 37: {
						const path_6417 = temp_6416[2];
						Main.processModule(project_6406, path_6417, false, info_6415, e)
					} break;
					};
				};
				if (global == true) { Main.processGlobals(project_6406, path_6407, fullPath_6408) };
				return lines;
			} catch (temp_6409) {
				if (true) { 
				const e = temp_6409
				{
					throw e;
				} } else
				
				throw temp_6409;
			} };
			return (-1);
		};
		let roots = project_6406.roots;
		{
			let step_6418 = 0;
			const relative_6419 = relative;
			let temp_6420 = null;
			if (step_6418 == 0 && relative_6419 != null) {
				temp_6420 = (!path_6407.startsWith('/'));
				step_6418 = 1;
			};
			if (step_6418 == 1 && temp_6420 != false) { step_6418 = 2 };
			if (step_6418 == 2) {
				const root_6421 = Path.dirname(relative_6419.file);
				roots = [root_6421];
			};
		};
		for (const root of $toIterator(roots)) {
			const file_6422 = Path.join(root, path_6407 + '.hexa');
			let fullPath_6423 = '';
			if (Fs.existsSync(file_6422)) { fullPath_6423 = Path.relative(Path.dirname(project_6406.json), file_6422).slice(0, (-5)).split('\\').join('/') };
			const index_6424 = project_6406.moduleName.indexOf(fullPath_6423);
			if (index_6424 > (-1)) {
				if (global == true) { Main.processGlobals(project_6406, path_6407, fullPath_6423) };
				project_6406.mapModules.set(node, project_6406.moduleInfo[index_6424]);
				return lines;
			};
			const lines_6425 = tryInRoot(root, fullPath_6423);
			if (lines_6425 > (-1)) { return lines_6425 };
		};
		let msg_6426 = ('Cannot find file `' + (path_6407) + '` in any of the roots.\n');
		if (path_6407.endsWith('.hexa')) { msg_6426 += ('Do not write `.hexa` extension in imports, just use `import ... in \'' + (path_6407.replace('.hexa', '')) + '\'`.\n') };
		for (const root of $toIterator(roots)) {
			const file_6427 = Path.join(root, path_6407 + '.hexa');
			msg_6426 += ('Checked here: `' + (file_6427) + '`\n');
		};
		{
			let step_6428 = 0;
			const data_6429 = project_6406.data.get(node);
			if (step_6428 == 0 && data_6429 != null) { step_6428 = 1 };
			if (step_6428 == 1) { throw new CompilerErrors([new CompilerError(3, msg_6426, data_6429.line, data_6429.column, data_6429.fileName)]) };
		};
		throw new CompilerErrors([new CompilerError(5, msg_6426, 1, 1, project_6406.json)]);
	};
	var Server = class {
		constructor(port) { 
		{
		this.port = ((port == null)? (3978) : parseInt(port));
		const port_6516 = this.port;
		console.log('Requested language server at localhost:' + port_6516);
		Lexer.init();
		const http = require('http');
		const fs = require('fs');
		const path = require('path');
		const url = require('url');
		const project_6517 = new Project();
		const empty = '[]';
		const handleRequest = (project_6518, req, res) => {
			const chunks = [];
			req.on('data', (chunk) => (chunks.push(chunk)));
			req.on('end', () => {
				const start = Date.now();
				const data = Buffer.concat(chunks);
				const text = data.toString().trim();
				if (text.length > 0) {
					const json = JSON.parse(data.toString());
					const commands = json;
					if (commands.length == 0) {
						res.writeHead(404, {});
						res.write('[]');
						res.end();
					} else {
						const responseToAll = [];
						for (const command of $toIterator(commands)) {
							const response = [];
							{
								const temp_6519 = command.kind;
								switch (temp_6519) {
								case 'GetWholeFileSyntaxErrors': {
									{
										const file_6520 = 'hexa.hexa';
										const content_6521 = Buffer.from(command.payload);
										const errors_6522 = syntaxCheckOnly('hexa.hexa', content_6521);
										for (const error of $toIterator(errors_6522)) {
											response.push(error);
										};
									}
								} break;
								
								case 'HoverProvider': {
									{
										const fsPath_6523 = Path.resolve(command.payload.fsPath);
										const line = command.payload.line + 1;
										const character = command.payload.character;
										const project_6524 = findProjectFile(fsPath_6523);
										if (project_6524.found == true) { try {
											const main = new Main();
											main.typecheck(project_6524.dir);
											const typecheckProject = main.typecheckProject;
											for (const mod of $toIterator(typecheckProject.moduleInfo)) {
												if (mod.file != fsPath_6523) { continue };
												const poss = [];
												let nearest = null;
												for (const node of $toIterator(mod.nodes)) {
													const data_6526 = typecheckProject.data.get(node);
													{
														let step = 0;
														const data_6527 = data_6526;
														if (step == 0 && data_6527 != null) { step = 1 };
														if (step == 1) {
															poss.push(DataHelper.nameOf(node) + ' ' + JSON.stringify(data_6527));
															const offset = 0;
															let width = 0;
															{
																const temp_6528 = node;
																switch (temp_6528&&temp_6528[0]) {
																case 25: {
																	const t = temp_6528[1];
																	width = 6 + NodeType.stringify(t).length
																} break;
																};
															};
															if ((line == data_6527.line) && (character >= data_6527.column + offset) && (character < data_6527.column + offset + width)) {
																nearest = node;
																break;
															};
														};
													};
												};
												{
													let step_6529 = 0;
													const nearest_6530 = nearest;
													if (step_6529 == 0 && nearest_6530 != null) { step_6529 = 1 };
													if (step_6529 == 1) {
														let code = '';
														const doc = '';
														{
															const temp_6531 = nearest_6530;
															switch (temp_6531&&temp_6531[0]) {
															case 25: {
																const t_6532 = temp_6531[1];
																{
																	const name = NodeType.stringify(t_6532);
																	code = 'class ' + name;
																}
															} break;
															
															case 39: {
																const t_6533 = temp_6531[1];
																{
																	const name_6534 = NodeType.stringify(t_6533);
																	code = 'enum ' + name_6534;
																}
															} break;
															};
														};
														response.push({code:code, markdown:doc + '\n\n' + line + ':!:' + character + ' = ' + '\n' + poss.join('\n') + '\n\n\n' + Node.stringify(nearest_6530)});
													};
												};
											};
											response.push({markdown:'Hover information not available for ' + fsPath_6523});
										} catch (temp_6525) {
											if (true) { 
											const e = temp_6525
											{
												response.push({markdown:'Fix errors in code to see type hints'});
											} } else
											
											throw temp_6525;
										} } else {
											response.push({markdown:'Hover information does not work with files not attached to any projects'});
										};
									}
								} break;
								
								case 'DocumentSymbolProvider': {
									{
										const fsPath_6535 = Path.resolve(command.payload.fsPath);
										const content_6536 = fileContents.get(fsPath_6535);
										const project_6537 = new Project();
										{
											let step_6538 = 0;
											const buffer = content_6536;
											let nodes = null;
											if (step_6538 == 0 && buffer != null) {
												nodes = parseOnly(fsPath_6535, content_6536, project_6537);
												step_6538 = 1;
											};
											if (step_6538 == 1 && nodes != null) { step_6538 = 2 };
											if (step_6538 == 2) {
												let lastPos = {line:1, start:1, end:1};
												const posToRange = (node, length) => {
													const data_6539 = project_6537.data.get(node);
													{
														let step_6540 = 0;
														const data_6541 = data_6539;
														if (step_6540 == 0 && data_6541 != null) { step_6540 = 1 };
														if (step_6540 == 1) { lastPos = {line:data_6541.line - 1, start:data_6541.column, end:data_6541.column + length} };
													};
													return lastPos;
												};
												const inferTypeFromExpr = (node_6542) => {
													{
														const temp_6543 = node_6542;
														switch (temp_6543&&temp_6543[0]) {
														case null: case undefined: {
															return null
														} break;
														
														case 0: {
															return 'String'
														} break;
														
														case 31: {
															return 'Array'
														} break;
														
														case 32: {
															return 'Map'
														} break;
														
														case 5: {
															return 'Int'
														} break;
														
														case 7: {
															return 'Float'
														} break;
														
														case 2: {
															return 'Bool'
														} break;
														};
													};
													return null;
												};
												const fieldToSymbol = (node_6544, isStatic) => {
													{
														const temp_6545 = node_6544;
														switch (temp_6545&&temp_6545[0]) {
														case 24: {
															const name_6546 = temp_6545[1];
															const t_6547 = temp_6545[2];
															const expr = temp_6545[3];
															const const_6548 = temp_6545[4];
															return {name:name_6546, detail:(((isStatic)? ('static ') : '')) + ((() => {
																const result = NodeType.stringify(t_6547);
																if (result != null) { return result };
																return (() => {
																	const result_6549 = inferTypeFromExpr(expr);
																	if (result_6549 != null) { return result_6549 };
																	return (((const_6548)? ('let') : 'var'));
																})();
															})()), kind:((const_6548)? (13) : 12), range:posToRange(node_6544, name_6546.length), children:[]}
														} break;
														
														case 22: {
															const name_6550 = temp_6545[1];
															const external = temp_6545[5];
															{
																const name_6551 = (() => {
																	const result_6552 = name_6550;
																	if (result_6552 != null) { return result_6552 };
																	return 'new';
																})();
																return {name:name_6551, detail:((external)? ('declare fun') : (((isStatic)? ('static fun') : (((name_6551 == 'new')? ('constructor') : 'fun'))))), kind:11, range:posToRange(node_6544, name_6551.length), children:[]};
															}
														} break;
														
														case 47: {
															const field = temp_6545[1];
															return fieldToSymbol(field, true)
														} break;
														
														case 51: {
															const type = temp_6545[1];
															{
																const name_6553 = NodeType.stringify(type);
																return {name:name_6553, detail:'', kind:21, range:posToRange(node_6544, name_6553.length), children:[]};
															}
														} break;
														
														case 10: {
															const a = temp_6545[1];
															const op = temp_6545[2];
															const b = temp_6545[3];
															{
																const name_6554 = Node.stringify(a);
																return {name:name_6554, detail:'= ' + Node.stringify(b), kind:21, range:posToRange(node_6544, name_6554.length), children:[]};
															}
														} break;
														
														case 13: {
															const e = temp_6545[1];
															const args = temp_6545[2];
															const argNames = temp_6545[3];
															{
																const name_6555 = Node.stringify(e);
																return {name:name_6555, detail:argNames.join(', '), kind:21, range:posToRange(node_6544, name_6555.length), children:[]};
															}
														} break;
														};
													};
													return null;
												};
												const fieldsToSymbols = (fields) => { return fields.map((field_6556) => (fieldToSymbol(field_6556, false))).filter((f) => (f != null)) };
												for (const node of $toIterator(nodes)) {
													const temp_6557 = node;
													switch (temp_6557&&temp_6557[0]) {
													case 24: {
														response.push(fieldToSymbol(node, false))
													} break;
													
													case 22: {
														response.push(fieldToSymbol(node, false))
													} break;
													
													case 25: {
														const t_6558 = temp_6557[1];
														const extend = temp_6557[2];
														const implement = temp_6557[3];
														const fields_6559 = temp_6557[4];
														{
															let detail = 'class';
															{
																let step_6560 = 0;
																const extend_6561 = extend;
																if (step_6560 == 0 && extend_6561 != null) { step_6560 = 1 };
																if (step_6560 == 1) { detail = 'extends ' + NodeType.stringify(extend_6561) };
															};
															const name_6562 = NodeType.stringify(t_6558);
															response.push({name:name_6562, detail:detail, kind:4, range:posToRange(node, name_6562.length), children:fieldsToSymbols(fields_6559)});
														}
													} break;
													
													case 39: {
														const t_6563 = temp_6557[1];
														const fields_6564 = temp_6557[2];
														const valuesType = temp_6557[3];
														{
															let detail_6565 = 'enum';
															{
																let step_6566 = 0;
																const valuesType_6567 = valuesType;
																if (step_6566 == 0 && valuesType_6567 != null) { step_6566 = 1 };
																if (step_6566 == 1) { detail_6565 = ': ' + NodeType.stringify(valuesType_6567) };
															};
															const name_6568 = NodeType.stringify(t_6563);
															response.push({name:name_6568, detail:detail_6565, kind:9, range:posToRange(node, name_6568.length), children:fieldsToSymbols(fields_6564)});
														}
													} break;
													};
												};
												fileOutline.set(fsPath_6535, response);
												console.log('chached: ' + fsPath_6535 + ' ' + response.length);
											} else {
												let step_6569 = 0;
												const cache = (fileOutline.get(fsPath_6535));
												if (step_6569 == 0 && cache != null) { step_6569 = 1 };
												if (step_6569 == 1) {
													console.log('from chache: ' + fsPath_6535 + ' ' + cache.length);
													for (const item of $toIterator(cache)) {
														response.push(item);
													};
												} else {
													console.log('notInCache: ' + fsPath_6535);
													response.push({fail:'notInCache', fsPath:fsPath_6535});
												};
											};
										};
									}
								} break;
								
								case 'SyncFileContents': {
									{
										const fsPath_6570 = command.payload.fsPath;
										const content_6571 = command.payload.content;
										fileContents.set(Path.resolve(fsPath_6570), Buffer.from(content_6571));
									}
								} break;
								
								case 'DiscardFileContents': {
									{
										const fsPath_6572 = command.payload.fsPath;
										fileContents.delete(Path.resolve(fsPath_6572));
									}
								} break;
								
								case 'AutocheckProject': {
									{
										const fsPath_6573 = command.payload.fsPath;
										const project_6574 = findProjectFile(fsPath_6573);
										if (project_6574.found == true) { try {
											const e_6576 = new Main().typecheck(project_6574.dir);
											const errors_6577 = e_6576.errors;
											if (errors_6577 == null) { console.log('e -->', e_6576) };
											for (const error of $toIterator(errors_6577)) {
												response.push(error);
											};
										} catch (temp_6575) {
											if (true) { 
											const e = temp_6575
											{
												console.log('Compiler stopped with exception', e);
												response.push(new CompilerError(6, 'Compiler stopped with exception: ' + JSON.stringify(e.message), 0, 0, project_6574.dir + Path.sep + 'hexa.json'));
											} } else
											
											throw temp_6575;
										} } else {
											const resolved = Path.resolve(fsPath_6573);
											{
												let step_6578 = 0;
												const content_6579 = fileContents.get(resolved);
												if (step_6578 == 0 && content_6579 != null) { step_6578 = 1 };
												if (step_6578 == 1) {
													const errors_6580 = syntaxCheckOnly(resolved, content_6579);
													for (const error of $toIterator(errors_6580)) {
														response.push(error);
													};
												};
											};
										};
									}
								} break;
								
								case 'FindProjectFile': {
									{
										const fsPath_6581 = command.payload;
										response.push(findProjectFile(fsPath_6581));
									}
								} break;
								
								case 'CompletionItemProvider': {
									{
										const fsPath_6582 = Path.resolve(command.payload.fsPath);
										const project_6583 = findProjectFile(fsPath_6582);
										if (project_6583.found == true) { try {
											const main_6585 = new Main();
											const e_6586 = main_6585.typecheck(project_6583.dir);
											const completes = [];
											const errors_6587 = e_6586.errors;
											const typecheckProject_6588 = main_6585.typecheckProject;
											for (const mod of $toIterator(typecheckProject_6588.moduleInfo)) {
												if (mod.file != fsPath_6582) { continue };
												console.log('mod.file', mod.file, mod.path, Path.relative(project_6583.dir, mod.file));
												const available = [];
												for (const name of $toIterator(mod.imported.keys())) {
													available.push(name);
												};
												for (const name of $toIterator(mod.exported.keys())) {
													available.push(name);
												};
												for (const name of $toIterator(typecheckProject_6588.globals.keys())) {
													if ((!available.includes(name))) { available.push(name) };
												};
												for (const name of $toIterator(available)) {
													let node_6589 = mod.exported.get(name);
													let imported = '';
													let file_6590 = '';
													if (node_6589 == null) {
														node_6589 = mod.imported.get(name);
														{
															let step_6591 = 0;
															const temp_6592 = node_6589 != null;
															let mod = null;
															if (step_6591 == 0 && temp_6592 != false) {
																mod = typecheckProject_6588.mapModules.get(node_6589);
																step_6591 = 1;
															};
															if (step_6591 == 1 && mod != null) { step_6591 = 2 };
															if (step_6591 == 2) {
																imported = mod.path;
																file_6590 = mod.file;
															};
														};
													};
													if (node_6589 == null) {
														imported = '*';
														node_6589 = typecheckProject_6588.globals.get(name);
													};
													const complete = {imported:imported, file:file_6590, name:name, detail:name, kind:0};
													{
														const temp_6593 = node_6589;
														switch (temp_6593&&temp_6593[0]) {
														case 25: {
															const t_6594 = temp_6593[1];
															{
																complete.detail = 'class ' + NodeType.stringify(t_6594) + ' {  }';
																complete.kind = 6;
															}
														} break;
														
														case 39: {
															const t_6595 = temp_6593[1];
															const valuesType_6596 = temp_6593[3];
															{
																{
																	let step_6597 = 0;
																	const valuesType_6598 = valuesType_6596;
																	if (step_6597 == 0 && valuesType_6598 != null) { step_6597 = 1 };
																	if (step_6597 == 1) { complete.detail = 'enum ' + NodeType.stringify(t_6595) + ' : ' + NodeType.stringify(valuesType_6598) + ' {  }' } else {
																		complete.detail = 'enum ' + NodeType.stringify(t_6595) + ' {  }';
																	};
																};
																complete.kind = 12;
															}
														} break;
														
														case 24: {
															const const_6599 = temp_6593[4];
															{
																complete.detail = (((const_6599)? ('let ') : 'var ')) + name;
																complete.kind = 5;
															}
														} break;
														
														case 22: {
															{
																complete.detail = 'fun ' + name + '() {  }';
																complete.kind = 2;
															}
														} break;
														};
													};
													completes.push(complete);
												};
												break;
											};
											response.push(completes);
										} catch (temp_6584) {
											if (true) { 
											const e = temp_6584
											{
											} } else
											
											throw temp_6584;
										} } else {
											response.push([]);
										};
									}
								} break;
								
								default: 
								console.log('Unknown command kind', command.kind, command)
								};
							};
							responseToAll.push(response);
						};
						res.writeHead(200, {});
						res.write(JSON.stringify(responseToAll));
						const end = Date.now();
						const heapUsed = Math.round(process.memoryUsage().heapUsed / 1024 / 1024);
						console.log(('[Response finished in ' + (end - start) + ' ms, uses ' + (heapUsed) + ' MB]'));
						res.end();
					};
				} else {
					res.writeHead(400, {});
					res.write('[]');
					res.end();
				};
			});
		};
		const server = http.createServer((req_6600, res_6601) => (handleRequest(project_6517, req_6600, res_6601)));
		server.listen(port_6516, () => ((() => {
			console.log('Compiler version:', version);
			return console.log('Ready to Hexa!');
		})()));
	} };
	}
	function hasOwnProperty(object, name) { return object.hasOwnProperty(name) };
	function btoa(text_3472) { return Buffer.from(text_3472, 'binary').toString('base64') };
	function atob(base64) { return Buffer.from(base64, 'base64').toString('binary') };
	function availableGenerators(name) {
		const temp = name;
		switch (temp) {
		case 'js': {
			return 'JavaScript'
		} break;
		
		case 'native': {
			return 'Native'
		} break;
		
		case 'c': {
			return 'Native'
		} break;
		
		default: 
		return null
		};
	};
	function setLibrary(target, options, defines) {
		const files = [];
		defines.native = (() => {
			const result = defines.native;
			if (result != null) { return result };
			return false;
		})();
		defines.js = (() => {
			const result_6388 = defines.js;
			if (result_6388 != null) { return result_6388 };
			return false;
		})();
		{
			const temp_6389 = target;
			switch (temp_6389) {
			case 'JavaScript': {
				{
					defines.js = (() => {
						const result_6390 = defines.js;
						if (result_6390 != null) { return result_6390 };
						return true;
					})();
					files.push('/js/js');
					if (options.includes('nodejs')) { files.unshift('/nodejs/nodejs') };
					if (options.includes('browser')) { files.unshift('/browser/html') };
				}
			} break;
			
			case 'Native': {
				{
					defines.native = (() => {
						const result_6391 = defines.native;
						if (result_6391 != null) { return result_6391 };
						return true;
					})();
					const is64 = ((defines.bit64 == null)? (true) : defines.bit64);
					defines.bit64 = ((is64)? (true) : false);
					defines.bit32 = ((is64)? (false) : true);
					defines.native = (() => {
						const result_6392 = defines.native;
						if (result_6392 != null) { return result_6392 };
						return true;
					})();
					defines.bundledRuntime = (() => {
						const result_6393 = defines.bundledRuntime;
						if (result_6393 != null) { return result_6393 };
						return true;
					})();
					files.push('/c/c');
					files.push('/c/array');
					files.push('/c/string');
					files.push('/c/map');
					files.push('/c/runtime');
					for (const option of $toIterator(options)) {
						const temp_6394 = option;
						switch (temp_6394) {
						default: 
						console.log(('Option `' + (option) + '` ignored for target `' + (target) + '`'))
						};
					};
				}
			} break;
			};
		};
		return files;
	};
	function indigo(text) { return '\x1b[35m' + text + '\x1b[0m' };
	function blue(text_6395) { return '\x1b[34m' + text_6395 + '\x1b[0m' };
	function ocean(text_6396) { return '\x1b[36m' + text_6396 + '\x1b[0m' };
	function ignoreRestArguments() { if (process.argv.length > 0) {
		const args = process.argv;
		console.log('Argument' + (((args.length > 1)? ('s') : '')) + ' \x1b[36m`' + args.join('`\x1b[0m, \x1b[36m`') + '`\x1b[0m ignored');
	} };
	function quote(text_6397) {
		const result = [];
		let even = false;
		for (const string of $toIterator(text_6397.split('`'))) {
			if (even == false) { result.push(string) } else {
				result.push('\x1b[33m');
				result.push('`');
				result.push(string);
				result.push('`');
				result.push('\x1b[0m');
			};
			even = (!even);
		};
		return result.join('');
	};
	function printVersion() {
		console.log(indigo(('Hexa ' + (version) + ' on node.js ') + process_3459.versions.node));
		process.argv.shift();
		ignoreRestArguments();
		process.exit(0);
	};
	function printHelp() {
		console.log(indigo(('Hexa ' + (version) + ' on node.js ') + process_3459.versions.node));
		console.log(ocean('Use `hexa hexa.json` to simply build `default` target'));
		console.log(quote('`hexa init` creates new project by asking some questions'));
		console.log(quote('`hexa hexa.json targets` show available targets for the project'));
		console.log(quote('`hexa help` shows this help'));
		console.log(quote('`hexa version` shows compiler version'));
		console.log(quote('`hexa listen` or `hexa listen 3978` starts language server on the selected port'));
		process.argv.shift();
		ignoreRestArguments();
		process.exit(0);
	};
	function question(query) {
		process_3459.stdout.write(query);
		const bufsize = 256;
		const buf = Buffer.alloc(bufsize);
		let bytesRead = 0;
		const stdin = (((process.platform == 'win32'))? (process_3459.stdin.fd) : Fs.openSync('/dev/stdin', 'rs'));
		try { bytesRead = Fs.readSync(stdin, buf, 0, bufsize) } catch (temp) {
			if (true) { 
			const e = temp
			{
				const e = e;
				if (e.code == 'EAGAIN') { return 'ERROR: interactive stdin input not supported.' };
				if (e.code == 'EOF') { return '' };
				throw e;
			} } else
			
			throw temp;
		};
		if (bytesRead == 0) { return '' };
		const answer = buf.toString('utf8', 0, bytesRead).trim();
		return answer;
	};
	function symlink() {
		const temp = (process.platform);
		switch (temp) {
		case 'linux': case 'mac???TODO': {
			{
				Fs.renameSync('./hexa', '/usr/bin/hexa');
				console.log('Symlinked successfully!');
			}
		} break;
		
		case 'win32???TODO': {
			{
			}
		} break;
		
		default: 
		{
			console.log(('Cannot symlink on ' + (process.platform) + '. You must add hexa to your PATH manually.'));
			process_3459.exit(1);
		}
		};
	};
	function init() {
		if (Fs.existsSync('hexa.json')) {
			const create = question('Hexa package \'hexa.json\' already exists here. Create new? (no): ');
			if (create == '' || (!isYes(create))) { process_3459.exit(1) };
		};
		const currentDirTmp = process.cwd().split(Path.sep);
		const packageFileName = process.cwd() + Path.sep + 'hexa.json';
		const currentDir = currentDirTmp[currentDirTmp.length - 1];
		let name = question(('Enter package name (' + (currentDir) + '): '));
		if (name == '') { name = currentDir };
		let version_6508 = question('Enter package version (1.0.0): ');
		if (version_6508 == '') { version_6508 = '1.0.0' };
		const description = question('Enter package description: ');
		let main = question('Enter main file (main.hexa): ');
		if (main == '') { main = 'main.hexa' };
		const target = {name:'default', generator:'js', output:name, options:[]};
		const generator = question('Enter target (Node.js/JavaScript):\n1. Node.js/JavaScript\n2. Web/JavaScript\n3. Raw/JavaScript\n> ').trim();
		if (generator == '2') {
			target.options.push('browser');
			target.output += '.js';
		} else if (generator == '3') { target.output += '.js' } else {
			target.options.push('nodejs');
			target.output += '.js';
		};
		while ((!main.endsWith('.hexa'))) {
			process_3459.stdout.write('Wrong file name. Must end with \'.hexa\'.\n');
			main = question('Enter main file (main.hexa): ');
		};
		const user = (() => {
			const result = require('os').userInfo().username;
			if (result != null) { return result };
			return process.env['USERNAME'];
		})();
		let author = question(('Enter package author name (' + (user) + '): '));
		if (author == '') { author = user };
		let license = question('Enter license (LGPL-3.0-only): ');
		if (license == '') { license = 'LGPL-3.0-only' };
		const pack = {name:name, version:version_6508, description:description, author:author, license:license, targets:[target], entry:main.split('.')[0]};
		const extras = [];
		let addGit = false;
		if (Fs.existsSync('.git')) { if ((!Fs.existsSync('.gitignore')) || (!Fs.existsSync('.gitattributes'))) {
			const confirm = question('Create additional git files(.gitignore, .gitattributes)? (yes): ').toLowerCase().trim();
			if (isYes(confirm)) {
				if ((!Fs.existsSync('.gitignore'))) { extras.push('.gitignore') };
				if ((!Fs.existsSync('.gitattributes'))) { extras.push('.gitattributes') };
				addGit = true;
			};
		} };
		const addMain = Fs.existsSync(main) == false;
		if (addMain) { extras.push(main) };
		const packageStr = JSON.stringify(pack, null, '\t').split('\r\n').join('\n').split('\n').join('\r\n');
		const extrasStr = ((extras.length > 0)? ('\nAnd \'' + extras.join('\', \'') + '\'') : '');
		const answ = question(('About to write to: ' + (packageFileName) + ':\n' + (packageStr) + '' + (extrasStr) + '\nIs this ok? (yes): '));
		if ((!isYes(answ))) {
			console.log('Exiting without changes');
			process_3459.exit(1);
		};
		Fs.writeFileSync('hexa.json', packageStr + '\r\n');
		if ((addMain) && ((!Fs.existsSync(main)))) { Fs.writeFileSync(main, 'console.log("Thank you for choosing Hexa")\r\n') };
		if ((addGit) && ((!Fs.existsSync('.gitattributes')))) { Fs.writeFileSync('.gitattributes', ['# Auto detect text files and perform LF normalization', '* text=auto', ''].join('\r\n')) };
		if ((addGit) && ((!Fs.existsSync('.gitignore')))) { Fs.writeFileSync('.gitignore', ['# Mac & Win', '*~', '._*', '*DS_Store*', '.DS_Store', '.DS_Store?', '.Spotlight-V100', '.Trashes', 'ehthumbs.db', 'Thumbs.db', '*Thumbs.db', '__MACOSX', '', '# Custom', '*.map', target.output, 'node_modules', ''].join('\r\n')) };
		process_3459.stdout.write('Hexa package initialized!');
	};
	function isYes(answer) { return ['y', 'yes', ''].includes(answer.toLowerCase().trim()) };
	function findProjectFile(fsPath) {
		let lastPath = '*';
		let dir = Path.dirname(fsPath);
		let found = false;
		while (lastPath != dir) {
			if (Fs.existsSync(Path.join(dir, 'hexa.json'))) {
				found = true;
				break;
			};
			lastPath = dir;
			dir = Path.dirname(dir);
		};
		return {found:found, dir:dir};
	};
	function syntaxCheckOnly(file, content) {
		try {
			const tokens = Lexer.tokenize(content, file);
			try { const parser = Parser.parseNodes(tokens, new Project(), true) } catch (temp_6509) {
				if (temp_6509 instanceof CompilerErrors) { 
				const e = temp_6509
				{
					const errors_6510 = e.errors;
					return errors_6510;
				} } else
				
				throw temp_6509;
			};
		} catch (temp) {
			if (temp instanceof CompilerErrors) { 
			const e = temp
			{
				const errors = e.errors;
				return errors;
			} } else
			
			throw temp;
		};
		return [];
	};
	function parseOnly(file_6511, content_6512, project) {
		try {
			const tokens_6514 = Lexer.tokenize(content_6512, file_6511);
			try { return Parser.parseNodes(tokens_6514, project, true) } catch (temp_6515) {
				if (temp_6515 instanceof CompilerErrors) { 
				const e = temp_6515
				{
					return null;
				} } else
				
				throw temp_6515;
			};
		} catch (temp_6513) {
			if (temp_6513 instanceof CompilerErrors) { 
			const e = temp_6513
			{
				return null;
			} } else
			
			throw temp_6513;
		};
		return null;
	};
	var alternativeErrorFormat = false
	var colorIndigo = '\x1b[35m'
	var colorBlue = '\x1b[34m'
	var colorYellow = '\x1b[33m'
	var colorOcean = '\x1b[36m'
	var colorDefault = '\x1b[0m'
	var version = selfVersion
	var fileContentsu = new Map()
	var fileContents = new Map()
	var fileOutline = new Map()
	{
		{
			if (process.argv[0].endsWith('node.exe') || process.argv[0].endsWith('node')) {
				process.argv.shift();
				process.argv.shift();
			} else if (process.argv[0].endsWith('.exe')) { process.argv.shift() };
			{
				const temp = process.argv[0];
				switch (temp) {
				case 'listen': {
					const temp_6602 = new Server(process.argv[1])
				} break;
				
				case 'help': {
					printHelp()
				} break;
				
				case 'version': {
					printVersion()
				} break;
				
				case 'symlink': {
					symlink()
				} break;
				
				case 'init': {
					init()
				} break;
				
				default: 
				try { new Main().perform() } catch (temp_6603) {
					if (temp_6603 instanceof CompilerErrors) { 
					const e = temp_6603
					{
						console.log(e.toString());
					} } else
					
					throw temp_6603;
				}
				};
			};
		}
	}
})();
