// The Hexa Compiler
// Copyright (C) 2020  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

	// See: `/docs/typer.md`
	class Typer {
		// Note that we use new instance for each build to avoid collisions with unit tests
		// and to support parallel compilation in future
		var project: Project
		new (project: Project) {
			this.project = project
		}

		// A starting point of typer
		// Validates that file starts with `module`s and has own namespace
		// Fills module namespaces, module types, than file expressions
		fun fillFiles(collected: [[Node]]): Void {
			fun fillModuleNamespace(m: Node) {
				var el: [Node] = null as! [Node] // TODO
				var root: String? = null
				switch (m) {
					case Node.Module(path, els):
					el = els
					root = path.join('.')
					case _: throw 'Unreachable #2'
				}

				if (namespaces.get(root) == null) {
					namespaces.set(root, m)
				} else {
					var els: [Node] = null as! [Node] // TODO
					switch (namespaces.get(root)) {
						case Node.Module(_, el): els = el
						case _: throw 'Unreachable #1'
					}
					while (el.length > 0) {
						els.push(el.pop())
					}
				}

				{
					var els: [Node] = null as! [Node] // TODO
					switch (namespaces.get(root)) {
						case Node.Module(_, el): els = el
						case _: throw 'Unreachable #4'
					}

					for (e in els) {
						var name = nameOfModuleItem(e)
						var found = false
						for (el in els) {
							if (nameOfModuleItem(el) == name) {
								if (found) {
									fail(
									'The `\(name)` already exists in module\n' +
									positionOf(el) + '`\(name)` is defined here', e)
								}

								if (!found) {
									found = true
								}
							}
						}
					}
				}
			}

			// Let's fill global namespaces first to avoid delayed expansion
			for (file in collected) {
				var didInit = false
				var lastOne = file[0]
				for (e in file) { switch (e) {
					case Node.Module(path, el):
						if (didInit) {
							fail(
							'Modules should follow before expressions\n'
							+ positionOf(lastOne) + 'Expression is here',
							e)
						}
						fillModuleNamespace(e)
					case _:
						lastOne = e
						didInit = true
				}
			}}

			var intermediate: [String] = []

			// Fill intermediate non-existsing modules (module aaa.not_exists.bbb {})
			// Say, we have `module aaa {}` and `module aaa.not_exists.bbb {}`
			// but no `module aaa.not_exists {}`, it creates `aaa.not_exists` namespace
			{
				var intermediateSubs = []
				for (ns in namespaces.keys()) {
					var path = ns.split('.')
					var namespace = path.shift()
					fun check(namespace) {
						if (namespaces.get(namespace) == null && intermediate.indexOf(namespace) == -1) {
							intermediate.push(namespace)
						}
					}
					check(namespace)
					while (path.length > 0) {
						namespace += '.' + path.shift()
						check(namespace)
					}
				}

				for (path in intermediate) {
					var m = Node.Module(path.split('.'), [])
					namespaces.set(path, m)
				}
			}

			fun findBasicType(name: String, callback: Any): ClassType {
				let subj = findInNamespaceRoots(name)
				if (subj == null) {
					fail('Cannot find basic type `\(name)`. This type should be a part of standard library of the compilation target.')
				}
				return registerClassType(subj, callback)
			}

			// Types cache
			findBasicType('Array', function (type) {typeArray = type})
			findBasicType('Any', fun (type) {typeAny = type.instantiate()})
			findBasicType('Int', fun (type) {typeInt = type.instantiate()})
			findBasicType('Bool', fun (type) {typeBool = type.instantiate()})
			findBasicType('Float', fun (type) {typeFloat = type.instantiate()})
			findBasicType('String', fun (type) {typeString = type.instantiate()})
			findBasicType('Map', fun (type) {typeMap = type})
			findBasicType('Void', fun (type) {typeVoid = type.instantiate()})

			findBasicType('BigInt', fun (type) {typeBigInt = type.instantiate()})
			findBasicType('Int32', fun (type) {typeInt32 = type.instantiate()})
			findBasicType('Int64', fun (type) {typeInt64 = type.instantiate()})
			findBasicType('Int16', fun (type) {typeInt16 = type.instantiate()})
			findBasicType('Int8', fun (type) {typeInt8 = type.instantiate()})
			findBasicType('UInt32', fun (type) {typeUInt32 = type.instantiate()})
			findBasicType('UInt64', fun (type) {typeUInt64 = type.instantiate()})
			findBasicType('UInt16', fun (type) {typeUInt16 = type.instantiate()})
			findBasicType('UInt8', fun (type) {typeUInt8 = type.instantiate()})
			findBasicType('Float32', fun (type) {typeFloat32 = type.instantiate()})

			// Fill module scopes of all files at first
			pushScope()
			for (file in collected) { for (e in file) { switch (e) {
				case Node.Module(path, el):
					// Fill classes and non-ambiguous nodes first
					for (node in el) { switch (node) {
						case Node.Class(_):
							parents.set(node, e)
							fill(node)
						case Node.Enum(_):
							parents.set(node, e)
							fill(node)
						case Node.Function(name, expr, vars, rettype):
							if (let rettype = rettype) {
								types.set(node, Type.Function(varTypes(vars), toType(rettype, node)))
							}
						case Node.Var(name, t, e, const):
							if (let t = t) {
								types.set(node, toType(t, node))
							}
						case _:
					}}
					for (node in el) { switch (node) {
						case Node.Class(_):
						case Node.Enum(_):
						case _:
							parents.set(node, e)
							fill(node)
					}}
				case _:
			}}}
			popScope()

			// Fill initialization code at files roots
			for (file in collected) {
				pushScope()
				for (e in file) { switch (e) {
					case Node.Module(path, el):
					case _: fill(e)
				}}
				popScope()
			}

			if (failures.length > 0) {
				let errors = failures.slice()
				failures = []
				throw new CompilerErrors(errors)
			}
		}

		fun fillModules() {
			// Globals already pre-filled in package loader
			// so we do not fill them here
			fun checkOverrides(info: Module, name: String, e: Node) {
				if (info.exported.has(name)) {
					fail('Module `\(info.path)` already exports name `\(name)`', e)
				}

				if (info.imported.has(name)) {
					fail('Module `\(info.path)` already imports name `\(name)`', e)
				}
			}

			// Fill exports first to allow recursive imports
			for (info in project.moduleInfo) {
				let nodes = info.nodes

				for (e in nodes) {
					var named = true
					switch (e) {
						case Node.Var(_):
						case Node.Enum(_):
						case Node.Function(_):
						case Node.Class(_):
						// TODO type alias
						case _:
							named = false
					}

					if (named) {
						let name = DataHelper.nameOf(e)
						info.exported.set(name, e)
					}
				}
			}

			// Imports & expressions
			for (info in project.moduleInfo) {
				let nodes = info.nodes
				pushScope()

				var doneImports = false
				for (e in nodes) {
					var named = true
					var lastOne = nodes[0]
					switch (e) {
						case Node.Import(els, path):
							if (doneImports) {
								fail(
									'Imports should follow before expressions\n'
									+ positionOf(lastOne) + 'Expression is here',
								e)
							}

							let index = project.moduleName.indexOf(path)
							if (index == -1) {
								fail('Cannot import ' + path, e)
							}

							fun importAs(name: String, to: String) {
								if (let target = project.moduleInfo[index]) {
									if (let what = target.exported.get(name)) {
										checkOverrides(info, to, e)
										info.imported.set(to, what)
									} else {
										let has = [for (key in target.exported.keys()) key].join(', ')
										fail('Module `\(path)` does not export `\(name)`\nAvailable exports: \(has)', e)
									}
								}
							}

							for (el in els) {
								switch (el) {
									case ImportNode.Lower(name):
										// TODO only camelCase
										importAs(name, name)
									case ImportNode.Upper(name):
										// TODO only TitleCase
										importAs(name, name)
									case ImportNode.As(left, right):
										var lhs = ''
										switch (left) {
											case ImportNode.Lower(name):
												lhs = name
											case ImportNode.Upper(name):
												lhs = name
										}
										switch (right) {
											case ImportNode.Lower(name):
												// TODO only camelCase
												importAs(lhs, name)
											case ImportNode.Upper(name):
												// TODO only TitleCase
												importAs(lhs, name)
										}
									case _:
										fail('This import kind not implemented yet', e)
								}
							}
						case _:
							lastOne = e
							doneImports = true

							// Fill classes and non-ambiguous nodes first
							let node = e
							currentModule = info
							switch (node) {
								case Node.Class(_):
									parents.set(node, e)
									fillModuleTypes(node)
								case Node.Enum(_):
									parents.set(node, e)
									fillModuleTypes(node)
								case Node.Function(name, expr, vars, rettype):
									if (let rettype = rettype) {
										types.set(node, Type.Function(varTypes(vars), toType(rettype, node)))
									}
								case Node.Var(name, t, e, const):
									if (let t = t) {
										types.set(node, toType(t, node))
									}
								case _:
							}
					}
				}
			}

			for (info in project.moduleInfo) {
				let nodes = info.nodes
				pushScope()
				// Fill expression bodies
				for (node in nodes) {
					switch (node) {
						case Node.Import(_):
						case Node.Class(_):
						case Node.Enum(_):
						case _:
							parents.set(node, Node.Module(info.path, info.nodes)) // TODO module itself
							fill(node)
					}
				}

				popScope()
			}

			if (failures.length > 0) {
				let errors = failures.slice()
				failures = []
				throw new CompilerErrors(errors)
			}
		}

			var subj = null
		fun find(name: String): Node? {
			for (i in scopes.length) {
				subj = scopes[scopes.length - i - 1].get(name)
				if (subj != null) {
					break
				}
			}
			if (subj == null) {
				subj = findInNamespaceRoots(name)
			}
			return subj
		}

		// Generates `Did you mean xxx?`
		// TODO use this for other errors
		fun proposeSimilar(names: [String], subject: String, what: String): String {
			let available = 'Available \(what) are: ' + names.join(', ')
			let subject = subject.toLowerCase()
			let charSubj = subject.split('')
			var bestValue = 0
			var bestName = ''

			// TODO for (name : index in _) _
			for (name in names) {
				let named = name.toLowerCase()
				if (named.startsWith(subject) || subject.startsWith(named)) {
					return 'Did you mean `\(name)`?\n\n' + available
				}

				var index = 0
				var thisValue = 0
				// TODO for (name : index in _) _
				for (char in named.split('')) {
					if (char == charSubj[index]) {
						thisValue++
					}
					index++
				}

				if (thisValue > bestValue) {
					bestValue = thisValue
					bestName = name
				}
			}

			// Avoid really useless proposals
			if (bestValue > 2) {
				return 'Did you mean `\(bestName)`?\n\n' + available
			}

			return available
		}

		// `class T {}`
		fun registerClassType(node: Node, callback: Any): ClassType {
			if (let type = types.get(node)) {
				switch (type) {
					// Avoid typing if already typed
					case Type.Class(t):
						if (let setup = callback) {
							setup(t)
						}
						return t
				}
			} else {
				let type = new ClassType()
				let typeName = DataHelper.nameOf(node)
				let _thisType = thisType
				let _thisNode = thisNode
				thisType = type.instantiate()
				thisNode = node
				type.parent = node
				type.name = typeName
				types.set(node, Type.Class(type))

				// Solve race condition
				// TODO do only for std lib
				if (let setup = callback) {
					setup(type)
				}

				switch (type.name) {
					case 'Int': typeInt = type.instantiate()
					case 'Bool': typeBool = type.instantiate()
					case 'Float': typeFloat = type.instantiate()
					case 'String': typeString = type.instantiate()
					case 'Array': typeArray = type
					case 'Map': typeMap = type
					case 'Any': typeAny = type.instantiate()
					case 'Void': typeVoid = type.instantiate()
				}

				fun getRename(f: Node): String? {
					let atts = project.mapDecorators.get(f)
					if (let native = DataHelper.getDecorator(atts, 'native')) {
						if (native.values.length != 1) {
							throw '@native takes one string argument'
						}
						if (native != null) { switch (native.values[0]) {
							case Node.String(s): return s
							case _: throw '@native takes string as argument'
						}}
					}
					return null
				}

				switch (node) {
					case Node.Class(t, extend, implement, f, external):
						switch (t) {
							case NodeType.ParametricType(name, params):
								type.genericParams.push(DataHelper.extractTypeName(params[0]))
								let names = type.genericParams
								for (i in 1 ... params.length) {
									let name = DataHelper.extractTypeName(params[i])
									if (names.includes(name)) {
										fail('Parameter `\(name)` already exists in `<T, ...>`', node)
									}
									names.push(name)
								}
						}

						if (let ext = extend) {
							toType(ext, node)
						}
						for (impl in implement) {
							toType(impl, node)
						}
						pushScope()

						for (genericParam in type.genericParams) {
							addScopeType(genericParam, typeAny)
						}

						// Fill scopes
						for (field in f) {
							switch (field) {
								case Node.Function(name, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', field)
									}
									type.fieldNames.push(name)
									if (name == 'new') {
										type.constructor = type.fieldNames.length - 1
									} else {
										type.fieldRenames[type.fieldNames.length - 1] = getRename(field)
									}
									addScope(name, field)
								case Node.Var(name, t, e, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', field)
									}
									type.fieldNames.push(name)
									type.fieldInitialized[type.fieldNames.length - 1] = false
									type.fieldRenames[type.fieldNames.length - 1] = getRename(field)
									addScope(name, field)
								case Node.Property(field, _, _):
									switch (field) {
										case Node.Var(name, _):
											if (type.fieldNames.includes(name)) {
												fail('Field `\(name)` already exists', field)
											}
											type.fieldNames.push(name)
											addScope(name, field)
									}
								case Node.Static(f): switch (f) {
									case Node.Function(name, _):
										if (type.fieldNames.includes(name)) {
											fail('Field `\(name)` already exists', field)
										}
										type.fieldNames.push(name)
										type.fieldStatic[type.fieldNames.length - 1] = true
										addScope(name, field)
									case Node.Var(name, _):
										if (type.fieldNames.includes(name)) {
											fail('Field `\(name)` already exists', field)
										}
										type.fieldNames.push(name)
										type.fieldStatic[type.fieldNames.length - 1] = true
										addScope(name, field)
								}
								case _:
									fail('Wrong class field format', field)
							}
							parents.set(field, node)
						}

						// Fill fields with non-ambiguous types
						for (field in f) { switch (field) {
							// `var\let a: known T`
							case Node.Var(name, t, e, const):
								if (let t = t) {
									types.set(field, toType(t, field))
								}
							// `function a(args with known types or no args): known ret type`
							case Node.Function(name, expr, vars, rettype):
								if (let rettype = rettype) {
									types.set(field, Type.Function(varTypes(vars), toType(rettype, field)))
								}

							case Node.Static(f): switch (f) {
								case Node.Function(name, expr, vars, rettype):
									if (let rettype = rettype) {
										types.set(f, Type.Function(varTypes(vars), toType(rettype, f)))
										types.set(field, types.get(f))
									}
								case Node.Var(name, t, e, const):
									if (let t = t) {
										types.set(f, toType(t, f))
										types.set(field, types.get(f))
									}
							}
						}}

						// Fill expressions
						for (field in f) { switch (field) {
							// Instance method
							case Node.Function(name, expr, vars, rettype):
								if (name == 'new') {
									type.constructor = type.fieldNames.length - 1
								}
								if (external, expr != null) {
									if (name == 'new') {
										fail('External class constructor `new()` cannot have a body `{}`', field)
									} else {
										fail('External class method `function \(name)` cannot have a body `{}`', field)
									}
								}
								let _insideClassMethod = insideClassMethod
								let _allowSuper = allowSuper
								insideClassMethod = true
								allowSuper = (extend != null)
								if (!external) {
									fillFunction(field, expr, vars, rettype)
								}
								if (external, types.get(field) == null) {
									types.set(field, Type.Function(varTypes(vars), rettype!=null? toType(rettype, field) : typeVoid))
								}
								insideClassMethod = _insideClassMethod
								allowSuper = _allowSuper

							// Field of `var` or `let`
							case Node.Var(name, t, e, const):
								if (external, e != null) {
									fail('External class field `var \(name)` cannot have `= value`', field)
								}
								let _insideClassMethod = insideClassMethod
								insideClassMethod = true
								if (e != null) {
									fillExpression(e)
								}
								insideClassMethod = _insideClassMethod
								mixVarTypes(t, e, field)
								type.fieldInitialized[type.fieldNames.indexOf(name)] = true
								if (types.get(field) == null) {
									fail('Field `var \(name)` initialized, but got no type '+e, field)
								}

							// The thing with getters and setters
							case Node.Property(f, _, _):
									switch (f) {
										case Node.Var(name, t, e, const):
											if (external, e != null) {
												fail('External class field `var \(name)` cannot have expression', field)
											}
											let _insideClassMethod = insideClassMethod
											insideClassMethod = true
											if (e != null) {
												fillExpression(e)
											}
											insideClassMethod = _insideClassMethod
											mixVarTypes(t, e, f)
											type.fieldInitialized[type.fieldNames.indexOf(name)] = true
											if (types.get(f) == null) {
												fail('Property `\(name)` initialized, but got no type '+e, field)
											}
											types.set(field, types.get(f))
								}

							// `static f`
							case Node.Static(f): switch (f) {
								case Node.Function(name, expr, vars, rettype):
									if (external, expr != null) {
										fail('External class field `static fun \(name)` cannot have a body', field)
									}
									let _insideClassMethod = insideClassMethod
									insideClassMethod = false
									if (!external) {
										fillFunction(f, expr, vars, rettype)
									}
									if (external) {
										types.set(f, Type.Function(varTypes(vars), rettype!=null? toType(rettype, f) : typeVoid))
									}
									insideClassMethod = _insideClassMethod
									if (types.get(f) == null) {
										fail('Function get no type: class ' + DataHelper.nameOf(node) + ' static ' + name, f)
									}
									types.set(field, types.get(f))
								case Node.Var(name, t, e, const):
									if (external, e != null) {
										fail('External class field `static var \(name)` cannot have expression', field)
									}
									if (e != null) {
										fillExpression(e)
									}
									mixVarTypes(t, e, f)
									types.set(field, types.get(f))
							}

							case _:
								fail('Wrong class field format', node)
						}}

						popScope()
					case _:
						fail('ClassType expects (declare) class node, but got ' + node, node)
				}

				thisType = _thisType
				thisNode = _thisNode
				return type
			}
		}

		// `enum T {}`
		fun registerEnumType(node: Node): Type {
			if (let type = types.get(node)) {
				switch (type) {
					// Avoid typing if already typed
					case Type.Enum(t): return t
				}
			} else {
				let type = new EnumType()
				type.parent = node
				type.name = DataHelper.nameOf(node)
				types.set(node, Type.Enum(type))

				switch (node) {
					case Node.Enum(t, f, valuesType, extend):
					pushScope()
					if (let valuesType = valuesType) {
						type.fieldsTypeSimple = toType(valuesType, node)
					}

					if (
						type.fieldsTypeSimple != null,
						type.fieldsTypeSimple != typeInt,
						type.fieldsTypeSimple != typeString
					) {
						fail('Simple enums may be only of types `Int` and `String`', node)
					}

					if (f.length == 0, extend == null) {
						fail('Enum `\(type.name)` must have at least one value `enum \(type.name) { Value }`', node)
					}

					// Check for incompatible tag format and fill scopes
					for (field in f) {
						switch (field) {
							// `enum E { A }`
							case Node.NodeTypeValue(t): switch (t) {
								case NodeType.Type(name):
									if (type.fieldNames.includes(name)) {
										throw fail('Field `\(name)` already exists', node)
									}
									type.fieldNames.push(name)
									// TODO refactor `length - 1`
									type.fieldEnumConstructor[type.fieldNames.length - 1] = true
									type.tagBindVars[type.fieldNames.length - 1] = []
									type.tagBindVarsNames[type.fieldNames.length - 1] = []
									type.fieldType[type.fieldNames.length - 1] = Type.EnumInstance(type, type.fieldNames.length - 1)
								case _:
									fail('Wrong enum constructor format, should be `Name`', node)
							}

							// `enum E { A(b: C) }`
							case Node.Call(e, args, argNames):
								if (valuesType != null) {
									throw fail('Cannot use `Value(args)` format for simple enum', node)
								}
								switch (e) {
									case Node.NodeTypeValue(t): switch (t) {
										case NodeType.Type(name):
											if (type.fieldNames.includes(name)) {
												throw fail('Field `\(name)` already exists', node)
											}
											type.fieldNames.push(name)
											type.fieldEnumConstructor[type.fieldNames.length - 1] = true
											type.fieldType[type.fieldNames.length - 1] = Type.EnumConstructor(type, type.fieldNames.length - 1)
											let tagBindVars = []
											let tagBindVarsNames = []
											type.tagBindVars[type.fieldNames.length - 1] = tagBindVars
											type.tagBindVarsNames[type.fieldNames.length - 1] = tagBindVarsNames

											if (args.length == 0) {
												fail('Enum constructor expects more than zero arguments `(value: Type)`', e)
											}

											for (i in args.length) {
												if (argNames[i] == null) {
													fail('Enum constructor arguments should have names `E(name1: T, name2: T)', args[i])
												}
													tagBindVars[i] = nodeToNodeType(args[i])

													if (tagBindVarsNames.includes(argNames[i])) {
														fail('Enum constructor argument `\(argNames[i])` already exists', args[i])
													}

													tagBindVarsNames[i] = argNames[i]
											}
										case _:
											fail('Wrong enum constructor format, should be `Name(value: T)`', e)
									}
								}

							// `enum E { A = b }`
							case Node.Binop(a, op, b):
								if (op != Token.OpAssign) {
									fail('Should use `Value = value` not `Value \(Token.stringify(op)) value` format for enum tag value', node)
								}
								if (valuesType == null) {
									fail('Cannot use `Value = value` format for complex enum', node)
								}
								switch (a) {
									case Node.NodeTypeValue(t): switch (t) {
										case NodeType.Type(name):
											if (type.fieldNames.includes(name)) {
												fail('Field `\(name)` already exists', node)
											}
											type.fieldNames.push(name)
											type.fieldEnumConstructor[type.fieldNames.length - 1] = true
											switch (b) {
												case Node.Int(_): if (type.fieldsTypeSimple != typeInt) {
													fail('`\(name) = value` expects constant value of type `\(Type.stringify(type.fieldsTypeSimple))`', b)
												}
												case Node.String(_): if (type.fieldsTypeSimple != typeString) {
													fail('`\(name) = value` expects constant value of type `\(Type.stringify(type.fieldsTypeSimple))`', b)
												}
												// TODO non-constant values
												// TODO other types
											}
											fillExpression(b)
											type.fieldType[type.fieldNames.length - 1] = types.get(b)
									}
								}

							// `enum E { a }`
							case Node.Ident(name):
								fail('Cannot use lowercase `\(name)` format for enum values', node)

							// `enum E { static ... }`
							case Node.Static(f): switch (f) {
								case Node.Function(name, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', node)
									}
									type.fieldNames.push(name)
									type.fieldStatic[type.fieldNames.length - 1] = true
									addScope(name, field)
								case Node.Var(name, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', node)
									}
									type.fieldNames.push(name)
									type.fieldStatic[type.fieldNames.length - 1] = true
									addScope(name, field)
							}

							case _:
								fail('Wrong enum field format', field)
						}

						parents.set(field, node)
					}

					// Fill expressions
					for (field in f) { switch (field) {
						case Node.Function(name, expr, vars, rettype):
							fillFunction(field, expr, vars, rettype)
						case Node.Var(name, _):
						case Node.Static(f): switch (f) {
							case Node.Function(name, expr, vars, rettype):
								let _insideClassMethod = insideClassMethod
								insideClassMethod = false

								// This weird hack, because of race condition
								// if function called within self
								if (rettype != null) {
									types.set(f, Type.Function([], toType(rettype, f)))
								} else {
									types.set(f, Type.Function([], typeVoid))
								}
								types.set(field, types.get(f))

								fillFunction(f, expr, vars, rettype)
								insideClassMethod = _insideClassMethod
								if (types.get(f) == null) {
									fail('Function get no type: enum ' + DataHelper.nameOf(node) + ' static ' + name, f)
								}
								types.set(field, types.get(f))
							case Node.Var(name, t, e, const):
								if (e != null) {
									fillExpression(e)
								}
								mixVarTypes(t, e, f)
								types.set(field, types.get(f))
						}
						case Node.NodeTypeValue(_): // Ok
						case Node.Call(_): // Ok
						case Node.Binop(_): // TODO validate them
						case _:
							fail('Unknown enum field format', field)
					}}
					popScope()
					case _:
						fail('EnumType expects (declare) enum node, but got ' + node, node)
				}

				return type
			}
		}

		static let never = '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.'
		static var failures: [{msg: String, node: Node?}] = []

		// TODO node: Node = null error
		fun fail(msg: String, node: Node = null): Void {
			failNonFatal(msg, node)
			let errors = failures.slice()
			failures = []
			throw new CompilerErrors(errors)
		}

		fun failNonFatal(msg: String, node: Node = null): Void {
			let data = project.data.get(node)
			if (let data = data) {
				failures.push(new CompilerError(Fail.TyperError, msg, data.line, data.column, data.fileName))
			} else {
				failures.push(new CompilerError(Fail.TyperError, msg, 0, 0, ""))
			}
		}

		fun positionOf(node: Node) {
			let data = project.data.get(node)
			if (data == null) {
				return "[Unknown]: "
			}
			return "[" + data.fileName + ":" + data.line + ":" + data.column + "]: "
		}

		static fun nodeToNodeType(node: Node): NodeType { switch (node) {
			case Node.Array(el):
				if (el.length > 1) {
					fail('Array type `[T]` cannot have more than 1 parameter `T`', el[1])
				}
				return NodeType.ParametricType("Array", [nodeToNodeType(el[0])])
			case Node.NodeTypeValue(t):
				return t
			case Node.Object(names, el):
				let types = [for (e in el) nodeToNodeType(e)]
				return NodeType.Object(names, types)
			case _:
				fail('Cannot nodeToNodeType of ' + Node.stringify(node), node)
		}}

		// Takes only nodes valid for `module { node }`
		fun nameOfModuleItem(node: Node): String {
			switch (node) {
				case Node.Var(name, _): return name
				case Node.Function(name, _):
					if (let named = name) {
						return named
					} else {
						throw 'Module function should have a name'
					}
				case Node.Private(node): switch (node) {
					case Node.Class(t, _): switch (t) {
						case NodeType.Type(name): return name
						case NodeType.ParametricType(name): return name
					}
				}
				case Node.Class(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.Enum(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TypeAlias(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case _: fail('Improper module item format, wrap expressions as `{ expressions }`', node)
			}
		}

		var currentModule: Module = new Module()
		fun findInNamespaceRoots(name: String): Node? {
			if (let node = currentModule.imported.get(name)) {
				return node
			}

			if (let node = project.globals.get(name)) {
				return node
			}

			return null

			if (namespaces.get(name) != null) {
				return namespaces.get(name)
			}
			var m = namespaces.get('')
			var el: [Node] = null as! [Node]
			switch (m) {
				case Node.Module(_, els): el = els
				case _: return null // No root
			}
			for (e in el) {
				if (name == nameOfModuleItem(e)) {
					return e
				}
			}
			return null
		}

		// Scopes
		private let scopes: [[String : Node]] = [[:]]
		private let scopeTypes: [[String : Type]] = [[:]]
		let parents: [Node : Node] = [:]

		private fun pushScope(): Void {
			scopes.push([:])
			scopeTypes.push([:])
		}

		private fun popScope(): Void {
			scopes.pop()
			scopeTypes.pop()
		}

		private fun addScope(name: String, node: Node): Void {
			scopes[scopes.length - 1].set(name, node)
		}

		private fun addScopeType(name: String, type: Type): Void {
			scopeTypes[scopeTypes.length - 1].set(name, type)
		}

		// Types
		private let types: [String : Type] = [:]
		private var typeString: Type? = null
		private var typeInt: Type? = null
		private var typeFloat: Type? = null
		private var typeBool: Type? = null
		private var typeArray: Type? = null // Type instantiators
		private var typeMap: ClassType = null as! ClassType // Type instantiators
		private var typeAny: Type? = null
		private var typeVoid: Type? = null
		private var namespaces: [String : Node] = [:]

		private var typeBigInt: Type? = null
		private var typeInt32: Type? = null
		private var typeInt64: Type? = null
		private var typeInt16: Type? = null
		private var typeInt8: Type? = null
		private var typeUInt32: Type? = null
		private var typeUInt64: Type? = null
		private var typeUInt16: Type? = null
		private var typeUInt8: Type? = null
		private var typeFloat32: Type? = null

		// Stack
		var functionAllowedToThrow = false // `true` if `@noThrow` is *not* set
		var functionThrows = false // `throw` is happened
		var insideTry = false // `try { insideTry } catch (...) { ... }`
		var insideFunction = false // `function () { insideFunction }`
		var allowBreakAndContinue = false // Used in loops
		var functionReturnsAType: Type? = null // `: T` is happened, or infer if `null`
		var functionActuallyReturns: Bool = false // `return something` is actually happened
		var insideClassMethod = false // `class T { function () { insideClassMethod } }` non-static!
		var allowSuper = false // `class T extends C { function () { super() } }` non-static!
		var thisType: Type = null as! Type // Current class
		var thisNode: Node = null as! Node // Current class node

		// var to = from
		fun unify(to: Type, fromValue: Type, node: Node): Type {
			// Short path
			if (to == fromValue) {
				return to
			}

			if (to == typeAny) {
				return to
			}

			if (fromValue == typeVoid) {
				fail('Incompatible types `\(Type.stringify(to))` and non-value type `Void`', node)
			}

			// `Int` is assignable to `Float`
			if (to == typeFloat, fromValue == typeInt) {
				return typeFloat
			}

			// Nullability
			fun isNullable(t: Type): Bool {
				switch (t) {
					case Type.UnknownNullable(_): return true
					case Type.Nullable(_): return true
				}
				return false
			}

			fun unwrapNullable(t: Type): Type {
				switch (t) {
					case Type.UnknownNullable(handle): return handle.value
					case Type.Nullable(t): return t
				}
				return t
			}

			fun instanceOfClass(t: Type): ClassType? {
				switch (unwrapNullable(t)) {
					case Type.ClassInstance(t): return t
					case Type.Class(t):
						fail('Cannot take classes `class \(t.name)` as values', node)
				}
				return null
			}

			// Fill unknown nullable
			switch (to) {
				case Type.UnknownNullable(handle):
					if (handle.value == null) {
						handle.value = switch (fromValue) {
							case Type.UnknownNullable(handle): handle.value
							case Type.Nullable(t): t
							case _: fromValue
						}
					}
			}

			var toNullable = isNullable(to)
			var fromNullable = isNullable(fromValue)

			//if (fromNullable, !toNullable, Type.stringify)
			//	fail('Cannot assign nullable type `\(Type.stringify(fromValue))` to non-nullable `\(Type.stringify(to))`', node)

			var toInstance = instanceOfClass(to)
			var fromInstance = instanceOfClass(fromValue)
			if (toInstance == null || fromInstance == null) {
				return to ?? fromValue
			}

			if (toInstance != fromInstance, unwrapNullable(to) != typeAny, unwrapNullable(fromValue) != typeAny) {
				fail('Incompatible types `\(Type.stringify(to))` and value of `\(Type.stringify(fromValue))`', node)
			}

			return to ?? fromValue
		}

		fun findType(name: String): Node? {
			for (i in scopes.length) {
				if (let subj = scopes[scopes.length - i - 1].get(name)) {
					return subj
				}
			}
			return findInNamespaceRoots(name)
		}

		fun findActualType(name: String): Type? {
			for (i in scopeTypes.length) {
				if (let subj = scopeTypes[scopeTypes.length - i - 1].get(name)) {
					return subj
				}
			}
			// TODO global
			return null
		}

		fun toType(t: NodeType, node: Node): Type {
			switch (t) {
				case NodeType.Type(name):
					if (types.get(nodeType) == null) { switch (nodeType) {
					let nodeType: Node = findType(name) ?? currentModule.exported.get(name)
						case Node.Class(_):
							registerClassType(nodeType)
						case Node.Enum(_):
							registerEnumType(nodeType)
					}}
					let type: Type? = findActualType(name) ?? types.get(nodeType)
					switch (type) {
						case Type.Class(type):
							if (type.genericParams.length > 0) {
								fail('The type `\(type.name)` requires `<\(type.genericParams)>` generic parameters', node)
							}
							return type.instantiate()
						case Type.Enum(type):
							return types.get(nodeType)
						case null:
							fail('Cannot find type `\(name)`', node)
						case _:
							if (type == typeAny) {
								return typeAny
							}
							fail('Unsupported type `\(name)`', node)
					}
				case NodeType.ParametricType(name, params):
					let nodeType: Node = findType(name) ?? currentModule.exported.get(name)
					if (types.get(nodeType) == null) { switch (nodeType) {
						case Node.Class(_):
							registerClassType(nodeType)
						case Node.Enum(_):
							registerEnumType(nodeType)
					}}
					let type: Type? = findActualType(name) ?? types.get(nodeType)
					switch (type) {
						case Type.Class(type):
							if (type.genericParams.length == 0) {
								fail('The type `\(type.name)` requires zero generic parameters', node)
							}
							if (type.genericParams.length != params.length) {
								fail('The type `\(type.name)` requires `<\(type.genericParams)>` generic parameters', node)
							}
							return type.instantiateGeneric([for (p in params) toType(p, node)])
						case null:
							fail('Cannot find type `\(name)`', node)
						case _:
							if (type == typeAny) {
								// Ignore all parameters here
								return typeAny
							}
							fail('Unsupported type `\(name)`', node)
					}
				case NodeType.Optional(t):
					return Type.Nullable(toType(t, node))
				case NodeType.Function(args, ret):
					return Type.Function([for (arg in args) toType(arg, node)], toType(ret, node))
				case NodeType.Object(names, el):
					let els = [for (e in el) toType(e, node)]
					return Type.Struct(names, els)
				case _:
					fail('Unsupported node type ' + t + never, node)
			}
		}

		// `var node: NodeType = e`
		fun mixVarTypes(t: NodeType?, e: Node?, node: Node) {
			if (t != null, e != null) {
				types.set(node, unify(toType(t, node), types.get(e), e))
			}
			if (t == null, e != null) {
				types.set(node, types.get(e))
			}
			if (t == null, e == null) {
				types.set(node, Type.UnknownNullable({value: null}))
			}
			if (t != null, e == null) {
				types.set(node, toType(t, node))
			}
		}

		fun varTypes(vars: [Node]): [Type] {
			let varTypes: [Type] = []

			for (v in vars) {
				switch (v) {
					case Node.Var(_, t):
						if (let t = t) {
							varTypes.push(toType(t, v))
						} else {
							varTypes.push(Type.Unknown({ value: null }))
						}
				}
			}

			return varTypes
		}

		// Uses idea of stacks to track nested function behavior
		private fun fillFunction(node, expr, vars: [Node], rettype, arrow: Bool = false): Void {
			pushScope()
			// Save stack
			let _insideFunction = insideFunction
			let _functionAllowedToThrow = functionAllowedToThrow
			let _functionThrows = functionThrows
			let _functionReturnsAType = functionReturnsAType
			let _functionActuallyReturns = functionActuallyReturns
			let _insideTry = insideTry

			for (i in vars.length) {
				let v = vars[i]
				switch (v) {
					case Node.Var(vname, t, e, const):
						if (t != null, toType(t, v) == typeVoid) {
							fail('Argument cannot be of type `Void`', v)
						}

						if (t != null) {
							types.set(v, toType(t, v))
						}

						if (e != null) {
							fillExpression(e)

							if (let t = types.get(v)) {
								unify(types.get(e), t, e)
							}
						}

						addScope(vname, v)
				}
			}

			// Reset stack
			var ret: Type? = null // TODO = if (let)
			if (let rt = rettype) {
				ret = toType(rt, node)
			}
			functionReturnsAType = ret
			functionActuallyReturns = false

			let atts = project.mapDecorators.get(node)

			if (let noThrow = DataHelper.getDecorator(atts, 'noThrow')) {
				if (noThrow.values.length > 0) {
					fail('Decorator `@noThrow` should have no parameters', node)
				}
				functionAllowedToThrow = false
			} else {
				functionAllowedToThrow = true
			}

			if (let throws = DataHelper.getDecorator(atts, 'throws')) {
				if (functionAllowedToThrow == false) {
					fail('Decorator `@noThrow` cannot be used with `@throws`', node)
				}
				functionThrows = true
			} else {
				functionThrows = false
			}

			insideFunction = true
			insideTry = false

			if (arrow, expr != null) {
				fillExpression(expr)
			}
			if (!arrow, expr != null) {
				fill(expr)
			}
			popScope()

			ret = functionReturnsAType // Inferred
			if (ret == null) ret = typeVoid
			if (ret != typeVoid, expr != null, functionActuallyReturns == false)
				fail('Function expects result of `\(Type.stringify(ret))` but never does `return value`', node)

			// Restore stack
			insideFunction = _insideFunction
			functionReturnsAType = _functionReturnsAType
			functionActuallyReturns = _functionActuallyReturns

			// Set function type
			types.set(node, Type.Function(args: [for (v in vars) types.get(v)], returns: ret))
		}

		private fun fillModuleTypes(node: Node): Void {
			switch (node) {
				// `class T {}`
				case Node.Class(t, extend, implement, f, external):
					addScope(DataHelper.extractTypeName(t), node)
					registerClassType(node)

				// `enum T {}`
				case Node.Enum(t, f, valuesType):
					addScope(DataHelper.extractTypeName(t), node)
					registerEnumType(node)

				// `declare A = T`
				case Node.TypeAlias(alias, value):
					types.set(node, Type.Alias(null))
					addScope(nameOfModuleItem(node), node)
			}
		}

		// Syntax tree traverse
		private fun fill(node: Node): Void {
			switch (node) {

				// Types

				case Node.Class(_):
					fail('Defining classes within blocks not allowed', node)
				case Node.Enum(_):
					fail('Defining enums within blocks not allowed', node)
				case Node.TypeAlias(_):
					types.set(node, Type.Alias(null))
					addScope(nameOfModuleItem(node), node)
					// TODO
					// fail('Defining types within blocks not allowed', node)

				// Statements do not return value

				// `var a = e, b: T, c`
				case Node.Vars(e):
					for (ee in e) {
						fill(ee)
					}

				// `{...}`
				case Node.Block(el):
					pushScope()
					for (e in el) {
						fill(e)
					}
					popScope()

				// `var name: t = e`
				case Node.Var(name, t, e, const, external):
					if (e == null, const, !external) {
						fail('Constant should have a value `let \(name) = value`', node)
					}
					if (e != null, external) {
						fail('External variable should not have a value `declare let \(name)`', node)
					}
					if (t == null, external) {
						fail('External variable should have a type `declare let \(name): T`', node)
					}
					if (e != null) {
						pushScope()
						fillExpression(e)
						popScope()
					}

					mixVarTypes(t, e, node)

					addScope(name, node)

				// `a op b` like `a + b`
				case Node.Binop(a, op, b):
					fillExpression(a)
					fillExpression(b)

					var parent: Node = parents.get(a)
					// `a = b`
					if (op == Token.OpAssign) { switch (parent) {
						case null:
						case Node.Var(name, _, _, const):
							if (const) {
								fail(
									'Cannot reassign a constant `let \(name)`, redefine it as `var \(name)` to allow reassignment\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							}
							types.set(node, unify(types.get(a), types.get(b), b))
						case Node.Ident(name):
							fail('Cannot reassign case parameter `\(name)`', node)
						case Node.Function(name, _):
							fail('Cannot reassign a function `\(name)`', node)
						case Node.Class(_):
							fail('Cannot reassign class', node)
						case Node.Enum(_):
							fail('Cannot reassign enum', node)
						case Node.For(name, _):
							fail(
								'Cannot reassign iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for (\(name) in ...)` is defined here',
							node)
						case Node.Static(_):
						case Node.Super(_):
							fail('Cannot reassign `super`', node)
						case _:
							fail('`=` not implemented for: ' + parent, node)
					}}

				// `break`
				case Node.Break:
					if (!allowBreakAndContinue) {
						fail('Cannot use `break` outside of loop', node)
					}

				// `for (name in over ... range) { by }`
				case Node.For(name, over, by, range):
					pushScope()
					fillExpression(over)
					let overType = types.get(over)
					switch (overType) {
						case Type.ClassInstance(type, generic):
							// Extract Array<T>
							if (generic != null, generic.length == 1) {
								types.set(node, generic[0])
							} else if (overType == typeInt) {
								types.set(node, typeInt)
							} else {
								fail('Type of iterable is neither Int nor Array, but ' + Type.stringify(overType), over)
							}

						case Type.Nullable(_):
							fail('Type of iterable should not be nullable', over)

						case Type.UnknownNullable(_):
							fail('Type of iterable should not be nullable', over)

						case null:
						case _:
							fail('Type of iterable is neiter Int nor Array', over)
					}
					if (let range = range) {
						fillExpression(range)
						// Ranges always integer/Int for now
						if (types.get(range) != typeInt) {
							fail('Range end must be of Int type', range)
						}
						if (overType != typeInt) {
							fail('Range start must be of Int type', over)
						}
						types.set(node, typeInt)
					}
					addScope(name, node)
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					switch (by) {
						case Node.Block(_):
						case _:
							fail('Loop body must be a `{` block `}`', by)
					}
					fill(by)
					allowBreakAndContinue = _allowBreakAndContinue
					popScope()

				// `function name(vars): rettype {expr}`
				// `vars` are `Var(name, t, ...)` where `function(name: t)`
				case Node.Function(name, expr, vars, rettype, external):
					if (!external, expr == null) {
						fail('Non-external function `\(name)` should have a body', node)
					}
					if (external, rettype == null) {
						fail('External function `\(name)` should have a returning type', node)
					}
					addScope(name, node)
					fillFunction(node, expr, vars, rettype)
					if(false){

					// Save stack
					let _insideFunction = insideFunction
					// Reset stack
					insideFunction = true
					pushScope()
					if (expr != null) {
						fill(expr)
					}
					popScope()

					// Restore stack
					insideFunction = _insideFunction

				}

				// `if (econd) eif else eelse`
				// `if (econd) eif`
				// Also `if (let bind = value, econd..., econd...)`
				case Node.If(econd, eif, eelse):
					var depth = 0
					for (e in econd) {
						switch (e) {
							case Node.Var(name, t, expr, const):
								if (!const) {
									fail('Only if-let bindings supported, not if-var', node)
								}
								if (t != null) {
									fail('Do not specify a type `: T` in if-let bindings', node)
								}
								if (expr == null) {
									fail('if-let binding should have a value `\(name) = value', node)
								}
								depth++
								pushScope()
								pushScope()
								fillExpression(expr)
								popScope()
								switch (types.get(expr)) {
									case Type.Nullable(t): types.set(e, t)
									case Type.UnknownNullable(handle):
										if (let t = handle.value) {
											types.set(e, t)
										} else {
											fail('if-let cannot bind not fully known nullable type', node)
										}
									case _: types.set(e, types.get(expr))
								}
								addScope(name, e)
							case _:
								fillExpression(e)
								// Only Bool allowed
								let type = types.get(e)
								if (type != typeBool, type != typeAny, type != null) {
									fail('`if (value)` expects `value` only of type `Bool`, but got `' + Type.stringify(types.get(e)) + '`', e)
								}
						}
					}
					fill(eif)
					while (depth > 0) {
						depth--
						popScope()
					}

					if (eelse != null) {
						fill(eelse)
					}

				// `switch (exprs) { case conds if (guards): { cases } }`
				case Node.Switch(exprs, conds, guards, cases):
					fillSwitch(node, false)

				// `try { } catch (e: T) { }`
				case Node.Try(e, t, v, ca):
					// Save stack
					let _insideTry = insideTry
					// Reset stack
					insideTry = true
					switch (e) {
						case Node.Block(_):
						case _:
							fail('Try body must be a `{ block }`', e)
					}
					fill(e)
					// Restore stack
					insideTry = _insideTry

					for (i in ca.length) {
						let type = toType(t[i], ca[i])
						switch (type) {
							case Type.Struct(_):
								fail('Catch type must be a specific class, not `{}`', ca[i])
							case Type.Function(_):
								fail('Catch type must be a specific class, not function', ca[i])
						}
						types.set(t[i], type)
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						switch (ca[i]) {
							case Node.Block(_):
							case _:
								fail('Catch body must be a `{ block }`', ca[i])
						}
						fill(ca[i])
						popScope()
					}

				// `while (econd) e` if pre == true
				// `do e while (econd)` if pre == false
				case Node.While(econd, e, pre):
					if (pre == true) {
						fillExpression(econd)
					}
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					switch (e) {
						case Node.Block(_):
						case _:
							fail('`while` statements must be wrapped with a `{` block `}`', e)
					}
					fill(e)
					allowBreakAndContinue = _allowBreakAndContinue
					if (pre == false) {
						fillExpression(econd)
					}
					types.set(node, typeVoid)

				// `continue`
				case Node.Continue:
					types.set(node, typeVoid)
					if (!allowBreakAndContinue) {
						fail('Cannot use `continue` outside of loop', node)
					}

				// Expressions and errors
				case _:
					fillExpression(node)
			}
		}

		// Expressions return values
		function fillExpression(node) {
			switch (node) {
				// Just `name`
				case Node.Ident(name):
					var subj = null
					for (i in scopes.length) {
						subj = scopes[scopes.length - i - 1].get(name)
						if (subj != null) {
							break
						}
					}

					if (subj == null) {
						subj = findInNamespaceRoots(name)
					}
					if (subj == null, name == 'const') {
						fail('No variable named `const` found. Are you trying to use `const` as a keyword? Use `let varname` syntax instead.', node)
					}
					if (subj == null) {
						fail('Cannot find variable with name `\(name)`', node)
					}
					if (parents.get(node) != null, parents.get(node) != subj) {
						fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
					}
					parents.set(node, subj)
					if (let type = types.get(subj)) {
						types.set(node, type)
					}


				// `(args)=>{expr}`
				case Node.Arrow(expr, vars, rettype):
					fillFunction(node, expr, vars, rettype, arrow: true)
					if(false){
					pushScope()
					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true
					fillExpression(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				}

				// `function name(vars): rettype {expr}`
				case Node.Function(name, expr, vars, rettype, external):
					if (external) {
						fail('External function `declare fun \(name)` cannot be taken as a value', node)
					}

					fillFunction(node, expr, vars, rettype)

					if(false){
					pushScope()
					addScope(name, node)

					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true

					if (expr != null) {
						fill(expr)
					}
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				}

				// `[a,b,c]`
				case Node.Array(el):
					// `[for(name in over ... range) by]`
					switch (el[0]) {
						case Node.For(name, over, by, range):
							if (el.length > 1) {
								fail('Cannot use loop `for` within array of more than one element `[for(), ...]`', el[1])
							}
							if (range != null) {
								fail('Ranges `...range` are not supported here yet', range)
							}

							pushScope()
							fillExpression(over)
							types.set(el[0], types.get(over))
							addScope(name, el[0])
							let _allowBreakAndContinue = allowBreakAndContinue
							allowBreakAndContinue = false
							fillExpression(by)
							allowBreakAndContinue = _allowBreakAndContinue
							popScope()

							types.set(node, typeArray.instantiateGeneric([types.get(by)]))
						case _:
							for (e in el) {
								fillExpression(e)
							}
							types.set(node, typeArray.instantiateGeneric([
								if (el.length > 0) {
									types.get(el[0])
								} else {
									Type.Unknown({ value: null })
								}
							]))
					}

				// `[k:v, k:v]`
				case Node.Map(keys, values):
					if (keys.length == 0) {
						types.set(node, typeMap.instantiateGeneric([
							Type.Unknown({value: null}),
							Type.Unknown({value: null})
						]))
						return
					}
					for (i in keys.length) {
						fillExpression(keys[i])
						fillExpression(values[i])
					}
					types.set(node,
						typeMap.instantiateGeneric([types.get(keys[0]), types.get(values[0])])
					)

				// `e as  t`
				// `e as! t`
				// `e as? t`
				case Node.As(e, kind, t):
					let type = toType(t, node)
					if (type == typeVoid) {
						fail('Conversion `as Void` makes no sense', e)
					}
					fillExpression(e)
					if (types.get(e) == typeVoid) {
						fail('Conversion of `value as \(Type.stringify(t))` where `value` is of type `Void` makes no sense', e)
					}
					types.set(t, type)
					types.set(node, type)

				// `e is t`
				case Node.Is(e, t):
					let type = toType(t, node)
					if (type == typeAny) {
						fail('Comparing `is Any` makes no sense, always true', e)
					}
					if (type == typeVoid) {
						fail('Comparing `is Void` makes no sense', e)
					}
					fillExpression(e)
					types.set(t, type)
					types.set(node, typeBool)

				// `{...}`
				case Node.Block(el):
					if (el.length == 0) {
						types.set(node, Type.Struct([], []))
					} else {
						pushScope()
						for (i in el.length) { if (i < el.length - 1) {
							fill(el[i])
						}}
						let latest = el[el.length - 1]
						fillExpression(latest)
						types.set(node, types.get(latest))
						popScope()
					}

				// `e.n`
				case Node.Dot(e, n):
					switch (e) {
						case Node.Super(_):
							if (!allowSuper) {
								fail('Cannot access `super` here', node)
							}
						case _:
							fillExpression(e)
					}
					if (let etype = types.get(e)) { switch (etype) {
						case Type.ClassInstance(type): // Non-static fields
							type.useless = false
							if (etype == typeAny) {
								types.set(node, typeAny)
								return
							}
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Class `\(nameOfModuleItem(type.parent))` has no field `.\(n)`\nAvailable fields are: ' + type.fieldNames.join(', '), e ?? node)
							}
							if (type.fieldStatic[index] == true) {
								fail('Class `\(nameOfModuleItem(type.parent))` field `.\(n)` is static', node)
							}
							switch (type.parent) {
								case Node.Class(t, extend, implement, fields, external):
									registerClassType(type.parent)
									for (field in fields) {
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
											if (types.get(field) == null) {
												console.log(positionOf(node) + 'Note: field fieldInitialized[\(n)] =', type.fieldInitialized[type.fieldNames.indexOf(n)])
												fail('Type for this field is null: ' + n, field)
											}
										}
									}
								case _:
									fail(type.parent, type.parent)
							}
						case Type.Class(type): // Static fields
							type.useless = false
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Class `\(nameOfModuleItem(type.parent))` has no static field `.\(n)`\nAvailable fields are: ' + type.fieldNames.join(', '), node)
							}
							if (type.fieldStatic[index] != true) {
								fail('Class `\(nameOfModuleItem(type.parent))` field `.\(n)` is not static', node)
							}
							switch (type.parent) {
								case Node.Class(t, extend, implement, fields, external):
									for (field in fields) {
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
										}
									}
								case _:
									fail(type.parent, type.parent)
							}
						case Type.Enum(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Enum `\(type.name)` has no field `.\(n)`', node)
							}
							if (type.fieldStatic[index] != true) {
								fail('Enum field `.\(n)` is not static', node)
							}
							switch (type.parent) {
								case Node.Enum(t, fields, valuesType):
									for (field in fields) { switch (field) {
										case Node.Call(_):
										case Node.NodeTypeValue(_):
										case Node.Binop(_):
										case _:
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
										}
									}}
								case _:
									fail(type.parent, type.parent)
							}
						case Type.Struct(names, els):
							let index = names.indexOf(n)
							if (index < 0) {
								var object = ''
								switch (e) {
									case Node.Ident(name): object = ' `\(name)`' // Note a space after '
									case _: {}
								}

								if (names.length == 0) {
									fail('Object\(object) is empty `{}` and has no fields. Create object with all fields defined upfront, like this: `obj = { \(n): value }`', node)
								}
								if (names.length != 0) {
									fail('Object\(object) has no field `.\(n)`\nAvailable fields are: ' + names.join(', '), node)
								}
							}
							types.set(node, els[index])
						case Type.UnknownNullable(handle):
							failNonFatal('Cannot access `.\(n)` of nullable type `\(Type.stringify(etype))`, try to unwrap it with `if(let)`', node)
							types.set(node, typeAny) // TODO unwrap proper type
						case Type.Nullable(type):
							failNonFatal('Cannot access `.\(n)` of nullable type `\(Type.stringify(etype))`, try to unwrap it with `if(let)`', node)
							types.set(node, typeAny) // TODO unwrap proper type
						case Type.Unknown(handle):
							if (let type = handle.value) {
								// TODO
							} else {
								failNonFatal('Cannot access `.\(n)` due to type of value being unknown, try to specify a proper type (set full type `[T]` if this value coming from array)', node)
								types.set(node, typeAny) // TODO unwrap proper type
							}
						case null:
							fail('Cannot access `.\(n)` due to type being `null`, seems to be internal compiler error', node)
						case _:
							fail('Cannot access `.\(n)` due to type being unhandled `\(Type.stringify(etype))`, seems to be internal compiler error', node)
					}} else {
						types.set(node, typeAny)
					}

				// `e.N`
				case Node.DotUpper(e, n):
					switch (e) {
						case Node.Super(_):
							fail('Cannot access `super` here', node)
					}
					fillExpression(e)
					switch (types.get(e)) {
						case Type.Class(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Class has no field `.\(n)`', node)
							}
							if (type.fieldStatic[index] != true) {
								fail('Class field `.\(n)` is not static', node)
							}
						case Type.Enum(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Enum has no value constructor `.\(n)`\n' + proposeSimilar(type.fieldNames.filter((element, index) => type.fieldEnumConstructor[index]), n, 'constructors'), node)
							}
							if (type.fieldEnumConstructor[index] != true) {
								fail('Enum field `.\(n)` is not a value constructor', node)
							}
							if (let fieldType = type.fieldType[index]) {
								types.set(node, fieldType)
							} else {
								fail('Enum field type is null for `\(Node.stringify(node))`', node)
							}
						case null:
							fail('Doing .Upper `\(Node.stringify(node))` over `\(Node.stringify(e))` (\(e)) of type null', node)
						case _:
					}// else fail('Got node without type `\(e)`' + never, node)

				// `T` or `T<G>`
				case Node.NodeTypeValue(t): switch (t) {
					case NodeType.Type(name):
						let subj = find(name)
						if (subj == null) {
							fail('Cannot find type with name `\(name)`', node)
						}
						if (parents.get(node) != null, parents.get(node) != subj) {
							fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
						}
						parents.set(node, subj)
						if (let type = types.get(subj)) {
							types.set(node, type)
						} else {
							// Try eager on-demand type build
							switch (subj) {
								case Node.Class(_): registerClassType(subj)
								case Node.Enum(_): registerEnumType(subj)
							}

							if (let type = types.get(subj)) {
								types.set(node, type)
							} else {
								console.log(positionOf(subj) + '\(name) is here')
								fail('Cannot find type for `\(name)` even after late build' + never, node)
							}
						}
					case NodeType.ParametricType(name, _):
						fail('Cannot use generic type `\(name)` as a value', node)
					case _:
						fail('Cannot use this type as a value', node)
				}

				// `new T {names:values} ()`
				case Node.New(path, t, el, names, values):
					let type = toType(t, node)
					let subj = find(DataHelper.extractTypeName(t))
					parents.set(node, subj)
					for (e in el) {
						fillExpression(e)
					}
					switch (type) {
						case Type.ClassInstance(type):
							if (type.constructor == -1) {
								fail('Cannot construct class without `new () {}` constructor', node)
							}
							type.useless = false
						case _:
							fail('Constructor `new` may instantiate only classes', node)
					}

					types.set(node, type)

				// `{names:el, ...}`
				case Node.Object(names, el):
					for (name in names.length) {
						if (names.indexOf(names[name]) != name) {
							fail('Field `\(names[name])` already exists', node)
						}
					}

					for (e in el) {
						fillExpression(e)
					}

					let els = [for (e in el) types.get(e)]
					types.set(node, Type.Struct(names, els))

				// `try { ... value } catch (e: T) { ... value }`
				case Node.Try(e, t, v, ca):
					// Save stack
					let _insideTry = insideTry
					// Reset stack
					insideTry = true
					fillExpression(e)
					// Restore stack
					insideTry = _insideTry

					for (i in ca.length) {
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						fill(ca[i])
						popScope()
					}
					types.set(node, types.get(e))

				// `if (econd) eif else eelse`
				case Node.If(econd, eif, eelse, ternary):
					if (econd.length > 1) {
						fail('More than one condition is not yet supported', econd[1])
					}
					switch (econd[0]) {
						case Node.Var(_):
							fail('Variable bindings in ternary conditions are not yet supported', econd[0])
					}
					if (eelse == null) {
						fail('Expression `if` should have an `else` clause', eif)
					}
					fillExpression(econd[0])
					if (ternary == false) {
						switch (eif) {
							case Node.Block(_):
							case _:
								fail('Ternary `if` should have a `{ block }` as a body', eif)
						}
						switch (eelse) {
							case Node.Block(_):
							case _:
								fail('Ternary `else` should have a `{ block }` as a body', eelse)
						}
					}
					fillExpression(eif)
					fillExpression(eelse)
					types.set(node, unify(types.get(eif), types.get(eelse), eelse))

				// Simple nodes
				case Node.Null:
					types.set(node, Type.UnknownNullable({value:null}))

				case Node.String(_):
					types.set(node, typeString)

				case Node.Bool(_):
					types.set(node, typeBool)

				case Node.Int(_):
					types.set(node, typeInt)

				case Node.MetaInt(_, meta):
					switch (meta) {
						case Meta.BigInt: types.set(node, typeBigInt)

						case Meta.Int32: types.set(node, typeInt32)
						case Meta.Int64: types.set(node, typeInt64)
						case Meta.Int16: types.set(node, typeInt16)
						case Meta.Int8: types.set(node, typeInt8)

						case Meta.UInt32: types.set(node, typeUInt32)
						case Meta.UInt64: types.set(node, typeUInt64)
						case Meta.UInt16: types.set(node, typeUInt16)
						case Meta.UInt8: types.set(node, typeUInt8)

						case Meta.Float32: types.set(node, typeFloat32)

						case _: fail('Unhandled meta type of number', node)
					}

				case Node.Float(_):
					types.set(node, typeFloat)

				// `(e)`
				case Node.Parenthesis(e):
					fillExpression(e)
					types.set(node, types.get(e))

				// `a ?? b`
				case Node.Elvis(a, b):
					fillExpression(a)
					fillExpression(b)
					unify(types.get(a), types.get(b), b)
					types.set(node, types.get(b))

				// `e(elNames: el, ...)`
				case Node.Call(e, el, elNames):
					// JavaScript evaluates arguments first
					switch (e) {
						case Node.Super(_):
							if (!allowSuper) {
								fail('Cannot access `super` here', node)
							}
						case _:
				 			fillExpression(e)
				 	}

					for (e in el) {
						fillExpression(e)
					}

				 	switch (types.get(e)) {
				 		case Type.Function(args, returns):
				 			for (i in el.length) { if (let arg = args[i]) {
				 				unify(arg, types.get(el[i]), el[i])
				 			}}
				 			types.set(node, returns)
				 			// TODO (name: )
				 			// TODO Not enough
				 			// TODO Too many
				 			// TODO ...rest
				 			// TODO optional args
				 			// TODO default args expressions+typing to use in normalization
				 			// TODO is const exprs >= 3 then require second names
				 			// "This function call is hard to read.\Replace this code: ... with this one: ..."
				 		case Type.EnumConstructor(type, tag):
				 			let name = type.fieldNames[tag]

				 			if (el.length < type.tagBindVars[tag].length) {
				 				fail('Not enough enum parameters, required `\(name)` parameters are: ' + type.tagBindVarsNames[tag].join(', '), node)
							}

				 			if (el.length > type.tagBindVars[tag].length) {
				 				fail('Too many enum parameters, required `\(name)` parameters are: ' + type.tagBindVarsNames[tag].join(', '), node)
							}

				 			// Don't allow `A.B()` syntax, require `A.B(a, b, c)` or just `A.B`
				 			if (el.length == 0) {
				 				fail('Use syntax without empty `()`', node)
							}

				 			types.set(node, Type.EnumInstance(type, tag))
				 			// TODO check arg types
				 		case null:
				 			//fail('Calling null ' + Node.stringify(e), e)
				 		case _:
				 			if (types.get(e) == typeAny) {
				 				types.set(node, typeAny)
				 			} else {
				 				fail('Calling *not* a function, type is `' + Type.stringify(types.get(e)) + '`', e)
							}
				 	}

				// `a op b` like `a + b`
				case Node.Binop(a, op, b):
					fill(a)
					fillExpression(b)

					// Anything + String = String
					if (op == Token.OpAdd, types.get(a) == typeString) {
						types.set(node, types.get(a))
					} else
					// Always provides boolean result
					if (
						op == Token.OpGte ||
						op == Token.OpGt ||
						op == Token.OpLte ||
						op == Token.OpLt ||
						op == Token.OpBoolAnd ||
						op == Token.OpBoolOr ||
						op == Token.OpEq ||
						op == Token.OpNotEq
					) {
						types.set(node, typeBool)
					} else {
					types.set(node, types.get(b) ?? types.get(a))
					}

				// `op e` or `e op`
				case Node.Unop(op, postfix, e):
					fillExpression(e)

					// Always provides boolean result
					if (op == Token.OpNot, !postfix) {
						let type = types.get(e)
						if (type != typeBool, type != typeAny, type != null) {
							fail('Operator `!value` takes `value` of type `Bool` only, but got `\(Type.stringify(types.get(e)))`', e)
						}
						types.set(node, typeBool)
						return
					}

					types.set(node, types.get(e))

					let mutates = op == Token.OpIncrement || op == Token.OpDecrement
					if (!mutates) { return }
					var parent: Node = parents.get(e)
					switch (parent) {
						case Node.Var(name, _, _, const):
							if (const) {
								fail(
									'Cannot change a constant `let \(name)`, redefine it as `var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							}
						case Node.Function(name, _):
							fail('Cannot `\(Token.stringify(op))` a function `\(name)`', node)
						case Node.For(name, _):
							fail(
								'Cannot change iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for (\(name) in ...)` is defined here',
							node)
						case Node.Static(f): switch (f) {
							case Node.Function(name, _):
								fail('Cannot `\(Token.stringify(op))` a static function `\(name)`', node)
							case Node.Var(name, _, _, const):
								if (const) {
									fail(
									'Cannot change a constant `static let \(name)`, redefine it as `static var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`static let \(name)` is defined here',
									node)
								}
						}
						case _:
							switch (e) {
								case Node.Index(_):
									// Ok
									// Sets NaN to `[n]` in JavaScript if `[n] == null` and returns NaN
									// TODO maybe require `a[i] == a[i] ?? n + 1` instead?
									// cause also string/etc arrays...
								case _:
									let ops = Token.OpIncrement? 'increment `++`' : 'decrement `--`'
									fail('You can \(ops) only a variable, .field or array element', node)
									// TODO `x={i:123} x.i++` <- by type and const factor
							}
					}


				// `e[i]`
				case Node.Index(e, i):
					fillExpression(e)
					fillExpression(i)

					// For now, only Int & Any index supported
					var indexableIsAny = false
					switch (types.get(e)) {
						case Type.ClassInstance(type, generic):
							if (type.name == 'Any') {
								indexableIsAny = true
							}
					}

					if (!indexableIsAny) {
					switch (types.get(i)) {
						case Type.ClassInstance(type):
							if (type.name != 'Int', type.name != 'Any') {
								fail('`value[i]` expects `i` only of type `Int`, but got `' + Type.stringify(types.get(i)) + '`', e)
							}
						case _:
							fail('`value[i]`????? expects `i` only of type `Int`, but got `' + Type.stringify(types.get(i)) + '`', e)
						case null:
					}}

					// For now, only Array[i] supported
					switch (types.get(e)) {
						case Type.ClassInstance(type, generic):
							if (generic != null, generic.length == 1) {
								types.set(node, generic[0])
							} else if (['Array','Buffer','Uint8Array','Uint32Array'].includes(type.name)) {
								types.set(node, toType(NodeType.Type("Int"), node))
							} else if (['Any'].includes(type.name)) {
								types.set(node, toType(NodeType.Type("Any"), node))
							} else {
								fail('value[i] generic is null or >1', e)
							}
						case _:
						case null:
					}

				// `a op= b`
				case Node.AssignOp(a, op, b):
					// `===`
					if (op == Token.OpEq) {
						fail('`===` not supported, use `strictEqual`', node)
					}
					// `!==`
					if (op == Token.OpEq) {
						fail('`!==` not supported, use `strictNotEqual`', node)
					}

					fillExpression(a)
					var parent: Node = parents.get(a)
					switch (parent) {
						case Node.Var(name, _, _, const):
							if (const) {
								fail(
									'Cannot change a constant `let \(name)`, redefine it as `var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							}
						case Node.Function(name, _):
							fail('Cannot reassign a function `\(name)`', node)
						case Node.For(name, _):
							fail(
								'Cannot change iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for (\(name) in ...)` is defined here',
							node)
						case _: // Ok
					}
					fillExpression(b)
					types.set(node, unify(types.get(a), types.get(b), b))

				// `throw e`
				case Node.Throw(e):
					if (!insideFunction && !insideTry) {
						fail('Cannot throw outside of `function` or `try`', node)
					}
					if (insideFunction && !functionAllowedToThrow) {
						fail('Cannot throw in a @noThrow function', node)
					}
					if (insideFunction) {
						functionThrows = true // Infer that function throws
					}
					fillExpression(e)

				// `this`
				case Node.This:
					if (!insideClassMethod) {
						fail('Cannot access `this` outside of class method', node)
					}
					if (thisType == null) {
						fail('Cannot access `this` in class method', node)
					}
					types.set(node, thisType)
					parents.set(node, thisNode)

				// `super`
				case Node.Super(_):
					fail('Cannot use `super` as value', node)

				// `return e`
				case Node.Return(e):
					switch (e) {
						case Node.Var(name, _, _, const):
							let prefix = const? 'let' : 'var'
							fail('This `return` tries to return a variable `\(prefix) \(name)`. Try to wrap it into braces like this `{ return } \(prefix) \(name)`', node)
						case Node.Return(_):
							fail('Cannot return another return. Try to wrap first `{ return } return 2` into braces', node)
					}
					if (!insideFunction) {
						fail('Cannot use `return` outside of function', node)
					}
					if (e != null) {
						if (functionReturnsAType == typeVoid) {
							fail('Function returns `Void`, cannot return a value here', e)
						}
						fillExpression(e)
						let ret = types.get(e)
						if (ret == typeVoid) {
							fail('Cannot `return` a `Void` non-value', node)
						}
						functionReturnsAType = unify(functionReturnsAType, ret, e)
						functionActuallyReturns = true
					} else {
						if (let ret = functionReturnsAType) {
							if (ret != typeVoid) {
								fail('Expected `return value` of type `\(Type.stringify(ret))`', node)
							}
						} else {
							functionReturnsAType = typeVoid
						}
					}

				// Errors
				case Node.Underscore:
					fail('Cannot use underscore `_` outside of case pattern', node)
				case Node.Static(_):
					fail('Cannot use `static` here: only applicable to class fields', node)
				case Node.Private(_):
					fail('Cannot use `private` here: only applicable to class fields and module declarations', node)
				case Node.Module(_):

				// Not expressions
				case Node.Break:
					fail('Cannot use `break` as a value', node)
				case Node.Continue:
					fail('Cannot use `continue` as a value', node)
				case Node.Class(_):
					fail('Cannot use `class` as a value', node)
				case Node.Enum(_):
					fail('Cannot use `enum` as a value', node)
				case Node.TypeAlias(_):
					fail('Cannot use `declare` as a value', node)
				case Node.Import(_):
					fail('Cannot use `import` as a value', node)
				case Node.Var(name, _, _, const):
					let prefix = const? 'let' : 'var'
					fail('Cannot use `\(prefix) \(name)` as a value', node)
				case Node.Switch(_):
					fillSwitch(node, true)
				case Node.While(_):
					fail('Cannot use `while` as a value', node)
				case Node.For(_):
					fail('Cannot use `for` as a value. To build array from loop, surround with `[for()]` brackets.', node)

				// Fails
				case null:
					fail('Got null node' + never, node)
				case _:
					fail('Unknown node expression kind to type ' + node + never, node)
			}
		}

		function fillSwitch(node, value: Bool) {
			switch (node) {
				// TODO extracting like this is weird, Just pass arguments to fillSwitch
				case Node.Switch(exprs, conds, guards, cases):
					for (e in exprs) { pushScope() fillExpression(e) popScope() }
					if (let expr = exprs[1]) {
						fail('Multiple switch values are not yet supported', expr)
					}


					fun unwrapUnknownAndNullable(type: Type?): Type? {
						switch (type) {
							case null: return null
							case Type.Nullable(type): return unwrapUnknownAndNullable(type)
							case Type.Unknown(type): return unwrapUnknownAndNullable(type.value)
							case Type.UnknownNullable(type): return unwrapUnknownAndNullable(type.value)
						}

						return type
					}

					let etype = unwrapUnknownAndNullable(types.get(exprs[0]))

					if (etype == null) {
						fail('Value of switch `\(Node.stringify(exprs[0]))` must have a known type at this postition', exprs[0])
					}

					var enumType: EnumType? = null
					var shortHandSyntax = false

					// TODO typeArray
					// TODO typeMap?
					if (etype == typeBool) {
						// Okay
					} else if (etype == typeInt) {
						// Okay
					} else if (etype == typeString) {
						// Okay
					} else if (etype == typeFloat) {
						fail('Due to imprecise nature of `Float` type, switching over it is not allowed', exprs[0])
					} else {
						switch (etype) {
							case Type.Enum(type):
								enumType = type
							case Type.EnumInstance(type, _):
								enumType = type
							case _:
								fail('Cannot switch over `\(Type.stringify(etype))` type', exprs[0])
						}
					}

					// TODO if typeof(expr) == typeInt ... special code path
					// same for simple enums
					// and special for complex enums
					// and error on typeVoid, type unknown (not inferred) and etc
					// same for Normalizer

					// TODO support for simple (exhaustive checked) nested patterns
					// like A(true) A(false) and A(NonComplexEnum)
					// complex enums may break readability... but helpful for
					// shader langs? meh.. they require some computations
					// (like case normalization)
					// between mattern matching anyway

					// TODO guards
					// let expr = if (let expr = exprs[0]) expr else return
					// @guard let expr = exprs[0]
					// Node.TMacroExpansion <- for simple debug and print of
					// result of evaluated syntax @macro

					// TODO exprs is a positive array like
					// : [T, 1 ...] 1 or more elements, so [0] != don't require null check

					// TODO error on not-all-matched patterns of enum by default,
					// but @hint makes it only a hint and @ok to ignore

					var tags: [String] = []
					var i = 0
					while (i < cases.length) {
						pushScope()
						var e = conds[i]
						// Fill case condition `case pattern:`
						var currentType = null
						var currentTag = null
						var currentTagBind = 0
						var interval = false

						fun follow(e: Node) {
							switch (e) {
								case Node.DotUpper(ex, name):
									fillExpression(e)
									switch (types.get(ex) as! Type) {
										case Type.Enum(type):
											currentType = type
											currentTag = name
											if (tags.includes(currentTag)) {
												fail('Tag `\(currentTag)` already matched', e)
												// TODO .. at line
											} else {
												tags.push(currentTag)
											}
									}
								case Node.Parenthesis(e): {fill(e)}
								// `case _:` default case
								case Node.Underscore: {}

								// TODO error on complex enums
								case Node.Null: {}
								case Node.Bool(_):
									if (etype != typeBool) {
										fail('Cannot switch over boolean here', e)
									}
								case Node.Int(_):
									if (etype != typeInt) {
										fail('Cannot switch over number here', e)
									}
								case Node.String(_):
									if (etype != typeString) {
										fail('Cannot switch over string here', e)
									}
								case Node.Call(ex, args, argNames): {
									// TODO rethink nested pattern mechanics
									// TODO don't follow nested patterns for now
									follow(ex)
									currentTagBind = 0

									if (args.length == 0) {
										fail('Do not use `()` empty pattern, use `\(currentTag)(...)` syntax to ignore all bindings', e)
									}

									if (
										let enumType = enumType,
										enumType.fieldsTypeSimple != null
									) {
										fail('The `\(enumType.name)` is simple enum and has no `()` bindings', e)
									}

									if (
										let enumType = enumType,
										shortHandSyntax == true,
										let i = enumType.fieldNames.indexOf(currentTag),
										let binds = enumType.tagBindVarsNames[i],
										binds.length == 0
									) {
										switch (args[0]) {
											case Node.Interval(_):
												// Okay
											case _:
												fail('The `\(currentTag)` has no `()` bindings, use `\(currentTag)(...)` syntax to ignore all future bindings added', e)
										}
									}

									for (ee in args) {
										if (interval) {
											fail('Do not match any patterns after `...` interval', ee)
										}

										switch (ee) {
										case Node.Interval(_):
											interval = true
										case Node.Ident(name):
											follow(ee)
											currentTagBind++
										case Node.Underscore:
											if (
												let enumType = enumType,
												shortHandSyntax == true,
												let i = enumType.fieldNames.indexOf(currentTag),
												let binds = enumType.tagBindVarsNames[i],
												binds.length <= currentTagBind
											) {
												fail('Too many bindings ignored with `_` for `F` tag, use `...` syntax to ignore all future bindings', e)
											}

											currentTagBind++
										case _:
											fail('This case pattern is not supported', e)
										}
									}
								}

								// case TagName:
								case Node.NodeTypeValue(t):
									shortHandSyntax = true
									switch (t) {
										case NodeType.Type(name):
											if (let enumType = enumType) {
												if (let i = enumType.fieldNames.indexOf(name), enumType.fieldEnumConstructor[i] == true) {
													currentType = enumType
													currentTag = name
													if (tags.includes(currentTag)) {
														fail('Tag `\(currentTag)` already matched', e)
														// TODO .. at line
													} else {
														tags.push(currentTag)
													}
												} else {
													fail('The `\(name)` is not an enum constructor of `\(enumType.name)`', e)
												}
											} else {
												fail('This case pattern is not supported over non-enum types', e)
											}
										case _:
											fail('This case pattern is not supported', e)
									}

								case Node.Ident(name): // Bind (var)
								{
									if (name.charAt(0) == name.charAt(0).toUpperCase()) {fill(e)}
									else {
										addScope(name, e)

										// Find tag bind var and set it's type:
										if (let currentType = currentType) {
											let indexOf = currentType.fieldNames.indexOf(currentTag)
											if (indexOf == -1) {
												fail('currentType.fieldNames.indexOf == -1', e)
											}
											let type = currentType.tagBindVars[indexOf][currentTagBind]
											let name = currentType.tagBindVarsNames[indexOf][currentTagBind]
											if (name == null) {
												let available = currentType.tagBindVarsNames[indexOf].join(', ')
												if (available.length == 0) {
													fail('No bindings available for `.' + currentTag + '`', e)
												}
												fail('Too many bindings requested for `\(currentTag)`, available are: ' + available, e)
											}
											if (type != null) {
												types.set(e, toType(type, e))
											} else {
												fail('tagBindVars no type for ' + name, e)
											}
										} else {
											fail('No currentType for '+name, e)
										}
									}
								}
								case Node.Binop(a, op, b):
									if (op == Token.OpOr) {
										follow(a)
										follow(b)
									} else {
										fail('This case pattern is not supported', e)
									}
								case Node.If(econd, _, _):
									pushScope()
									fill(econd[0])
									popScope()
								case _:
									fail('This case pattern is not supported', e)
							}
						}
						follow(e)
						// Fill case result expression
						var e = cases[i]
						pushScope()

						if (let guard = guards[i]) {
							fillExpression(guard)
							if (types.get(guard) != typeBool) {
								fail('Case guard must be a simple boolean expression', guard)
							}
						}

						if (value == false) {
							fill(e)
						}
						if (value == true) {
							fillExpression(e)
							if (types.get(node) == null) {
								types.set(node, types.get(e))
							} else {
								types.set(node, unify(types.get(node), types.get(e), e))
							}
						}
						popScope()

						popScope()
						i++
					}
			}
		}
	}
