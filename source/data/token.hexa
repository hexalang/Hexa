// The Hexa Compiler
// Copyright (C) 2018-2020  Oleg Petrenko
// Copyright (C) 2018  Bogdan Danylchenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// List of all available lexemes and tokens
enum Token : Int {
	// Default
	Eof          = 0
	Default      = 123 // Simplifies some parsing

	// Keywords
	// Order makes no sense
	KBreak       = 3
	KCase        = 4
	KCatch       = 6
	KClass       = 7
	KContinue    = 8
	KDo          = 9
	KElse        = 10
	KEnum        = 11
	KExtends     = 12
	KDeclare     = 13
	KFalse       = 14
	KFor         = 15
	KFun         = 21
	KIf          = 17
	KImplements  = 18
	KImport      = 2
	KIn          = 20
	KInterface   = 22
	KLet         = 23
	KNew         = 25
	KNull        = 26
	KPrivate     = 29
	KReturn      = 31
	KStatic      = 32
	KSwitch      = 33
	KThis        = 34
	KThrow       = 35
	KTrue        = 36
	KTry         = 37
	KVar         = 40
	KWhile       = 41
	KIs			 = 57
	KAs          = 58
	KSuper       = 59

	// Literals
	LFloat       = 60 // 0.123
	LUpper       = 61 // Word
	LLower       = 62 // word
	LInt         = 63 // 123
	LString      = 64 // "", ''
	LDoc         = 65 // /** doc **/
	LBacktick    = 66 // ``

	// Symbols
	Underscore   = 1
	At           = 70 // @
	BkClose      = 71 // ]
	BkOpen       = 72 // [
	BrClose      = 73 // }
	BrOpen       = 74 // {
	Comma        = 75 // ,
	Colon        = 76 // :
	Dot          = 77 // .
	Sharp        = 78 // #
	PClose       = 79 // )
	POpen        = 80 // (
	Question     = 81 // ?
	Semicolon    = 82 // ;
	Query        = 83 // $
	Interval     = 98 // ...

	// Unop
	OpDecrement  = 86 // --
	OpIncrement  = 87 // ++
	OpNegBits    = 88 // ~
	OpNot        = 89 // !

	// Binop
	OpArrow      = 90 // =>
	OpAssign     = 91 // =
	OpBoolAnd    = 92 // &&
	OpBoolOr     = 93 // ||
	OpDiv        = 94 // /
	OpEq         = 95 // == TODO // com as /// doc for all values
	OpGt         = 96 // >
	OpGte        = 97 // >=
	OpLt         = 99 // <
	OpLte       = 100 // <=
	OpMod       = 101 // %
	OpMult      = 102 // `*`
	OpNotEq     = 103 // !=
	// TODO consider creating += -= >>>= tokens
	// ^ not, to use in parser, there should be a way
	// to get >>> from >>>= by doing token - offset or something
	OpOr        = 104 // |
	OpShl       = 105 // <<
	OpShr       = 106 // >>
	OpSub       = 107 // -
	OpUShr      = 108 // >>>
	OpXor       = 109 // ^
	OpIntDiv    = 110 // \
	OpAdd       = 111 // +
	OpAnd       = 112 // &
	OpChain     = 113 // ?.

	static fun stringify(token: Token, param: String? = null): String {
		switch token {
		case At: return "@"
		case Query: return "$"
		case Sharp: return "#"
		case BkClose: return "]"
		case BkOpen: return "["
		case BrClose: return "}"
		case BrOpen: return "{"
		case Colon: return ":"
		case Comma: return ","
		case Default: return "<!--default-->"
		case Dot: return "."
		case Eof: return "<!--eof-->"
		case Interval: return "..."
		case KAs: return "as"
		case KBreak: return "break"
		case KCase: return "case"
		case KCatch: return "catch"
		case KClass: return "class"
		case KContinue: return "continue"
		case KDo: return "do"
		case KElse: return "else"
		case KEnum: return "enum"
		case KExtends: return "extends"
		case KDeclare: return "declare"
		case KFalse: return "false"
		case KFor: return "for"
		case KFun: return "fun"
		case KIf: return "if"
		case KImplements: return "implements"
		case KImport: return "import"
		case KIn: return "in"
		case KInterface: return "interface"
		case KLet: return "let"
		case KNew: return "new"
		case KNull: return "null"
		case KPrivate: return "private"
		case KReturn: return "return"
		case KStatic: return "static"
		case KSuper: return "super"
		case KSwitch: return "switch"
		case KThis: return "this"
		case KThrow: return "throw"
		case KTrue: return "true"
		case KTry: return "try"
		case KVar: return "var"
		case KWhile: return "while"
		case OpAdd: return "+"
		case OpAnd: return "&"
		case OpArrow: return "=>"
		case OpAssign: return "="
		case OpBoolAnd: return "&&" // We keep it like this (not `and`) to simplify JavaScript generation
		case OpBoolOr: return "||"
		case OpDecrement: return "--"
		case OpDiv: return "/"
		case OpEq: return "=="
		case OpGt: return ">"
		case OpGte: return ">="
		case OpIncrement: return "++"
		case OpIntDiv: return "\\"
		case OpLt: return "<"
		case OpLte: return "<="
		case OpMod: return "%"
		case OpMult: return "*"
		case OpNegBits: return "~"
		case OpNot: return "!"
		case OpNotEq: return "!="
		case OpOr: return "|"
		case OpShl: return "<<"
		case OpShr: return ">>"
		case OpSub: return "-"
		case OpUShr: return ">>>"
		case OpXor: return "^"
		case OpChain: return "?."
		case PClose: return ")"
		case POpen: return "("
		case Question: return "?"
		case Semicolon: return ";"
		case Underscore: return "_"
		case LUpper: return (param == null)? 'TitleCase' : param
		case LString: return (param == null)? 'string' : '\'\(param)\''
		case LBacktick: return (param == null)? 'backtick' : '`\(param)`'
		case LLower: return (param == null)? 'identifier' : param
		case LInt: return (param == null)? 'integer' : param
		case LFloat: return (param == null)? 'float' : param
		case LDoc: return '///\(param)'
		case KIs: return "is"
		}
	}
}

enum Meta : Int {
	Default

	BigInt

	Int32
	Int64
	Int16
	Int8

	UInt32
	UInt64
	UInt16
	UInt8

	Float32
	// Float64 -> Float is 64-bit by Default
}
