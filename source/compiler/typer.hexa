// The Hexa Compiler
// Copyright (C) 2021-2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// Analyzes and transforms untyped syntax tree from parser into typed syntax tree, and sends into normalizer
@final
class Typer {
		// Note that we use new instance for each build to avoid collisions with unit tests
		// and to support parallel compilation in future
		var project: Project

		// TODO move all variables here

		new (project: Project) {
			this.project = project
		}

		// Starting point of typer
		fun fillModules() {
			// Globals already pre-filled in package loader
			// so we do not fill them here
			fun checkOverrides(info: Module, name: String, e: Node) {
				if (info.exported.has(name)) {
					fail('Module `\(info.path)` already exports name `\(name)`', e)
				}

				if (info.imported.has(name)) {
					fail('Module `\(info.path)` already imports name `\(name)`', e)
				}
			}

			// Fill exports first to allow recursive imports
			for info in project.moduleInfo {
				let nodes = info.nodes

				for e in nodes {
					var named = true
					switch e {
						case Var(_):
						case Enum(_):
						case Function(_):
						case Class(_):
						case TypeAlias(_):
						// TODO type alias
						case _:
							named = false
					}

					if named {
						let name = DataHelper.nameOf(e)
						checkOverrides(info, name, e)
						info.exported.set(name, e)
						project.mapModules.set(e, info)
					}
				}
			}

			// Imports & expressions
			for info in project.moduleInfo {
				let nodes = info.nodes
				pushScope()

				var doneImports = false
				for e in nodes {
					var named = true
					var lastOne = nodes[0]
					switch e {
						case Import(els, path):
							if doneImports {
								fail(
									'Imports should follow before expressions\n'
									+ positionOf(lastOne) + 'Expression is here',
								e)
							}

							let index: Module? = project.mapModules.get(e)

							if index == null {
								fail('Cannot import ' + path, e)
							}

							fun importAs(name: String, to: String) {
								if let target = index {
									if name == '*' {
										info.imported.set(to, Node.ModuleExports(target))
									} else
									if let what = target.exported.get(name) {
										checkOverrides(info, to, e)
										info.imported.set(to, what)
									} else {
										var has = [for key in target.exported.keys() key].join(', ')
										if has == '' {
											has = 'module is empty'
										}
										fail('Module `\(path)` does not export `\(name)`\nAvailable exports: \(has)', e)
									}
								}
							}

							// TODO `let target = target.exported.keys() ?? throw 'unreachable'` special case for `??` nodes
							if els.length == 0 {
								if let target = index {
									for key in target.exported.keys() {
										info.imported.set(key, target.exported.get(key))
									}
								}
							}

							for el in els {
								switch el {
									case Lower(name):
										// TODO only camelCase
										importAs(name, name)
									case Upper(name):
										// TODO only TitleCase
										importAs(name, name)
									case As(left, right):
										var lhs = ''
										switch left {
											case Lower(name):
												lhs = name
											case Upper(name):
												lhs = name
											case AllTheThings:
												lhs = '*'
											case _:
												fail('This `import ??? as` kind not implemented yet or syntax is incorrect', e)
										}
										switch right {
											case Lower(name):
												// TODO only camelCase
												importAs(lhs, name)
											case Upper(name):
												// TODO only TitleCase
												importAs(lhs, name)
											case _:
												fail('This `import \(lhs) as ???` kind not implemented yet or syntax is incorrect', e)
										}
									case _:
										fail('This import kind not implemented yet', e)
								}
							}
						case _:
							lastOne = e
							doneImports = true

							// Fill classes and non-ambiguous nodes first
							let node = e
							currentModule = info

							switch node {
								case Class(_):
									parents.set(node, e)
									fillModuleTypes(node)
								case Enum(_):
									parents.set(node, e)
									fillModuleTypes(node)
								case TypeAlias(_):
									parents.set(node, e)
									fillModuleTypes(node)
								case Function(name, expr, vars, rettype):
									if let rettype = rettype {
										types.set(node, Type.Function(varTypes(vars), toType(rettype, node)))
									}
								case Var(name, t, e, const):
									if let t = t {
										types.set(node, toType(t, node))
									}
								case _:
							}
					}
				}
			}

			for info in project.moduleInfo {
				let nodes = info.nodes
				let self = Node.Module(info.path, info.nodes)
				pushScope()
				currentModule = info

				// Fill expression bodies
				for node in nodes {
					switch node {
						case Import(_):
						case Class(_):
						case TypeAlias(_):
						case Enum(_):
						case _:
							parents.set(node, self) // TODO module itself
							fill(node)
					}
				}

				popScope()
			}

			if failures.length > 0 {
				let errors = failures.slice()
				failures = []
				throw new CompilerErrors(errors)
			}
		}

		fun find(name: String): Node? {
			var subj: Node? = null
			for i in scopes.length {
				subj = scopes[scopes.length - i - 1].get(name)
				if subj != null {
					break
				}
			}
			if subj == null {
				subj = findInNamespaceRoots(name)
			}
			return subj
		}

		// Generates `Did you mean xxx?`
		// TODO use this for other errors
		fun proposeSimilar(names: [String], subject: String, what: String): String {
			if names.length == 0 {
				return 'No \(what) available for access'
			}

			let ten = if names.length > 11 { // Yeah, 11, so it says "more whats" in plural
				names.slice(0, 10).join(', ') + ' and ' + (names.length - 10) + ' more ' + what
			} else {
				names.join(', ')
			}

			// TODO limit `what` to `types` and `...whatever`
			// TODO if `types` must recommend only UpperCased ones
			// TODO ^ lower for otherwise
			let available = 'Available \(what) are: ' + ten
			let subject = subject.toLowerCase()
			let charSubj = subject.split('')
			var bestValue = 0
			var bestName = ''

			// TODO for name : index in _ _
			for name in names {
				let named = name.toLowerCase()
				if named.startsWith(subject) || subject.startsWith(named) {
					return 'Did you mean `\(name)`?\n\n' + available
				}

				var index = 0
				var thisValue = 0
				// TODO for name : index in _ _
				for char in named.split('') {
					if char == charSubj[index] {
						thisValue++
					}
					index++
				}

				if thisValue > bestValue {
					bestValue = thisValue
					bestName = name
				}
			}

			// Avoid really useless proposals
			if bestValue > 2 {
				return 'Did you mean `\(bestName)`?\n\n' + available
			}

			return available
		}

		fun registerClassType(node: Node, callback: Any): ClassType {
			let mod = currentModule
			currentModule = project.mapModules.get(node) ?? mod
			let registered = registerClassTypeWrapped(node, callback)
			currentModule = mod
			return registered
		}

		// `class T {}`
		fun registerClassTypeWrapped(node: Node, callback: Any): ClassType {
			if let type = types.get(node) {
				switch type as! Type {
					// Avoid typing if already typed
					case Class(t):
						if let setup = callback {
							setup(t)
						}
						return t
				}
			} else {
				let typeName = DataHelper.nameOf(node)

				let type = switch typeName {
					// TODO respect "built in" decorator
					case 'Int':
						typeIntClass
					case 'Array':
						typeArray
					case 'Any':
						typeAnyClass
					case _:
						new ClassType()
				}

				let _thisType = thisType
				let _thisNode = thisNode

				// TODO not simply instantiate, must be filled with generic dummies
				thisType = type.instantiate()
				thisNode = node
				type.parent = node
				type.name = typeName
				types.set(node, Type.Class(type))

				// Solve race condition
				// TODO do only for std lib
				if let setup = callback {
					setup(type)
				}

				// TODO detect only in root module
				// probably create them upfront and assign definition later?
				switch type.name {
					case 'Int': //typeInt = type.instantiate()
					case 'Bool': typeBool = type.instantiate()
					case 'Float': typeFloat = type.instantiate()
					case 'String': typeString = type.instantiate()
					case 'Array': typeArray = type
					case 'Map': typeMap = type
					case 'Any':
						nodeAny = node
					case 'Void': typeVoid = type.instantiate()

					case 'UInt8': typeUInt8 = type.instantiate()
					case 'UInt16': typeUInt16 = type.instantiate()
					case 'UInt32': typeUInt32 = type.instantiate()
					case 'UInt64': typeUInt64 = type.instantiate()
				}

				fun getRename(f: Node): String? {
					let atts = project.mapDecorators.get(f)
					if let native = DataHelper.getDecorator(atts, 'rename') {
						if native.values.length != 1 {
							throw '@rename takes one string argument'
						}
						if native != null { switch native.values[0] {
							case String(s): return s
							case _: throw '@rename takes string as argument'
						}}
					}
					return null
				}

				switch node {
					case Class(t, extend, implement, f, external):
						switch t {
							case ParametricType(name, params):
								type.genericParams.push(DataHelper.extractTypeName(params[0]))
								let names = type.genericParams
								for i in 1 ... params.length {
									let name = DataHelper.extractTypeName(params[i])
									if names.includes(name) {
										fail('Parameter `\(name)` already exists in `<T, ...>`', node)
									}
									names.push(name)
								}
						}

						if let ext = extend {
							toType(ext, node)
							// TODO cannot extend self or recursively in circle
							// TODO limit nesting depth
						}
						for impl in implement {
							// TODO
							toType(impl, node)
						}
						pushScope()

						for genericParam in type.genericParams {
							addScopeType(genericParam, typeAny)
						}

						// Fill scopes
						for field in f {
							switch field {
								case Function(name, _):
									if type.fieldNames.includes(name) {
										fail('Field `\(name)` already exists', field)
									}
									type.fieldNames.push(name)
									if (name == 'new') {
										type.constructor = type.fieldNames.length - 1
									} else {
										type.fieldRenames[type.fieldNames.length - 1] = getRename(field)
									}
									addScope(name, field)
								case Var(name, t, e, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', field)
									}
									type.fieldNames.push(name)
									type.fieldInitialized[type.fieldNames.length - 1] = false
									type.fieldRenames[type.fieldNames.length - 1] = getRename(field)
									addScope(name, field)
								case Property(field, _, _):
									switch field {
										case Var(name, _):
											if (type.fieldNames.includes(name)) {
												fail('Field `\(name)` already exists', field)
											}
											type.fieldNames.push(name)
											addScope(name, field)
									}
								case Static(f): switch f {
									case Function(name, _):
										if (type.fieldNames.includes(name)) {
											fail('Field `\(name)` already exists', field)
										}
										type.fieldNames.push(name)
										type.fieldStatic[type.fieldNames.length - 1] = true
										addScope(name, field)
									case Var(name, _):
										if (type.fieldNames.includes(name)) {
											fail('Field `\(name)` already exists', field)
										}
										type.fieldNames.push(name)
										type.fieldStatic[type.fieldNames.length - 1] = true
										addScope(name, field)
								}
								case _:
									fail('Wrong class field format', field)
							}
							parents.set(field, node)
						}

						// Fill fields with non-ambiguous types
						for field in f { switch field {
							// `var\let a: known T`
							case Var(name, t, e, const):
								if let t = t {
									types.set(field, toType(t, field))
								}
							// `function a(args with known types or no args): known ret type`
							case Function(name, expr, vars, rettype):
								if let rettype = rettype {
									types.set(field, Type.Function(varTypes(vars), toType(rettype, field)))
								}

							case Static(f): switch f {
								case Function(name, expr, vars, rettype):
									if let rettype = rettype {
										types.set(f, Type.Function(varTypes(vars), toType(rettype, f)))
										types.set(field, types.get(f))
									}
								case Var(name, t, e, const):
									if let t = t {
										types.set(f, toType(t, f))
										types.set(field, types.get(f))
									}
							}
						}}

						// Fill expressions
						for field in f { switch field {
							// Instance method
							case Function(name, expr, vars, rettype):
								if (name == 'new') {
									type.constructor = type.fieldNames.length - 1
								}
								if external, expr != null {
									if (name == 'new') {
										fail('External class constructor `new()` cannot have a body `{}`', field)
									} else {
										fail('External class method `function \(name)` cannot have a body `{}`', field)
									}
								}
								let _insideClassMethod = insideClassMethod
								let _allowSuper = allowSuper
								insideClassMethod = true
								allowSuper = (extend != null)
								if !external {
									fillFunction(field, expr, vars, rettype)
								}
								if external, types.get(field) == null {
									types.set(field, Type.Function(varTypes(vars), rettype!=null? toType(rettype, field) : typeVoid))
								}
								insideClassMethod = _insideClassMethod
								allowSuper = _allowSuper

							// Field of `var` or `let`
							case Var(name, t, e, const):
								if external, e != null {
									fail('External class field `var \(name)` cannot have `= value`', field)
								}
								let _insideClassMethod = insideClassMethod
								insideClassMethod = true
								if e != null {
									fillExpression(e)
								}
								insideClassMethod = _insideClassMethod
								mixVarTypes(t, e, field)
								type.fieldInitialized[type.fieldNames.indexOf(name)] = true
								if types.get(field) == null {
									fail('Field `var \(name)` initialized, but got no type '+e, field)
								}

							// The thing with getters and setters
							case Property(f, _, _):
									switch f {
										case Var(name, t, e, const):
											if external, e != null {
												fail('External class field `var \(name)` cannot have expression', field)
											}
											let _insideClassMethod = insideClassMethod
											insideClassMethod = true
											if e != null {
												fillExpression(e)
											}
											insideClassMethod = _insideClassMethod
											mixVarTypes(t, e, f)
											type.fieldInitialized[type.fieldNames.indexOf(name)] = true
											if types.get(f) == null {
												fail('Property `\(name)` initialized, but got no type '+e, field)
											}
											types.set(field, types.get(f))
								}

							// `static f`
							case Static(f): switch f {
								case Function(name, expr, vars, rettype):
									if external, expr != null {
										fail('External class field `static fun \(name)` cannot have a body', field)
									}
									let _insideClassMethod = insideClassMethod
									insideClassMethod = false
									if !external {
										fillFunction(f, expr, vars, rettype)
									}
									if external {
										types.set(f, Type.Function(varTypes(vars), rettype!=null? toType(rettype, f) : typeVoid))
									}
									insideClassMethod = _insideClassMethod
									if (types.get(f) == null) {
										fail('Function get no type: class ' + DataHelper.nameOf(node) + ' static ' + name, f)
									}
									types.set(field, types.get(f))
								case Var(name, t, e, const):
									if external, e != null {
										fail('External class field `static var \(name)` cannot have expression', field)
									}
									if (e != null) {
										fillExpression(e)
									}
									mixVarTypes(t, e, f)
									types.set(field, types.get(f))
							}

							case _:
								fail('Wrong class field format', node)
						}}

						popScope()
					case _:
						fail('ClassType expects (declare) class node, but got ' + node, node)
				}

				thisType = _thisType
				thisNode = _thisNode
				return type
			}
		}

		// `enum T {}`
		fun registerEnumType(node: Node): EnumType {
			if let type = types.get(node) {
				switch type as! Type {
					// Avoid typing if already typed
					case Enum(t): return t
				}
			} else {
				let type = new EnumType()
				type.parent = node
				type.name = DataHelper.nameOf(node)
				types.set(node, Type.Enum(type))

				switch node {
					case Enum(t, f, valuesType, extend):
					pushScope()
					if let valuesType = valuesType {
						type.fieldsTypeSimple = toType(valuesType, node)
					}

					if
						type.fieldsTypeSimple != null,
						type.fieldsTypeSimple != typeInt,
						type.fieldsTypeSimple != typeString
					{
						fail('Simple enums may be only of types `Int` and `String`', node)
					}

					if f.length == 0, extend == null {
						fail('Enum `\(type.name)` must have at least one value `enum \(type.name) { Value }`', node)
					}

					// Check for incompatible tag format and fill scopes
					for field in f {
						switch field {
							// `enum E { A }`
							case NodeTypeValue(t): switch t {
								case Type(name):
									if (type.fieldNames.includes(name)) {
										throw fail('Field `\(name)` already exists', node)
									}
									type.fieldNames.push(name)
									// TODO refactor `length - 1`
									type.fieldEnumConstructor[type.fieldNames.length - 1] = true
									type.tagBindVars[type.fieldNames.length - 1] = []
									type.tagBindVarsNames[type.fieldNames.length - 1] = []
									type.fieldType[type.fieldNames.length - 1] = Type.EnumInstance(type, type.fieldNames.length - 1)
								case _:
									fail('Wrong enum constructor format, should be `Name`', node)
							}

							// `enum E { A(b: C) }`
							case Call(e, args, argNames):
								if (valuesType != null) {
									throw fail('Cannot use `Value(args)` format for simple enum', node)
								}
								switch e {
									case NodeTypeValue(t): switch t {
										case Type(name):
											if (type.fieldNames.includes(name)) {
												throw fail('Field `\(name)` already exists', node)
											}
											type.fieldNames.push(name)
											type.fieldEnumConstructor[type.fieldNames.length - 1] = true
											type.fieldType[type.fieldNames.length - 1] = Type.EnumConstructor(type, type.fieldNames.length - 1)
											let tagBindVars = []
											let tagBindVarsNames = []
											type.tagBindVars[type.fieldNames.length - 1] = tagBindVars
											type.tagBindVarsNames[type.fieldNames.length - 1] = tagBindVarsNames

											if (args.length == 0) {
												// TODO fix this `: ` and other messages
												fail('Enum constructor expects more than zero arguments `(value: Type)`', e)
											}

											for i in args.length {
												if (argNames[i] == null) {
													fail('Enum constructor arguments should have names `E(name1: T, name2: T)', args[i])
												}
													tagBindVars[i] = nodeToNodeType(args[i])

													if (tagBindVarsNames.includes(argNames[i])) {
														fail('Enum constructor argument `\(argNames[i])` already exists', args[i])
													}

													tagBindVarsNames[i] = argNames[i]
											}
										case _:
											fail('Wrong enum constructor format, should be `Name(value: T)`', e)
									}
								}

							// `enum E { A = b }`
							// TODO allow BigInt as possible enum value type?
							case Binop(a, op, b):
								if op != Token.OpAssign {
									fail('Should use `Value = value` not `Value \(Token.stringify(op)) value` format for enum tag value', node)
								}
								if (valuesType == null) {
									fail('Cannot use `Value = value` format for complex enum', node)
								}
								switch a {
									case NodeTypeValue(t): switch t {
										case Type(name):
											if (type.fieldNames.includes(name)) {
												fail('Field `\(name)` already exists', node)
											}
											type.fieldNames.push(name)
											type.fieldEnumConstructor[type.fieldNames.length - 1] = true
											switch b {
												case Int(_): if (type.fieldsTypeSimple != typeInt) {
													fail('`\(name) = value` expects constant value of type `\(Type.stringify(type.fieldsTypeSimple))`', b)
												}
												case String(_): if (type.fieldsTypeSimple != typeString) {
													fail('`\(name) = value` expects constant value of type `\(Type.stringify(type.fieldsTypeSimple))`', b)
												}
												// TODO non-constant values
												// TODO other types
											}
											fillExpression(b)
											type.fieldType[type.fieldNames.length - 1] = Type.EnumInstance(type, type.fieldNames.length - 1)
									}
								}

							// `enum E { a }`
							case Ident(name):
								fail('Cannot use lowercase `\(name)` format for enum values', node)

							// `enum E { static ... }`
							case Static(f): switch f {
								case Function(name, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', node)
									}
									type.fieldNames.push(name)
									type.fieldStatic[type.fieldNames.length - 1] = true
									addScope(name, field)
								case Var(name, _):
									if (type.fieldNames.includes(name)) {
										fail('Field `\(name)` already exists', node)
									}
									type.fieldNames.push(name)
									type.fieldStatic[type.fieldNames.length - 1] = true
									addScope(name, field)
							}

							case _:
								fail('Wrong enum field format', field)
						}

						parents.set(field, node)
					}

					// Fill expressions
					for field in f { switch field {
						case Function(name, expr, vars, rettype):
							fillFunction(field, expr, vars, rettype)
						case Var(name, _):
						case Static(f): switch f {
							case Function(name, expr, vars, rettype):
								let _insideClassMethod = insideClassMethod
								insideClassMethod = false

								// This weird hack, because of race condition
								// if function called within self
								if (rettype != null) {
									types.set(f, Type.Function([], toType(rettype, f)))
								} else {
									types.set(f, Type.Function([], typeVoid))
								}
								types.set(field, types.get(f))

								fillFunction(f, expr, vars, rettype)
								insideClassMethod = _insideClassMethod
								if (types.get(f) == null) {
									fail('Function get no type: enum ' + DataHelper.nameOf(node) + ' static ' + name, f)
								}
								types.set(field, types.get(f))
							case Var(name, t, e, const):
								if (e != null) {
									fillExpression(e)
								}
								mixVarTypes(t, e, f)
								types.set(field, types.get(f))
						}
						case NodeTypeValue(_): // Ok
						case Call(_): // Ok
						case Binop(_): // TODO validate them
						case _:
							fail('Unknown enum field format', field)
					}}
					popScope()
					case _:
						fail('EnumType expects (declare) enum node, but got ' + node, node)
				}

				return type
			}
		}

		static let never = '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.'
		static var failures: [{msg: String, node: Node?}] = []

		// TODO node: Node = null error
		fun fail(msg: String, node: Node = null): Void {
			failNonFatal(msg, node)
			let errors = failures.slice()
			failures = []
			// TODO failures is `let` not `var`!
			throw new CompilerErrors(errors)
		}

		fun failNonFatal(msg: String, node: Node = null): Void {
			let data = project.data.get(node)
			if let data = data {
				failures.push(new CompilerError(Fail.TyperError, msg, data.line, data.column, data.fileName))
			} else {
				failures.push(new CompilerError(Fail.TyperError, msg, 0, 0, ""))
			}
		}

		fun positionOf(node: Node) {
			let data = project.data.get(node)
			if (data == null) {
				return "[Unknown]: "
			}
			return "[" + data.fileName + ":" + data.line + ":" + data.column + "]: "
		}

		static fun nodeToNodeType(node: Node): NodeType { switch node {
			case Array(el):
				if (el.length > 1) {
					fail('Array type `[T]` cannot have more than 1 parameter `T`', el[1])
				}
				return NodeType.ParametricType("Array", [nodeToNodeType(el[0])], null)
			case NodeTypeValue(t):
				return t
			case Object(names, el):
				let types = [for e in el nodeToNodeType(e)]
				return NodeType.Object(names, types)
			case _:
				fail('Cannot nodeToNodeType of ' + Node.stringify(node), node)
		}}

		// Takes only nodes valid for `module { node }`
		fun nameOfModuleItem(node: Node): String {
			switch node {
				case Var(name, _): return name
				case Function(name, _):
					if let named = name {
						return named
					} else {
						throw 'Module function should have a name'
					}
				case Private(node): switch node {
					case Class(t, _): switch t {
						case Type(name): return name
						case ParametricType(name): return name
					}
				}
				case Class(t, _): switch t {
					case Type(name): return name
					case ParametricType(name): return name
				}
				case Enum(t, _): switch t {
					case Type(name): return name
					case ParametricType(name): return name
				}
				case TypeAlias(t, _): switch t {
					case Type(name): return name
					case ParametricType(name): return name
				}
				case _: fail('Improper module item format, wrap expressions as `{ expressions }`', node)
			}
		}

		var currentModule: Module = new Module()
		fun findInNamespaceRoots(name: String): Node? {
			if let node = currentModule.imported.get(name) {
				return node
			}

			if let node = currentModule.exported.get(name) {
				return node
			}

			if let node = project.globals.get(name) {
				return node
			}

			return null

			if (namespaces.get(name) != null) {
				return namespaces.get(name)
			}
			var m = namespaces.get('')
			var el: [Node] = null as! [Node]
			switch m as! Node {
				case Module(_, els): el = els
				case _: return null // No root
			}
			for e in el {
				if (name == nameOfModuleItem(e)) {
					return e
				}
			}
			return null
		}

		// Scopes
		private let scopes: [[String : Node]] = [[:]]
		private let scopeTypes: [[String : Type]] = [[:]]
		let parents: [Node : Node] = [:]

		private fun pushScope(): Void {
			scopes.push([:])
			scopeTypes.push([:])
		}

		private fun popScope(): Void {
			scopes.pop()
			scopeTypes.pop()
		}

		private fun addScope(name: String, node: Node): Void {
			scopes[scopes.length - 1].set(name, node)
		}

		private fun addScopeType(name: String, type: Type): Void {
			scopeTypes[scopeTypes.length - 1].set(name, type)
		}

		// Types
		private let types: [String : Type] = [:]
		private var typeString: Type? = null
		private var typeIntClass: ClassType = new ClassType()
		private var typeInt: Type = typeIntClass.instantiate()
		private var typeFloat: Type? = null
		private var typeBool: Type? = null
		private var typeArray: ClassType = new ClassType() // Type instantiators
		private var typeMap: ClassType = null as! ClassType // Type instantiators
		private var typeAnyClass: ClassType = new ClassType()
		private var typeAny: Type = typeAnyClass.instantiate()
		private var nodeAny: Node? = null
		private var typeVoid: Type? = null
		private var namespaces: [String : Node] = [:]

		// Meta
		private var typeBigInt: Type? = null
		private var typeInt32: Type? = null
		private var typeInt64: Type? = null
		private var typeInt16: Type? = null
		private var typeInt8: Type? = null
		private var typeUInt32: Type? = null
		private var typeUInt64: Type? = null
		private var typeUInt16: Type? = null
		private var typeUInt8: Type? = null
		private var typeFloat32: Type? = null

		// Stack
		var functionAllowedToThrow = false // `true` if `@noThrow` is *not* set
		var functionThrows = false // `throw` is happened
		var insideTry = false // `try { insideTry } catch ... { ... }`
		var insideFunction = false // `function () { insideFunction }`
		var allowBreakAndContinue = false // Used in loops
		var functionReturnsAType: Type? = null // `: T` is happened, or infer if `null`
		var functionActuallyReturns: Bool = false // `return something` is actually happened
		var insideClassMethod = false // `class T { function () { insideClassMethod } }` non-static!
		var allowSuper = false // `class T extends C { function () { super() } }` non-static!
		var thisType: Type = null as! Type // Current class
		var thisNode: Node = null as! Node // Current class node

		// `var to = from`
		fun unify(to: Type, fromValue: Type, node: Node): Type {
			// Short path
			if to == fromValue {
				return to
			}

			if to == typeAny {
				return to
			}

			if fromValue == typeVoid {
				fail('Incompatible types `\(Type.stringify(to))` and non-value type `Void`', node)
			}

			// `Int` is assignable to `Float`
			if to == typeFloat, fromValue == typeInt {
				return typeFloat
			}

			// Nullability
			fun isNullable(t: Type): Bool {
				switch t {
					case UnknownNullable(_): return true
					case Nullable(_): return true
				}
				return false
			}

			fun instanceOfClass(t: Type): ClassType? {
				switch Type.unwrapNullable(t) {
					case ClassInstance(t): return t
					case Class(t):
						fail('Cannot take classes `class \(t.name)` as values', node)
					// TODO case Enum(t):
					//	fail('Cannot take enums `enum \(t.name)` as values', node)
				}
				return null
			}

			fun instanceOfEnum(t: Type): EnumType? {
				switch Type.unwrapNullable(t) {
					case EnumInstance(t, _): return t
					case Enum(t): return t
				}
				return null
			}

			// Fill unknown nullable
			switch to {
				case UnknownNullable(handle):
					if (handle.value == null) {
						handle.value = switch fromValue {
							case UnknownNullable(handle): handle.value
							case Nullable(t): t
							case _: fromValue
						}
					}
			}

			var toNullable = isNullable(to)
			var fromNullable = isNullable(fromValue)

			//if (fromNullable, !toNullable, Type.stringify)
			//	fail('Cannot assign nullable type `\(Type.stringify(fromValue))` to non-nullable `\(Type.stringify(to))`', node)

			var toInstance = instanceOfClass(to)
			var fromInstance = instanceOfClass(fromValue)

			var toEnumInstance = instanceOfEnum(to)
			var fromEnumInstance = instanceOfEnum(fromValue)

			if
				(toInstance == null and toEnumInstance == null)
				||
				(fromInstance == null and fromEnumInstance == null)
			{
				return to ?? fromValue
			}

			if toInstance != fromInstance, Type.unwrapNullable(to) != typeAny, Type.unwrapNullable(fromValue) != typeAny {
				// TODO OK by known positive values and zero `: UInt64 = 123`
				// TODO same for comparisons `if UInt64 == 0 {}`
				fail('Incompatible types `\(Type.stringify(to))` and value of `\(Type.stringify(fromValue))`', node)
			}

			if toEnumInstance != fromEnumInstance, Type.unwrapNullable(to) != typeAny, Type.unwrapNullable(fromValue) != typeAny {
				// TODO
				//fail('Incompatible types `\(Type.stringify(to))` and value of `\(Type.stringify(fromValue))`', node)
			}

			return to ?? fromValue
		}

		fun findType(name: String): Node? {
			for i in scopes.length {
				if let subj = scopes[scopes.length - i - 1].get(name) {
					return subj
				}
			}
			return findInNamespaceRoots(name)
		}

		fun findActualType(name: String): Type? {
			for i in scopeTypes.length {
				if let subj = scopeTypes[scopeTypes.length - i - 1].get(name) {
					return subj
				}
			}

			// TODO global
			return null
		}

		fun toType(t: NodeType, node: Node): Type {
			switch t {
				case Type(name, path):
					var nodeType: Node? = null

					if let path = path {
						switch currentModule.imported.get(path) as! Node {
							case ModuleExports(handle):
								nodeType = handle.exported.get(name)
								if nodeType == null {
									let file = handle.file
									fail('Namespace `\(path)` does not export type `\(name)` (aliased module is `\(file)`)', node)
								}
							case _:
								fail('Cannot find supposedly imported namespace `\(path)` of type `\(name)`', node)
						}
					} else {
						nodeType = findType(name) ?? currentModule.exported.get(name) ?? currentModule.imported.get(name)
					}

					if (types.get(nodeType) == null) {
						switch nodeType {
						case Class(_):
							let mod = currentModule
							registerClassType(nodeType)
							currentModule = mod

						case Enum(_):
							registerEnumType(nodeType)
						case null:
						case _:
					}}
					// TODO ^ fix indentation
					let type: Type? = findActualType(name) ?? types.get(nodeType)
					switch type {
						case Class(type):
							if (type.genericParams.length > 0) {
								fail('The type `\(type.name)` requires `<\(type.genericParams)>` generic parameters', node)
							}
							return type.instantiate()
						case Enum(type):
							return types.get(nodeType)
						case null:
							let available = []

							for name in currentModule.imported.keys() {
								available.push(name)
							}

							for name in currentModule.exported.keys() {
								available.push(name)
							}

							fail(
								'Cannot find type `\(name)`\n'
								+ proposeSimilar(available.filter((named) => DataHelper.isTitleCase(named)), name, 'types'),
							 node)
						case _:
							if type == typeAny {
								return typeAny
							}
							fail('Unsupported type `\(name)`', node)
					}
				case ParametricType(name, params, path):
					let nodeType: Node = findType(name) ?? currentModule.exported.get(name) ?? currentModule.imported.get(name)
					if (types.get(nodeType) == null) { switch nodeType {
						case Class(_):
							let mod = currentModule
							registerClassType(nodeType)
							currentModule = mod
						case Enum(_):
							registerEnumType(nodeType)
					}}
					let type: Type? = findActualType(name) ?? types.get(nodeType)
					switch type {
						case Class(type):
							if (type.genericParams.length == 0) {
								fail('The type `\(type.name)` requires zero generic parameters', node)
							}
							if (type.genericParams.length != params.length) {
								fail('The type `\(type.name)` requires `<\(type.genericParams)>` generic parameters', node)
							}
							return type.instantiateGeneric([for p in params toType(p, node)])
						case null:
							fail('Cannot find type `\(name)`', node)
						case _:
							if (type == typeAny) {
								// Ignore all parameters here
								return typeAny
							}
							fail('Unsupported type `\(name)`', node)
					}
				case Optional(t):
					return Type.Nullable(toType(t, node))
				case Function(args, ret):
					return Type.Function([for arg in args toType(arg, node)], toType(ret, node))
				case Object(names, el):
					let els = [for e in el toType(e, node)]
					return Type.Struct(names, els)
				case Int(value):
					return Type.Constant('' + value)
					return Type.Constant // TODO must error: not enough args
				case Ident(value):
					return Type.Constant('' + value)
				case _:
					fail('Unsupported node type ' + t + never, node)
			}
		}

		// `var node: NodeType = e`
		fun mixVarTypes(t: NodeType?, e: Node?, node: Node) {
			if t != null, e != null {
				types.set(node, unify(toType(t, node), types.get(e), e))
			}
			if t == null, e != null {
				types.set(node, types.get(e))
			}
			if t == null, e == null {
				types.set(node, Type.UnknownNullable({value: null}))
			}
			if t != null, e == null {
				types.set(node, toType(t, node))
			}
		}

		fun varTypes(vars: [Node]): [Type] {
			let varTypes: [Type] = []

			for v in vars {
				switch v {
					case Var(_, t):
						if let t = t {
							varTypes.push(toType(t, v))
						} else {
							varTypes.push(Type.Unknown({ value: null }))
						}
				}
			}

			return varTypes
		}

		/// `Bool` or convertible to `Bool`
		fun booleanable(type: Type?): Bool {
			return (type == typeBool) or (type == typeAny)
		}

		// Uses idea of stacks to track nested function behavior
		private fun fillFunction(node, expr, vars: [Node], rettype, arrow: Bool = false): Void {
			// TODO move duplicate argument names check to parser (so it can be cached)
			pushScope()
			// Save stack
			let _insideFunction = insideFunction
			let _functionAllowedToThrow = functionAllowedToThrow
			let _functionThrows = functionThrows
			let _functionReturnsAType = functionReturnsAType
			let _functionActuallyReturns = functionActuallyReturns
			let _insideTry = insideTry

			for i in vars.length {
				let v = vars[i]
				switch v {
					case Var(vname, t, e, const):
						if t != null, toType(t, v) == typeVoid {
							fail('Argument cannot be of type `Void`', v)
						}

						if t != null {
							types.set(v, toType(t, v))
						}

						if e != null {
							// TODO fillExpression should return type of `e` to not do `types.get(e)`
							fillExpression(e)

							if let t = types.get(v) {
								unify(types.get(e), t, e)
							}
						}

						addScope(vname, v)
				}
			}

			// Reset stack
			var ret: Type? = null // TODO = if (let)
			if let rt = rettype {
				ret = toType(rt, node)
			}
			functionReturnsAType = ret
			functionActuallyReturns = false

			let atts = project.mapDecorators.get(node)

			if let noThrow = DataHelper.getDecorator(atts, 'noThrow') {
				if (noThrow.values.length > 0) {
					fail('Decorator `@noThrow` should have no parameters', node)
				}
				functionAllowedToThrow = false
			} else {
				functionAllowedToThrow = true
			}

			if let throws = DataHelper.getDecorator(atts, 'throws') {
				if (functionAllowedToThrow == false) {
					fail('Decorator `@noThrow` cannot be used with `@throws`', node)
				}
				functionThrows = true
			} else {
				functionThrows = false
			}

			insideFunction = true
			insideTry = false

			if arrow, expr != null {
				fillExpression(expr)
			}
			if !arrow, expr != null {
				fill(expr)
			}
			popScope()

			ret = functionReturnsAType // Inferred
			if arrow {
				if arrow, ret == null, expr != null {
					ret = types.get(expr)
				} else {
					unify(types.get(expr), ret, expr)
				}
			} else {
			if (ret == null) {
				ret = typeVoid
			}
			if ret != typeVoid, expr != null, functionActuallyReturns == false {
				// To handle arrow
				fail('Function expects result of `\(Type.stringify(ret))` but never does `return value`', node)
			}
			}

			// Restore stack
			insideFunction = _insideFunction
			functionReturnsAType = _functionReturnsAType
			functionActuallyReturns = _functionActuallyReturns

			// Set function type
			types.set(node, Type.Function(args: [for v in vars types.get(v)], returns: ret))
		}

		private fun fillModuleTypes(node: Node): Void {
			switch node {
				// `class T {}`
				case Class(t, extend, implement, f, external):
					addScope(DataHelper.extractTypeName(t), node)
					let mod = currentModule
					registerClassType(node)
					currentModule = mod

				// `enum T {}`
				case Enum(t, f, valuesType):
					addScope(DataHelper.extractTypeName(t), node)
					let mod = currentModule
					registerEnumType(node)
					currentModule = mod

				// `declare A = T`
				case TypeAlias(alias, value):
					let type = new AliasType()

					// TODO pre-check somehow that aliased type exists (and takes generic parameters)
					types.set(node, Type.Alias(type))
					addScope(nameOfModuleItem(node), node)
			}
		}

		// Syntax tree traverse
		private fun fill(node: Node): Void {
			switch node {

				// Types

				case Class(_):
					fail('Defining classes within blocks not allowed', node)

				case Enum(_):
					fail('Defining enums within blocks not allowed', node)

				case TypeAlias(_, t):
					fail('Defining alias within blocks not allowed', node)
					addScope(nameOfModuleItem(node), node)
					// TODO
					// fail('Defining types within blocks not allowed', node)

				// Statements do not return value

				// `var a = e, b: T, c`

				// `{...}`
				case Block(el):
					pushScope()
					for e in el {
						fill(e)
					}
					popScope()

				// `var name: t = e`
				case Var(name, t, e, const, external):
					if e == null, const, !external {
						fail('Constant should have a value `let \(name) = value`', node)
					}
					if e != null, external {
						fail('External variable should not have a value `declare let \(name)`', node)
					}
					if t == null, external {
						fail('External variable should have a type `declare let \(name): T`', node)
					}
					if e != null {
						pushScope()
						fillExpression(e)
						popScope()
					}

					mixVarTypes(t, e, node)

					addScope(name, node)

				// `a op b` like `a + b`
				case Binop(a, op, b):
					fillExpression(node)

					var parent: Node = parents.get(a)
					// `a = b`
					// TODO separate assign node? or just nested pattern...
					if (op == Token.OpAssign) { switch parent {
						case null:
							// TODO typings for `[]` etc
						case Var(name, _, _, const):
							if const {
								fail(
									'Cannot reassign a constant `let \(name)`, redefine it as `var \(name)` to allow reassignment\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							}
							types.set(node, unify(types.get(a), types.get(b), b))
						case Ident(name):
							fail('Cannot reassign case parameter `\(name)`', node)
						case Function(name, _):
							fail('Cannot reassign a function `\(name)`', node)
						case Class(_):
							fail('Cannot reassign class', node)
						case Enum(_):
							fail('Cannot reassign enum', node)
						case For(name, _):
							fail(
								'Cannot reassign iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for \(name) in ...` is defined here',
							node)
						case Static(_):
						case Super:
							fail('Cannot reassign `super`', node)
						case _:
							fail('`=` not implemented for: ' + parent, node)
					}}

				// `break`
				case Break:
					if not allowBreakAndContinue {
						fail('Cannot use `break` outside of loop', node)
					}

				// `for name in over ... range { by }`
				case For(name, over, by, range):
					pushScope()
					fillExpression(over)
					let overType: Type = types.get(over)
					switch overType {
						case ClassInstance(type, generic):
							// Extract Array<T>
							if generic != null, generic.length == 1 {
								types.set(node, generic[0])
							} else if overType == typeInt {
								types.set(node, typeInt)
							} else if ((overType == typeUInt32) || (overType == typeUInt64)) {
								types.set(node, overType)
							} else {
								fail('Type of iterable is neither Int nor Array, but ' + Type.stringify(overType), over)
							}

						case Nullable(_):
							fail('Type of iterable should not be nullable', over)

						case UnknownNullable(_):
							fail('Type of iterable should not be nullable', over)

						case null:
						case _:
							fail('Type of iterable is neiter Int nor Array', over)
					}
					if let range = range {
						fillExpression(range)
						// TODO `fillExpression(X)` to return `types.get(X)` and fix other places
						// Ranges always integer/Int for now
						if (types.get(range) != typeInt) {
							fail('Range end must be of Int type', range)
						}
						if (overType != typeInt) {
							fail('Range start must be of Int type', over)
						}
						types.set(node, typeInt)
					}
					addScope(name, node)
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					switch by {
						case Block(_):
						case _:
							fail('Loop body must be a `{` block `}`', by)
					}
					fill(by)
					allowBreakAndContinue = _allowBreakAndContinue
					popScope()

				// `function name(vars): rettype {expr}`
				// `vars` are `Var(name, t, ...)` where `function(name: t)`
				case Function(name, expr, vars, rettype, external):
					if !external, expr == null {
						fail('Non-external function `\(name)` should have a body', node)
					}
					if external, rettype == null {
						fail('External function `\(name)` should have a returning type', node)
					}
					addScope(name, node)
					fillFunction(node, expr, vars, rettype)
					if false {

					// Save stack
					let _insideFunction = insideFunction
					// Reset stack
					insideFunction = true
					pushScope()
					if (expr != null) {
						fill(expr)
					}
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				} // if false

				// `if econd { eif } else { eelse }`
				// `if econd { eif }`
				// Also `if let bind = value, econd..., econd...`
				case If(econd, eif, eelse):
					var depth = 0
					for e in econd {
						switch e {
							case Var(name, t, expr, const):
								if not const {
									fail('Only `if let` bindings supported, not `if var`', node)
								}
								if t != null {
									fail('Do not specify a type `: T` in `if let` bindings', node)
								}
								if expr == null {
									fail('`if let` binding should have a value `\(name) = value', node)
								}
								depth++
								pushScope()
								pushScope()
								fillExpression(expr)
								popScope()
								switch types.get(expr) as! Type {
									case Nullable(t): types.set(e, t)
									case UnknownNullable(handle):
										if let t = handle.value {
											types.set(e, t)
										} else {
											fail('`if let` cannot bind not fully known nullable type', node)
										}
									case _: types.set(e, types.get(expr))
								}
								addScope(name, e)
							case _:
								fillExpression(e)
								// Only Bool allowed
								let type = types.get(e)
								if type != typeBool, type != typeAny, type != null {
									fail('`if (value)` expects `value` only of type `Bool`, but got `' + Type.stringify(types.get(e)) + '`', e)
								}
						}
					}
					fill(eif)
					while depth > 0 {
						depth--
						popScope()
					}

					// TODO Hint Consider changing this code to `if let eelse = eelse`
					if eelse != null {
						fill(eelse)
					}

				// `switch exprs { case conds if (guards): { cases } }`
				case Switch(exprs, conds, guards, cases):
					fillSwitch(node, false)

				// `try { } catch e: T { }`
				case Try(e, t, v, ca):
					// Save stack
					let _insideTry = insideTry
					// Reset stack
					insideTry = true
					switch e {
						case Block(_):
						case _:
							fail('Try body must be a `{ block }`', e)
					}
					fill(e)
					// Restore stack
					insideTry = _insideTry

					for i in ca.length {
						let type = toType(t[i], ca[i])
						switch type {
							case Struct(_):
								fail('Catch type must be a specific class, not `{}`', ca[i])
							case Function(_):
								fail('Catch type must be a specific class, not function', ca[i])
						}
						types.set(t[i], type)
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						switch ca[i] {
							case Block(_):
							case _:
								fail('Catch body must be a `{ block }`', ca[i])
						}
						fill(ca[i])
						popScope()
					}

				// `while (econd) e` if pre == true
				// `do e while (econd)` if pre == false
				case While(econd, e, pre):
					if (pre == true) {
						fillExpression(econd)
					}
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					switch e {
						case Block(_):
						case _:
							fail('`while` statements must be wrapped with a `{` block `}`', e)
					}
					fill(e)
					allowBreakAndContinue = _allowBreakAndContinue
					if (pre == false) {
						fillExpression(econd)
					}
					types.set(node, typeVoid)

				// `continue`
				case Continue:
					types.set(node, typeVoid)
					if not allowBreakAndContinue {
						fail('Cannot use `continue` outside of loop', node)
					}

				// Expressions and errors
				case _:
					fillExpression(node)
			}
		}

		// Expressions return values
		fun fillExpression(node: Node) {
			switch node {
				// Just `name`
				case Ident(name):
					var subj = null
					for i in scopes.length {
						subj = scopes[scopes.length - i - 1].get(name)
						if (subj != null) {
							break
						}
					}

					if subj == null {
						subj = findInNamespaceRoots(name)
					}
					if subj == null, name == 'const' {
						fail('No variable named `const` found. Are you trying to use `const` as a keyword? Use `let varname` syntax instead.', node)
					}
					if subj == null {
						fail('Cannot find variable with name `\(name)`', node)
					}
					if parents.get(node) != null, parents.get(node) != subj {
						fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
					}
					parents.set(node, subj)
					if let type = types.get(subj) {
						types.set(node, type)
					}

				// `(args)=>{expr}`
				case Arrow(expr, vars, rettype):
					fillFunction(node, expr, vars, rettype, arrow: true)
					if false {
					pushScope()
					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true
					fillExpression(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				}

				// `function name(vars): rettype {expr}`
				case Function(name, expr, vars, rettype, external):
					if external {
						fail('External function `declare fun \(name)` cannot be taken as a value', node)
					}

					fillFunction(node, expr, vars, rettype)

					if false {
					pushScope()
					addScope(name, node)

					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true

					if (expr != null) {
						fill(expr)
					}
					popScope()

					// Restore stack
					insideFunction = _insideFunction
				}

				// `[a,b,c]`
				case Array(el):
					// `[for name in over ... range by]`
					switch el[0] {
						case For(name, over, by, range):
							if (el.length > 1) {
								fail('Cannot use loop `for` within array of more than one element `[for, ...]`', el[1])
							}
							if (range != null) {
								fail('Ranges `...range` are not supported here yet', range)
							}

							pushScope()
							fillExpression(over)
							// TODO reuse code from for-as-statement
							let overType: Type = types.get(over)
							switch overType {
								case ClassInstance(type, generic):
									// Extract Array<T>
									// TODO check type == typeArray
									if generic != null, generic.length == 1 {
										types.set(el[0], generic[0])
									} else if overType == typeInt {
										types.set(el[0], typeInt)
									} else if ((overType == typeUInt32) || (overType == typeUInt64)) {
										types.set(el[0], overType)
									} else {
										fail('Type of iterable is neither Int nor Array, but ' + Type.stringify(overType), over)
									}

								case Nullable(_):
									fail('Type of iterable should not be nullable', over)

								case UnknownNullable(_):
									fail('Type of iterable should not be nullable', over)

								case null:
								case _:
									fail('Type of iterable is neiter Int nor Array', over)
							}

							addScope(name, el[0])
							let _allowBreakAndContinue = allowBreakAndContinue
							allowBreakAndContinue = false
							fillExpression(by)
							allowBreakAndContinue = _allowBreakAndContinue
							popScope()

							types.set(node, typeArray.instantiateGeneric([types.get(by)]))
						case _:
							for e in el {
								fillExpression(e)
							}
							types.set(node, typeArray.instantiateGeneric([
								if (el.length > 0) {
									types.get(el[0])
								} else {
									Type.Unknown({ value: null })
								}
							]))
					}

				// `[k:v, k:v]`
				case Map(keys, values):
					if (keys.length == 0) {
						types.set(node, typeMap.instantiateGeneric([
							Type.Unknown({value: null}),
							Type.Unknown({value: null})
						]))
						return
					}
					for i in keys.length {
						fillExpression(keys[i])
						fillExpression(values[i])
					}
					types.set(node,
						typeMap.instantiateGeneric([types.get(keys[0]), types.get(values[0])])
					)

				// `e as  t`
				// `e as! t`
				// `e as? t`
				case As(e, kind, t):
					// TODO error position must not a node, but at node type (`x as __here__` not `__here__ as tt`)
					let type = toType(t, node)
					if (type == typeVoid) {
						fail('Conversion `as Void` makes no sense', e)
					}
					fillExpression(e)
					if (types.get(e) == typeVoid) {
						fail('Conversion of `value as \(Type.stringify(t))` where `value` is of type `Void` makes no sense', e)
					}
					types.set(t, type)
					types.set(node, type)

				// `e is t`
				case Is(e, t):
					let type = toType(t, node)
					if (type == typeAny) {
						fail('Comparing `is Any` makes no sense, always true', e)
					}
					if (type == typeVoid) {
						fail('Comparing `is Void` makes no sense', e)
					}
					fillExpression(e)
					types.set(t, type)
					types.set(node, typeBool)

				// `{...}`
				case Block(el):
					if (el.length == 0) {
						types.set(node, Type.Struct([], []))
					} else {
						pushScope()
						for i in el.length { if (i < el.length - 1) {
							fill(el[i])
						}}
						let latest = el[el.length - 1]
						fillExpression(latest)
						types.set(node, types.get(latest))
						popScope()
					}

				// `e.n`
				case Dot(e, n):
					switch e {
						case Super:
							if not allowSuper {
								fail('Cannot access `super` here', node)
							}
						case _:
							fillExpression(e)
					}
					if let etype = types.get(e) as! Type? { switch etype {
						case ClassInstance(type): // Non-static fields
							type.useless = false
							if etype == typeAny {
								types.set(node, typeAny)
								return
							}
							let index = type.fieldNames.indexOf(n)
							let named = nameOfModuleItem(type.parent)
							if index < 0 {
								fail(
									'Class `\(named)` has no field `.\(n)`\n'
									+ positionOf(type.parent) + '`\(named)` is defined here\n'
									+ proposeSimilar(type.fieldNames, n, 'fields'), e ?? node)
							}
							if type.fieldStatic[index] == true {
								fail('Class `\(named)` field `.\(n)` is static', node)
							}
							switch type.parent {
								case Class(t, extend, implement, fields, external):
									let mod = currentModule
									registerClassType(type.parent)
									currentModule = mod

									for field in fields {
											types.set(node, types.get(field))
										if DataHelper.nameOf(field) == n {
											parents.set(node, field)

											if types.get(field) == null {
												console.log(positionOf(node) + 'Note: field fieldInitialized[\(n)] =', type.fieldInitialized[type.fieldNames.indexOf(n)])
												fail('Type for this field is null: ' + n, field)
											}
										}
									}
								case _:
									fail('type.parent not a class, internal error', type.parent)
							}
						case Class(type): // Static fields
							type.useless = false
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Class `\(nameOfModuleItem(type.parent))` has no static field `.\(n)`\nAvailable fields are: ' + type.fieldNames.join(', '), node)
							}
							if (type.fieldStatic[index] != true) {
								fail('Class `\(nameOfModuleItem(type.parent))` field `.\(n)` is not static', node)
							}
							switch type.parent {
								case Class(t, extend, implement, fields, external):
									for field in fields {
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
										}
									}
								case _:
									fail('type.parent not a class, internal error', type.parent)
							}
						case Enum(type):
							let index = type.fieldNames.indexOf(n)
							if (index < 0) {
								fail('Enum `\(type.name)` has no field `.\(n)`', node)
							}
							if (type.fieldStatic[index] != true) {
								fail('Enum field `.\(n)` is not static', node)
							}
							switch type.parent {
								case Enum(t, fields, valuesType):
									for field in fields { switch field {
										case Call(_):
										case NodeTypeValue(_):
										case Binop(_):
										case _:
										if (DataHelper.nameOf(field) == n) {
											types.set(node, types.get(field))
											parents.set(node, field)
										}
									}}
								case _:
									fail('type.parent not an enum, internal error', type.parent)
							}
						case Struct(names, els):
							let index = names.indexOf(n)
							if (index < 0) {
								var object = ''
								switch e {
									case Ident(name): object = ' `\(name)`' // Note a space after '
									case _: {}
								}

								if (names.length == 0) {
									fail('Object\(object) is empty `{}` and has no fields. Create object with all fields defined upfront, like this: `obj = { \(n): value }`', node)
								}
								if (names.length != 0) {
									fail('Object\(object) has no field `.\(n)`\nAvailable fields are: ' + names.join(', '), node)
								}
							}
							types.set(node, els[index])
						case UnknownNullable(handle):
							failNonFatal('Cannot access `.\(n)` of nullable type `\(Type.stringify(etype))`, try to unwrap it with `if let`', node)
							types.set(node, typeAny) // TODO unwrap proper type
						case Nullable(type):
							failNonFatal('Cannot access `.\(n)` of nullable type `\(Type.stringify(etype))`, try to unwrap it with `if let`', node)
							types.set(node, typeAny) // TODO unwrap proper type
						case Unknown(handle):
							if let type = handle.value {
								// TODO
							} else {
								failNonFatal('Cannot access `.\(n)` due to type of value being unknown, try to specify a proper type (set full type `[T]` if this value coming from array)', node)
								types.set(node, typeAny) // TODO unwrap proper type
							}
						case null:
							fail('Cannot access `.\(n)` due to type being `null`, seems to be internal compiler error', node)
						case _:
							fail('Cannot access `.\(n)` due to type being unhandled `\(Type.stringify(etype))`, seems to be internal compiler error', node)
					}} else {
						types.set(node, typeAny)
					}

				// `e.N`
				case DotUpper(e, n):
					switch e {
						case Super:
							fail('Cannot access `super` here', node)
					}
					fillExpression(e)
					switch types.get(e) as! Type {
						case EnumInstance(type):
							fail('Enum instance has no field `.\(n)`', node)
						case ClassInstance(type):
							fail('Class has no field `.\(n)`', node)
						case Class(type):
							fail('Class has no field `.\(n)`', node)
						case Enum(type):
							let index = type.fieldNames.indexOf(n)
							if index < 0 {
								fail('Enum has no value constructor `.\(n)`\n' + proposeSimilar(type.fieldNames.filter((element, index) => type.fieldEnumConstructor[index]), n, 'constructors'), node)
							}
							if type.fieldEnumConstructor[index] != true {
								fail('Enum field `.\(n)` is not a value constructor', node)
							}
							if let fieldType = type.fieldType[index] {
								types.set(node, fieldType)
							} else {
								fail('Enum field type is null for `\(Node.stringify(node))`', node)
							}
						case null:
							fail('Accessing non-existing field `.\(n)` of `\(Node.stringify(e))`', node)
						case _:
					}// else TODO fail('Got node without type `\(e)`' + never, node)

				// `T` or `T<G>`
				case NodeTypeValue(t): switch t {
					case Type(name):
						let subj = find(name)
						if subj == null {
							fail('Cannot find type with name `\(name)`', node)
						}
						if parents.get(node) != null, parents.get(node) != subj {
							fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
						}
						parents.set(node, subj)
						if let type = types.get(subj) {
							types.set(node, type)
						} else {
							// Try eager on-demand type build
							switch subj {
								case Class(_):
									let mod = currentModule
									registerClassType(subj)
									currentModule = mod
								case Enum(_): registerEnumType(subj)
							}

							if let type = types.get(subj) {
								types.set(node, type)
							} else {
								console.log(positionOf(subj) + '\(name) is here')
								fail('Cannot find type for `\(name)` even after late build' + never, node)
							}
						}
					case ParametricType(name, _):
						fail('Cannot use generic type `\(name)` as a value', node)
					case _:
						fail('Cannot use this type as a value', node)
				}

				// `new T {names: values} ()`
				case New(path, t, el, names, values):
					let type = toType(t, node)
					let subj = find(DataHelper.extractTypeName(t))
					parents.set(node, subj)
					for e in el {
						fillExpression(e)
					}
					switch type {
						case ClassInstance(type):
							if (type.constructor == -1) {
								fail('Cannot construct class without `new () {}` constructor', node)
							}
							type.useless = false
						case _:
							fail('Constructor `new` may instantiate only classes', node)
					}

					types.set(node, type)

				// `{names:el, ...}`
				case Object(names, el):
					for name in names.length {
						if names.indexOf(names[name]) != name {
							fail('Field `\(names[name])` already exists', node)
						}
					}

					for e in el {
						fillExpression(e)
					}

					let els = [for e in el types.get(e)]
					types.set(node, Type.Struct(names, els))

				// `try { ... value } catch e: T { ... value }`
				case Try(e, t, v, ca):
					// Save stack
					let _insideTry = insideTry
					// Reset stack
					insideTry = true
					fillExpression(e)
					// Restore stack
					insideTry = _insideTry

					for i in ca.length {
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						fill(ca[i])
						popScope()
					}
					types.set(node, types.get(e))

				// `if (econd) eif else eelse`
				case If(econd, eif, eelse, ternary):
					if econd.length > 1 {
						fail('More than one condition is not yet supported', econd[1])
					}
					switch econd[0] {
						case Var(_):
							fail('Variable bindings in ternary conditions are not yet supported', econd[0])
					}
					if eelse == null {
						fail('Expression `if` should have an `else` clause', eif)
					}
					fillExpression(econd[0])
					if ternary == false {
						switch eif {
							case Block(_):
							case _:
								fail('Ternary `if` should have a `{ block }` as a body', eif)
						}
						switch eelse {
							case Block(_):
							case _:
								fail('Ternary `else` should have a `{ block }` as a body', eelse)
						}
					}
					fillExpression(eif)
					fillExpression(eelse)
					types.set(node, unify(types.get(eif), types.get(eelse), eelse))

				// Simple nodes
				// `null`
				case Null:
					types.set(node, Type.UnknownNullable({value: null}))

				case String(_):
					types.set(node, typeString)

				case Bool(_):
					types.set(node, typeBool)

				case Int(_):
					types.set(node, typeInt)

				case MetaInt(_, meta):
					switch meta {
						case BigInt: types.set(node, typeBigInt)

						case Int32: types.set(node, typeInt32)
						case Int64: types.set(node, typeInt64)
						case Int16: types.set(node, typeInt16)
						case Int8: types.set(node, typeInt8)

						case UInt32: types.set(node, typeUInt32)
						case UInt64: types.set(node, typeUInt64)
						case UInt16: types.set(node, typeUInt16)
						case UInt8: types.set(node, typeUInt8)

						// TODO move to MetaNumber or Float(meta)?
						case Float32: types.set(node, typeFloat32)

						case _: fail('Unhandled meta type of number', node)
					}

				case Float(_):
					types.set(node, typeFloat)

				// `(e)`
				case Parenthesis(e):
					fillExpression(e)
					types.set(node, types.get(e))

				// `a ?? b`
				case Elvis(a, b):
					fillExpression(a)
					fillExpression(b)
					unify(types.get(a), types.get(b), b)
					types.set(node, types.get(b))

				// `e(elNames: el, ...)`
				// TODO show called function/method position
				case Call(e, el, elNames):
					// JavaScript evaluates arguments first
					switch e {
						case Super:
							if not allowSuper {
								fail('Cannot access `super` here', node)
							}
						case _:
				 			fillExpression(e)
				 	}

					for e in el {
						fillExpression(e)
					}

				 	switch types.get(e) as! Type {
				 		case Function(args, returns):
				 			for i in el.length { if let arg = args[i] {
				 				unify(arg, types.get(el[i]), el[i])
				 			}}
				 			types.set(node, returns)
				 			// TODO (name: )
				 			// TODO Not enough
				 			// TODO Too many
				 			// TODO ...rest
				 			// TODO optional args
				 			// TODO default args expressions+typing to use in normalization
				 			// TODO is const exprs >= 3 then require second names
				 			// "This function call is hard to read.\Replace this code: ... with this one: ..."
				 		case EnumConstructor(type, tag):
				 			let name = type.fieldNames[tag]

				 			if el.length < type.tagBindVars[tag].length {
				 				fail('Not enough enum parameters, required `\(name)` parameters are: ' + type.tagBindVarsNames[tag].join(', '), node)
							}

				 			if el.length > type.tagBindVars[tag].length {
				 				fail('Too many enum parameters, required `\(name)` parameters are: ' + type.tagBindVarsNames[tag].join(', '), node)
							}

				 			// Don't allow `A.B()` syntax, require `A.B(a, b, c)` or just `A.B`
				 			if el.length == 0 {
				 				fail('Use syntax without empty `()`', node)
							}

				 			types.set(node, Type.EnumInstance(type, tag))
				 			// TODO check arg types
				 		case null:
				 			// TODO fail('Calling null ' + Node.stringify(e), e)
				 		case _:
				 			if types.get(e) == typeAny {
				 				types.set(node, typeAny)
				 			} else {
				 				fail('Calling *not* a function, type is `' + Type.stringify(types.get(e)) + '`', e)
							}
				 	}

				// `a op b` like `a + b`
				case Binop(a, op, b):
					fillExpression(a)
					fillExpression(b)

					let typeA = types.get(a)
					let typeB = types.get(b)

					// Anything + String = String
					if op == Token.OpAdd, typeA == typeString {
						types.set(node, typeString)
					} else
					if (
						op == Token.OpBoolAnd or op == Token.OpBoolOr
					) {
						let token = op == Token.OpBoolAnd? 'and' : 'or'
						if not booleanable(typeA) {
							fail('Operator `a \(token) b` takes `a` of type `Bool` only, but got `\(Type.stringify(typeA))`', a)
						}
						if not booleanable(typeB) {
							// TODO textual static analysis: typeB-a should be typeB-b
							fail('Operator `a \(token) b` takes `b` of type `Bool` only, but got `\(Type.stringify(typeB))`', b)
						}
						types.set(node, typeBool)
					} else
					// Always provides boolean result
					if (
						(op == Token.OpGte) ||
						(op == Token.OpGt) ||
						(op == Token.OpLte) ||
						(op == Token.OpLt) ||
						(op == Token.OpEq) ||
						(op == Token.OpNotEq)
					) {
						types.set(node, typeBool)
					} else {
						// TODO
						types.set(node, types.get(b) ?? types.get(a))
					}

				// `op e` or `e op`
				case Unop(op, postfix, e):
					fillExpression(e)

					// Always provides boolean result
					if op == Token.OpNot, !postfix {
						let type = types.get(e)
						if not booleanable(type) {
							fail('Operator `!value` takes `value` of type `Bool` only, but got `\(Type.stringify(types.get(e)))`', e)
						}
						types.set(node, typeBool)
						return
					}

					types.set(node, types.get(e))

					let mutates = op == Token.OpIncrement || op == Token.OpDecrement
					if not mutates { return }
					var parent: Node = parents.get(e)
					switch parent {
						case Var(name, _, _, const):
							if const {
								fail(
									'Cannot change a constant `let \(name)`, redefine it as `var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							}
						case Function(name, _):
							fail('Cannot `\(Token.stringify(op))` a function `\(name)`', node)
						case For(name, _):
							fail(
								'Cannot change iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for \(name) in ...` is defined here',
							node)
						case Static(f): switch f {
							case Function(name, _):
								fail('Cannot `\(Token.stringify(op))` a `static fun \(name)`', node)
							case Var(name, _, _, const):
								if const {
									fail(
									'Cannot change a constant `static let \(name)`, redefine it as `static var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`static let \(name)` is defined here',
									node)
								}
						}
						case _:
							switch e {
								case Index(_):
									// Ok
									// Sets NaN to `[n]` in JavaScript if `[n] == null` and returns NaN
									// TODO maybe require `a[i] == a[i] ?? n + 1` instead?
									// cause also string/etc arrays...
								case _:
									let ops = Token.OpIncrement? 'increment `++`' : 'decrement `--`'
									fail('You can \(ops) only a variable, .field or array element', node)
									// TODO `x={i:123} x.i++` <- by type and const factor
							}
					}


				// `e[i]`
				case Index(e, i):
					fillExpression(e)
					fillExpression(i)

					let eType = types.get(e) as! Type
					let iType = types.get(i) as! Type

					// For now, only Int & Any index supported
					var indexableIsAny = false
					switch eType {
						case ClassInstance(type, generic):
							if type.name == 'Any' { // TODO
								indexableIsAny = true
							}
					}

					if not indexableIsAny {
					switch iType {
						case ClassInstance(type):
							if type.name != 'Int', type.name != 'Any' {
								fail('`value[i]` expects `i` only of type `Int`, but got `' + Type.stringify(iType) + '`', e)
							}
						case _:
							fail('`value[i]`????? expects `i` only of type `Int`, but got `' + Type.stringify(iType) + '`', e)
							// TODO is this even reachable?
						case null:
					}}

					// For now, only Array[i] supported
					switch eType {
						case ClassInstance(type, generic):
							if generic != null, generic.length == 1 {
								types.set(node, generic[0])
							} else if ['Array','Buffer','Uint8Array','Uint32Array'].includes(type.name) {
								types.set(node, toType(NodeType.Type("Int", null), node))
								// TODO check actual types
							} else if ['Any'].includes(type.name) {
								types.set(node, toType(NodeType.Type("Any", null), node))
							} else {
								fail('Cannot index `\(Node.stringify(e))` because `\(Type.stringify(eType))` is not indexable', e)
							}
						case _:
						case null:
					}

				// `a op= b`
				case AssignOp(a, op, b):
					// `===`
					if (op == Token.OpEq) {
						fail('`===` not supported, use `strictEqual`', node)
					}
					// `!==`
					if (op == Token.OpEq) {
						fail('`!==` not supported, use `strictNotEqual`', node)
					}

					fillExpression(a)
					var parent: Node = parents.get(a)
					switch parent {
						case Var(name, _, _, const):
							if const {
								fail(
									'Cannot change a constant `let \(name)`, redefine it as `var \(name)` to allow value changes\n'
									+ positionOf(parent) + '`let \(name)` is defined here',
								node)
							}
						case Function(name, _):
							fail('Cannot reassign a function `\(name)`', node)
						case For(name, _):
							fail(
								'Cannot change iterator value `\(name)` of for loop\n'
								+ positionOf(parent) + '`for \(name) in ...` is defined here',
							node)
						case _: // Ok
					}
					fillExpression(b)
					types.set(node, unify(types.get(a), types.get(b), b))

				// `throw e`
				case Throw(e):
					if not insideFunction, not insideTry {
						fail('Cannot throw outside of `function` or `try`', node)
					}
					if insideFunction, not functionAllowedToThrow {
						fail('Cannot throw in a @noThrow function', node)
					}
					if insideFunction {
						functionThrows = true // Infer that function throws
					}
					fillExpression(e)

				// `this`
				case This:
					if not insideClassMethod {
						fail('Cannot access `this` outside of class method', node)
					}
					if thisType == null {
						fail('Cannot access `this` in class method', node)
					}
					types.set(node, thisType)
					parents.set(node, thisNode)

				// `super`
				case Super:
					fail('Cannot use `super` as value', node)

				// `return e`
				case Return(e):
					switch e {
						case Var(name, _, _, const):
							let prefix = const? 'let' : 'var'
							fail('This `return` tries to return a variable `\(prefix) \(name)`. Try to wrap it into braces like this `{ return } \(prefix) \(name)`', node)
						case Return(_):
							fail('Cannot return another return. Try to wrap first `{ return } return 2` into braces', node)
					}
					if not insideFunction {
						fail('Cannot use `return` outside of function', node)
					}
					if e != null {
						if functionReturnsAType == typeVoid {
							fail('Function returns `Void`, cannot return a value here', e)
						}
						fillExpression(e)
						let ret = types.get(e)
						if ret == typeVoid {
							fail('Cannot `return` a `Void` non-value', node)
						}
						functionReturnsAType = unify(functionReturnsAType, ret, e)
						functionActuallyReturns = true
					} else {
						if let ret = functionReturnsAType {
							if ret != typeVoid {
								fail('Expected `return value` of type `\(Type.stringify(ret))`', node)
							}
						} else {
							functionReturnsAType = typeVoid
						}
					}

				// Errors
				case Underscore:
					fail('Cannot use underscore `_` outside of case pattern', node)
				case Static(_):
					fail('Cannot use `static` here: only applicable to class fields', node)
				case Private(_):
					fail('Cannot use `private` here: only applicable to class fields and module declarations', node)
				case Module(_):

				// Not expressions
				case Break:
					fail('Cannot use `break` as a value', node)
				case Continue:
					fail('Cannot use `continue` as a value', node)
				case Class(_):
					fail('Cannot use `class` as a value', node)
				case Enum(_):
					fail('Cannot use `enum` as a value', node)
				case TypeAlias(_):
					fail('Cannot use `declare` as a value', node)
				case Import(_):
					fail('Cannot use `import` as a value', node)
				case Var(name, _, _, const):
					let prefix = const? 'let' : 'var'
					fail('Cannot use `\(prefix) \(name)` as a value', node)
				case Switch(_):
					fillSwitch(node, true)
				case While(_):
					fail('Cannot use `while` as a value', node)
				case For(_):
					fail('Cannot use `for` as a value. To build array from loop, surround with `[for]` brackets.', node)

				// Fallback
				case ParametricIdent(name, params):
					// TODO
					let fallback = Node.Ident(name)
					project.data.set(fallback, project.data.get(node))
					fillExpression(fallback)

				// Fails
				case null:
					fail('Got null node' + never, node)
				case _:
					fail('Unknown node expression kind to type ' + node + never, node)
			}
		}

		fun fillSwitch(node: Node, value: Bool) {
			switch node {
				// TODO extracting like this is weird, Just pass arguments to fillSwitch
				case Switch(exprs, conds, guards, cases):
					for e in exprs { pushScope() fillExpression(e) popScope() }
					if let expr = exprs[1] {
						fail('Multiple switch values are not yet supported', expr)
					}

					fun unwrapUnknownAndNullable(type: Type?): Type? {
						switch type {
							case null: return null
							case Nullable(type): return unwrapUnknownAndNullable(type)
							case Unknown(type): return unwrapUnknownAndNullable(type.value)
							case UnknownNullable(type): return unwrapUnknownAndNullable(type.value)
						}

						return type
					}

					let etype = unwrapUnknownAndNullable(types.get(exprs[0]))

					if etype == null {
						fail('Value of switch `\(Node.stringify(exprs[0]))` must have a known type at this postition', exprs[0])
					}

					var enumType: EnumType? = null
					var shortHandSyntax = false

					// TODO typeArray
					// TODO typeMap?
					if etype == typeBool {
						// Okay
					} else if etype == typeInt {
						// Okay
					} else if etype == typeString {
						// Okay
					} else if etype == typeFloat {
						fail('Due to imprecise nature of `Float` type, switching over it is not allowed', exprs[0])
					} else {
						switch etype {
							case Enum(type):
								enumType = type
							case EnumInstance(type, _):
								enumType = type
							case _:
								fail('Cannot switch over `\(Type.stringify(etype))` type', exprs[0])
						}
					}

					// TODO if typeof(expr) == typeInt ... special code path
					// same for simple enums
					// and special for complex enums
					// and error on typeVoid, type unknown (not inferred) and etc
					// same for Normalizer

					// TODO support for simple (exhaustive checked) nested patterns
					// like A(true) A(false) and A(NonComplexEnum)
					// complex enums may break readability... but helpful for
					// shader langs? meh.. they require some computations
					// (like case normalization)
					// between mattern matching anyway

					// TODO guards
					// let expr = if (let expr = exprs[0]) expr else return
					// @guard let expr = exprs[0]
					// Node.TMacroExpansion <- for simple debug and print of
					// result of evaluated syntax @macro

					// TODO exprs is a positive array like
					// : [T, 1 ...] 1 or more elements, so [0] != don't require null check

					// TODO error on not-all-matched patterns of enum by default,
					// but @hint makes it only a hint and @ok to ignore

					var tags: [String] = []
					var i = 0

					// Avoid repeating tags `case Tag:` and values `case 123:`
					fun tagCheck(currentTag: String, e: Node) {
						if tags.includes(currentTag) {
							fail('Tag `\(currentTag)` already matched', e)
							// TODO .. at line
						} else {
							tags.push(currentTag)
						}
					}

					while i < cases.length {
						pushScope()
						var e = conds[i]
						// Fill case condition `case pattern:`
						var currentType: EnumType? = null
						var currentTag: String? = null
						var currentTagBind = 0
						var interval = false

						fun follow(e: Node) {
							switch e {
								// `case E.T:`
								case DotUpper(ex, name):
									fillExpression(e)
									switch types.get(ex) as! Type {
										case Enum(type):
											currentType = type
											// TODO currentType = 123
											currentTag = name

											// This syntax is not supported anymore
											fail('Use `case \(currentTag)` instead of `case \(type.name).\(currentTag)`', e)

											if tags.includes(currentTag) {
												fail('Tag `\(currentTag)` already matched', e)
												// TODO .. at line
											} else {
												tags.push(currentTag)
											}
									}
								case Parenthesis(e): {fill(e)}
								// `case _:` default case
								case Underscore: {}

								// TODO error on complex enums
								case Null: {}
								case Bool(val):
									tagCheck('' + val, e)
									if etype != typeBool {
										fail('Cannot switch over boolean here', e)
									}
								// TODO MetaInt
								case Int(val):
									tagCheck('' + val, e)
									if etype != typeInt {
										fail('Cannot switch over number here', e)
									}
								case String(val):
									tagCheck(val, e)
									if etype != typeString {
										fail('Cannot switch over string here', e)
									}
								case Call(ex, args, argNames): {
									// TODO rethink nested pattern mechanics
									// TODO don't follow nested patterns for now
									follow(ex)
									currentTagBind = 0

									if args.length == 0 {
										fail('Do not use `()` empty pattern, use `\(currentTag)(...)` syntax to ignore all bindings', e)
									}

									if
										let enumType = enumType,
										enumType.fieldsTypeSimple != null
									{
										fail('The `\(enumType.name)` is simple enum and has no `()` bindings', e)
									}

									if
										let enumType = enumType,
										shortHandSyntax == true,
										let i = enumType.fieldNames.indexOf(currentTag),
										let binds = enumType.tagBindVarsNames[i],
										binds.length == 0
									{
										switch args[0] {
											case Interval:
												// Okay
											case _:
												fail('The `\(currentTag)` has no `()` bindings, use `\(currentTag)(...)` syntax to ignore all future bindings added', e)
										}
									}

									for ee in args {
										if interval {
											fail('Do not match any patterns after `...` interval', ee)
										}

										switch ee {
										case Interval:
											interval = true
										case Ident(name):
											follow(ee)
											currentTagBind++
										case Underscore:
											if
												let enumType = enumType,
												shortHandSyntax == true,
												let i = enumType.fieldNames.indexOf(currentTag),
												let binds = enumType.tagBindVarsNames[i],
												binds.length <= currentTagBind
											{
												fail('Too many bindings ignored with `_` for `F` tag, use `...` syntax to ignore all future bindings', e)
											}

											currentTagBind++
										case _:
											fail('This case pattern is not supported', e)
										}
									}
								}

								// case TagName:
								case NodeTypeValue(t):
									shortHandSyntax = true
									switch t {
										case Type(name):
											if let enumType = enumType {
												if let i = enumType.fieldNames.indexOf(name), enumType.fieldEnumConstructor[i] == true {
													currentType = enumType
													currentTag = name
													if tags.includes(currentTag) {
														fail('Tag `\(currentTag)` already matched', e)
														// TODO .. at line
													} else {
														tags.push(currentTag)
													}
												} else {
													fail('The `\(name)` is not an enum constructor of `\(enumType.name)`', e)
												}
											} else {
												fail('This case pattern is not supported over non-enum types', e)
											}
										case _:
											fail('This case pattern is not supported', e)
									}

								case Ident(name): // Bind (var)
								{
									if (name.charAt(0) == name.charAt(0).toUpperCase()) {fill(e)}
									else {
										addScope(name, e)

										// Find tag bind var and set it's type:
										if let currentType = currentType {
											let indexOf = currentType.fieldNames.indexOf(currentTag)
											if indexOf == -1 {
												fail('currentType.fieldNames.indexOf == -1', e)
											}
											let type = currentType.tagBindVars[indexOf][currentTagBind]
											let name = currentType.tagBindVarsNames[indexOf][currentTagBind]
											if name == null {
												let available = currentType.tagBindVarsNames[indexOf].join(', ')
												if available.length == 0 {
													fail('No bindings available for `.' + currentTag + '`', e)
												}
												fail('Too many bindings requested for `\(currentTag)`, available are: ' + available, e)
											}
											if type != null {
												types.set(e, toType(type, e))
											} else {
												fail('tagBindVars no type for ' + name, e)
											}
										} else {
											fail('No currentType for '+name, e)
										}
									}
								}
								case Binop(a, op, b):
									if op == Token.OpOr {
										follow(a)
										follow(b)
									} else {
										fail('This case pattern is not supported', e)
									}
								case If(econd, _, _):
									pushScope()
									fill(econd[0])
									popScope()
								case _:
									fail('This case pattern is not supported', e)
							}
						}
						follow(e)
						// Fill case result expression
						var e = cases[i]
						pushScope()

						if let guard = guards[i] {
							fillExpression(guard)
							if types.get(guard) != typeBool {
								fail('Case guard must be a simple boolean expression', guard)
							}
						}

						if value == false {
							fill(e)
						}
						if value == true {
							fillExpression(e)
							if types.get(node) == null {
								types.set(node, types.get(e))
							} else {
								types.set(node, unify(types.get(node), types.get(e), e))
							}
						}
						popScope()

						popScope()
						i++
					}
			}
		}
}
