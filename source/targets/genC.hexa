// The Hexa Compiler
// Copyright (C) 2021-2024 Oleh Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// Generates C with C++ compatibility
/// Some features require C11
// TODO extends Generator .features(): GeneratorFeatures
class GenCxx {
	static fun spawn() {
		return new GenCxx()
	}

	new () {
		// Fields are initialized at declarations
	}

	// TODO no name no error: fun (){}
	// TODO no body no error: fun x()
	// fun()

	fun perform(normalizer, target: String, options: [String]): String {
		project = normalizer
		extraUnderscore = options.includes('extraUnderscore')
		return stringify(target)
	}

	/// On x64 it is always fast call,
	/// but on Win32 i686 we should use std call
	var defaultCallingConvention = '__conventionName '
	/// Quick access
	var memory64 = true
	let nativeIterators = false
	let globalAccessor = ''
	var project: NiceProject
	var declarationsOfFunctions: [String] = []
	var declarationsOfOpaqueTypes: [String] = []
	var declarationsOfFullTypes: [String] = []
	/// Mapping of original strings (optimization)
	var declarationsOfStringsMap: [String : Int] = [:]
	var declarationsOfStrings: [String] = []
	let forwardFunctions: [String] = []
	let typedefFunctions: [String] = []
	let globalVariables: [String] = []
	let globalFunctions: [String] = []
	let types: [String] = []
	let dllExports: [String] = []
	// TODO Docs
	/// Sets `__link` prefix for `_link` names
	/// Workaround for LLVM 32-bit linker
	var extraUnderscore = false

	fun stringify(target: String) {
		// Configure
		if project.memory == Memory.Modern64 {
			// No space
			defaultCallingConvention = ''
		} else {
			// With space
			// TODO probably should be only on Win32 platform
			// Note this is used for all of Win32 API and COM interfaces anyway
			// thus we default to this calling convention
			defaultCallingConvention = '__stdcall '
			memory64 = false
		}

		// Contains forward declarations
		let header = ['// Generated by Hexa \(version) https://hexalang.github.io']
		if project.package.addLicenseNoticeToOutput {
			// rename addLicenseNoticeToOutput
			header.push('// Project: \(project.package.name)')
			header.push('// LICENSE \(project.package.license)')
		} else {
			header.push('// The generated code is subject to the original license')
		}

		header.push(Fs.readFileSync(__dirname + '/library/cxx/hexa.c').toString('utf8').split('\r\n').join('\n'))
		header.push('#ifdef __cplusplus')
		header.push('extern "C" {')
		header.push('#endif')
		// virtual abstract $unref();
		// virtual abstract $ref();

		// TODO copy hexa.cpp to output folder if not exists (updates??)
		// create hexa.cpp in library/cpp ^
		// ^ just copy into output file
		//header.push('#include "hexa.cpp"')

			let out: [String] = []
			let forward: [String] = []

			// Strings
			registerString('') // id == 0
			declarationsOfStringsMap.set('', 0)
			registerString('null') // id == 1
			declarationsOfStringsMap.set('null', 1)

			// Types
			// TODO use _HEX16GUID_ClassName_ instead of _mangledNameSpace_ClassName_!
			// ^ and save this String to class definition for cache in normalizer
			// cause JS will use it too for now
			for e in project.enumsSimple {
				// No need to output simple enum values
				// TODO proper base type
				forward.push('struct ' + e.name + '_;')
				if (e.staticVars.length + e.staticMethods.length == 0) {
					continue
				}
				// TODO tdef C* C
				types.push(e.name + '_ {\n\t')

				// Static vars before static functions
				for v in e.staticVars { switch v {
					case Var(name, expr, type):
						//types.push('\n\tstatic void* ' + name + '_;')
						//types.push('\n\tstatic \(stringifyType(type)) ' + name + '_;')
						globalVariables.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
						//if (expr != null) out.push(' = ' + printExpression(expr))
					case Const(name, expr, type):
						//types.push('\n\tstatic void* ' + name + '_;')
						//types.push('\n\tstatic \(stringifyType(type)) ' + name + '_;')
						globalVariables.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
						//out.push(' = ' + printExpression(expr))
				}}

				//for (v in e.staticMethods) switch v {
				//	case Function(name, expr, args, defaults, funcType):
				//		types.push('\n\tstatic ')
				//		types.push(printFunctionReturnType(funcType))
				//		types.push(' ' + name + '_')
				//		types.push(printFunctionArguments(args, funcType, true))
				//		types.push(';')
				//}
				types.push('\n};\n')

				for v in e.staticMethods { switch v {
					case Function(name, expr, args, defaults, funcType):
						forwardFunctions.push(printFunctionReturnType(funcType))
						forwardFunctions.push(' ' + e.name + '_$' + name + '_')
						forwardFunctions.push(printFunctionArguments(args, funcType))
						forwardFunctions.push(';\n')

						// TODO cache `printFunctionReturnType` here etc to not print twice
						out.push(printFunctionReturnType(funcType))
						out.push(' ' + e.name + '_$' + name + '_')
						out.push(printFunctionArguments(args, funcType))
						let _currentReturnType = currentReturnType
						currentReturnType = getFunctionReturnType(funcType)
						out.push(' ' + printBlock(expr) + ';\n\n')
						//out.push(' {};\n')
						currentReturnType = _currentReturnType
				}}
			}

			for e in project.enumsComplex {
				forward.push('struct ' + e.name + '_;')
				types.push(e.name + '_ : Unknown_ {\n\t')
				types.push('\n\tAny_** enum_;') // Enum.Name(enum_...)
				types.push('\n\tuint16_t is_;')
				types.push('\n\tuint8_t length_;') // Amount of enum_[] to dealloc

				var i = 0
				for name in e.names {
					if e.constructors[i] != null {
						//types.push('\n\tstatic ' + e.name + '_* ' + name + '_(')
						////types.push([for (c in e.constructors[i]) 'Any_* ' + c + '_'].join(', '))
						//types.push([for (c in e.constructors[i].length)
						//	stringifyType(e.constructorsTypes[i][c]) + ' ' + e.constructors[i][c] + '_'
						//].join(', '))
						//types.push(');')

						out.push(e.name + '_* ' + e.name + '_$' + name + '_(')
						//out.push([for (c in e.constructors[i]) 'Any_* ' + c + '_'].join(', '))
						out.push([for c in e.constructors[i].length
							stringifyType(e.constructorsTypes[i][c]) + ' ' + e.constructors[i][c] + '_'
						].join(', '))
						out.push(') {\n')
						out.push('\t' + e.name + '_* _ = (' + e.name + '_*)(HEXA_NEW(sizeof(' + e.name + '_)));\n')
						out.push('\t_->length_ = \(e.constructors[i].length);\n')
						out.push('\t_->enum_ = (Any_**)(HEXA_NEW(sizeof(Any_*) * \(e.constructors[i].length)));\n')
						out.push('\t_->is_ = \(i);\n')
						for c in e.constructors[i].length {
							//out.push('\t_->enum_[\(c)] = \(e.constructors[i][c])_;\n')
							out.push('\t_->enum_[\(c)] = ')
							//out.push(printTypeConverter(e.constructors[i][c] + '_', e.constructorsTypes[i][c], project.typer.typeAny))
							out.push(printToAnyConverter(e.constructors[i][c] + '_', e.constructorsTypes[i][c]))
							out.push(';\n')
						}
						out.push('\treturn _;\n')
						out.push('};\n')
					} else {
						//types.push('\n\tstatic ' + e.name + '_* ' + name + '_();')

						out.push(e.name + '_* ' + e.name + '_$' + name + '_() {\n')
						out.push('\t' + e.name + '_* _ = (' + e.name + '_*)(HEXA_NEW(sizeof(' + e.name + '_)));\n')
						out.push('\t_->length_ = 0;\n')
						out.push('\t_->is_ = \(i);\n')
						out.push('\treturn _;\n')
						out.push('};\n')
					}
					i++
				}

				// Static vars before static functions
				// TODO is = printed?
				for v in e.staticVars { switch v {
					case Var(name, expr, type):
						//types.push('\n\tstatic void* ' + name + '_;')
						//types.push('\n\tstatic \(stringifyType(type)) ' + name + '_;')
						globalVariables.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
						//if (expr != null) out.push(' = ' + printExpression(expr))
					case Const(name, expr, type):
						//types.push('\n\tstatic void* ' + name + '_;')
						//types.push('\n\tstatic \(stringifyType(type)) ' + name + '_;')
						globalVariables.push('\(stringifyType(type)) ' + e.name + '_$' + name + '_;\n')
						//out.push(' = ' + printExpression(expr))
				}}

				for v in e.staticMethods { switch v {
						case Function(name, expr, args, defaults, funcType):
							//types.push('\n\tstatic ')
							//types.push(printFunctionReturnType(funcType))
							//types.push(' ' + name + '_')
							//types.push(printFunctionArguments(args, funcType, true))
							//types.push(';')

							forwardFunctions.push(printFunctionReturnType(funcType))
							forwardFunctions.push(' ' + e.name + '_$' + name + '_')
							forwardFunctions.push(printFunctionArguments(args, funcType))
							forwardFunctions.push(';\n')

							out.push(printFunctionReturnType(funcType))
							out.push(' ' + e.name + '_$' + name + '_')
							out.push(printFunctionArguments(args, funcType))

							let _currentReturnType = currentReturnType
							currentReturnType = getFunctionReturnType(funcType)
							//out.push(' {};\n')
							out.push(' ' + printBlock(expr) + ';\n\n')
							currentReturnType = _currentReturnType
					}}
				types.push('\n};\n')
			}

			// TODO get rid of this workaround
			let duplicates: [String] = []
			// TODO this syntax `let duplicates = String []`
			for c in project.classes {
				if c.external {
					// TODO rename to just 'require'
					if c.jsRequire != null {
						// `@require('#include <...>')`
						forward.push(c.jsRequire)
					}
					// TODO rename to just 'rename'
					if let jsNative = c.jsNative, jsNative != c.name {
						forward.push('#define ' + c.name + ' ' + jsNative)
					}
					continue
				}
				//if (c.name == 'String') {
				//	continue
				//}
				if c.name == 'Any' {
					//forward.push('#define Any_ Unknown_')
					continue
				}
				// TODO better idea
				if c.name == 'Bool' {
					continue
				}
				if c.useless {
					// TODO continue
				}
				if c.template {
					continue
				}

				// TODO better way
				c.name = stringifyType(c.type).replace('_*','')

				var isStruct = false
				var isUnion = false
				var isPacked = false
				switch c.type {
					// TODO `case Class(type) or ClassInstance(type): {`
					case Class(type): {
						let atts = project.mapDecorators.get(type.parent)
						isStruct = Decorator.getDecorator(atts, 'struct') != null
						isUnion = Decorator.getDecorator(atts, 'union') != null
						isPacked = Decorator.getDecorator(atts, 'packed') != null
					}
					case ClassInstance(type): {
						let atts = project.mapDecorators.get(type.parent)
						isStruct = Decorator.getDecorator(atts, 'struct') != null
						isUnion = Decorator.getDecorator(atts, 'union') != null
						isPacked = Decorator.getDecorator(atts, 'packed') != null
					}
				}

				let nativeKind = isUnion? 'union ' : 'struct '

				let forwardedAs = nativeKind + c.name + '_;'
				if duplicates.includes(forwardedAs) {
					continue
				}
				duplicates.push(forwardedAs)

				forward.push(forwardedAs)
				forward.push('typedef \(nativeKind)\(c.name)_ \(c.name)_;')

				if isPacked {
					types.push('#pragma pack(1)\n')
				}
				types.push(nativeKind + c.name + '_ {\n\t')
				let vtable = ['struct ' + c.name + '__ {\n\t']
				// TODO const pointer to const struct
				if isStruct or c.api == ClassBinaryInterface.StructureNoVirtual {
					// Ok
				} else {
					types.push('\n\tconst struct ' + c.name + '__ * const _;')
				}
				let vtableValue = ['const struct ' + c.name + '__ ' + c.name + '__$ = {\n\t']
				let vtableBind = []

				// TODO `for i : v in`
				var vi = -1
				for v in c.vars {
					vi++

					switch v {
					case Var(name, expr, type):
						if let bits = c.varBits[vi] {
							types.push('\n\t\(stringifyType(type)) ' + name + '_')
							types.push(' : ' + bits)
							types.push(';') // TODO probably must be a single `types.push` if bit-arrays-by-value are supported in C
						} else {
							types.push('\n\t\(stringifyType(type)) ' + name + '_;')
						}
						switch type {
							case ClassInstance(type, generics): {
								if type.name == 'ArrayByValue' {
									var arraySize = ''
									if let count = generics[1] {
										arraySize = '[' + Type.stringify(count) + ']'
									} else {
										arraySize = '[]'
									}

									types.pop() // TODO better idea
									types.push('\n\t\(stringifyType(generics[0])) ' + name + '_' + arraySize + ';')
								}
							}
						}
					case Const(name, expr, type):
						types.push('\n\t\(stringifyType(type)) ' + name + '_;')
				}
				}

				// Empty struct has size 0 in C, size 1 in C++
				var nonEmptyTable = false
				var hasToString = false

				for v in c.methods { switch v {
					case Function(name, expr, args, defaults, funcType):
						hasToString = hasToString or name == 'toString'
						if (name == null || name == 'new') {
							forwardFunctions.push(c.name + '_* ' + c.name + '_$new_')
							forwardFunctions.push(printFunctionArguments(args, funcType))
							forwardFunctions.push(';\n')
							// TODO cache printFunctionArguments to local var here

							// Init
							out.push(c.name + '_* ' + c.name + '_$this_')
							thisArgument = c.name + '_* $this'
							out.push(printFunctionArguments(args, funcType))
							thisArgument = null
							out.push(' {\n')
							// TODO cache own vtable on function enter

							// Init fields
							customThis = '$this'
							for v in c.vars { switch v {
								case Var(name, expr, type):
									if expr != null {
										// TODO `isArrayByValue` helper
										var isArrayByValue = false
										switch type {
											case ClassInstance(c):
												if c.name == 'ArrayByValue' {
													// TODO support `array = [...]` assignments everywhere cause C doesn't
													isArrayByValue = true
												}
										}
										if not isArrayByValue {
											out.push('\t$this->' + name + '_ = ' + printInitializer(type, expr) + ';\n')
										} else {
											// TODO
										}
									}
								case Const(name, expr, type):
									if expr != null {
										out.push('\t$this->' + name + '_ = ' + printInitializer(type, expr) + ';\n')
									}
							}}
							pushTab()
							switch expr {
								// TODO pattern match as `[...head]` or `[head, ...tail]`
								// ^ and optimize to no-saving-to-bind cause bound var not used later
								case Block(el): if el.length > 0 {
									out.push('\t' + printBlock(expr) + ';\n')
								}
								case _:
									out.push('\t' + printBlock(expr) + ';\n')
							}
							popTab()
							customThis = null
							out.push('\n\treturn $this;\n')
							out.push('};\n\n')

							// Alloc
							//out.push(c.name + '_* ' + c.name + '_$new_() {\n')
							out.push(c.name + '_* ' + c.name + '_$new_')
							out.push(printFunctionArguments(args, funcType))
							out.push(' {\n')
							out.push('\tvoid** $_ = (void**)(HEXA_NEW(sizeof(' + c.name + '_)));\n')
							// TODO why so complicated? Just assign `_` v table pointer, makes also type-safer
							if c.api == ClassBinaryInterface.StructureNoVirtual {
							} else {
								out.push('\t$_[0] = (void *)&' + c.name + '__$;\n')
							}
							out.push('\t' + c.name + '_* _ = (' + c.name + '_*)($_);\n')

							//out.push('\tvoid* buffer_ = (struct ' + c.name + '_*)(HEXA_NEW(sizeof(struct ' + c.name + '_)));\n')
							//out.push('\tstruct ' + c.name + '_* _ = new (buffer_) ' + c.name + '_();\n')
							//out.push('\tstruct ' + c.name + '_* _ = new (buffer_) ' + c.name + '_();\n')
							//out.push('\t_->this_();\n')
							//out.push('\t_->this_(')
							out.push('\t' + c.name + '_$this_(')
							//out.push([for (a in args) a + '_'].join(', '))
							let arg = [for a in args a + '_']
							arg.unshift('_')
							out.push(arg.join(', '))
							out.push(');\n')
							out.push('\treturn _;\n')
							out.push('};\n\n')
						} else {
							thisArgument = c.name + '_* $this'
							vtable.push('\n\t')
							vtable.push(printFunctionReturnType(funcType))
							vtable.push(' (*const ' + name + '_) ')
							vtable.push(printFunctionArguments(args, funcType))
							vtable.push(';')
							nonEmptyTable = true

							forwardFunctions.push(printFunctionReturnType(funcType))
							forwardFunctions.push(' ' + c.name + '_$' + name + '_')
							forwardFunctions.push(printFunctionArguments(args, funcType))
							forwardFunctions.push(';\n')

							let vbind = '&' + c.name + '_$' + name + '_'
							vtableBind.push(vbind)

							out.push(printFunctionReturnType(funcType))
							out.push(' ' + c.name + '_$' + name + '_')
							out.push(printFunctionArguments(args, funcType))
							let _currentReturnType = currentReturnType
							currentReturnType = getFunctionReturnType(funcType)
							customThis = '$this'
							thisArgument = null
							// TODO cache own vtable on function enter
							if let expr = expr {
								out.push(' ' + printBlock(expr) + ';\n\n')
							} else {
								let temp = tempId++
								// TODO proper `nullptr` kind
								out.push(' {\n\tHEXA_UNREACHABLE(\(temp));\n\treturn nullptr;\n};\n\n')
							}
							customThis = null
							currentReturnType = _currentReturnType

							if false {
							out.push(printFunctionReturnType(funcType))
							out.push(' ' + c.name + '_::' + name + '_')
							out.push(printFunctionArguments(args, funcType))
							let _currentReturnType = currentReturnType
							currentReturnType = getFunctionReturnType(funcType)
							//out.push(' {};\n')
							//out.push(' ' + printBlock(expr) + ';\n')
							//thisArgument = 'this'
							//let arg = args.slice()
							let arg = [for a in args a + '_']
							arg.unshift('this')
							//console.log('slice', arg == args, arg, args)
							//out.push(' { return ' + c.name + '_$' + name + '_(' + arg.join(', ') + '); };\n')
							out.push(' { return this->_->' + name + '_(' + arg.join(', ') + '); };\n')
							//out.push(' { return ' + c.name + '_$' + name + '_' + printFunctionArguments(args) + '; };\n')
							//thisArgument = null
							}
							currentReturnType = _currentReturnType
						}
				}}

				if nonEmptyTable == false {
					vtable.push('uint8_t padding_;')
				}

				if not hasToString {
					out.push('String_* ' + c.name + '_$toString_(\(c.name)_* this_) { return ')
					out.push(printExpression(Expression.String('[object Object]')))
					out.push('; };\n\n')
				}

				// Static vars before static functions
				for v in c.staticVars { switch v {
					case Var(name, expr, type):
						//types.push('\n\tstatic \(stringifyType(type)) ' + name + '_;')
						globalVariables.push('\(stringifyType(type)) ' + c.name + '_$' + name + '_;\n')
						//types.push('\n\tstatic void* ' + name + '_;')
						//if (expr != null) out.push(' = ' + printExpression(expr))
					case Const(name, expr, type):
						//types.push('\n\tstatic void* ' + name + '_;')
						//types.push('\n\tstatic \(stringifyType(type)) ' + name + '_;')
						globalVariables.push('\(stringifyType(type)) ' + c.name + '_$' + name + '_;\n')
						//out.push(' = ' + printExpression(expr))
				}}

				//for (v in c.staticMethods) switch v {
				//	case Function(name, expr, args, defaults, funcType):
				//		types.push('\n\tstatic ')
				//		types.push(printFunctionReturnType(funcType))
				//		types.push(' ' + name + '_')
				//		types.push(printFunctionArguments(args, funcType))
				//		types.push(';')
				//}

				types.push('\n};\n')
				if isPacked {
					types.push('#pragma pack()\n')
				}
				vtable.push('\n};\n')
				vtableValue.push(vtableBind.join(',\n\t'))
				vtable.push(vtableValue.join('') + '\n};\n')
				types.unshift(vtable.join(''))

				for v in c.staticMethods { switch v {
					case Function(name, expr, args, defaults, funcType):
						forwardFunctions.push(printFunctionReturnType(funcType))
						forwardFunctions.push(' ' + c.name + '_$' + name + '_')
						forwardFunctions.push(printFunctionArguments(args, funcType))
						forwardFunctions.push(';\n')

						out.push(printFunctionReturnType(funcType))
						out.push(' ' + c.name + '_$' + name + '_')
						out.push(printFunctionArguments(args, funcType))

						let _currentReturnType = currentReturnType
						currentReturnType = getFunctionReturnType(funcType)
						//out.push('\t{printf("\(c.name).\(name)()\\n");\n\t')
						//out.push('{};\n')
						out.push(' ' + printBlock(expr) + ';\n\n')
						//out.push('\t};\n')
						currentReturnType = _currentReturnType
						//out.push(printFunctionArguments(args, defaults) + ' => { ' + printStatement(expr) + ' }')
				}}
			}

			for g in project.globalFuncs { switch g {
				case Function(name, expr, args, defaults, funcType, variadic):
					let link = project.globalLink.get(g) // TODO null guard
					var shouldEmitHeader = false
					var customHeader: String? = null
					var spec = ''
					var name = name + '_'
					var exports = false

					if let link = link {
						switch link.convention {
							case FastCall:
								spec += '__attribute__((fastcall)) '
							case Default:
								spec += defaultCallingConvention
							case _:
								// TODO more
						}

						if link.dllImport {
							spec += '__declspec(dllimport) '
							shouldEmitHeader = true
						}

						if link.emitHeader {
							// TODO seems like it doesn't respects `@rename`
							shouldEmitHeader = true
						}

						if link.customHeader != null {
							customHeader = link.customHeader
						}

						// Note: before `dllExports.push`
						if let rename = link.rename {
							name = rename
						}

						if link.dllExport {
							spec += '__declspec(dllexport) '
							exports = true
							dllExports.push(link.linkName ?? name)
						}
					} else {
						spec += defaultCallingConvention
					}

					if let customHeader = customHeader {
						// TODO error that dllexport/etc incompatible with customHeader
						types.push(customHeader)
						types.push('\n')
					} else if expr != null or shouldEmitHeader {
						types.push(spec)
						types.push(printFunctionReturnType(funcType))
						types.push(' ' + name)
						types.push(printFunctionArguments(args, funcType, variadic))
						if let link = link, let linkName = link.linkName {
							if exports and extraUnderscore and linkName.startsWith('_') {
								types.push(' HEXA_LINK("_')
							} else {
								types.push(' HEXA_LINK("')
							}

							types.push(linkName)
							types.push('")')
						}
						types.push(';\n')
					}

					if let expr = expr {
						out.push(printFunctionReturnType(funcType))
						out.push(' ' + name)
						out.push(printFunctionArguments(args, funcType, variadic))

						let _currentReturnType = currentReturnType
						currentReturnType = getFunctionReturnType(funcType)
						out.push(' ' + printBlock(expr) + ';\n\n')
						currentReturnType = _currentReturnType
					}
			}}

			// Init
			out.push('int HEXA_MAIN(int argc, char **argv) {\n')
			out.push('%%%HEXA_STRINGS@@@\n')
			//out.push('\tString_Strings = (String_**)HEXA_NEW(HEXA_STRINGS * sizeof(String_*));\n')
			pushTab()

			for e in project.enumsSimple {
				for v in e.staticVars { switch v {
					case Var(name, expr, type):
						if (expr != null) {
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
						}
					case Const(name, expr, type):
						if (expr != null) {
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
						}
				}}
			}

			for e in project.enumsComplex {
				for v in e.staticVars { switch v {
					case Var(name, expr, type):
						if expr != null {
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
						}
					case Const(name, expr, type):
						if expr != null {
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
						}
				}}
			}

			for e in project.classes {
				for v in e.staticVars { switch v {
					case Var(name, expr, type):
						if expr != null {
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
						}
					case Const(name, expr, type):
						if expr != null {
							out.push('\t' + e.name + '_$' + name + '_ = ' + printExpression(expr) + ';\n')
						}
				}}
			}

			for g in project.globalVars {
				var defaults = true
				// TODO rename 'default' in JS gen `var default = true`
				switch g {
				// TODO maybe use "var"
				case Var(name, expr, type):
					switch type {
						// TODO same for const
						case ClassInstance(type, generics): {
							if type.name == 'ArrayByValue' {
								var arraySize = ''
								if let count = generics[1] {
									arraySize = '[' + Type.stringify(count) + ']'
								} else {
									arraySize = '[]'
								}

								globalVariables.push('\(stringifyType(generics[0])) ' + name + '_' + arraySize)
								if let expr = expr {
									switch expr {
										case Array(el):
											let valueType = generics[0]
											// TODO reuse same initializer as in expression and use meta-blocks
											globalVariables.push(' = {' + [for a in el printTypeConverter(printExpression(a), getType(a), valueType)].join(', ') + '}')
										case _:
											// TODO more
											globalVariables.push(' = {0}')
									}
								}
								globalVariables.push(';\n')

								defaults = false
							}
						}
					}

					if defaults {
					//types.push('void* ' + name + '_;\n')
					globalVariables.push(stringifyType(type))
					globalVariables.push(' ' + name + '_;\n')
					if expr != null {
						out.push('\t' + name + '_ = ' + printExpression(expr) + ';\n')
					}
					}
					//out.push('\n\tvar ' + name)
					//if (expr != null) out.push(' = ' + printExpression(expr))
					// TODO meybe not useful
					//else out.push(' = null')
				case Const(name, expr, type):
					globalVariables.push(stringifyType(type))
					globalVariables.push(' ' + name + '_;\n')
					if expr != null {
						out.push('\t' + name + '_ = ' + printExpression(expr) + ';\n')
					}
					//types.push('void* ' + name + '_;\n')
					//out.push('\n\tvar ' + name + ' = ' + printExpression(expr))
			}}

			if project.init.length > 1 {
				throw 'project.init.length > 1'
			}
			let init = printStatement(project.init[0])

			// Note: strings should be gathered after ALL expressions printed
			// TODO may be [] length == 0
			let strings: [String] = ['\tString_$root_ = String_$new_();\n']
			for id in declarationsOfStrings.length {
				// Note: `const char[]` causes compiler to make a copy of the entire string on every usage
				// TODO set ref counting
				//strings.push('\tString_Strings[\(id)] = String_fromUTF8z("\(declarationsOfStrings[id])");\n')
				strings.push('\tString_\(id) = String_$fromUTF16z_((const uint16_t*)String_\(id)_);\n')
				// TODO ^ add predefined known bytes length? like sizeof
				forward.push('String_* String_\(id); static const wchar_t *String_\(id)_ = L"\(declarationsOfStrings[id])";')
				//strings.push('\twprintf(L"\(declarationsOfStrings[id])");\n')
			}
			out.push('\t')
			out.push(init)
			popTab()
			//for (init in project.init) {
			//	// TODO custom entry
			//	// TODO globalVars
			//	out.push('\t')
			//	out.push(printStatement(init))
			//	popTab()
			//}
			out.push('\tfflush(stdout);\n')
			out.push('\treturn 0;\n}\n')

			out.push('#ifdef __cplusplus\n')
			out.push('}\n')
			out.push('#endif\n')

			// TODO all those to [ ].join('\n') instead of `+`

			if dllExports.length > 0 {
				Fs.writeFileSync(target + '.dllExport.txt', dllExports.join(' '))
			}

			// TODO instead of + + + use [String].join() as a rope
			// ^ also header/etc concat to others instead of .join('\n')
			// ^ \n can be placed at the header.push() lines or all.push('\n')
			// ^ allocate `all [String]` with known capacity to avoid relocations
			return (
				header.join('\n')
				+ '\n// Forward\n' +
				forward.join('\n')

				+ '\n// Typedef functions\n' +
				typedefFunctions.join('')

				+ '\n// Forward functions\n' +
				// TODO forwardStructs.join('\nstruct '), forwardTypes
				forwardFunctions.join('')

				+ '\n// Types\n' +
				types.join('')

				+ '\n// Global variables\n' +
				globalVariables.join('')

				+ '\n// Global functions\n' +
				globalFunctions.join('')

				+ '\n// Defaults\n' +
				Fs.readFileSync(__dirname + '/library/c/hexa.c').toString('utf8').split('\r\n').join('\n')

				+ '// Statements\n' +
				// TODO Boi, dat weird
				// ^ can be a call into `static void hexaInitStrings()` which also calls runtime string-init fun if required
				out.join('').split('%%%HEXA_STRINGS@@@').join(strings.join(''))
			).split('\n').join('\r\n')










			var out = ''

			// Types
			for e in project.enumsSimple {
				// No need to output simple enum values
				//out += '\n' + 'struct _x' + e.name + ' {};'
				//out += '\n' + 'uint32_t _x' + e.name + ';'
				declarationsOfOpaqueTypes.push('typedef uint16_t _x' + e.name)
				// TODO typedef, renamed
				for v in e.staticVars { switch v {
					case Var(name, expr, type):
						out += '\n' + stringifyType(type) + ' _x' + e.name + '_' + name
						if (expr != null) {
							out += ' = ' + printExpression(expr) + ';' //!to constructor
						}
						// += ;
					case Const(name, expr, type):
						out += '\n' + stringifyType(type) + ' _x' + e.name + '_' + name
						out += ' = ' + printExpression(expr) + ';'
				}}
				for v in e.staticMethods { switch v { // TODO forward, auto args
					//case Function(name, expr, args, defaults, types, returns):
					//	out += '\n' + printType(returns) + ' _x' + e.name + '_' + name
					//	out += printFunctionArguments(args, defaults, types) + ' { ' + printStatement(expr) + ' };'
				}}
			}

			for c in project.classes {
				if c.external {
					if c.jsRequire != null {
						// todo MAKE IT possible to use plain-c include's!
						// like "declare" vs "deep extern declare" for Haxe
						out += '\n ' + '/*var ' + c.name + ' = require("' + c.jsRequire + '")*/'
						continue
					}
					//declarationsOfOpaqueTypes.push('#define _x' + c.name + ' ' + (c.jsNative ?? c.name))
					// Avoid adding of `;`
					//header.push('#define _x' + c.name + ' ' + (c.jsNative ?? c.name))
					header.push('typedef ' + (c.jsNative ?? c.name) + ' _x' + c.name + ';')
					continue
				}

				let renamed = '_x' + c.name
				let t = ['struct ', renamed, ' {'] // t should be used instead of out???
				//out += '\n ' + 'struct ' + c.name + ' {'
				// maybe use as struct* not just `struct`?
				declarationsOfOpaqueTypes.push('typedef struct \(renamed)* \(renamed)')
				t.push('\n _xclass _xclass;') // Reference counting and metatable
				for v in c.vars { switch v {
					case Var(name, expr, type):
					t.push('\n ' + stringifyType(type) + ' _x' + name + ';')
					//if (expr != null) out += ' = ' + printExpression(expr)
					//t.push(';')
					case Const(name, expr, type):
					//t.push('\n ' + printType(type) + ' = ' + printExpression(expr) + ';')
					t.push('\n ' + stringifyType(type) + ' _x' + name + ';')
				}}
				for v in c.methods { switch v {
					case Function(name, expr, args, defaults): // Class method
					let types = null
					let returns = null
					var declaration = printType(returns) + ' '
					let constructor = (name == null || name == 'new')
					// TODO finally decide on 'new'
					if constructor {
						declaration = renamed + ' '
					}
					declaration += renamed + '_' + name

					if constructor {
						if args.length > 0 {
							declaration += '(void* _x' + args.join(', void* _x') + ')'
						} else {
							declaration += '()'
						}
					} else {
						if args.length > 0 {
							declaration += '(\(renamed) _xthis, void* _x' + args.join(', void* _x') + ')'
						} else {
							declaration += '(\(renamed) _xthis)'
						}
					}

					declarationsOfFunctions.push(declaration)
					//if (name == null || name == 'new') declaration = '\(renamed) \(renamed)_new'
					//if (name == null || name == 'new') out += '\n\(renamed)* constructor_\(renamed)'
					//else out += '\nauto ' + name
					out += '\n' + declaration
					//out += '(' + args.join(', ') + ') { '
					out += ' { '

					if constructor {
						out += '\n \(renamed) _xthis = (\(renamed))HEXA_NEW(sizeof(struct \(renamed)));'
						// Init fields
						for v in c.vars { switch v {
							case Var(name, expr, type):
							if expr != null {
								out += '\n _xthis->_x' + name + ' = ' + printExpression(expr) + ';'
							}
							case Const(name, expr, type):
							out += '\n _xthis->_x' + name + ' = ' + printExpression(expr) + ';'
						}}
						out += '\n '
						out += printStatement(expr) + '\n return _xthis;\n};'
					} else {
						out += printStatement(expr) + '\n};'
					}
				}}
				t.push('\n}')
				declarationsOfFullTypes.push(t.join(''))

				for v in c.staticVars { switch v {
					case Var(name, expr, type):
						out += '\n ' + stringifyType(type) + ' ' + renamed + '_' + name
						//t.push('\n ' + c.name + '.' + name)
						// TODO to main()
						//if (expr != null) out += ' = ' + printExpression(expr)
						out += ';'
						//if (expr != null) t.push(' = ' + printExpression(expr))
				}}
			}
		}

		var tabs = ''

		@inline fun pushTab() {
			tabs += '\t'
		}

		@inline fun popTab() {
			tabs = tabs.substring(0, tabs.length - 1)
		}

		// All names are prefixed with `_x`, so reserved words are not required
		var reserved = []

		// For `return value` conversions (like Bool to Any)
		var currentReturnType: Type? = null

		// Surrounds with { brackets } single statement
		// TODO rename to printAsBlock
		fun printBlock(s: Statement): String {
			//return printStatement(s)
			switch s {
				case Block(el):
					return printStatement(s)
				//if (el.length == 1) return '{ ' + printStatement(el[0]) + '; }'
				if el.length == 1 { switch (el[0]) {
					case Block(_): return printBlock(el[0])
					case _: return '{ ' + printStatement(el[0]) + '; }'
				}}
				if el.length == 0 {
					return '{}'
				}
				return printStatement(s)
				case _: //return '{ ' + printStatement(s) + '; }'
					return printStatement(Statement.Block([s]))
			}
		}

		var metaBlock: [String] = []
		var tempId = 0

		var last: Statement = '' as! Statement // TODO remove
		fun printStatement(s: Statement) {
			last = s ?? last // TODO should error! cause String!
			switch s {
				case Statements(els):
					var r = ''
					for s in els {
						if s != null {
							r += '\n' + tabs + printStatement(s) + ';'
						}
					}
					return r

				case Break:
					return 'break'

				case Continue:
					return 'continue'

				case Block(el):
					if el.length == 0 {
						return '{}'
					}
					pushTab()

					fun printMetaBlock(e: Statement) {
						let meta = metaBlock
						metaBlock = []

						var ss = printStatement(e)
						var r = []
						for line in metaBlock {
							//r.unshift(line)
							r.push(line)
						}
						r.push(ss)

						metaBlock = meta
						return r.join(';\n' + tabs)
					}

					var r = '{'

					for e in el { switch e {
						case null:
						case Statements(els):
							for s in els {
								if s != null {
									r += '\n' + tabs + printMetaBlock(s) + ';'
								}
							}
						case _:
							// TODO r could be a rope/join
							// ^ interesting idea is rope-promotion,
							// cause r never leaves owning block (in js too)
							r += '\n' + tabs + printMetaBlock(e) + ';'
					}}

					popTab()
					return r + '\n' + tabs + '}'

				// TODO case New(e, args): return '' + printExpression(e) + '$new_' + printCallArguments(args)

				case Const(name, expr, type):
					return printStatement(Statement.Var(name, expr, type))
					return stringifyType(type) + ' ' + name + '_' + (expr == null? '' : ' = ' + printTypeConverter(printExpression(expr), getType(expr), type))

				case Var(name, expr, type):
					switch type {
						case ClassInstance(typeClass, generics):
							var arraySize = ''
							var arrayLength = 0x7FFFFFFF
							if typeClass.name == 'ArrayByValue' {
								if let count = generics[1] {
									arraySize = '[' + Type.stringify(count) + ']'
									switch count {
										case Constant(value): {
											arrayLength = parseInt(value)
										}
									}
								} else {
									arraySize = '[]'
								}

								switch expr {
									case Array(el):
										let valueType = generics[0]
										// TODO typer check: 1 or N elements and type of elements
										// TODO use meta-blocks for non-constant values and strings
										return stringifyType(valueType) + ' ' + name + '_' + arraySize + ' = {' + [for a in el printTypeConverter(printExpression(a), getType(a), valueType)].join(', ') + '}'
									case String(string):
										if arrayLength <= string.length {
											throw 'String initializer is of length `\(string.length + 1)` including null terminator'
										}

										let valueType = generics[0]
										if generics[0] == project.typer.typeUInt8 {
											return stringifyType(valueType) + ' ' + name + '_' + arraySize + ' = "' + string + '"'
										}
										throw 'String initializer is incompatible'
									case null:
										// TODO check this in typer
										throw 'Array initializer required ' + name
								}
							} else if typeClass.name == 'ByValue' {
								switch expr {
									case null:
									case New(e, args, result):
										// Just print out `T varName; init(&varName);`
										return stringifyType(type) + ' ' + name + '_; ' // + stringifyType(type) + '$this_(&' + name + '_);'
								}
							}
					}

					return stringifyType(type) + ' ' + name + '_' + (expr == null? '' : ' = ' + printTypeConverter(printExpression(expr), getType(expr), type))

				//case Function(name, expr, args, defaults, types, returns):
				//	return printType(returns) + ' _x' + name + printFunctionArguments(args, defaults, types) + ' ' + printBlock(expr)
				//	//return 'const void* _x' + name + ' = ' + ((async==true)?'async ':'') + printFunctionArguments(args, defaults) + ' => ' + printBlock(expr)
				case Function(name, expr, args, defaults, funcType):
					let _currentReturnType = currentReturnType
					currentReturnType = getFunctionReturnType(funcType)

					let temp = tempId++
					let rt = printFunctionReturnType(funcType)
					forwardFunctions.push(rt)
					forwardFunctions.push(' _$\(temp)')
					forwardFunctions.push(printFunctionArguments(args, funcType))
					forwardFunctions.push(';\n')
//
//
//
//					rt::forwardFunctions.push
//
//					rt::forwardFunctions.push()
//
//					rt |> forwardFunctions.push |> sort
//
//					rt.(forwardFunctions.push).(sort)
//
//					...(rt, forwardFunctions.push, sort)
//
//
//					printFunctionArguments(args, funcType, true) |> globalFunctions.push()
//
//					printFunctionArguments(args, funcType, true) |> globalFunctions.push
//
//					printFunctionArguments(args, funcType, true) :: globalFunctions.push
//
//					printFunctionArguments(args, funcType, true)::globalFunctions.push
//
//

					let tab = tabs
					tabs = ''
					globalFunctions.push(rt)
					globalFunctions.push(' _$\(temp)')
					globalFunctions.push(printFunctionArguments(args, funcType))
					globalFunctions.push(' ')
					globalFunctions.push(printBlock(expr))
					tabs = tab

					currentReturnType = _currentReturnType
					return stringifyType(funcType) + ' \(name)_ = _$\(temp)'

				case Return(e):
					if e == null {
						return 'return'
					}
					//let type = getType(e)
					//if (type != currentReturnType) {
					//	if (type == project.typer.typeBool) return 'return Any_fromBool(' + printExpression(e) + ')'
					//	if (currentReturnType == project.typer.typeBool) return 'return (' + printExpression(e) + ')->_toBool()'
					//	return 'return (' + stringifyType(currentReturnType) + ')(' + printExpression(e) + ')'
					//}
					return 'return ' + printTypeConverter(printExpression(e), getType(e), currentReturnType)

				case If(econd, eif, eelse):
					var r = '\n\(tabs)if (' + printExpression(econd) + ') ' + printBlock(eif)
					if eelse != null {
						r += ' else ' + printStatement(eelse)
					}
					return r

				case Call(e, args, expects, kind):
					//let type = getType(e)
					//switch type {
					//	case ClassInstance(_, _): return 'virtual'
					//	case Class(_, _): return 'static'
					//}
					switch kind {
						// TODO error on (_,_) if simple enum case CallKind.VirtualMethod(_, _): return '*.virtual'
						case VirtualMethod:
						switch e {
							case Dot(expr, name, result):
								let temp = tempId++

								let exprType = getType(expr)
								let typeString = stringifyType(exprType)
								let meta = typeString + ' _$\(temp) = ' + printExpression(expr)

								var isStruct = false
								switch exprType {
									case ClassInstance(type, params): {
										let atts = project.mapDecorators.get(type.parent)
										isStruct = Decorator.getDecorator(atts, 'struct') != null
									}
								}

								metaBlock.push(typeString + ' _$\(temp) = ' + printExpression(expr))

								if isStruct {
									// TODO add `, expects` to other `printCallArgumentsVirtual` calls
									return omitPointer(typeString) + '$' + name + '_' + printCallArgumentsVirtual('_$\(temp)', args, expects)
								}

								return
									'_$\(temp)->_->' + name + '_' + printCallArgumentsVirtual('_$\(temp)', args, expects)// + ';\n' + tabs// +
						}
						//case CallKind.Static: return '*.static'
						//case CallKind.Function: return '*.function'
						//case _: return '*.???' + kind
					}
					//'/*Statement.Call*/' + Type.stringify(type)
					return printExpression(e) + printCallArguments(args, expects)

				case Try(expr, t, v, catches):
					pushTab()
					var r = '_try {\n' + tabs
					// TODO transfer &$try as function argument
					r += 'struct Any_* $try = (struct Any_*)0;' + '\n' + tabs
					r += printStatement(expr)
					popTab()
					// TODO test $try for null at each functions calls and goto $catch
					// TODO test $try for null and do ARC
					r += '\n' + tabs + '$catch: ; } _catch(' + printType(t[0]) + ' _x' + v[0] + ') {\n' + tabs + ' '
					pushTab()
					r += printStatement(catches[0])
					popTab()
					return r + '\n' + tabs + '}'

				case Assign(a, v):
					// TODO kinds like `static`
					switch a {
						case Dot(expr, name):
							// Dynamic
							let type = getType(expr)
							if ((type == project.typer.typeAny) || (type == null)) {
								// `static var` TODO describe logic more obviously
								switch expr {
									case Ident(named): {
										if DataHelper.isTitleCase(named) {
											// TODO proper conversion type in `printTypeConverter` of assigned field
											return printExpression(expr) + '$' + name + '_ = ' + printInitializer(getType(a), v)
										}
									}
								}

								return printExpression(expr) +
									'->$set(String_$fromUTF16z_(L"' + name + '"), ' + printToAnyConverter(printExpression(v), getType(v)) + ')'
							}
						case Index(expr, index):
							switch getType(expr) {
								case ClassInstance(type, generic):
									if type.name != 'Array' {
										return printExpression(expr) + '[' + printTypeConverter(printExpression(index), getType(index), project.typer.typeInt) + ']'
										+ ' = ' + printExpression(v)
									}
									// TODO meta block
									return printExpression(Expression.Call(
										Expression.Dot(expr, 'set', null /*TODO*/),
										[index, v],
										project.typer.typeVoid,
										// [project.typer.typeInt, generic[0] /*TODO is this correct way to pass `T`*/],
										CallKind.VirtualMethod
									))
							}
					}
					return printExpression(a) + ' = ' + printInitializer(getType(a), v)
					//return printExpression(a) + ' = ' + printTypeConverter(printExpression(v), getType(v), getType(a))

				case Throw(e):
					return '_throw(' + printExpression(e) + ')'

				case For(name, over, by):
					return 'for (FIXME TODO struct Any_* ' + name + '_; ' + printExpression(over) + ';) ' + printStatement(by)

				case Increment(e):
					return printExpression(e) + '++'

				case Decrement(e):
					return printExpression(e) + '--'

				case While(econd, e, pre):
					// TODO ^ separate WhileDo DoWhile
					if pre {
						return '\n\(tabs)while (' + printExpression(econd) + ') ' + printStatement(e)
					}
					return '\n\(tabs)do {' + printStatement(e) /*block*/ + '} while (' + printExpression(econd) + ')'

				case Assignop(a, op, value):
					// TODO rename to AssignOp
					if getType(a) == project.typer.typeString, op == Token.Add {
						switch a {
							case Index(expr, index): {
								// Cache `index` to not re-evaluate twice
								let tempIndex = tempId++
								{
									let indexType = getType(index)
									let indexString = stringifyType(indexType)
									// TODO should be converted to valid index type
									let metaIndex = indexString + ' _$\(tempIndex) = ' + printExpression(index)
									metaBlock.push(metaIndex)
								}

								// Cache storage to not re-evaluate twice
								let tempStorage = tempId++
								{
									let indexType = getType(expr)
									let indexString = stringifyType(indexType)
									let metaIndex = indexString + ' _$\(tempStorage) = ' + printExpression(expr)
									metaBlock.push(metaIndex)
								}

								// `storage[index] += string`
								return '_$\(tempStorage)->_->set_(_$\(tempStorage), _$\(tempIndex), String_$combine_(_$\(tempStorage)->_->get_(_$\(tempStorage), _$\(tempIndex)), '
									+ printTypeConverter(printExpression(value), getType(value), project.typer.typeString) + '))'
							}
						}
						return printExpression(a) + ' = String_$combine_(' + printExpression(a) + ', ' + printTypeConverter(printExpression(value), getType(value), project.typer.typeString) + ')'
					}
					return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)

				/*case Dot(expr, name): switch expr {
					// TODO ^ replace to Statement.Expression
					// TODO use types in future, cause renames may make expr to be lower case
					// ^ DotStaticMethodCall DotStaticMethodAsValue
					case Ident(id):
						// Static
						if (id.charAt(0) == id.charAt(0).toUpperCase()) {
							return id + '_:?:' + name + '_'
						}
					}
					return printExpression(expr) + '->' + name*/

				case Switch(expr, cases, statements):
					// Convert to if-else because C is not fun
					// TODO do it in normalizer
					// TODO support normal switch when possible
					// + option to always emulate switches for specific target
					let value = printExpression(expr)
					let valueType = stringifyType(getType(expr))
					var r = '{ \(valueType) switch_ = ' + value + ';'

					// case 1: case 2: case 3:
					var else_ = false
					for i in cases.length { if (cases[i].length > 1) {
						if else_ {
							r += ' else'
						}
						r += '\n' + tabs + 'if (('
						let conds = []
						for cc in cases[i] { switch cc {
							case Null:
								// TODO == nullptr for non-tagged enums
								// switch expr EnumTag
								conds.push('switch_ == -1')
							case _:
								conds.push('switch_ == ' + printExpression(cc))
						}}
						r += conds.join(') || (') +  ')) '
						pushTab()
						r += printBlock(statements[i])
						popTab()
						else_ = true
					} else if let cc = cases[i][0] {
						if else_ {
							r += ' else'
						}
						r += '\n' + tabs + 'if ('
						switch cc {
							case Null:
								r += 'switch_ == -1) '
							case _:
								r += 'switch_ == ' + printExpression(cc) + ') '
						}
						pushTab()
						r += printBlock(statements[i])
						popTab()
						else_ = true
					}}

					// default:
					for i in cases.length { if (cases[i].length == 0) {
						if else_ {
							r += ' else'
						}
						r += '\n' + tabs
						r += printBlock(statements[i])
					}}

					r += ';\n' + tabs
					return r + '}'

					// TODO: don't use "0" as tag, use 1+; use `switch (a? a->index : 0)` or
					// generate `if (a) switch () else null-case` in normalizer
					/*
						let temp = f()
						if temp != null {
							switch temp.index {
								// no null case
							}
						} else {
							null case
						}
						^ in normalizer
					*/
					var r = 'switch (' + printExpression(expr) + ') {'

					// case 1: case 2: case 3:
					for i in cases.length { if (cases[i].length > 0) {
						r += '\n' + tabs
						for cc in cases[i] {
							r += 'case ' + printExpression(cc) + ': '
						}
						//pushTab()
						//r += '{\n' + tabs
						//r += printStatement(statements[i])
						//popTab()
						//r += '\n' + tabs + '} break;\n' + tabs

						pushTab()
						r += printBlock(statements[i])
						popTab()
						r += ' break;'
					}}

					// default:
					for i in cases.length { if (cases[i].length == 0) {
						r += '\n' + tabs + 'default:'
						r += '\n' + tabs
						r += printBlock(statements[i])
						//r += '\n' + tabs
					}}

					r += '\n' + tabs
					return r + '}'

				case _: console.error("Unknown statement kind (GenCxx):", s)
			}
		}

		fun printCallArguments(args: [Expression], expects: [Type]? = null) {
			if let exp = expects {
				return '(' + [for i in args.length
					printTypeConverter(printExpression(args[i]), getType(args[i]), exp[i])
				].join(', ') + ')'
			}

			return '(' + [for a in args printExpression(a)].join(', ') + ')'
		}

		fun printCallArgumentsVirtual(me: String, args: [Expression], expects: [Type]? = null) {
			if args.length == 0 {
				return '(' + me + ')'
			}

			if let exp = expects {
				return '(' + me + ', ' + [for i in args.length
					printTypeConverter(printExpression(args[i]), getType(args[i]), exp[i])
				].join(', ') + ')'
			}

			return '(' + me + ', ' + [for a in args printExpression(a)].join(', ') + ')'
		}

		fun getFunctionReturnType(funcType: Type): Type? { switch funcType {
			case Function(args, returns):
				return returns
			case _:
				return null
		}}

		fun printFunctionReturnType(funcType: Type) { switch funcType {
			case Function(args, returns):
				return stringifyType(returns)
			case _:
				return 'void'
		}}

		fun printToAnyConverter(string: String, type: Type): String {
			if type == project.typer.typeAny {
				return string
			}
			if type == project.typer.typeBool {
				return 'Any_fromBool(' + string + ')'
			}
			if type == project.typer.typeInt {
				return 'Any_fromInt(' + string + ')'
			}
			return '(struct Any_*)(' + string + ')'
		}

		fun printValueToNullableConverter(string: String, fromValue: Type, to: Type): String {
			return '%printValueToNullableConverter%'
		}

		fun printNullableToValueConverter(string: String, fromValue: Type, to: Type): String {
			return '%printNullableToValueConverter%'
		}

		/// Note: this is a strict `as!` kind of conversion
		fun printTypeConverter(string: String, fromValue: Type, to: Type): String {
			if fromValue == to {
				return string
			}

			// Integers
			if fromValue == project.typer.typeUInt16, to == project.typer.typeInt {
				return '(int32_t/*!*/)(' + string + ')'
			}

			// TODO combine all `== project.typer.typeAny` to single `if`
			if fromValue == project.typer.typeBool, to == project.typer.typeAny {
				return 'Any_fromBool(' + string + ')'
			}
			if fromValue == project.typer.typeAny, to == project.typer.typeBool {
				return '(' + string + ')->_toBool()'
			}
			// ^ TODO ((==null)?false:_toBool)
			// != null SHOULD BE DONE ONLY FOR NULLABLE AND Any
			if fromValue == project.typer.typeAny, to == project.typer.typeInt {
				return '(' + string + ')->_toInt()'
			}
			// ^ TODO ((==null)?0:_toInt) cause 1+null+2=3

			if fromValue == project.typer.typeAny, to == project.typer.typeFloat {
				return '(' + string + ')->_toFloat()'
			}
			// ^ TODO ((==null)?0.0:_to) cause 1+null+2=3
			if fromValue == project.typer.typeInt, to == project.typer.typeString {
				return 'String_$fromInt32_(' + string + ')'
			}
			if fromValue == project.typer.typeInt8, to == project.typer.typeString {
				return 'String_$fromInt32_(' + string + ')'
			}
			if fromValue == project.typer.typeUInt8, to == project.typer.typeString {
				return 'String_$fromInt32_(' + string + ')'
			}
			if fromValue == project.typer.typeInt16, to == project.typer.typeString {
				return 'String_$fromInt32_(' + string + ')'
			}
			if fromValue == project.typer.typeUInt16, to == project.typer.typeString {
				return 'String_$fromInt32_(' + string + ')'
			}

			// 64-bit
			if fromValue == project.typer.typeUInt32, to == project.typer.typeString {
				return 'String_$fromUInt64_(' + string + ')'
			}
			if fromValue == project.typer.typeInt64, to == project.typer.typeString {
				return 'String_$fromInt64_(' + string + ')'
			}
			if fromValue == project.typer.typeUInt64, to == project.typer.typeString {
				return 'String_$fromUInt64_(' + string + ')'
			}

			// TODO ^ from Float, etc
			if fromValue == project.typer.typeBool, to == project.typer.typeString {
				return 'String_$fromBool_(' + string + ')'
			}

			if fromValue == project.typer.typeString { switch to {
				case ClassInstance(type): if (type.name == 'ConstCharPointer') {
					console.log(type)
					return '(' + string + ')->bytes_'
				}
			}}

			switch fromValue {
				case Nullable(_):
				case UnknownNullable(_):
				case _:
					if to == project.typer.typeString {
						let type = omitPointer(stringifyType(fromValue))
						// TODO use meta block
						if type != 'Any_' {
							return type + '$toString_(' + string + ')'
						}
					}
			}

			//console.log(to) // , (to as! Any). ConstCharPointer

			if to == project.typer.typeAny {
				return printToAnyConverter(string, fromValue)
			}

			if fromValue != to {
				// TODO in future reformat into `case N(A),N(B)|A,B if (A==B):` etc complex nested combined patterns
				// TODO what if use `E.nullable` instead of `Null(E)`? meh than T1 != T2 would be broken?
				switch to {
					// `T? = _`
					case Nullable(toNull): switch fromValue {
						case Nullable(fromNull):
							// `var x: T? = T?`
							if toNull == fromNull {
								return string
							}

							if to == project.typer.typeNullUInt64 {
								return 'toNull$UInt64((uint64_t)(' + string + '))'
							}

							// `var x: A? = B?` unsafe conversion
							// TODO `(Int?) as! (Float?)` should not be bit-cast (how C does `(double)(int)123`?)
							return '(/*A? = B?*/' + stringifyType(to) + ')(' + string + ')'
						case _:
							// `var x: T? = T`
							// TODO do in normalizer ToNullable(v,t1,t2)
							if toNull == fromValue {
								if toNull == project.typer.typeInt {
									return '((int32_t$)(' + string + '))' // TODO
								}
								if toNull == project.typer.typeUInt64 {
									return '(Null$UInt64){' + string + ', 1}'
								}
								if toNull == project.typer.typeInt64 {
									return '(Null$Int64){' + string + ', 1}'
								}
								if toNull == project.typer.typeFloat {
									// TODO isn't it `Null$Float64`?
									return '(Null$Float){' + string + ', 1}'
								}
								if toNull == project.typer.typeFloat32 {
									return '(Null$Float32){' + string + ', 1}'
								}

								// TODO more (un)wrapping cases for basic types where needed
								return string
							}
							// `var x: A? = B` unsafe conversion
							// TODO `(Int?) as! (Float)` should not be bit-cast (how C does `(double)(int)123`?)

							switch fromValue {
								// Essentially just `null`
								case UnknownNullable(value): if value.value == null {
								if toNull == project.typer.typeInt or toNull == project.typer.typeInt32 {
									return 'int32_t$null'
								}
								// TODO null float etc as struct for now
								if toNull == project.typer.typeUInt32 {
									return 'uint32_t$null'
								}
								if toNull == project.typer.typeInt16 {
									return 'int16_t$null'
								}
								if toNull == project.typer.typeUInt16 {
									return 'uint16_t$null'
								}
								if toNull == project.typer.typeInt8 {
									return 'int8_t$null'
								}
								if toNull == project.typer.typeUInt8 {
									return 'uint8_t$null'
								}
								if toNull == project.typer.typeUInt64 {
									return '(Null$UInt64){0, 0}'
								}
								if toNull == project.typer.typeInt64 {
									return '(Null$Int64){0, 0}'
								}
								if toNull == project.typer.typeFloat {
									return '(Null$Float64){0.0, 0}'
								}
								if toNull == project.typer.typeFloat32 {
									return '(Null$Float32){0.0f, 0}'
								}
								if toNull == project.typer.typeBool {
									return '(uint8_t)2'
								}
								switch toNull {
									case ClassInstance(type):
										if type.name == 'ClangWideChar' {
											return '(wchar_t)0'
										}
								}
								if toNull == null {
									return string // TODO seems like unspecified generic type <T>
								}
								return '/*%T? = null%*/(' + string + ')'
								}
							}

							//return '(/*2 from=' + stringifyType(fromValue) + '*/' + stringifyType(to) + ')(' + string + ')
							return '(/*A? = B*/' + stringifyType(to) + ')(' + string + ')'
					}
					// `T = _`
					case _: switch fromValue {
						case Nullable(fromNull):
							// `var x: T = T?` used in `if let`
							if to == fromNull {
								if fromNull == project.typer.typeInt {
									return '(int32_t)(' + string + ')' // Should truncate
									// TODO Example `return string + '.value_'`
								}
								if
									(fromValue == project.typer.typeNullUInt64 and to == project.typer.typeUInt64)
									or
									(fromValue == project.typer.typeNullFloat and to == project.typer.typeFloat)
									or
									(fromValue == project.typer.typeNullFloat32 and to == project.typer.typeFloat32)
								{
									return string + '.value_'
									// Note: no need to validate `has_` cause `null => has_ == 0 and value == 0`
								}
								return string + '/*T = T?*/'
								return '%T = T?%'
							}

							if fromNull == project.typer.typeInt, to == project.typer.typeString {
								return 'String_$fromNullableInt32_(' + string + ')'
							}

							if fromNull == project.typer.typeBool, to == project.typer.typeString {
								return 'String_$fromBool_(' + string + ')'
							}

							// `var x: A = B?` unsafe conversion
							// TODO `(Int?) as! (Float)` should not be bit-cast (how C does `(double)(int)123`?)
							return '(/*A = B? \(stringifyType(fromNull)) */' + stringifyType(to) + ')(' + string + ')'
						case _:
							// `var x: T = T`
							if to == fromValue {
								return string
							}

							// `var x: A = B` unsafe conversion
							switch fromValue {
								// Essentially just `null`, not `T?`!
								case UnknownNullable(value): if value.value == null {
								if to == project.typer.typeInt or to == project.typer.typeInt32 {
									return 'int32_t$null'
								}
								// TODO null float etc as struct for now
								if to == project.typer.typeUInt32 {
									return 'uint32_t$null'
								}
								if to == project.typer.typeInt16 {
									return 'int16_t$null'
								}
								if to == project.typer.typeUInt16 {
									return 'uint16_t$null'
								}
								if to == project.typer.typeInt8 {
									return 'int8_t$null'
								}
								if to == project.typer.typeUInt8 {
									return 'uint8_t$null'
								}
								// TODO this `if` should be detected as unreachable (if `to` is `let`)
								if to == project.typer.typeInt {
									return '(int32_t)0'
								}
								//'((Null$Int32)(' + string + ')).value_'
								if to == null {
									return string // TODO seems like unspecified generic type <T>
								}
								return '(/*T = null*/' + stringifyType(to) + ')(' + string + ')'
								}
							}

							if to == null {
								return string
							}

							// TODO do in normalizer
							var fromStructByValue = false
							var fromBasicType = false
							switch fromValue {
								case ClassInstance(type):
									let atts = project.mapDecorators.get(type.parent)

									fromBasicType = Decorator.getDecorator(atts, 'nativeBasicType') != null

									fromStructByValue = Decorator.getDecorator(atts, 'byValue') != null
									fromStructByValue = fromStructByValue or type.name == 'ByValue'
							}
							var toStructByPointer = false
							var toStructByValue = false
							switch to {
								case ClassInstance(type):
									let atts = project.mapDecorators.get(type.parent)

									toStructByPointer = Decorator.getDecorator(atts, 'struct') != null

									toStructByValue = Decorator.getDecorator(atts, 'byValue') != null
									toStructByValue = toStructByValue or type.name == 'ByValue'
							}

							if fromStructByValue and toStructByPointer, not fromBasicType {
								return '(/*struct to pointer*/' + stringifyType(to) + ')&(' + string + ')'
							}

							if fromStructByValue and toStructByValue {
								return '*((/*struct to struct*/' + omitPointer(stringifyType(to)) + '*)&(' + string + '))'
							}

							return '(' + stringifyType(to) + ')(' + string + ')'
					}
				}
			}
			return string
			// TODO ANYTHING to string should be checked =null always
		}

		var thisArgument: String? = null
		fun printFunctionArguments(args: [String], funcType: Type, variadic: VariadicKind = VariadicKind.NotVariadic) {
			if args.length == 0, thisArgument != null {
				// TODO variadic
				return '(' + thisArgument + ')'
			}

			if args.length == 0 {
				// TODO variadic
				return '(void)' // Otherwise C function takes infinite number of arguments
			}

			switch funcType {
				case Function(types, _):
					let results: [String] = []
					if let thisArgument = thisArgument {
						results.push(thisArgument)
					}

					for a in args.length {
						var result = stringifyType(types[a].type) + ' ' + args[a] + '_'
						results.push(result)
					}

					if variadic == VariadicKind.NativeVariadic {
						results.pop() // Last argument is unused
						results.push('...')
					}

					return '(' + results.join(', ') + ')'

					// TODO Incompatible types `String` and value of `Array<String?>`
					//var thisArgument: String? = null
					//let results: String = (thisArgument != null)? [thisArgument] : []
					// lol result [String] no String

			}

			// TODO seems like dead code
			return '(' + [for a in args.length
				'Any_* ' + args[a] + '_'
			].join(', ') + ')'
			// TODO defaults
			// 'void* ' + args[a] + ((defaults != null && defaults[a] != null)? ' = ' + printExpression(defaults[a]) : '')
		}

		fun stringType(t: NodeType, prefix: String) {
			//let prefix = prefix? '' : ''
			if (t == null) {
				return 'void*'
			}
			//if (t == null) return prefix + 'void*'
			switch t {
				case ParametricType(name, params):
			//		if (name == 'Buffer') return prefix + name
			//		return prefix + name + '<' + [for (param in params) stringType(param, false)].join(', ') + '>'
					return '_x' + name
				case Type(name):
			//		if (name == 'Any') return prefix + 'void*'
					return '_x' + name
				case Object(_):
			//		return prefix + '{}'
				case Optional(t):
			//		return prefix + 'Null<' + stringType(t, false) + '>'
					return stringType(t, '')
			}

			return prefix + 'void*'
		}

		fun printType(t: NodeType) {
			let type = stringType(t, '')
			return type
		}

		fun stringifyType(t: Type, prefixNull: Bool = false): String {
			switch t {
				case Generic(index, name): return 'Any_*' // + '/*TODO Generic<\(name)>*/'
				case Nullable(t):
					let name = stringifyType(t)
					if name == 'int32_t' {
						return 'int32_t$'
					}
					if name == 'int16_t' {
						return 'int16_t$'
					}
					if name == 'int8_t' {
						return 'int8_t$'
					}
					if name == 'Bool' {
						return 'Bool_'
					}
					if name == 'double' {
						return 'Null$Float64'
					}
					if name == 'float' {
						return 'Null$Float32'
					}
					if name == 'uint64_t' {
						return 'Null$UInt64'
					}
					if name == 'int64_t' {
						return 'Null$Int64'
					}

					if prefixNull == true {
						return 'Null$' + name
					}

					return name
				case Unknown(handle):
					return stringifyType(handle.value, prefixNull)
				case UnknownNullable(handle):
					return stringifyType(handle.value, prefixNull)
				case ClassInstance(type, generics):
					// TODO generic params < T > !!!!! just output into C++  templates
					// TODO type == typer.typeX

					if type.name == 'ByValue' {
						return omitPointer(stringifyType(generics[0], prefixNull))
					}
					if type.name == 'Int' {
						return 'int32_t'
					}
					if type.name == 'Int8' {
						return 'int8_t'
					}
					if type.name == 'Int16' {
						return 'int16_t'
					}
					if type.name == 'Int32' {
						return 'int32_t'
					}
					if type.name == 'Int64' {
						return 'int64_t'
					}
					if type.name == 'UInt8' {
						return 'uint8_t'
					}
					if type.name == 'UInt16' {
						return 'uint16_t'
					}
					if type.name == 'UInt32' {
						return 'uint32_t'
					}
					if type.name == 'UInt64' {
						return 'uint64_t'
					}

					// Useful for `sizeof`
					if type.name == 'ArrayByValue' {
						return stringifyType(generics[0]) + '['+ stringifyType(generics[1]) +']'
					}

					let atts = project.mapDecorators.get(type.parent)
					// TODO refactor
					var renamed = ''
					if let rename = Decorator.getDecorator(atts, 'rename') {
						renamed = DataHelper.asStringAttValue(rename, 0)
					}

					if let generic = generics, renamed == 'ConstArrayPointer' {
						return 'const ' + stringifyType(generic[0]) + '*'
					}

					if let generic = generics, renamed == 'ArrayPointer' {
						return stringifyType(generic[0]) + '*'
					}

					if let generic = generics, renamed == 'ArrayByValue' {
						//if let count = generic[1] {
						//	return stringifyType(generic[0]) + '[' + Type.stringify(count) + ']'
						//}
						//return stringifyType(generic[0]) + '[]'
						return stringifyType(generic[0])
					}

					// Keeps three states: 1 = true, 0 = false, 2 = null
					if type.name == 'Bool' {
						return 'Bool_'
					}

					// WinDef.h `typedef int BOOL;`
					// TODO should be just simple `enum Bool32 : Int32 { True False }`
					// TODO error if `Enum.V == xx` if Enum != simple enum (i.e. creates new instance so always false)
					// TODO allow short syntax `x == True` & `x != True` if enum's simple type is known
					if type.name == 'Bool32' {
						return 'int32_t'
					}

					// WinDef.h `typedef BYTE BOOLEAN; typedef unsigned char BYTE;`
					// TODO UBool8?
					if type.name == 'Bool8' {
						return 'uint8_t'
					}

					// TODO apparently should be just `@rename('void')`
					if type.name == 'Void' {
						return 'void'
					}

					if type.name == 'Float' {
						return 'double'
					}

					//if (let jsNative = type.jsNative) return jsNative

					let atts = project.mapDecorators.get(type.parent)

					let struct = Decorator.getDecorator(atts, 'struct') != null
					let byValue = Decorator.getDecorator(atts, 'byValue') != null

					if byValue and not struct {
						throw 'Must be @struct to be @byValue'
					}

					let native = Decorator.getDecorator(atts, 'rename')
					if let native = native { switch (native.values[0]) {
						case String(s):
							if struct and byValue {
								return s
							}
							if struct {
								return s + '*'
							}
							return s
					}}

					if let generic = generics, generic.length > 0 {
						var name = type.name

						if let instanceOf = type.instanceOf {
							name = instanceOf.name
						}

						name += '_$' + [for param in generic {
							omitPointer(stringifyType(param, prefixNull: true))
						}].join('$')

						if name.endsWith('_') {
							return name + '*'
						}

						return name + '_*'
					}

					return type.name + '_*'
				case Class(type):
					return type.name + '_*'
				// TODO ^ probably requires rename basic types too?
				case Enum(type):
					if let sub = type.fieldsTypeSimple {
						let atts = project.mapDecorators.get(type.parent)
						if let rename = Decorator.getDecorator(atts, 'castTo') {
							return DataHelper.asStringAttValue(rename, 0)
						}

						return stringifyType(sub)
					}

					return type.name + '_*'
				case EnumInstance(type):
					return stringifyType(Type.Enum(type))
				case Struct(_): return 'Any_*/*Struct*/'
				case Function(args, returns):
					let temp = tempId++
					typedefFunctions.push('typedef ')
					typedefFunctions.push(stringifyType(returns))
					// TODO use better name like _fun_123_
					// TODO de-dup all function types in normalizer, expressions to use funcTypes[id]
					typedefFunctions.push(' (')
					// TODO respect `link.convention`
					typedefFunctions.push(defaultCallingConvention)
					typedefFunctions.push('*_$')
					typedefFunctions.push('' + temp)
					typedefFunctions.push(')(')

					let a: [String] = []
					for arg in args {
						a.push(stringifyType(arg.type))
					}

					typedefFunctions.push(a.join(', '))
					typedefFunctions.push(');\n')
					return '_$\(temp)'
				case Constant(value): return value
				case null: return 'Any_*'
				case _:
					throw 'stringifyType ' + t
			}
		}

		// TODO move to Expression static fun
		fun getType(e: Expression): Type { switch e {
			case Int(_): return project.typer.typeInt
			case MetaInt(_, kind):
				switch kind {
					case Int8: return project.typer.typeInt8
					case Int16: return project.typer.typeInt16
					case Int32: return project.typer.typeInt32
					case Int64: return project.typer.typeInt64

					case UInt8: return project.typer.typeUInt8
					case UInt16: return project.typer.typeUInt16
					case UInt32: return project.typer.typeUInt32
					case UInt64: return project.typer.typeUInt64
				}

			case Float(_): return project.typer.typeFloat
			case String(_): return project.typer.typeString
			case True: return project.typer.typeBool
			case False: return project.typer.typeBool
			case Ident(_, type): return type
			case Parenthesis(expr): return getType(expr)
			case Call(_, _, type): return type
			//case If(_): return project.typer.typeAny
			case Binop(_, _, _, type): return type
			case NativeOperator(_, _, _, _, type): return type
			case Dot(_, _, type): return type
			case This(type): return type
			case Null: return Type.UnknownNullable({value: null})
			case UnsafeBitCast(_, to): return to
			case Index(_, _, result): return result
			case New(_, _, result): return result
			case Array(_, result): return result
			case Map(keys, values, keyType, valueType, mapType): return mapType
			case Unop(op, postfix, e): return getType(e) // TODO `-N` should convert `UInt` to `Int` in typer
			case If(econd, eif, eelse): return getType(eif)
			case Enum(type, tagName, tag, args):
				// TODO
				return project.typer.typeAny
			case EnumTag(expr):
				// TODO
				return project.typer.typeAny
			case Function(_):
				// TODO
				return project.typer.typeAny
			case Arrow(_):
				// TODO
				return project.typer.typeAny
			case Object(_):
				// TODO
				return project.typer.typeAny
			case _:
				return project.typer.typeAny
		}}

		/// Returns type name without last `*` on the end
		fun omitPointer(type: String): String {
			if type.endsWith('*') {
				return type.substr(0, type.length - 1)
			}
			return type
		}

		fun registerString(string: String): Int {
			declarationsOfStrings.push(string)
			return declarationsOfStrings.length - 1
		}

		fun printInitializer(ofType: Type, v: Expression) {
			switch ofType {
				case ClassInstance(c):
					if c.name == 'ArrayByValue' {
						switch v {
							case Array(el) if el.length == 1: {
								switch el[0] {
									case Int(val): {
										if val == 0 {
											// Print single-element (C-style) initializer for `ArrayByValue`
											return '{0}'
										}
										// TODO else what?
									}
								}
							}
						}
					}
			}

			return printExpression(v)
		}

		var customThis: String? = null
		fun printExpression(e: Expression) {
			switch e {
				case This: return customThis ?? 'this'
				case Ident(name):
					if project.native.get(e) == true {
						return name
					}
					return '' + name + '_'
				case Null(type):

					var type = type

					switch type {
						case UnknownNullable(handle): if let of = handle.value {
							type = of
						}
						case Nullable(of): type = of
					}

					if type == project.typer.typeInt {
						return 'int32_t$null'
					}

					if type == project.typer.typeUInt32 {
						return 'uint32_t$null'
					}

					if type == project.typer.typeInt16 {
						return 'int16_t$null'
					}

					if type == project.typer.typeUInt16 {
						return 'uint16_t$null'
					}

					if type == project.typer.typeInt8 {
						return 'int8_t$null'
					}

					if type == project.typer.typeUInt8 {
						return 'uint8_t$null'
					}

					if type == project.typer.typeBool {
						return '(uint8_t)2'
					}

					// TODO more types

					// TODO infer actual type of null in typer,
					// to print type conversion `((T*)0)`
					return 'nullptr'
					return '((Unknown_ *)0)'
					/*
					void f(int*) { /*...*/ }
					void f(double*) { /*...*/ }
					void g()
					{
					    f(nullptr); // compilation error, ambiguous call!
					    f(static_cast<int*>(nullptr)); // now compiler knows...
					}
					*/
				case Int(v): return '(int32_t)' + v
				case MetaInt(v, meta, type): {
					switch meta {
						case Int32: return '(int32_t)' + v
						case Int64: return '(int64_t)' + v
						case Int16: return '(int16_t)' + v
						case Int8: return '(int8_t)' + v

						case UInt32: return '(uint32_t)' + v
						case UInt64: return '(uint64_t)' + v
						case UInt16: return '(uint16_t)' + v
						case UInt8: return '(uint8_t)' + v
					}

					// TODO more kinds
				}
				case Float(v):
					let v = '' + v
					if v.indexOf('.') == -1 {
						return '(double)' + v + '.0'
					}
					return '(double)' + v
				case String(string):
					if let id = declarationsOfStringsMap.get(string) {
						return 'String_\(id)'
					}

					let s = string.split('')
					let charsOut = []
					while s.length > 0 {
						switch s[0] {
							case "'":
							charsOut.push("\\'")
							s.shift()
							case '"':
							charsOut.push('\\"')
							s.shift()
							case "\n":
							charsOut.push("\\n")
							s.shift()
							case "\r":
							charsOut.push("\\r")
							s.shift()
							case "\\":
							s.shift()
							if s[0] == "'" {
								charsOut.push("\\'")
								s.shift()
							} else if s[0] == '"' {
								charsOut.push('\\"')
								s.shift()
							} else if s[0] == '\\' {
								charsOut.push("\\\\")
								s.shift()
							} else {
								charsOut.push('\\')
							}
							case _:
							charsOut.push(s[0])
							s.shift()
						}
					}

					let id = registerString(charsOut.join(""))
					declarationsOfStringsMap.set(string, id)
					return 'String_\(id)'
					//return 'String_fromUTF8z("' + charsOut.join('') + '")'
				case True: return 'true_'
				case False: return 'false_'
				case Dot(expr, name):
					if name == 'toZeroOrOne' {
						let type = getType(expr)
						if type == project.typer.typeBool {
							return printExpression(expr)
						}
					}
				if name == 'ref' or name == 'address' {
					let type = getType(expr)
					switch type {
						case ClassInstance(c):
							if c.name == 'ByValue', name == 'ref' {
								return '(&' + printExpression(expr) + ')'
							}

							if c.name == 'ArrayByValue', name == 'ref' {
								return '(&' + printExpression(expr) + '[0])'
							}

							if c.name == 'ArrayByValue' and name == 'address' {
								return '(uint64_t)&(' + printExpression(expr) + ')'
							}
					}
				}

				switch expr {
					case This: return (customThis ?? 'this') + '->' + name + '_'
					case Ident(id, typed):
						// Static
						// TODO better detect
						if id.charAt(0) == id.charAt(0).toUpperCase(), not id.startsWith('_') {
							return id + '_$' + name + '_'
						}
						// Dynamic
						let type = getType(expr)
						if ((type == project.typer.typeAny) || (type == null)) {
							// TODO leaky!!
							return printExpression(expr) + '->let_(String_$fromUTF16z_(L"' + name + '"))'
						}

						switch typed {
							case ClassInstance(c):
								//if let rename = c.fieldRenames[c.fieldNames.indexOf(name)] { TODO
								if c.fieldRenames.includes(name) {
									return printExpression(expr) + '->' + name
								}
						}

						return printExpression(expr) + '->' + name + '_'
					case _:
						switch getType(expr) {
							case ClassInstance(c):
								if c.fieldRenames.includes(name) {
									return printExpression(expr) + '->' + name
								}
						}
						return printExpression(expr) + '->' + name + '_'
				}

				// TODO to keep local var caches, use something like block.push()
				// into current scope
				case Call(e, args, type, kind):
					switch kind {
						case Static:
							return printExpression(e) + printCallArguments(args)
						case VirtualMethod:
						switch e {
							case Dot(expr, name, result):
							let temp = tempId++
							let temp1 = tempId++
							let mb = metaBlock
							metaBlock = []
							let exprType = getType(expr)
							let typeString = stringifyType(exprType)
							let meta = typeString + ' _$\(temp) = ' + printExpression(expr)

							var isStruct = false
							switch exprType {
								case ClassInstance(type, params): {
									let atts = project.mapDecorators.get(type.parent)
									isStruct = Decorator.getDecorator(atts, 'struct') != null
								}
								// TODO `case ClassInstance(type, _) | Class(type)`
								// TODO same for statement
								// TODO this should be a NiceClass actually
								// TODO seems like `this` gets type of `Class` instead of instance somewhere
								case Class(type): {
									let atts = project.mapDecorators.get(type.parent)
									isStruct = Decorator.getDecorator(atts, 'struct') != null
								}
								case _:
							}

							let result = if isStruct {
								omitPointer(typeString) + '$' + name + '_' + printCallArgumentsVirtual('_$\(temp)', args)
							} else {
								'_$\(temp)->_->' + name + '_' + printCallArgumentsVirtual('_$\(temp)', args)
							}

							for b in metaBlock {
								mb.push(b)
							}
							mb.push(meta)
							//mb.push('/*result*/auto _$\(temp1) = ' + result)
							metaBlock = mb
							//return '_$\(temp1)'//result
							return result

							//return // + ';\n' + tabs// +
							//return printExpression(expr) + '/*virtual*/' + printCallArguments(args)
						}
					}

					return printExpression(e) + printCallArguments(args)

				case Arrow(expr, args, defaults, types, returns, funcType): {
					return printExpression(
						// TODO temp names '$arrow'
						Expression.Function(null, expr: Statement.Return(expr), args, defaults, funcType)
					)
				}

				case Function(name, expr, args, defaults, funcType):
					// TODO this should generate arguments from caller side, ie:
					// `f A -> B` `((a IA)=>IB)` => generate `((a A)=>B)`
					// ^ should be done at normalizer
					let _currentReturnType = currentReturnType
					currentReturnType = getFunctionReturnType(funcType)

					let temp = tempId++
					let rt = printFunctionReturnType(funcType)
					forwardFunctions.push(rt)
					forwardFunctions.push(' _$\(temp)')
					forwardFunctions.push(printFunctionArguments(args, funcType))
					forwardFunctions.push(';\n')

					let tab = tabs
					tabs = ''
					globalFunctions.push(rt)
					globalFunctions.push(' _$\(temp)')
					globalFunctions.push(printFunctionArguments(args, funcType))
					globalFunctions.push(' ')
					globalFunctions.push(printBlock(expr))
					globalFunctions.push('\n\n')
					tabs = tab

					currentReturnType = _currentReturnType
					return '_$\(temp)'

				case New(e, args, result):
					// TODO probably just `omitPointer(stringifyType(result))`
					var name = omitPointer(stringifyType(result)) // TODO redesign, just string from normalizer
					switch result {
						case ClassInstance(type, params): {
							let atts = project.mapDecorators.get(type.parent)
							let isStruct = Decorator.getDecorator(atts, 'struct') != null
							// TODO Only *external* `C++` and non-external Hexa structs have constructors
							// TODO check arguments count to be zero
							if isStruct {
								let shouldInit = not type.external
								if shouldInit {
									if args.length > 0 {
										// TODO should not wrap into ( )
										return name + '$this_((\(name)*)HEXA_NEW(sizeof(\(name))), ' + printCallArguments(args) + ')'
									}
									return name + '$this_((\(name)*)HEXA_NEW(sizeof(\(name))))'
								}
								return '(\(name)*)HEXA_NEW(sizeof(\(name)))'
							}
						}
					}
					return name + '$new_' + printCallArguments(args)

				case Array(el, arrayType):
					let type = stringifyType(arrayType)

					if el.length == 0 {
						return '\(omitPointer(type))$new_(0)'
					}

					switch arrayType {
						case ClassInstance(_, generic):
							let elType: String = stringifyType(generic[0])
							return '\(omitPointer(type))$from_(\(omitPointer(type))$new_(\(el.length)), (\(elType)[]){' + [for a in el printExpression(a)].join(', ') + '})'
					}

					return '\(omitPointer(type))$from_(\(omitPointer(type))$new_(\(el.length)), {' + [for a in el printExpression(a)].join(', ') + '})'

				case Unop(op, postfix, e):
					if postfix {
						return printExpression(e) + Token.stringify(op)
					}

					return Token.stringify(op) + printExpression(e)

				case Elvis(nullable, othewise):
					return '((' + printExpression(nullable) + ')||(' + printExpression(othewise) + '))'

				case Parenthesis(e):
					return '(' + printExpression(e) + ')'

				case Binop(a, op, b):
					if op == Token.Equal or op == Token.Unequal {
						// TODO commutative
						if let aType = getType(a), aType == project.typer.typeNullUInt64 {
							return (op == Token.Unequal? '!' : '') + 'equalNull$UInt64(' + printExpression(a) + ', ' + printTypeConverter(printExpression(b), getType(b), aType) + ')'
						}

						if let aType = getType(a), aType == project.typer.typeNullFloat32 {
							return (op == Token.Unequal? '!' : '') + 'equalNull$Float32(' + printExpression(a) + ', ' + printTypeConverter(printExpression(b), getType(b), aType) + ')'
						}
					}

					if op == Token.Add {
						if getType(a) == project.typer.typeString {
							return 'String_$combine_(' + printExpression(a) + ', ' + printTypeConverter(printExpression(b), getType(b), project.typer.typeString) + ')'
						}

						if getType(b) == project.typer.typeString {
							return 'String_$combine_(' + printTypeConverter(printExpression(a), getType(a), project.typer.typeString) + ', ' + printExpression(b) + ')'
						}
					}

					let token = op == Token.IntegerDivide? '/' : Token.stringify(op)
					return printExpression(a) + ' ' + token + ' ' + printExpression(b)

				case Index(expr, index):
					switch getType(expr) {
						case ClassInstance(type, generic):
							if type.name != 'Array' {
								return printExpression(expr) + '[' + printTypeConverter(printExpression(index), getType(index), project.typer.typeInt) + ']'
							}
					}

					// TODO meta block
					return printExpression(Expression.Call(
						// TODO `set`
						Expression.Dot(expr, 'get', null /*TODO*/),
						[index],
						project.typer.typeAny, // TODO this is a reflection access
						CallKind.VirtualMethod
					))

				case If(econd, eif, eelse):
					var r = ''
					try {
						r += '(' + printExpression(econd) + ')?'
						r += '(' + printExpression(eif) + ')'
						r += ':' + printExpression(eelse)
						return r
					} catch error: Any {
						console.log('If =>', e, error)
						// TODO eliminate this "debug"
						return r + '<!--If => error-->'
					}

				case EnumTag(expr):
					let e = printExpression(expr)
					return '(' + e + ' == ((Unknown_ *)0)? -1 : ' + e + '->is_)'

				case Object(names, el):
					return 'Object_from(' + [for i in el.length {
						((names[i]) + ', ' + printExpression(el[i]))
					}].join(', ') + ')'

				case Map(keys, values, keyType, valueType, mapType):
					let type = omitPointer(stringifyType(mapType))

					if keys.length == 0 {
						return '\(type)$new_()'
					}

					let kType: String = stringifyType(keyType)
					let vType: String = stringifyType(valueType)

					return '\(type)$from_(\(type)$new_(), \(keys.length), (\(kType)[]){' +
						[for el in keys printExpression(el)].join(', ')
						+ '}, (\(vType)[]){' +
						[for el in values printExpression(el)].join(', ')
					// TODO keep order with meta blocks `[for i in keys.length '' + printExpression(keys[i]) + ', ' + printExpression(values[i]) + ''].join(', ')`
					+ '})'

				// TODO rename to `AssignOp`
				case Assignop(a, op, value):
					return printExpression(a) + ' ' + Token.stringify(op) + '= ' + printExpression(value)

				case NativeOperator(kind, args, s, params, result): switch kind {
					case Infix:
						return '((' + printExpression(args[0]) + ')' + s + '(' + printExpression(args[1]) + '))'
					case Function:
						if let params = params, s == '*sizeof' {
							return 'sizeof(' + omitPointer(stringifyType(params[0])) + ')'
						}

						if let params = params, s == '&sizeof' {
							return 'sizeof(' + stringifyType(params[0]) + ')'
						}
						return s + printCallArguments(args)
					case Prefix:
						return '(' + s + '(' + printExpression(args[0]) + '))'
					case Postfix:
						return '((' + printExpression(args[1]) + ')' + s + ')'
				}

				case UnsafeBitCast(e, to):
					//switch e {
					//	case Null: return '(/*UnsafeBitCast*/(Unknown_ *)0)'
					//	// TODO maybe use `0` value? or static_cast?
					//}
					return printTypeConverter(printExpression(e), getType(e), to)
					//return 'reinterpret_cast<' + stringifyType(to) + '>(' + printExpression(e) + '))'
					//return '(*reinterpret_cast<' + stringifyType(to) + ' *>(&' + printExpression(e) + '))'

				case Enum(typeName, tagName, tag, args):
					return '' + typeName + '_$' + tagName + '_(' + [for a in args printExpression(a)].join(', ') + ')'

				case EnumParameter(expr, index):
					return printExpression(expr) + '->enum_[' + index + ']'

				case _:
					console.error("Unknown expression kind:", e)
					return '<!--' + ((e as! Any)??[])[0] + '-->'
			}
		}
	}
